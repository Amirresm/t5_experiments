1=========
->Original Input:
send a signal `signal.SIGUSR1` to the current process
->Original Target:
os.kill(os.getpid(), signal.SIGUSR1)
->Reconstructed Target:
os.kill(os.getpid(), signal.SIGUSR1)
->Reconstructed Predication:
sender = os.path.send(signal.SIGUSR1)
->Raw Input:
implement: send a signal signal.SIGUSR1 to the current process
->Raw Target:
os.kill(os.getpid(), signal.SIGUSR1)
--

2=========
->Original Input:
decode a hex string '4a4b4c' to UTF-8.
->Original Target:
bytes.fromhex('4a4b4c').decode('utf-8')
->Reconstructed Target:
bytes.fromhex('4a4b4c').decode('utf-8')
->Reconstructed Predication:
'4a4b4c'.decode('utf8')
->Raw Input:
implement: decode a hex string '4a4b4c' to UTF-8.
->Raw Target:
bytes.fromhex('4a4b4c').decode('utf-8')
--

3=========
->Original Input:
check if all elements in list `myList` are identical
->Original Target:
all(x == myList[0] for x in myList)
->Reconstructed Target:
all(x == myList[0] for x in myList)
->Reconstructed Predication:
all(item in myList)
->Raw Input:
implement: check if all elements in list myList are identical
->Raw Target:
all(x == myList[0] for x in myList)
--

4=========
->Original Input:
format number of spaces between strings `Python`, `:` and `Very Good` to be `20`
->Original Target:
print('%*s : %*s' % (20, 'Python', 20, 'Very Good'))
->Reconstructed Target:
print('%*s : %*s' % (20, 'Python', 20, 'Very Good'))
->Reconstructed Predication:
re.sub('(?=20)', ':', 'Very Good', Python)
->Raw Input:
implement: format number of spaces between strings Python, : and Very Good to be 20
->Raw Target:
print('%*s : %*s' % (20, 'Python', 20, 'Very Good'))
--

5=========
->Original Input:
None
->Original Target:
d.decode('cp1251').encode('utf8')
->Reconstructed Target:
res = k: v for k, v in list(kwargs.items()) if v is not None
->Reconstructed Predication:
kwargs.set_values()
->Raw Input:
implement: get rid of None values in dictionary kwargs
->Raw Target:
res = k: v for k, v in list(kwargs.items()) if v is not None
--

6=========
->Original Input:
get rid of None values in dictionary `kwargs`
->Original Target:
res = {k: v for k, v in list(kwargs.items()) if v is not None}
->Reconstructed Target:
res = dict((k, v) for k, v in kwargs.items() if v is not None)
->Reconstructed Predication:
kwargs.set_values()
->Raw Input:
implement: get rid of None values in dictionary kwargs
->Raw Target:
res = dict((k, v) for k, v in kwargs.items() if v is not None)
--

7=========
->Original Input:
get rid of None values in dictionary `kwargs`
->Original Target:
res = dict((k, v) for k, v in kwargs.items() if v is not None)
->Reconstructed Target:
subprocess.check_output('ps -ef | grep something | wc -l', shell=True)
->Reconstructed Predication:
sys.stdout.stdout(ps -ef | grep something | wc -l)
->Raw Input:
implement: capture final output of a chain of system commands ps -ef | grep something | wc -l
->Raw Target:
subprocess.check_output('ps -ef | grep something | wc -l', shell=True)
--

8=========
->Original Input:
capture final output of a chain of system commands `ps -ef | grep something | wc -l`
->Original Target:
subprocess.check_output('ps -ef | grep something | wc -l', shell=True)
->Reconstructed Target:
"""""".join(['a', 'b', 'c'])
->Reconstructed Predication:
['a', 'b', 'c']
->Raw Input:
implement: concatenate a list of strings ['a', 'b', 'c']
->Raw Target:
"""""".join(['a', 'b', 'c'])
--

9=========
->Original Input:
concatenate a list of strings `['a', 'b', 'c']`
->Original Target:
"""""".join(['a', 'b', 'c'])
->Reconstructed Target:
pd.Series(list(set(s1).intersection(set(s2))))
->Reconstructed Predication:
np.intersection(s1, s2)
->Raw Input:
implement: find intersection data between series s1 and series s2
->Raw Target:
pd.Series(list(set(s1).intersection(set(s2))))
--

10=========
->Original Input:
find intersection data between series `s1` and series `s2`
->Original Target:
pd.Series(list(set(s1).intersection(set(s2))))
->Reconstructed Target:
client.send('HTTP/1.0 200 OKrn')
->Reconstructed Predication:
client.sentheaders()
->Raw Input:
implement: sending http headers to client
->Raw Target:
client.send('HTTP/1.0 200 OKrn')
--

11=========
->Original Input:
sending http headers to `client`
->Original Target:
client.send('HTTP/1.0 200 OK\r\n')
->Reconstructed Target:
then = datetime.datetime.strptime(when, '%Y-%m-%d').date()
->Reconstructed Predication:
datetime.datetime.strptime('%m-%d %Y')
->Raw Input:
implement: Format a datetime string when to extract date only
->Raw Target:
then = datetime.datetime.strptime(when, '%Y-%m-%d').date()
--

12=========
->Original Input:
Format a datetime string `when` to extract date only
->Original Target:
then = datetime.datetime.strptime(when, '%Y-%m-%d').date()
->Reconstructed Target:
inputString.split('n')
->Reconstructed Predication:
inputString.split(',')
->Raw Input:
implement: split a multi-line string inputString into separate strings
->Raw Target:
inputString.split('n')
--

13=========
->Original Input:
split a multi-line string `inputString` into separate strings
->Original Target:
inputString.split('\n')
->Reconstructed Target:
' a n b rn c '.split('n')
->Reconstructed Predication:
re.split('n', a n b rn c)
->Raw Input:
implement: Split a multi-line string  a n b rn c  by new line character n
->Raw Target:
' a n b rn c '.split('n')
--

14=========
->Original Input:
Split a multi-line string ` a \n b \r\n c ` by new line character `\n`
->Original Target:
' a \n b \r\n c '.split('\n')
->Reconstructed Target:
""":""".join(str(x) for x in b)
->Reconstructed Predication:
[i for i, j in b if j == j!= j for i, j in b]
->Raw Input:
implement: concatenate elements of list b by a colon ":"
->Raw Target:
""":""".join(str(x) for x in b)
--

15=========
->Original Input:
concatenate elements of list `b` by a colon ":"
->Original Target:
""":""".join(str(x) for x in b)
->Reconstructed Target:
Entry.objects.filter()[:1].get()
->Reconstructed Predication:
Entry.objects.first()
->Raw Input:
implement: get the first object from a queryset in django model Entry
->Raw Target:
Entry.objects.filter()[:1].get()
--

16=========
->Original Input:
get the first object from a queryset in django model `Entry`
->Original Target:
Entry.objects.filter()[:1].get()
->Reconstructed Target:
a.sum(axis=1)
->Reconstructed Predication:
sum(x + y for x in 2D.np.sum())
->Raw Input:
implement: Calculate sum over all rows of 2D numpy array
->Raw Target:
a.sum(axis=1)
--

17=========
->Original Input:
Calculate sum over all rows of 2D numpy array
->Original Target:
a.sum(axis=1)
->Reconstructed Target:
warnings.simplefilter('always')
->Reconstructed Predication:
os.warning('always')
->Raw Input:
implement: enable warnings using action 'always'
->Raw Target:
warnings.simplefilter('always')
--

18=========
->Original Input:
enable warnings using action 'always'
->Original Target:
warnings.simplefilter('always')
->Reconstructed Target:
print(' '.join(map(str, l)))
->Reconstructed Predication:
[item for item in l if item not in'']
->Raw Input:
implement: concatenate items of list l with a space''
->Raw Target:
print(' '.join(map(str, l)))
--

19=========
->Original Input:
concatenate items of list `l` with a space ' '
->Original Target:
print(' '.join(map(str, l)))
->Reconstructed Target:
subprocess.call(['python.exe', 'hello.py', 'htmlfilename.htm'])
->Reconstructed Predication:
os.system('hello.py', 'htmlfilename.htm')
->Raw Input:
implement: run script 'hello.py' with argument 'htmlfilename.htm' on terminal using python executable
->Raw Target:
subprocess.call(['python.exe', 'hello.py', 'htmlfilename.htm'])
--

20=========
->Original Input:
run script 'hello.py' with argument 'htmlfilename.htm' on terminal using python executable
->Original Target:
subprocess.call(['python.exe', 'hello.py', 'htmlfilename.htm'])
->Reconstructed Target:
my_float = float(my_string.replace(',', ''))
->Reconstructed Predication:
my_float = float(my_string, '')
->Raw Input:
implement: convert a string my_string with dot and comma into a float number my_float
->Raw Target:
my_float = float(my_string.replace(',', ''))
--

21=========
->Original Input:
None
->Original Target:
time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S.%f')
->Reconstructed Target:
float('123,456.908'.replace(',', ''))
->Reconstructed Predication:
re.findall('n', '123,456.908')
->Raw Input:
implement: convert a string 123,456.908 with dot and comma into a floating number
->Raw Target:
float('123,456.908'.replace(',', ''))
--

22=========
->Original Input:
convert a string `my_string` with dot and comma into a float number `my_float`
->Original Target:
my_float = float(my_string.replace(',', ''))
->Reconstructed Target:
sys.path.append('/path/to/whatever')
->Reconstructed Predication:
os.path.set_pythonpath('path')
->Raw Input:
implement: set pythonpath in python script.
->Raw Target:
sys.path.append('/path/to/whatever')
--

23=========
->Original Input:
convert a string `123,456.908` with dot and comma into a floating number
->Original Target:
float('123,456.908'.replace(',', ''))
->Reconstructed Target:
re.split('(W+)', 'Words, words, words.')
->Reconstructed Predication:
re.split('(W+)', 'Words, words, words.')
->Raw Input:
implement: split string 'Words, words, words.' using a regex '(W+)'
->Raw Target:
re.split('(W+)', 'Words, words, words.')
--

24=========
->Original Input:
set pythonpath in python script.
->Original Target:
sys.path.append('/path/to/whatever')
->Reconstructed Target:
file = open('Output.txt', 'a')
->Reconstructed Predication:
f = open('Output.txt', 'rb')
->Raw Input:
implement: open a file Output.txt in append mode
->Raw Target:
file = open('Output.txt', 'a')
--

25=========
->Original Input:
split string 'Words, words, words.' using a regex '(\\W+)'
->Original Target:
re.split('(\\W+)', 'Words, words, words.')
->Reconstructed Target:
urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3','mp3.mp3')
->Reconstructed Predication:
urllib.request.urlopen('http://www.example.com/songs/mp3.mp3','mp3.mp3')
->Raw Input:
implement: download a file "http://www.example.com/songs/mp3.mp3" over HTTP and save to "mp3.mp3"
->Raw Target:
urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3','mp3.mp3')
--

26=========
->Original Input:
open a file `Output.txt` in append mode
->Original Target:
file = open('Output.txt', 'a')
->Reconstructed Target:
u = urllib.request.urlopen(url) f = open(file_name, 'wb') meta = u.info() file_size = int(meta.getheaders('Content-Length')[0]
->Reconstructed Predication:
file_name = url.request.file_name
->Raw Input:
implement: download a file url over HTTP and save to file_name
->Raw Target:
u = urllib.request.urlopen(url) f = open(file_name, 'wb') meta = u.info() file_size = int(meta.getheaders('Content-Length')[0]
--

27=========
->Original Input:
download a file "http://www.example.com/songs/mp3.mp3" over HTTP and save to "mp3.mp3"
->Original Target:
urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')
->Reconstructed Target:
response = urllib.request.urlopen('http://www.example.com/') html = response.read()
->Reconstructed Predication:
urllib.request.urlopen('http://www.example.com/')
->Raw Input:
implement: download a file 'http://www.example.com/' over HTTP
->Raw Target:
response = urllib.request.urlopen('http://www.example.com/') html = response.read()
--

28=========
->Original Input:
download a file `url` over HTTP and save to `file_name`
->Original Target:
u = urllib.request.urlopen(url)
f = open(file_name, 'wb')
meta = u.info()
file_size = int(meta.getheaders('Content-Length')[0])
print(('Downloading: %s Bytes: %s' % (file_name, file_size)))
file_size_dl = 0
block_sz = 8192
while True:
    buffer = u.read(block_sz)
    if (not buffer):
        break
    file_size_dl += len(buffer)
    f.write(buffer)
    status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))
    status = (status + (chr(8) * (len(status) + 1)))
    print(status, end=' ')
f.close()
->Reconstructed Target:
r = requests.get(url)
->Reconstructed Predication:
url = url.download()
->Raw Input:
implement: download a file url over HTTP
->Raw Target:
r = requests.get(url)
--

29=========
->Original Input:
download a file 'http://www.example.com/' over HTTP
->Original Target:
response = urllib.request.urlopen('http://www.example.com/')
html = response.read()
->Reconstructed Target:
response = requests.get(url, stream=True) with open('10MB', 'wb') as handle: for data in tqdm(response.iter_content()): handle.write(data)
->Reconstructed Predication:
url.request.open('http://www.htc.com.au/download/', '10MB')
->Raw Input:
implement: download a file url over HTTP and save to "10MB"
->Raw Target:
response = requests.get(url, stream=True) with open('10MB', 'wb') as handle: for data in tqdm(response.iter_content()): handle.write(data)
--

30=========
->Original Input:
download a file `url` over HTTP
->Original Target:
r = requests.get(url)
->Reconstructed Target:
parser.add_argument('--version', action='version', version='%(prog)s 2.0')
->Reconstructed Predication:
parser.add_args('--version', '%(prog)s 2.0')
->Raw Input:
implement: argparse add argument with flag '--version' and version action of '%(prog)s 2.0' to parser parser
->Raw Target:
parser.add_argument('--version', action='version', version='%(prog)s 2.0')
--

31=========
->Original Input:
download a file `url` over HTTP and save to "10MB"
->Original Target:
response = requests.get(url, stream=True)
with open('10MB', 'wb') as handle:
    for data in tqdm(response.iter_content()):
        handle.write(data)
->Reconstructed Target:
i: d[i] for i in d if i!= 'c'
->Reconstructed Predication:
d = d['c']
->Raw Input:
implement: remove key 'c' from dictionary d
->Raw Target:
i: d[i] for i in d if i!= 'c'
--

32=========
->Original Input:
argparse add argument with flag '--version' and version action of '%(prog)s 2.0' to parser `parser`
->Original Target:
parser.add_argument('--version', action='version', version='%(prog)s 2.0')
->Reconstructed Target:
pd.merge(split_df, csv_df, on=['key'], suffixes=('_left', '_right'))
->Reconstructed Predication:
df.concat(['key', csv_df, split_df, csv_df], rename=['_left', '_right'])
->Raw Input:
implement: Create new DataFrame object by merging columns "key" of dataframes split_df and csv_df and rename the columns from dataframes split_df and csv_df with suffix _left and _right respectively
->Raw Target:
pd.merge(split_df, csv_df, on=['key'], suffixes=('_left', '_right'))
--

33=========
->Original Input:
remove key 'c' from dictionary `d`
->Original Target:
{i: d[i] for i in d if i != 'c'}
->Reconstructed Target:
s.split(' ', 4)
->Reconstructed Predication:
s.split(',')
->Raw Input:
implement: Split a string s by space with 4 splits
->Raw Target:
s.split(' ', 4)
--

34=========
->Original Input:
Create new DataFrame object by merging columns "key" of  dataframes `split_df` and `csv_df` and rename the columns from dataframes `split_df` and `csv_df` with suffix `_left` and `_right` respectively
->Original Target:
pd.merge(split_df, csv_df, on=['key'], suffixes=('_left', '_right'))
->Reconstructed Target:
input('Enter your input:')
->Reconstructed Predication:
sys.keyboard.read()
->Raw Input:
implement: read keyboard-input
->Raw Target:
input('Enter your input:')
--

35=========
->Original Input:
Split a string `s` by space with `4` splits
->Original Target:
s.split(' ', 4)
->Reconstructed Target:
app.run(debug=True)
->Reconstructed Predication:
app.debug()
->Raw Input:
implement: enable debug mode on Flask application app
->Raw Target:
app.run(debug=True)
--

36=========
->Original Input:
read keyboard-input
->Original Target:
input('Enter your input:')
->Reconstructed Target:
pickle.dump(mylist, open('save.txt', 'wb'))
->Reconstructed Predication:
os.system('save.txt', mylist)
->Raw Input:
implement: python save list mylist to file object'save.txt'
->Raw Target:
pickle.dump(mylist, open('save.txt', 'wb'))
--

37=========
->Original Input:
enable debug mode on Flask application `app`
->Original Target:
app.run(debug=True)
->Reconstructed Target:
scipy.tensordot(P, T, axes=[1, 1]).swapaxes(0, 1)
->Reconstructed Predication:
scipy.multiply((P, T))
->Raw Input:
implement: Multiply a matrix P with a 3d tensor T in scipy
->Raw Target:
scipy.tensordot(P, T, axes=[1, 1]).swapaxes(0, 1)
--

38=========
->Original Input:
python save list `mylist` to file object 'save.txt'
->Original Target:
pickle.dump(mylist, open('save.txt', 'wb'))
->Reconstructed Target:
numpy.zeros((3, 3, 3))
->Reconstructed Predication:
np.array([3, 3, 3])
->Raw Input:
implement: Create 3d array of zeroes of size (3,3,3)
->Raw Target:
numpy.zeros((3, 3, 3))
--

39=========
->Original Input:
Multiply a matrix `P` with a 3d tensor `T` in scipy
->Original Target:
scipy.tensordot(P, T, axes=[1, 1]).swapaxes(0, 1)
->Reconstructed Target:
""" """.join(content.split(' ')[:-1])
->Reconstructed Predication:
content.strip()
->Raw Input:
implement: cut off the last word of a sentence content
->Raw Target:
""" """.join(content.split(' ')[:-1])
--

40=========
->Original Input:
Create 3d array of zeroes of size `(3,3,3)`
->Original Target:
numpy.zeros((3, 3, 3))
->Reconstructed Target:
x = np.asarray(x).reshape(1, -1)[(0), :]
->Reconstructed Predication:
x = x.array(x)
->Raw Input:
implement: convert scalar x to array
->Raw Target:
x = np.asarray(x).reshape(1, -1)[(0), :]
--

41=========
->Original Input:
cut off the last word of a sentence `content`
->Original Target:
""" """.join(content.split(' ')[:-1])
->Reconstructed Target:
sum(sum(i) if isinstance(i, list) else i for i in L)
->Reconstructed Predication:
sum(len(L))
->Raw Input:
implement: sum all elements of nested list L
->Raw Target:
sum(sum(i) if isinstance(i, list) else i for i in L)
--

42=========
->Original Input:
convert scalar `x` to array
->Original Target:
x = np.asarray(x).reshape(1, -1)[(0), :]
->Reconstructed Target:
struct.unpack('!f', '470FC614'.decode('hex'))[0]
->Reconstructed Predication:
float('470FC614', '%d')
->Raw Input:
implement: convert hex string '470FC614' to a float number
->Raw Target:
struct.unpack('!f', '470FC614'.decode('hex'))[0]
--

43=========
->Original Input:
sum all elements of nested list `L`
->Original Target:
sum(sum(i) if isinstance(i, list) else i for i in L)
->Reconstructed Target:
my_dict.update((x, y * 2) for x, y in list(my_dict.items()))
->Reconstructed Predication:
dict((k, v) for k, v in list(my_dict.items()) if k!= 2)
->Raw Input:
implement: Multiple each value by 2 for all keys in a dictionary my_dict
->Raw Target:
my_dict.update((x, y * 2) for x, y in list(my_dict.items()))
--

44=========
->Original Input:
convert hex string '470FC614' to a float number
->Original Target:
struct.unpack('!f', '470FC614'.decode('hex'))[0]
->Reconstructed Target:
subprocess.call('sleep.sh', shell=True)
->Reconstructed Predication:
sleep.sh.run('sleep.sh')
->Raw Input:
implement: running bash script'sleep.sh'
->Raw Target:
subprocess.call('sleep.sh', shell=True)
--

45=========
->Original Input:
Multiple each value by `2` for all keys in a dictionary `my_dict`
->Original Target:
my_dict.update((x, y * 2) for x, y in list(my_dict.items()))
->Reconstructed Target:
""",""".join(l)
->Reconstructed Predication:
[(x + y) for x in l if y!= ',']
->Raw Input:
implement: Join elements of list l with a comma,
->Raw Target:
""",""".join(l)
--

46=========
->Original Input:
running bash script 'sleep.sh'
->Original Target:
subprocess.call('sleep.sh', shell=True)
->Reconstructed Target:
myList = ','.join(map(str, myList))
->Reconstructed Predication:
[(x + y) for x in myList]
->Raw Input:
implement: make a comma-separated string from a list myList
->Raw Target:
myList = ','.join(map(str, myList))
--

47=========
->Original Input:
Join elements of list `l` with a comma `,`
->Original Target:
""",""".join(l)
->Reconstructed Target:
list(reversed(list(range(10))))
->Reconstructed Predication:
[(x + y) for x in range(1)]
->Raw Input:
implement: reverse the list that contains 1 to 10
->Raw Target:
list(reversed(list(range(10))))
--

48=========
->Original Input:
make a comma-separated string from a list `myList`
->Original Target:
myList = ','.join(map(str, myList))
->Reconstructed Target:
print('lamp, bag, mirror'.replace('bag,', ''))
->Reconstructed Predication:
re.sub('lamp, bag, mirror', '', bag)
->Raw Input:
implement: remove substring 'bag,' from a string 'lamp, bag, mirror'
->Raw Target:
print('lamp, bag, mirror'.replace('bag,', ''))
--

49=========
->Original Input:
reverse the list that contains 1 to 10
->Original Target:
list(reversed(list(range(10))))
->Reconstructed Target:
""".""".join(s.split('.')[::-1])
->Reconstructed Predication:
s.reverse('.', 1)
->Raw Input:
implement: Reverse the order of words, delimited by., in string s
->Raw Target:
""".""".join(s.split('.')[::-1])
--

50=========
->Original Input:
remove substring 'bag,' from a string 'lamp, bag, mirror'
->Original Target:
print('lamp, bag, mirror'.replace('bag,', ''))
->Reconstructed Target:
datetime.datetime.fromtimestamp(s).strftime('%Y-%m-%d %H:%M:%S.%f')
->Reconstructed Predication:
time.strftime('%Y-%m-%d %H:%M:%S.%f')
->Raw Input:
implement: convert epoch time represented as milliseconds s to string using format '%Y-%m-%d %H:%M:%S.%f'
->Raw Target:
datetime.datetime.fromtimestamp(s).strftime('%Y-%m-%d %H:%M:%S.%f')
--

51=========
->Original Input:
Reverse the order of words, delimited by `.`, in string `s`
->Original Target:
""".""".join(s.split('.')[::-1])
->Reconstructed Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807 / 1000.0))
->Reconstructed Predication:
print(mstime.strptime('1236472051807', '%Y-%m-%d %H:%M:%S'))
->Raw Input:
implement: parse milliseconds epoch time '1236472051807' to format '%Y-%m-%d %H:%M:%S'
->Raw Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807 / 1000.0))
--

52=========
->Original Input:
convert epoch time represented as milliseconds `s` to string using format '%Y-%m-%d %H:%M:%S.%f'
->Original Target:
datetime.datetime.fromtimestamp(s).strftime('%Y-%m-%d %H:%M:%S.%f')
->Reconstructed Target:
(datetime.datetime.now() - datetime.timedelta(days=7)).date()
->Reconstructed Predication:
datetime.datetime.now().strftime('7')
->Raw Input:
implement: get the date 7 days before the current date
->Raw Target:
(datetime.datetime.now() - datetime.timedelta(days=7)).date()
--

53=========
->Original Input:
parse milliseconds epoch time '1236472051807' to format '%Y-%m-%d %H:%M:%S'
->Original Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807 / 1000.0))
->Reconstructed Target:
print(sum(row[column] for row in data))
->Reconstructed Predication:
sum(x[1] for x in data] for x in column)
->Raw Input:
implement: sum elements at index column of each list in list data
->Raw Target:
print(sum(row[column] for row in data))
--

54=========
->Original Input:
get the date 7 days before the current date
->Original Target:
(datetime.datetime.now() - datetime.timedelta(days=7)).date()
->Reconstructed Target:
[sum(row[i] for row in array) for i in range(len(array[0]))]
->Reconstructed Predication:
sum(x * y for x in array)
->Raw Input:
implement: sum columns of a list array
->Raw Target:
[sum(row[i] for row in array) for i in range(len(array[0]))]
--

55=========
->Original Input:
sum elements at index `column` of each list in list `data`
->Original Target:
print(sum(row[column] for row in data))
->Reconstructed Target:
base64.b64encode(bytes('your string', 'utf-8'))
->Reconstructed Predication:
'your string'.encode('base64')
->Raw Input:
implement: encode binary string 'your string' to base64 code
->Raw Target:
base64.b64encode(bytes('your string', 'utf-8'))
--

56=========
->Original Input:
sum columns of a list `array`
->Original Target:
[sum(row[i] for row in array) for i in range(len(array[0]))]
->Reconstructed Target:
dict((k, [d[k] for d in dicts]) for k in dicts[0])
->Reconstructed Predication:
dict((k, v) for k, v in dicts.items())
->Raw Input:
implement: combine list of dictionaries dicts with the same keys in each list to a single dictionary
->Raw Target:
dict((k, [d[k] for d in dicts]) for k in dicts[0])
--

57=========
->Original Input:
encode binary string 'your string' to base64 code
->Original Target:
base64.b64encode(bytes('your string', 'utf-8'))
->Reconstructed Target:
k: [d[k] for d in dicts] for k in dicts[0]
->Reconstructed Predication:
dicts = dict.merge(k, nested=True)
->Raw Input:
implement: Merge a nested dictionary dicts into a flat dictionary by concatenating nested values with the same key k
->Raw Target:
k: [d[k] for d in dicts] for k in dicts[0]
--

58=========
->Original Input:
combine list of dictionaries `dicts` with the same keys in each list to a single dictionary
->Original Target:
dict((k, [d[k] for d in dicts]) for k in dicts[0])
->Reconstructed Target:
[k for k, v in list(Counter(mylist).items()) if v > 1]
->Reconstructed Predication:
[x for x in mylist if x is duplicate]
->Raw Input:
implement: identify duplicate values in list mylist
->Raw Target:
[k for k, v in list(Counter(mylist).items()) if v > 1]
--

59=========
->Original Input:
Merge a nested dictionary `dicts` into a flat dictionary by concatenating nested values with the same key `k`
->Original Target:
{k: [d[k] for d in dicts] for k in dicts[0]}
->Reconstructed Target:
sys.path.insert(1, os.path.join(os.path.dirname(__file__), 'apps'))
->Reconstructed Predication:
os.path.insert('apps', __file__)
->Raw Input:
implement: Insert directory 'apps' into directory __file__
->Raw Target:
sys.path.insert(1, os.path.join(os.path.dirname(__file__), 'apps'))
--

60=========
->Original Input:
None
->Original Target:
request.args['myParam']
->Reconstructed Target:
sys.path.append(os.path.join(os.path.dirname(__file__),'subdir'))
->Reconstructed Predication:
subdir.modify_sys.path('path')
->Raw Input:
implement: modify sys.path for python module subdir
->Raw Target:
sys.path.append(os.path.join(os.path.dirname(__file__),'subdir'))
--

61=========
->Original Input:
identify duplicate values in list `mylist`
->Original Target:
[k for k, v in list(Counter(mylist).items()) if v > 1]
->Reconstructed Target:
db.execute("INSERT INTO present VALUES('test2',?, 10)", (None,))
->Reconstructed Predication:
df['None'] = df['None']
->Raw Input:
implement: Insert a 'None' value into a SQLite3 table.
->Raw Target:
db.execute("INSERT INTO present VALUES('test2',?, 10)", (None,))
--

62=========
->Original Input:
Insert directory 'apps' into directory `__file__`
->Original Target:
sys.path.insert(1, os.path.join(os.path.dirname(__file__), 'apps'))
->Reconstructed Target:
[image for menuitem in list_of_menuitems for image in menuitem]
->Reconstructed Predication:
list_of_menuitems.flatten()
->Raw Input:
implement: flatten list list_of_menuitems
->Raw Target:
[image for menuitem in list_of_menuitems for image in menuitem]
--

63=========
->Original Input:
modify sys.path for python module `subdir`
->Original Target:
sys.path.append(os.path.join(os.path.dirname(__file__), 'subdir'))
->Reconstructed Target:
a.extend(b)
->Reconstructed Predication:
[i for i, j in a if j is not b]
->Raw Input:
implement: append elements of a set b to a list a
->Raw Target:
a.extend(b)
--

64=========
->Original Input:
Insert a 'None' value into a SQLite3 table.
->Original Target:
db.execute("INSERT INTO present VALUES('test2', ?, 10)", (None,))
->Reconstructed Target:
np.savetxt('c:datanp.txt', df.values, fmt='%d')
->Reconstructed Predication:
df.write('np.txt')
->Raw Input:
implement: write the data of dataframe df into text file np.txt
->Raw Target:
np.savetxt('c:datanp.txt', df.values, fmt='%d')
--

65=========
->Original Input:
flatten list `list_of_menuitems`
->Original Target:
[image for menuitem in list_of_menuitems for image in menuitem]
->Reconstructed Target:
df.to_csv('c:datapandas.txt', header=None, index=None, sep=' ', mode='a')
->Reconstructed Predication:
df.write('c:datapandas.txt')
->Raw Input:
implement: write content of DataFrame df into text file 'c:datapandas.txt'
->Raw Target:
df.to_csv('c:datapandas.txt', header=None, index=None, sep=' ', mode='a')
--

66=========
->Original Input:
append elements of a set `b` to a list `a`
->Original Target:
a.extend(b)
->Reconstructed Target:
print(x.rpartition('-')[0])
->Reconstructed Predication:
x.split('-')
->Raw Input:
implement: Split a string x by last occurrence of character -
->Raw Target:
print(x.rpartition('-')[0])
--

67=========
->Original Input:
None
->Original Target:
a.extend(list(b))
->Reconstructed Target:
print(x.rsplit('-', 1)[0])
->Reconstructed Predication:
re.findall('(.)+', '-')
->Raw Input:
implement: get the last part of a string before the character '-'
->Raw Target:
print(x.rsplit('-', 1)[0])
--

68=========
->Original Input:
write the data of dataframe `df` into text file `np.txt`
->Original Target:
np.savetxt('c:\\data\\np.txt', df.values, fmt='%d')
->Reconstructed Target:
ftp.storlines('STOR'+ filename, open(filename, 'r'))
->Reconstructed Predication:
upload('File.upload(File.Upload())))
->Raw Input:
implement: upload file using FTP
->Raw Target:
ftp.storlines('STOR'+ filename, open(filename, 'r'))
--

69=========
->Original Input:
write content of DataFrame `df` into text file 'c:\\data\\pandas.txt'
->Original Target:
df.to_csv('c:\\data\\pandas.txt', header=None, index=None, sep=' ', mode='a')
->Reconstructed Target:
browser.execute_script("document.getElementById('XYZ').value+='1'")
->Reconstructed Predication:
urllib.add_url('XYZ', urllib.hidden_urls=True)
->Raw Input:
implement: add one to the hidden web element with id 'XYZ' with selenium python script
->Raw Target:
browser.execute_script("document.getElementById('XYZ').value+='1'")
--

70=========
->Original Input:
Split a string `x` by last occurrence of character `-`
->Original Target:
print(x.rpartition('-')[0])
->Reconstructed Target:
np.maximum([2, 3, 4], [1, 5, 2])
->Reconstructed Predication:
np.array([2, 3, 4], [1, 5, 2])
->Raw Input:
implement: create array containing the maximum value of respective elements of array [2, 3, 4] and array [1, 5, 2]
->Raw Target:
np.maximum([2, 3, 4], [1, 5, 2])
--

71=========
->Original Input:
get the last part of a string before the character '-'
->Original Target:
print(x.rsplit('-', 1)[0])
->Reconstructed Target:
print(l[3:] + l[:3])
->Reconstructed Predication:
print(l[0] + 3 + l[0])
->Raw Input:
implement: print a list l and move first 3 elements to the end of the list
->Raw Target:
print(l[3:] + l[:3])
--

72=========
->Original Input:
upload file using FTP
->Original Target:
ftp.storlines('STOR ' + filename, open(filename, 'r'))
->Reconstructed Target:
for fn in os.listdir('.'): if os.path.isfile(fn): pass
->Reconstructed Predication:
os.path.join(os.path.overwrite('.'))
->Raw Input:
implement: loop over files in directory '.'
->Raw Target:
for fn in os.listdir('.'): if os.path.isfile(fn): pass
--

73=========
->Original Input:
add one to the hidden web element with id 'XYZ' with selenium python script
->Original Target:
browser.execute_script("document.getElementById('XYZ').value+='1'")
->Reconstructed Target:
for (root, dirs, filenames) in os.walk(source): for f in filenames: pass
->Reconstructed Predication:
os.path.join(source)
->Raw Input:
implement: loop over files in directory source
->Raw Target:
for (root, dirs, filenames) in os.walk(source): for f in filenames: pass
--

74=========
->Original Input:
create array containing the maximum value of respective elements of array `[2, 3, 4]` and array `[1, 5, 2]`
->Original Target:
np.maximum([2, 3, 4], [1, 5, 2])
->Reconstructed Target:
[int(1000 * random.random()) for i in range(10000)]
->Reconstructed Predication:
random.choice(list(range(9)), key=lambda x: int(x[1]))
->Raw Input:
implement: create a random list of integers
->Raw Target:
[int(1000 * random.random()) for i in range(10000)]
--

75=========
->Original Input:
print a list `l` and move first 3 elements to the end of the list
->Original Target:
print(l[3:] + l[:3])
->Reconstructed Target:
db.GqlQuery('SELECT * FROM Schedule WHERE station = $1', foo.key())
->Reconstructed Predication:
gq.app.execute('SELECT * FROM Schedule WHERE station = $1', 'foo.key()')
->Raw Input:
implement: Google App Engine execute GQL query 'SELECT * FROM Schedule WHERE station = $1' with parameter foo.key()
->Raw Target:
db.GqlQuery('SELECT * FROM Schedule WHERE station = $1', foo.key())
--

76=========
->Original Input:
loop over files in directory '.'
->Original Target:
for fn in os.listdir('.'):
    if os.path.isfile(fn):
        pass
->Reconstructed Target:
df.b.str.contains('f')
->Reconstructed Predication:
df.filter(['f'])
->Raw Input:
implement: filter rows in pandas starting with alphabet 'f' using regular expression.
->Raw Target:
df.b.str.contains('f')
--

77=========
->Original Input:
loop over files in directory `source`
->Original Target:
for (root, dirs, filenames) in os.walk(source):
    for f in filenames:
        pass
->Reconstructed Target:
print('n'.join('t'.join(str(col) for col in row) for row in tab))
->Reconstructed Predication:
print(tab.split())
->Raw Input:
implement: print a 2 dimensional list tab as a table with delimiters
->Raw Target:
print('n'.join('t'.join(str(col) for col in row) for row in tab))
--

78=========
->Original Input:
create a random list of integers
->Original Target:
[int(1000 * random.random()) for i in range(10000)]
->Reconstructed Target:
df.set_index(list('BC')).drop(tuples, errors='ignore').reset_index()
->Reconstructed Predication:
df.drop(df.values())
->Raw Input:
implement: pandas: delete rows in dataframe df based on multiple columns values
->Raw Target:
df.set_index(list('BC')).drop(tuples, errors='ignore').reset_index()
--

79=========
->Original Input:
None
->Original Target:
datetime.datetime.now().strftime('%H:%M:%S.%f')
->Reconstructed Target:
"""(:d goals, $:d)""".format(self.goals, self.penalties)
->Reconstructed Predication:
self.format(self.goals, self.penalties)
->Raw Input:
implement: format the variables self.goals and self.penalties using string formatting
->Raw Target:
"""(:d goals, $:d)""".format(self.goals, self.penalties)
--

80=========
->Original Input:
Google App Engine execute GQL query 'SELECT * FROM Schedule WHERE station = $1' with parameter `foo.key()`
->Original Target:
db.GqlQuery('SELECT * FROM Schedule WHERE station = $1', foo.key())
->Reconstructed Target:
"""( goals, $)""".format(self.goals, self.penalties)
->Reconstructed Predication:
"""( goals, $)""".format(goals, penalties)
->Raw Input:
implement: format string "( goals, $)" with variables goals and penalties
->Raw Target:
"""( goals, $)""".format(self.goals, self.penalties)
--

81=========
->Original Input:
filter rows in pandas starting with alphabet 'f' using regular expression.
->Original Target:
df.b.str.contains('^f')
->Reconstructed Target:
"""(0.goals goals, $0.penalties)""".format(self)
->Reconstructed Predication:
"""(0.goals goals, $0.penalties)""".format('0.goals goals)"
->Raw Input:
implement: format string "(0.goals goals, $0.penalties)"
->Raw Target:
"""(0.goals goals, $0.penalties)""".format(self)
--

82=========
->Original Input:
print a 2 dimensional list `tab` as a table with delimiters
->Original Target:
print('\n'.join('\t'.join(str(col) for col in row) for row in tab))
->Reconstructed Target:
[int(''.join(str(d) for d in x)) for x in L]
->Reconstructed Predication:
[int(x) for x in L]
->Raw Input:
implement: convert list of lists L to list of integers
->Raw Target:
[int(''.join(str(d) for d in x)) for x in L]
--

83=========
->Original Input:
pandas: delete rows in dataframe `df` based on multiple columns values
->Original Target:
df.set_index(list('BC')).drop(tuples, errors='ignore').reset_index()
->Reconstructed Target:
[''.join(str(d) for d in x) for x in L]
->Reconstructed Predication:
[int(x) for x in L]
->Raw Input:
implement: combine elements of each list in list L into digits of a single integer
->Raw Target:
[''.join(str(d) for d in x) for x in L]
--

84=========
->Original Input:
format the variables `self.goals` and `self.penalties` using string formatting
->Original Target:
"""({:d} goals, ${:d})""".format(self.goals, self.penalties)
->Reconstructed Target:
L = [int(''.join([str(y) for y in x])) for x in L]
->Reconstructed Predication:
[int(x) for x in L]
->Raw Input:
implement: convert a list of lists L to list of integers
->Raw Target:
L = [int(''.join([str(y) for y in x])) for x in L]
--

85=========
->Original Input:
format string "({} goals, ${})" with variables `goals` and `penalties`
->Original Target:
"""({} goals, ${})""".format(self.goals, self.penalties)
->Reconstructed Target:
myfile.write('n'.join(lines))
->Reconstructed Predication:
myfile.write('n', lines)
->Raw Input:
implement: write the elements of list lines concatenated by special character 'n' to file myfile
->Raw Target:
myfile.write('n'.join(lines))
--

86=========
->Original Input:
format string "({0.goals} goals, ${0.penalties})"
->Original Target:
"""({0.goals} goals, ${0.penalties})""".format(self)
->Reconstructed Target:
[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if 'X' not in x and 'N' not in x]
->Reconstructed Predication:
[x for x in re.sub('X', 'N') if 'N' in x]
->Raw Input:
implement: removing an element from a list based on a predicate 'X' or 'N'
->Raw Target:
[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if 'X' not in x and 'N' not in x]
--

87=========
->Original Input:
convert list of lists `L` to list of integers
->Original Target:
[int(''.join(str(d) for d in x)) for x in L]
->Reconstructed Target:
text = re.sub('b(w+)( 1b)+', '1', text)
->Reconstructed Predication:
re.sub('w+w+w+w+w+w+w+w+w+w+w+w+w+w+w+w+w+w+w+
->Raw Input:
implement: Remove duplicate words from a string text using regex
->Raw Target:
text = re.sub('b(w+)( 1b)+', '1', text)
--

88=========
->Original Input:
combine elements of each list in list `L` into digits of a single integer
->Original Target:
[''.join(str(d) for d in x) for x in L]
->Reconstructed Target:
df.astype(bool).sum(axis=1)
->Reconstructed Predication:
df.groupby(['0', ''].sum()])
->Raw Input:
implement: count non zero values in each column in pandas data frame
->Raw Target:
df.astype(bool).sum(axis=1)
--

89=========
->Original Input:
convert a list of lists `L` to list of integers
->Original Target:
L = [int(''.join([str(y) for y in x])) for x in L]
->Reconstructed Target:
re.search('(?!Distillr)AcroTray.exe', 'C:SomeDirAcroTray.exe')
->Reconstructed Predication:
re.findall('(?!Distillr)AcroTray.exe', 'C:SomeDirAcroTray.exe')
->Raw Input:
implement: search for string that matches regular expression pattern '(?!Distillr)AcroTray.exe' in string 'C:SomeDirAcroTray.exe'
->Raw Target:
re.search('(?!Distillr)AcroTray.exe', 'C:SomeDirAcroTray.exe')
--

90=========
->Original Input:
write the elements of list `lines` concatenated by special character '\n' to file `myfile`
->Original Target:
myfile.write('\n'.join(lines))
->Reconstructed Target:
"""QH QD JC KD JS""".split()
->Reconstructed Predication:
[item for item in 'QH QD JC KD JS']
->Raw Input:
implement: split string 'QH QD JC KD JS' into a list on white spaces
->Raw Target:
"""QH QD JC KD JS""".split()
--

91=========
->Original Input:
removing an element from a list based on a predicate 'X' or 'N'
->Original Target:
[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if 'X' not in x and 'N' not in x]
->Reconstructed Target:
print(re.search('>.*', line).group(0))
->Reconstructed Predication:
line.find('>.*')
->Raw Input:
implement: search for occurrences of regex pattern '>.*' in xml string line
->Raw Target:
print(re.search('>.*', line).group(0))
--

92=========
->Original Input:
Remove duplicate words from a string `text` using regex
->Original Target:
text = re.sub('\\b(\\w+)( \\1\\b)+', '\\1', text)
->Reconstructed Target:
open(filename, 'w').close()
->Reconstructed Predication:
os.remove(filename)
->Raw Input:
implement: erase all the contents of a file filename
->Raw Target:
open(filename, 'w').close()
--

93=========
->Original Input:
count non zero values in each column in pandas data frame
->Original Target:
df.astype(bool).sum(axis=1)
->Reconstructed Target:
datetime.datetime.strptime(string_date, '%Y-%m-%d %H:%M:%S.%f')
->Reconstructed Predication:
datetime.datetime.strptime('%Y-%m-%d %H:%M:%S.%f')
->Raw Input:
implement: convert a string into datetime using the format '%Y-%m-%d %H:%M:%S.%f'
->Raw Target:
datetime.datetime.strptime(string_date, '%Y-%m-%d %H:%M:%S.%f')
--

94=========
->Original Input:
search for string that matches regular expression pattern '(?<!Distillr)\\\\AcroTray\\.exe' in string 'C:\\SomeDir\\AcroTray.exe'
->Original Target:
re.search('(?<!Distillr)\\\\AcroTray\\.exe', 'C:\\SomeDir\\AcroTray.exe')
->Reconstructed Target:
[index for index, item in enumerate(thelist) if item[0] == '332']
->Reconstructed Predication:
[x[0] for x in thelist if x[0] == 332]
->Raw Input:
implement: find the index of a list with the first element equal to '332' within the list of lists thelist
->Raw Target:
[index for index, item in enumerate(thelist) if item[0] == '332']
--

95=========
->Original Input:
split string 'QH QD JC KD JS' into a list on white spaces
->Original Target:
"""QH QD JC KD JS""".split()
->Reconstructed Target:
re.sub('[sa-zA-Z0-9]', '', text).lower().strip()
->Reconstructed Predication:
print('n'.join('n'.join('n'.join(text))))
->Raw Input:
implement: lower a string text and remove non-alphanumeric characters aside from space
->Raw Target:
re.sub('[sa-zA-Z0-9]', '', text).lower().strip()
--

96=========
->Original Input:
search for occurrences of regex pattern '>.*<' in xml string `line`
->Original Target:
print(re.search('>.*<', line).group(0))
->Reconstructed Target:
re.sub('(?!s)[W_]', '', text).lower().strip()
->Reconstructed Predication:
re.sub('([a-z])', '1', text)
->Raw Input:
implement: remove all non-alphanumeric characters except space from a string text and lower it
->Raw Target:
re.sub('(?!s)[W_]', '', text).lower().strip()
--

97=========
->Original Input:
erase all the contents of a file `filename`
->Original Target:
open(filename, 'w').close()
->Reconstructed Target:
plt.plot(x, y, label='Hu2082O')
->Reconstructed Predication:
plt.label('x', 'y')['H20'] + '2'
->Raw Input:
implement: subscript text 'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
->Raw Target:
plt.plot(x, y, label='Hu2082O')
--

98=========
->Original Input:
convert a string into datetime using the format '%Y-%m-%d %H:%M:%S.%f'
->Original Target:
datetime.datetime.strptime(string_date, '%Y-%m-%d %H:%M:%S.%f')
->Reconstructed Target:
plt.plot(x, y, label='$H_2O$')
->Reconstructed Predication:
plt.label('x', 'y')['H20'] + '2'
->Raw Input:
implement: subscript text 'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
->Raw Target:
plt.plot(x, y, label='$H_2O$')
--

99=========
->Original Input:
find the index of a list with the first element equal to '332' within the list of lists `thelist`
->Original Target:
[index for index, item in enumerate(thelist) if item[0] == '332']
->Reconstructed Target:
[x for x in mylist if len(x) == 3]
->Reconstructed Predication:
mylist.lstrip()
->Raw Input:
implement: loop over a list mylist if sublists length equals 3
->Raw Target:
[x for x in mylist if len(x) == 3]
--

100=========
->Original Input:
lower a string `text` and remove non-alphanumeric characters aside from space
->Original Target:
re.sub('[^\\sa-zA-Z0-9]', '', text).lower().strip()
->Reconstructed Target:
lst = [Object() for _ in range(100)]
->Reconstructed Predication:
lst = [(x, y) for x in range(100)]
->Raw Input:
implement: initialize a list lst of 100 objects Object()
->Raw Target:
lst = [Object() for _ in range(100)]
--

101=========
->Original Input:
remove all non-alphanumeric characters except space from a string `text` and lower it
->Original Target:
re.sub('(?!\\s)[\\W_]', '', text).lower().strip()
->Reconstructed Target:
lst = [Object() for i in range(100)]
->Reconstructed Predication:
lst = [(Object) for object in list(Object.instances())]
->Raw Input:
implement: create list lst containing 100 instances of object Object
->Raw Target:
lst = [Object() for i in range(100)]
--

102=========
->Original Input:
subscript text 'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
->Original Target:
plt.plot(x, y, label='H\u2082O')
->Reconstructed Target:
self.driver.find_element_by_css_selector('.someclass a').get_attribute('href')
->Reconstructed Predication:
print((href.child(), whose parent has css someclass))
->Raw Input:
implement: get the content of child tag withhref attribute whose parent has css someclass
->Raw Target:
self.driver.find_element_by_css_selector('.someclass a').get_attribute('href')
--

103=========
->Original Input:
subscript text 'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
->Original Target:
plt.plot(x, y, label='$H_2O$')
->Reconstructed Target:
df1.merge(df2, on='Date_Time')
->Reconstructed Predication:
pd.concat([df1, df2, 'Date_Time']).match()
->Raw Input:
implement: joining data from dataframe df1 with data from dataframe df2 based on matching values of column 'Date_Time' in both dataframes
->Raw Target:
df1.merge(df2, on='Date_Time')
--

104=========
->Original Input:
loop over a list `mylist` if sublists length equals 3
->Original Target:
[x for x in mylist if len(x) == 3]
->Reconstructed Target:
'first string is: %s, second one is: %s' % (str1, 'geo.tif')
->Reconstructed Predication:
print('$'.join(str1 == str1))
->Raw Input:
implement: use %s operator to print variable values str1 inside a string
->Raw Target:
'first string is: %s, second one is: %s' % (str1, 'geo.tif')
--

105=========
->Original Input:
initialize a list `lst` of 100 objects Object()
->Original Target:
lst = [Object() for _ in range(100)]
->Reconstructed Target:
if (not os.path.exists(directory)): os.makedirs(directory)
->Reconstructed Predication:
os.path.exists(directory)
->Raw Input:
implement: check if directory directory  exists and create it if necessary
->Raw Target:
if (not os.path.exists(directory)): os.makedirs(directory)
--

106=========
->Original Input:
create list `lst` containing 100 instances of object `Object`
->Original Target:
lst = [Object() for i in range(100)]
->Reconstructed Target:
try: os.makedirs(path) except OSError: if (not os.path.isdir(path)): raise
->Reconstructed Predication:
os.path.exists(path)
->Raw Input:
implement: check if a directory path exists and create it if necessary
->Raw Target:
try: os.makedirs(path) except OSError: if (not os.path.isdir(path)): raise
--

107=========
->Original Input:
get the content of child tag with`href` attribute whose parent has css `someclass`
->Original Target:
self.driver.find_element_by_css_selector('.someclass a').get_attribute('href')
->Reconstructed Target:
distutils.dir_util.mkpath(path)
->Reconstructed Predication:
os.path.exists(path)
->Raw Input:
implement: check if a directory path exists and create it if necessary
->Raw Target:
distutils.dir_util.mkpath(path)
--

108=========
->Original Input:
joining data from dataframe `df1` with data from dataframe `df2` based on matching values of column 'Date_Time' in both dataframes
->Original Target:
df1.merge(df2, on='Date_Time')
->Reconstructed Target:
try: os.makedirs(path) except OSError as exception: if (exception.errno!= errno.EEXIST): raise
->Reconstructed Predication:
os.path.exists(path)
->Raw Input:
implement: check if a directory path exists and create it if necessary
->Raw Target:
try: os.makedirs(path) except OSError as exception: if (exception.errno!= errno.EEXIST): raise
--

109=========
->Original Input:
use `%s` operator to print variable values `str1` inside a string
->Original Target:
'first string is: %s, second one is: %s' % (str1, 'geo.tif')
->Reconstructed Target:
re.sub('bH3b', 'H1', text)
->Reconstructed Predication:
re.sub('(?w+)', 'H3', 'H1', text)
->Raw Input:
implement: Replace a separate word 'H3' by 'H1' in a string 'text'
->Raw Target:
re.sub('bH3b', 'H1', text)
--

110=========
->Original Input:
None
->Original Target:
[x.strip() for x in '2.MATCHES $$TEXT$$ STRING'.split('$$TEXT$$')]
->Reconstructed Target:
re.sub('D', '', 'aas30dsa20')
->Reconstructed Predication:
re.sub('(?(?))', '', 'aas30dsa20', '')
->Raw Input:
implement: substitute ASCII letters in string 'aas30dsa20' with empty string ''
->Raw Target:
re.sub('D', '', 'aas30dsa20')
--

111=========
->Original Input:
check if directory `directory ` exists and create it if necessary
->Original Target:
if (not os.path.exists(directory)):
    os.makedirs(directory)
->Reconstructed Target:
"""""".join([x for x in 'aas30dsa20' if x.isdigit()])
->Reconstructed Predication:
print(['aas30dsa20', ''.join(str(x)) for x in s.split(')]))
->Raw Input:
implement: get digits only from a string aas30dsa20 using lambda function
->Raw Target:
"""""".join([x for x in 'aas30dsa20' if x.isdigit()])
--

112=========
->Original Input:
check if a directory `path` exists and create it if necessary
->Original Target:
try:
    os.makedirs(path)
except OSError:
    if (not os.path.isdir(path)):
        raise
->Reconstructed Target:
print(soup.find('name').string)
->Reconstructed Predication:
soup.find_element_by_name('name')
->Raw Input:
implement: access a tag called "name" in beautifulsoup soup
->Raw Target:
print(soup.find('name').string)
--

113=========
->Original Input:
check if a directory `path` exists and create it if necessary
->Original Target:
distutils.dir_util.mkpath(path)
->Reconstructed Target:
records = dict((record['_id'], record) for record in cursor)
->Reconstructed Predication:
records = pyMongo.keys.values().values()
->Raw Input:
implement: get a dictionary records of key-value pairs in PyMongo cursor cursor
->Raw Target:
records = dict((record['_id'], record) for record in cursor)
--

114=========
->Original Input:
check if a directory `path` exists and create it if necessary
->Original Target:
try:
    os.makedirs(path)
except OSError as exception:
    if (exception.errno != errno.EEXIST):
        raise
->Reconstructed Target:
np.concatenate((A, B))
->Reconstructed Predication:
np.concat([a, b])
->Raw Input:
implement: Create new matrix object by concatenating data from matrix A and matrix B
->Raw Target:
np.concatenate((A, B))
--

115=========
->Original Input:
Replace a separate word 'H3' by 'H1' in a string 'text'
->Original Target:
re.sub('\\bH3\\b', 'H1', text)
->Reconstructed Target:
np.vstack((A, B))
->Reconstructed Predication:
numpy.concat([(A, B)]).concat([(A, B)])
->Raw Input:
implement: concat two matrices A and B in numpy
->Raw Target:
np.vstack((A, B))
--

116=========
->Original Input:
substitute ASCII letters in string 'aas30dsa20' with empty string ''
->Original Target:
re.sub('\\D', '', 'aas30dsa20')
->Reconstructed Target:
os.stat(filepath).st_size
->Reconstructed Predication:
np.characters(filepath)
->Raw Input:
implement: Get the characters count in a file filepath
->Raw Target:
os.stat(filepath).st_size
--

117=========
->Original Input:
get digits only from a string `aas30dsa20` using lambda function
->Original Target:
"""""".join([x for x in 'aas30dsa20' if x.isdigit()])
->Reconstructed Target:
l.count('a')
->Reconstructed Predication:
count(l, key=lambda x: x['a'])
->Raw Input:
implement: count the occurrences of item "a" in list l
->Raw Target:
l.count('a')
--

118=========
->Original Input:
access a tag called "name" in beautifulsoup `soup`
->Original Target:
print(soup.find('name').string)
->Reconstructed Target:
Counter(l)
->Reconstructed Predication:
sum(x for x in l)
->Raw Input:
implement: count the occurrences of items in list l
->Raw Target:
Counter(l)
--

119=========
->Original Input:
get a dictionary `records` of key-value pairs in PyMongo cursor `cursor`
->Original Target:
records = dict((record['_id'], record) for record in cursor)
->Reconstructed Target:
[[x, l.count(x)] for x in set(l)]
->Reconstructed Predication:
sum(x for x in l)
->Raw Input:
implement: count the occurrences of items in list l
->Raw Target:
[[x, l.count(x)] for x in set(l)]
--

120=========
->Original Input:
Create new matrix object  by concatenating data from matrix A and matrix B
->Original Target:
np.concatenate((A, B))
->Reconstructed Target:
dict(((x, l.count(x)) for x in set(l)))
->Reconstructed Predication:
sum(x for x in l)
->Raw Input:
implement: count the occurrences of items in list l
->Raw Target:
dict(((x, l.count(x)) for x in set(l)))
--

121=========
->Original Input:
concat two matrices `A` and `B` in numpy
->Original Target:
np.vstack((A, B))
->Reconstructed Target:
l.count('b')
->Reconstructed Predication:
count(l, key=lambda x: x['b'])
->Raw Input:
implement: count the occurrences of item "b" in list l
->Raw Target:
l.count('b')
--

122=========
->Original Input:
Get the characters count in a file `filepath`
->Original Target:
os.stat(filepath).st_size
->Reconstructed Target:
shutil.copy(srcfile, dstdir)
->Reconstructed Predication:
os.path.join(os.path.to_dstdir(srcfile))
->Raw Input:
implement: copy file srcfile to directory dstdir
->Raw Target:
shutil.copy(srcfile, dstdir)
--

123=========
->Original Input:
count the occurrences of item "a" in list `l`
->Original Target:
l.count('a')
->Reconstructed Target:
max(k for k, v in x.items() if v!= 0)
->Reconstructed Predication:
x.find(key=lambda x: x[1] - x[0])
->Raw Input:
implement: find the key associated with the largest value in dictionary x whilst key is non-zero value
->Raw Target:
max(k for k, v in x.items() if v!= 0)
--

124=========
->Original Input:
count the occurrences of items in list `l`
->Original Target:
Counter(l)
->Reconstructed Target:
(k for k, v in x.items() if v!= 0)
->Reconstructed Predication:
x[:(-1)]
->Raw Input:
implement: get the largest key whose not associated with value of 0 in dictionary x
->Raw Target:
(k for k, v in x.items() if v!= 0)
--

125=========
->Original Input:
count the occurrences of items in list `l`
->Original Target:
[[x, l.count(x)] for x in set(l)]
->Reconstructed Target:
max(k for k, v in x.items() if v!= 0)
->Reconstructed Predication:
x[:(-1)]
->Raw Input:
implement: get the largest key in a dictionary x with non-zero value
->Raw Target:
max(k for k, v in x.items() if v!= 0)
--

126=========
->Original Input:
count the occurrences of items in list `l`
->Original Target:
dict(((x, l.count(x)) for x in set(l)))
->Reconstructed Target:
file.seek(0)
->Reconstructed Predication:
cursor.place('', '')
->Raw Input:
implement: Put the curser at beginning of the file
->Raw Target:
file.seek(0)
--

127=========
->Original Input:
count the occurrences of item "b" in list `l`
->Original Target:
l.count('b')
->Reconstructed Target:
df['c'] = np.where(df['a'].isnull, df['b'], df['a'])
->Reconstructed Predication:
df['c'].groupby(['b', 'a'], axis=1)
->Raw Input:
implement: combine values from column 'b' and column 'a' of dataframe df into column 'c' of datafram df
->Raw Target:
df['c'] = np.where(df['a'].isnull, df['b'], df['a'])
--

128=========
->Original Input:
copy file `srcfile` to directory `dstdir`
->Original Target:
shutil.copy(srcfile, dstdir)
->Reconstructed Target:
del d['ele']
->Reconstructed Predication:
d = d['ele']
->Raw Input:
implement: remove key 'ele' from dictionary d
->Raw Target:
del d['ele']
--

129=========
->Original Input:
find the key associated with the largest value in dictionary `x` whilst key is non-zero value
->Original Target:
max(k for k, v in x.items() if v != 0)
->Reconstructed Target:
MyModel.objects.update(timestamp=F('timestamp') + timedelta(days=36524.25))
->Reconstructed Predication:
MyModel.datetime.datetime.now() + 100 years
->Raw Input:
implement: Update datetime field in MyModel to be the existing timestamp plus 100 years
->Raw Target:
MyModel.objects.update(timestamp=F('timestamp') + timedelta(days=36524.25))
--

130=========
->Original Input:
get the largest key whose not associated with value of 0 in dictionary `x`
->Original Target:
(k for k, v in x.items() if v != 0)
->Reconstructed Target:
['it'] + ['was'] + ['annoying']
->Reconstructed Predication:
['it'] = ['was'] = ['annoying']
->Raw Input:
implement: merge list ['it'] and list ['was'] and list ['annoying'] into one list
->Raw Target:
['it'] + ['was'] + ['annoying']
--

131=========
->Original Input:
get the largest key in a dictionary `x` with non-zero value
->Original Target:
max(k for k, v in x.items() if v != 0)
->Reconstructed Target:
str(int(x) + 1).zfill(len(x))
->Reconstructed Predication:
x[0] = int(x, x[0]))
->Raw Input:
implement: increment a value with leading zeroes in a number x
->Raw Target:
str(int(x) + 1).zfill(len(x))
--

132=========
->Original Input:
Put the curser at beginning of the file
->Original Target:
file.seek(0)
->Reconstructed Target:
all(df.index[:-1] = df.index[1:])
->Reconstructed Predication:
df.sort(index=True)
->Raw Input:
implement: check if a pandas dataframe df's index is sorted
->Raw Target:
all(df.index[:-1] = df.index[1:])
--

133=========
->Original Input:
combine values from column 'b' and column 'a' of dataframe `df`  into column 'c' of datafram `df`
->Original Target:
df['c'] = np.where(df['a'].isnull, df['b'], df['a'])
->Reconstructed Target:
list(t)
->Reconstructed Predication:
[x for x in t if x is not t[0]]
->Raw Input:
implement: Convert tuple t to list
->Raw Target:
list(t)
--

134=========
->Original Input:
remove key 'ele' from dictionary `d`
->Original Target:
del d['ele']
->Reconstructed Target:
tuple(l)
->Reconstructed Predication:
t = [(x, y) for x in t]
->Raw Input:
implement: Convert list t to tuple
->Raw Target:
tuple(l)
--

135=========
->Original Input:
Update datetime field in `MyModel` to be the existing `timestamp` plus 100 years
->Original Target:
MyModel.objects.update(timestamp=F('timestamp') + timedelta(days=36524.25))
->Reconstructed Target:
level1 = map(list, level1)
->Reconstructed Predication:
list(level1.items())
->Raw Input:
implement: Convert tuple level1 to list
->Raw Target:
level1 = map(list, level1)
--

136=========
->Original Input:
merge list `['it']` and list `['was']` and list `['annoying']` into one list
->Original Target:
['it'] + ['was'] + ['annoying']
->Reconstructed Target:
pprint.pprint(dataobject, logFile)
->Reconstructed Predication:
print(dataobject.send(logFile))
->Raw Input:
implement: send the output of pprint object dataobject to file logFile
->Raw Target:
pprint.pprint(dataobject, logFile)
--

137=========
->Original Input:
increment a value with leading zeroes in a number `x`
->Original Target:
str(int(x) + 1).zfill(len(x))
->Reconstructed Target:
df.loc[df['BoolCol']]
->Reconstructed Predication:
np.index('BoolCol')
->Raw Input:
implement: get index of rows in column 'BoolCol'
->Raw Target:
df.loc[df['BoolCol']]
--

138=========
->Original Input:
check if a pandas dataframe `df`'s index is sorted
->Original Target:
all(df.index[:-1] <= df.index[1:])
->Reconstructed Target:
df.iloc[np.flatnonzero(df['BoolCol'])]
->Reconstructed Predication:
df['BoolCol'] == True
->Raw Input:
implement: Create a list containing the indexes of rows where the value of column 'BoolCol' in dataframe df are equal to True
->Raw Target:
df.iloc[np.flatnonzero(df['BoolCol'])]
--

139=========
->Original Input:
Convert tuple `t` to list
->Original Target:
list(t)
->Reconstructed Target:
df[df['BoolCol'] == True].index.tolist()
->Reconstructed Predication:
[x for x in 'BoolCol' if x == True]
->Raw Input:
implement: get list of indexes of rows where column 'BoolCol' values match True
->Raw Target:
df[df['BoolCol'] == True].index.tolist()
--

140=========
->Original Input:
Convert list `t` to tuple
->Original Target:
tuple(l)
->Reconstructed Target:
df[df['BoolCol']].index.tolist()
->Reconstructed Predication:
df.loc[df['BoolCol'] == True]
->Raw Input:
implement: get index of rows in dataframe df which column 'BoolCol' matches value True
->Raw Target:
df[df['BoolCol']].index.tolist()
--

141=========
->Original Input:
Convert tuple `level1` to list
->Original Target:
level1 = map(list, level1)
->Reconstructed Target:
os.chdir(owd)
->Reconstructed Predication:
os.chdir(owd)
->Raw Input:
implement: change working directory to the directory owd
->Raw Target:
os.chdir(owd)
--

142=========
->Original Input:
send the output of pprint object `dataobject` to file `logFile`
->Original Target:
pprint.pprint(dataobject, logFile)
->Reconstructed Target:
c.execute("INSERT INTO test VALUES (?, 'bar')", (testfield,))
->Reconstructed Predication:
c = db.insert(testfield, '')
->Raw Input:
implement: insert data from a string testfield to sqlite db c
->Raw Target:
c.execute("INSERT INTO test VALUES (?, 'bar')", (testfield,))
--

143=========
->Original Input:
get index of rows in column 'BoolCol'
->Original Target:
df.loc[df['BoolCol']]
->Reconstructed Target:
"""x89n""".decode('string_escape')
->Reconstructed Predication:
"""x89n""".decode('normal')
->Raw Input:
implement: decode string "x89n" into a normal string
->Raw Target:
"""x89n""".decode('string_escape')
--

144=========
->Original Input:
Create a list containing the indexes of rows where the value of column 'BoolCol' in dataframe `df` are equal to True
->Original Target:
df.iloc[np.flatnonzero(df['BoolCol'])]
->Reconstructed Target:
raw_string.decode('string_escape')
->Reconstructed Predication:
''.join(raw_string)
->Raw Input:
implement: convert a raw string raw_string into a normal string
->Raw Target:
raw_string.decode('string_escape')
--

145=========
->Original Input:
get list of indexes of rows where column 'BoolCol' values match True
->Original Target:
df[df['BoolCol'] == True].index.tolist()
->Reconstructed Target:
raw_byte_string.decode('unicode_escape')
->Reconstructed Predication:
''.join(raw_byte_string)
->Raw Input:
implement: convert a raw string raw_byte_string into a normal string
->Raw Target:
raw_byte_string.decode('unicode_escape')
--

146=========
->Original Input:
get index of rows in dataframe `df` which column 'BoolCol' matches value True
->Original Target:
df[df['BoolCol']].index.tolist()
->Reconstructed Target:
[m.group(0) for m in re.finditer('(d)1*', s)]
->Reconstructed Predication:
re.findall('(?=[s])', s)
->Raw Input:
implement: split a string s with into all strings of repeated characters
->Raw Target:
[m.group(0) for m in re.finditer('(d)1*', s)]
--

147=========
->Original Input:
change working directory to the directory `owd`
->Original Target:
os.chdir(owd)
->Reconstructed Target:
plt.scatter(np.random.randn(100), np.random.randn(100), facecolors='none')
->Reconstructed Predication:
p = scatter(x, y, np.random.randn(100))
->Raw Input:
implement: scatter a plot with x, y position of np.random.randn(100) and face color equal to none
->Raw Target:
plt.scatter(np.random.randn(100), np.random.randn(100), facecolors='none')
--

148=========
->Original Input:
insert data from a string `testfield` to sqlite db `c`
->Original Target:
c.execute("INSERT INTO test VALUES (?, 'bar')", (testfield,))
->Reconstructed Target:
plt.plot(np.random.randn(100), np.random.randn(100), 'o', mfc='none')
->Reconstructed Predication:
plt.scatter('n')
->Raw Input:
implement: do a scatter plot with empty circles
->Raw Target:
plt.plot(np.random.randn(100), np.random.randn(100), 'o', mfc='none')
--

149=========
->Original Input:
decode string "\\x89\\n" into a normal string
->Original Target:
"""\\x89\\n""".decode('string_escape')
->Reconstructed Target:
soup.find('div', id='main-content').decompose()
->Reconstructed Predication:
soup.remove(div.id='main-content')
->Raw Input:
implement: remove a div with a id main-content using beautifulsoup
->Raw Target:
soup.find('div', id='main-content').decompose()
--

150=========
->Original Input:
convert a raw string `raw_string` into a normal string
->Original Target:
raw_string.decode('string_escape')
->Reconstructed Target:
df[df['ids'].str.contains('ball')]
->Reconstructed Predication:
ids.filter('ball')
->Raw Input:
implement: filter rows containing key word ball in column ids
->Raw Target:
df[df['ids'].str.contains('ball')]
--

151=========
->Original Input:
convert a raw string `raw_byte_string` into a normal string
->Original Target:
raw_byte_string.decode('unicode_escape')
->Reconstructed Target:
df.reset_index(level=0, inplace=True)
->Reconstructed Predication:
df.columns[0].to_index()
->Raw Input:
implement: convert index at level 0 into a column in dataframe df
->Raw Target:
df.reset_index(level=0, inplace=True)
--

152=========
->Original Input:
split a string `s` with into all strings of repeated characters
->Original Target:
[m.group(0) for m in re.finditer('(\\d)\\1*', s)]
->Reconstructed Target:
df['index1'] = df.index
->Reconstructed Predication:
df.groupby(index1).index1.index().add_index()
->Raw Input:
implement: Add indexes in a data frame df to a column index1
->Raw Target:
df['index1'] = df.index
--

153=========
->Original Input:
scatter a plot with x, y position of `np.random.randn(100)` and face color equal to none
->Original Target:
plt.scatter(np.random.randn(100), np.random.randn(100), facecolors='none')
->Reconstructed Target:
df.reset_index(level=['tick', 'obs'])
->Reconstructed Predication:
df.columns
->Raw Input:
implement: convert pandas index in a dataframe to columns
->Raw Target:
df.reset_index(level=['tick', 'obs'])
--

154=========
->Original Input:
do a scatter plot with empty circles
->Original Target:
plt.plot(np.random.randn(100), np.random.randn(100), 'o', mfc='none')
->Reconstructed Target:
[x[::-1] for x in b]
->Reconstructed Predication:
b.reverse()
->Raw Input:
implement: Get reverse of list items from list 'b' using extended slicing
->Raw Target:
[x[::-1] for x in b]
--

155=========
->Original Input:
remove a div with a id `main-content` using beautifulsoup
->Original Target:
soup.find('div', id='main-content').decompose()
->Reconstructed Target:
np.array([zip(x, y) for x, y in zip(a, b)])
->Reconstructed Predication:
tuple(a, b)
->Raw Input:
implement: join each element in array a with element at the same index in array b as a tuple
->Raw Target:
np.array([zip(x, y) for x, y in zip(a, b)])
--

156=========
->Original Input:
filter rows containing key word `ball` in column `ids`
->Original Target:
df[df['ids'].str.contains('ball')]
->Reconstructed Target:
np.array(zip(a.ravel(), b.ravel()), dtype='i4,i4').reshape(a.shape)
->Reconstructed Predication:
zip(a, b)
->Raw Input:
implement: zip two 2-d arrays a and b
->Raw Target:
np.array(zip(a.ravel(), b.ravel()), dtype='i4,i4').reshape(a.shape)
--

157=========
->Original Input:
convert index at level 0 into a column in dataframe `df`
->Original Target:
df.reset_index(level=0, inplace=True)
->Reconstructed Target:
""",""".join([str(i) for i in list_of_ints])
->Reconstructed Predication:
''.join(''.join(''.join(''.join(''.'.)) for i in list_of_ints))
->Raw Input:
implement: convert list list_of_ints into a comma separated string
->Raw Target:
""",""".join([str(i) for i in list_of_ints])
--

158=========
->Original Input:
Add indexes in a data frame `df` to a column `index1`
->Original Target:
df['index1'] = df.index
->Reconstructed Target:
requests.post(url, data=DATA, headers=HEADERS_DICT, auth=(username, password))
->Reconstructed Predication:
re.send('u003u003u003u003u003u003u003u003u003u003u003u003u003u003
->Raw Input:
implement: Send a post request with raw data DATA and basic authentication with username and password
->Raw Target:
requests.post(url, data=DATA, headers=HEADERS_DICT, auth=(username, password))
--

159=========
->Original Input:
convert pandas index in a dataframe to columns
->Original Target:
df.reset_index(level=['tick', 'obs'])
->Reconstructed Target:
'abcddef'.rfind('')
->Reconstructed Predication:
"""abcddef""".findall('')
->Raw Input:
implement: Find last occurrence of character '' in string "abcddef"
->Raw Target:
'abcddef'.rfind('')
--

160=========
->Original Input:
Get reverse of list items from list 'b' using extended slicing
->Original Target:
[x[::-1] for x in b]
->Reconstructed Target:
print([item for item in [1, 2, 3]])
->Reconstructed Predication:
iter([1, 2, 3])
->Raw Input:
implement: Iterate ove list [1, 2, 3] using list comprehension
->Raw Target:
print([item for item in [1, 2, 3]])
--

161=========
->Original Input:
join each element in array `a` with element at the same index in array `b` as a tuple
->Original Target:
np.array([zip(x, y) for x, y in zip(a, b)])
->Reconstructed Target:
[(x['x'], x['y']) for x in d]
->Reconstructed Predication:
[d['x'], d['y'], axis=1)
->Raw Input:
implement: extract all the values with keys 'x' and 'y' from a list of dictionaries d to list of tuples
->Raw Target:
[(x['x'], x['y']) for x in d]
--

162=========
->Original Input:
zip two 2-d arrays `a` and `b`
->Original Target:
np.array(zip(a.ravel(), b.ravel()), dtype='i4,i4').reshape(a.shape)
->Reconstructed Target:
print(os.path.splitext(os.path.basename('hemanth.txt'))[0])
->Reconstructed Predication:
os.path.dirname('hemanth.txt')
->Raw Input:
implement: get the filename without the extension from file 'hemanth.txt'
->Raw Target:
print(os.path.splitext(os.path.basename('hemanth.txt'))[0])
--

163=========
->Original Input:
convert list `list_of_ints` into a comma separated string
->Original Target:
""",""".join([str(i) for i in list_of_ints])
->Reconstructed Target:
dict(x[i:i + 2] for i in range(0, len(x), 2))
->Reconstructed Predication:
dict((k, v) for k, v in x.items() if v)
->Raw Input:
implement: create a dictionary by adding each two adjacent elements in tuple x as key/value pair to it
->Raw Target:
dict(x[i:i + 2] for i in range(0, len(x), 2))
--

164=========
->Original Input:
Send a post request with raw data `DATA` and basic authentication with `username` and `password`
->Original Target:
requests.post(url, data=DATA, headers=HEADERS_DICT, auth=(username, password))
->Reconstructed Target:
values = sum([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], [])
->Reconstructed Predication:
[['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]
->Raw Input:
implement: create a list containing flattened list [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]
->Raw Target:
values = sum([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], [])
--

165=========
->Original Input:
Find last occurrence of character '}' in string "abcd}def}"
->Original Target:
'abcd}def}'.rfind('}')
->Reconstructed Target:
df = df[(df['closing_price'] >= 99) & (df['closing_price'] = 101)]
->Reconstructed Predication:
df['closing_price'].select()
->Raw Input:
implement: select rows in a dataframe df column 'closing_price' between two values 99 and 101
->Raw Target:
df = df[(df['closing_price'] >= 99) & (df['closing_price'] = 101)]
--

166=========
->Original Input:
Iterate ove list `[1, 2, 3]` using list comprehension
->Original Target:
print([item for item in [1, 2, 3]])
->Reconstructed Target:
df.replace('n': 'br>', regex=True)
->Reconstructed Predication:
df.replace('n', 'br>')
->Raw Input:
implement: replace all occurences of newlines n with br> in dataframe df
->Raw Target:
df.replace('n': 'br>', regex=True)
--

167=========
->Original Input:
extract all the values with keys 'x' and 'y' from a list of dictionaries `d` to list of tuples
->Original Target:
[(x['x'], x['y']) for x in d]
->Reconstructed Target:
df.replace('n': 'br>', regex=True)
->Reconstructed Predication:
df.replace('n', 'br>')
->Raw Input:
implement: replace all occurrences of a string n by string br> in a pandas data frame df
->Raw Target:
df.replace('n': 'br>', regex=True)
--

168=========
->Original Input:
get the filename without the extension from file 'hemanth.txt'
->Original Target:
print(os.path.splitext(os.path.basename('hemanth.txt'))[0])
->Reconstructed Target:
[(x + y) for x, y in zip(word, word[1:])]
->Reconstructed Predication:
[x for x in word for x in re.findall('w+w+w+w+w+w+', '', word)]
->Raw Input:
implement: create a list containing each two adjacent letters in string word as its elements
->Raw Target:
[(x + y) for x, y in zip(word, word[1:])]
--

169=========
->Original Input:
create a dictionary by adding each two adjacent elements in tuple `x` as key/value pair to it
->Original Target:
dict(x[i:i + 2] for i in range(0, len(x), 2))
->Reconstructed Target:
list(map(lambda x, y: x + y, word[:-1], word[1:]))
->Reconstructed Predication:
[(x + y) for x in word.split()]
->Raw Input:
implement: Get a list of pairs from a string word using lambda function
->Raw Target:
list(map(lambda x, y: x + y, word[:-1], word[1:]))
--

170=========
->Original Input:
create a list containing flattened list `[['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]`
->Original Target:
values = sum([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], [])
->Reconstructed Target:
print(re.findall('(https?://[s]+)', myString))
->Reconstructed Predication:
urllib.find(myString, 'n')
->Raw Input:
implement: extract a url from a string myString
->Raw Target:
print(re.findall('(https?://[s]+)', myString))
--

171=========
->Original Input:
select rows in a dataframe `df` column 'closing_price' between two values 99 and 101
->Original Target:
df = df[(df['closing_price'] >= 99) & (df['closing_price'] <= 101)]
->Reconstructed Target:
print(re.search('(?Purl>https?://[s]+)', myString).group('url'))
->Reconstructed Predication:
urllib.find(myString, 'n')
->Raw Input:
implement: extract a url from a string myString
->Raw Target:
print(re.search('(?Purl>https?://[s]+)', myString).group('url'))
--

172=========
->Original Input:
replace all occurences of newlines `\n` with `<br>` in dataframe `df`
->Original Target:
df.replace({'\n': '<br>'}, regex=True)
->Reconstructed Target:
re.sub('[A-Za-z0-9]+', '', mystring)
->Reconstructed Predication:
mystring.replace('', '', re.sub('', '', ''))
->Raw Input:
implement: remove all special characters, punctuation and spaces from a string mystring using regex
->Raw Target:
re.sub('[A-Za-z0-9]+', '', mystring)
--

173=========
->Original Input:
replace all occurrences of a string `\n` by string `<br>` in a pandas data frame `df`
->Original Target:
df.replace({'\n': '<br>'}, regex=True)
->Reconstructed Target:
pd.date_range('2016-01-01', freq='WOM-2FRI', periods=13)
->Reconstructed Predication:
datetime.datetime.strptime('2016-01-01', 13).strftime('%Y-%m-%d, %Y')
->Raw Input:
implement: create a DatetimeIndex containing 13 periods of the second friday of each month starting from date '2016-01-01'
->Raw Target:
pd.date_range('2016-01-01', freq='WOM-2FRI', periods=13)
--

174=========
->Original Input:
create a list containing each two adjacent letters in string `word` as its elements
->Original Target:
[(x + y) for x, y in zip(word, word[1:])]
->Reconstructed Target:
matrix = [[a, b], [c, d], [e, f]]
->Reconstructed Predication:
matrix = python.matrix(row=3, column=2, cols=1)
->Raw Input:
implement: Create multidimensional array matrix with 3 rows and 2 columns in python
->Raw Target:
matrix = [[a, b], [c, d], [e, f]]
--

175=========
->Original Input:
Get a list of pairs from a string `word` using lambda function
->Original Target:
list(map(lambda x, y: x + y, word[:-1], word[1:]))
->Reconstructed Target:
mystring.replace(' ', '_')
->Reconstructed Predication:
re.sub('[]+', '', '', s)
->Raw Input:
implement: replace spaces with underscore
->Raw Target:
mystring.replace(' ', '_')
--

176=========
->Original Input:
extract a url from a string `myString`
->Original Target:
print(re.findall('(https?://[^\\s]+)', myString))
->Reconstructed Target:
os.path.abspath('mydir/myfile.txt')
->Reconstructed Predication:
os.path.dirname('mydir/myfile.txt')
->Raw Input:
implement: get an absolute file path of file'mydir/myfile.txt'
->Raw Target:
os.path.abspath('mydir/myfile.txt')
--

177=========
->Original Input:
extract a url from a string `myString`
->Original Target:
print(re.search('(?P<url>https?://[^\\s]+)', myString).group('url'))
->Reconstructed Target:
""" """.join(my_string.split())
->Reconstructed Predication:
my_string.split()
->Raw Input:
implement: split string my_string on white spaces
->Raw Target:
""" """.join(my_string.split())
--

178=========
->Original Input:
remove all special characters, punctuation and spaces from a string `mystring` using regex
->Original Target:
re.sub('[^A-Za-z0-9]+', '', mystring)
->Reconstructed Target:
os.path.splitext(filename)[0]
->Reconstructed Predication:
os.path.getfile(filename)
->Raw Input:
implement: get filename without extension from file filename
->Raw Target:
os.path.splitext(filename)[0]
--

179=========
->Original Input:
create a DatetimeIndex containing 13 periods of the second friday of each month starting from date '2016-01-01'
->Original Target:
pd.date_range('2016-01-01', freq='WOM-2FRI', periods=13)
->Reconstructed Target:
[sum(l[:i]) for i, _ in enumerate(l)]
->Reconstructed Predication:
[sum(i) + i + i) for i, l in zip(l, l)]
->Raw Input:
implement: get a list containing the sum of each element i in list l plus the previous elements
->Raw Target:
[sum(l[:i]) for i, _ in enumerate(l)]
--

180=========
->Original Input:
Create multidimensional array `matrix` with 3 rows and 2 columns in python
->Original Target:
matrix = [[a, b], [c, d], [e, f]]
->Reconstructed Target:
"""Docs/src/Scripts/temp""".replace('/', '/x00/').split('x00')
->Reconstructed Predication:
re.split('Docs/src/Scripts/temp', '/')
->Raw Input:
implement: split a string Docs/src/Scripts/temp by / keeping / in the result
->Raw Target:
"""Docs/src/Scripts/temp""".replace('/', '/x00/').split('x00')
--

181=========
->Original Input:
replace spaces with underscore
->Original Target:
mystring.replace(' ', '_')
->Reconstructed Target:
np.random.shuffle(np.transpose(r))
->Reconstructed Predication:
np.shuffle([r, r[np.shuffle(r, r)], axis=1)
->Raw Input:
implement: shuffle columns of an numpy array 'r'
->Raw Target:
np.random.shuffle(np.transpose(r))
--

182=========
->Original Input:
get an absolute file path of file 'mydir/myfile.txt'
->Original Target:
os.path.abspath('mydir/myfile.txt')
->Reconstructed Target:
df['D'] = df['B']
->Reconstructed Predication:
df['B'].copy().replace('D', axis=1)
->Raw Input:
implement: copy all values in a column 'B' to a new column 'D' in a pandas data frame 'df'
->Raw Target:
df['D'] = df['B']
--

183=========
->Original Input:
split string `my_string` on white spaces
->Original Target:
""" """.join(my_string.split())
->Reconstructed Target:
list(data['A']['B'].values())[0]['maindata'][0]['Info']
->Reconstructed Predication:
json.get('data', 'B')
->Raw Input:
implement: find a value within nested json 'data' where the key inside another key 'B' is unknown.
->Raw Target:
list(data['A']['B'].values())[0]['maindata'][0]['Info']
--

184=========
->Original Input:
get filename without extension from file `filename`
->Original Target:
os.path.splitext(filename)[0]
->Reconstructed Target:
all(predicate(x) for x in string)
->Reconstructed Predication:
string.ispredicate()
->Raw Input:
implement: check characters of string string are true predication of function predicate
->Raw Target:
all(predicate(x) for x in string)
--

185=========
->Original Input:
get a list containing the sum of each element `i` in list `l` plus the previous elements
->Original Target:
[sum(l[:i]) for i, _ in enumerate(l)]
->Reconstructed Target:
os.statvfs('/').f_files - os.statvfs('/').f_ffree
->Reconstructed Predication:
np.memory()
->Raw Input:
implement: determine number of files on a drive with python
->Raw Target:
os.statvfs('/').f_files - os.statvfs('/').f_ffree
--

186=========
->Original Input:
split a string `Docs/src/Scripts/temp` by `/` keeping `/` in the result
->Original Target:
"""Docs/src/Scripts/temp""".replace('/', '/\x00/').split('\x00')
->Reconstructed Target:
user_list = [int(number) for number in user_input.split(',')]
->Reconstructed Predication:
user_list = [int(x) for x in user_input]
->Raw Input:
implement: convert string user_input into a list of integers user_list
->Raw Target:
user_list = [int(number) for number in user_input.split(',')]
--

187=========
->Original Input:
shuffle columns of an numpy array 'r'
->Original Target:
np.random.shuffle(np.transpose(r))
->Reconstructed Target:
[int(s) for s in user.split(',')]
->Reconstructed Predication:
list(int(user.split()))
->Raw Input:
implement: Get a list of integers by splitting a string user with comma
->Raw Target:
[int(s) for s in user.split(',')]
--

188=========
->Original Input:
copy all values in a column 'B' to a new column 'D' in a pandas data frame 'df'
->Original Target:
df['D'] = df['B']
->Reconstructed Target:
ut.sort(key=cmpfun, reverse=True)
->Reconstructed Predication:
sorted(ut, key=operator.itemgetter(1))
->Raw Input:
implement: sort a list of objects ut, based on a function cmpfun in descending order
->Raw Target:
ut.sort(key=cmpfun, reverse=True)
--

189=========
->Original Input:
find a value within nested json 'data' where the key inside another key 'B' is unknown.
->Original Target:
list(data['A']['B'].values())[0]['maindata'][0]['Info']
->Reconstructed Target:
ut.sort(key=lambda x: x.count, reverse=True)
->Reconstructed Predication:
ut.reverse('count', key=operator.itemgetter(1))
->Raw Input:
implement: reverse list ut based on the count attribute of each object
->Raw Target:
ut.sort(key=lambda x: x.count, reverse=True)
--

190=========
->Original Input:
check characters of string `string` are true predication of function `predicate`
->Original Target:
all(predicate(x) for x in string)
->Reconstructed Target:
ut.sort(key=lambda x: x.count, reverse=True)
->Reconstructed Predication:
sorted(ut, key=lambda x: x[1])
->Raw Input:
implement: sort a list of objects ut in reverse order by their count property
->Raw Target:
ut.sort(key=lambda x: x.count, reverse=True)
--

191=========
->Original Input:
determine number of files on a drive with python
->Original Target:
os.statvfs('/').f_files - os.statvfs('/').f_ffree
->Reconstructed Target:
driver.find_element_by_partial_link_text('Send').click()
->Reconstructed Predication:
urllib.request.urlopen('Send', 'r')
->Raw Input:
implement: click a href button 'Send' with selenium
->Raw Target:
driver.find_element_by_partial_link_text('Send').click()
--

192=========
->Original Input:
None
->Original Target:
cursor.fetchone()[0]
->Reconstructed Target:
driver.findElement(By.linkText('Send InMail')).click()
->Reconstructed Predication:
sendInMail('Send InMail')
->Raw Input:
implement: click a href button having text Send InMail with selenium
->Raw Target:
driver.findElement(By.linkText('Send InMail')).click()
--

193=========
->Original Input:
convert string `user_input` into a list of integers `user_list`
->Original Target:
user_list = [int(number) for number in user_input.split(',')]
->Reconstructed Target:
driver.find_element_by_link_text('Send InMail').click()
->Reconstructed Predication:
urllib.request.urlurl.urlopen('Send InMail', 'http://www.urllib.org/search')
->Raw Input:
implement: click a href button with text 'Send InMail' with selenium
->Raw Target:
driver.find_element_by_link_text('Send InMail').click()
--

194=========
->Original Input:
Get a list of integers by splitting  a string `user` with comma
->Original Target:
[int(s) for s in user.split(',')]
->Reconstructed Target:
'ME' + str(i)
->Reconstructed Predication:
i = 'ME'.join(i)
->Raw Input:
implement: cast an int i to a string and concat to string 'ME'
->Raw Target:
'ME' + str(i)
--

195=========
->Original Input:
None
->Original Target:
sorted(list, key=lambda x: (x[0], -x[1]))
->Reconstructed Target:
open('outfile', 'w').write('#test firstlinen' + open('infile').read())
->Reconstructed Predication:
os.savefile('outfile')['#test firstlinen']
->Raw Input:
implement: prepend the line '#test firstlinen' to the contents of file 'infile' and save as the file 'outfile'
->Raw Target:
open('outfile', 'w').write('#test firstlinen' + open('infile').read())
--

196=========
->Original Input:
sort a list of objects `ut`, based on a function `cmpfun` in descending order
->Original Target:
ut.sort(key=cmpfun, reverse=True)
->Reconstructed Target:
l.sort(key=lambda t: len(t[1]), reverse=True)
->Reconstructed Predication:
sorted(l, key=lambda x: (len(x[1])))
->Raw Input:
implement: sort a list l by length of value in tuple
->Raw Target:
l.sort(key=lambda t: len(t[1]), reverse=True)
--

197=========
->Original Input:
reverse list `ut` based on the `count` attribute of each object
->Original Target:
ut.sort(key=lambda x: x.count, reverse=True)
->Reconstructed Target:
re.findall('b(w+)db', s)
->Reconstructed Predication:
s.split('d')
->Raw Input:
implement: split string s by words that ends with 'd'
->Raw Target:
re.findall('b(w+)db', s)
--

198=========
->Original Input:
sort a list of objects `ut` in reverse order by their `count` property
->Original Target:
ut.sort(key=lambda x: x.count, reverse=True)
->Reconstructed Target:
bool(re.search('ba[rzd]', 'foobarrrr'))
->Reconstructed Predication:
re.findall('foobarrrr', 'ba[rzd]')
->Raw Input:
implement: return True if string foobarrrr contains regex ba[rzd]
->Raw Target:
bool(re.search('ba[rzd]', 'foobarrrr'))
--

199=========
->Original Input:
click a href button 'Send' with selenium
->Original Target:
driver.find_element_by_partial_link_text('Send').click()
->Reconstructed Target:
list(set(t))
->Reconstructed Predication:
[duplicates for d in t]
->Raw Input:
implement: Removing duplicates in list t
->Raw Target:
list(set(t))
--

200=========
->Original Input:
click a href button having text `Send InMail` with selenium
->Original Target:
driver.findElement(By.linkText('Send InMail')).click()
->Reconstructed Target:
list(set(source_list))
->Reconstructed Predication:
source_list = list(remove(lambda x: x.remove(x.remove(x.remove(x.remove(x.remove(x.remove(x.remove(x.
->Raw Input:
implement: Removing duplicates in list source_list
->Raw Target:
list(set(source_list))
--

201=========
->Original Input:
click a href button with text 'Send InMail' with selenium
->Original Target:
driver.find_element_by_link_text('Send InMail').click()
->Reconstructed Target:
list(OrderedDict.fromkeys('abracadabra'))
->Reconstructed Predication:
abracadabra.remove(lambda x: x.split())
->Raw Input:
implement: Removing duplicates in list abracadabra
->Raw Target:
list(OrderedDict.fromkeys('abracadabra'))
--

202=========
->Original Input:
cast an int `i` to a string and concat to string 'ME'
->Original Target:
'ME' + str(i)
->Reconstructed Target:
numpy.array(a).reshape(-1).tolist()
->Reconstructed Predication:
[i for i in a for i in i]
->Raw Input:
implement: Convert array a into a list
->Raw Target:
numpy.array(a).reshape(-1).tolist()
--

203=========
->Original Input:
None
->Original Target:
df.sort_values(['System_num', 'Dis'])
->Reconstructed Target:
numpy.array(a)[0].tolist()
->Reconstructed Predication:
[np.arange(a[0], a[0])]
->Raw Input:
implement: Convert the first row of numpy matrix a to a list
->Raw Target:
numpy.array(a)[0].tolist()
--

204=========
->Original Input:
prepend the line '#test firstline\n' to the contents of file 'infile' and save as the file 'outfile'
->Original Target:
open('outfile', 'w').write('#test firstline\n' + open('infile').read())
->Reconstructed Target:
print(soup.find(text='Address:').findNext('td').contents[0])
->Reconstructed Predication:
soup.get('td', text='Address:')
->Raw Input:
implement: In soup, get the content of the sibling of the td tag with text content Address:
->Raw Target:
print(soup.find(text='Address:').findNext('td').contents[0])
--

205=========
->Original Input:
sort a list `l` by length of value in tuple
->Original Target:
l.sort(key=lambda t: len(t[1]), reverse=True)
->Reconstructed Target:
""" """.join([('%d@%d' % t) for t in l])
->Reconstructed Predication:
"""@""".join([(x[1]) for x in l])
->Raw Input:
implement: convert elements of each tuple in list l into a string separated by character @
->Raw Target:
""" """.join([('%d@%d' % t) for t in l])
--

206=========
->Original Input:
split string `s` by words that ends with 'd'
->Original Target:
re.findall('\\b(\\w+)d\\b', s)
->Reconstructed Target:
""" """.join([('%d@%d' % (t[0], t[1])) for t in l])
->Reconstructed Predication:
[(x + y) for x in l]
->Raw Input:
implement: convert each tuple in list l to a string with '@' separating the tuples' elements
->Raw Target:
""" """.join([('%d@%d' % (t[0], t[1])) for t in l])
--

207=========
->Original Input:
return `True` if string `foobarrrr` contains regex `ba[rzd]`
->Original Target:
bool(re.search('ba[rzd]', 'foobarrrr'))
->Reconstructed Target:
driver.execute_script('return document.documentElement.outerHTML;')
->Reconstructed Predication:
driver.get_html()
->Raw Input:
implement: get the html from the current web page of a Selenium driver
->Raw Target:
driver.execute_script('return document.documentElement.outerHTML;')
--

208=========
->Original Input:
Removing duplicates in list `t`
->Original Target:
list(set(t))
->Reconstructed Target:
[i for i in teststr if re.search('d+[xX]', i)]
->Reconstructed Predication:
print(re.findall('d+[xX]', teststr))
->Raw Input:
implement: Get all matches with regex pattern d+[xX] in list of string teststr
->Raw Target:
[i for i in teststr if re.search('d+[xX]', i)]
--

209=========
->Original Input:
Removing duplicates in list `source_list`
->Original Target:
list(set(source_list))
->Reconstructed Target:
df['A'][(df['B'] > 50) & (df['C'] == 900)]
->Reconstructed Predication:
df['A'].loc['B'] > 50, df['C'] - 900]
->Raw Input:
implement: select values from column 'A' for which corresponding values in column 'B' will be greater than 50, and in column 'C' - equal 900 in dataframe df
->Raw Target:
df['A'][(df['B'] > 50) & (df['C'] == 900)]
--

210=========
->Original Input:
Removing duplicates in list `abracadabra`
->Original Target:
list(OrderedDict.fromkeys('abracadabra'))
->Reconstructed Target:
sorted(o.items())
->Reconstructed Predication:
sorted(list(o.items()), key=o.itemgetter(1))
->Raw Input:
implement: Sort dictionary o in ascending order based on its keys and items
->Raw Target:
sorted(o.items())
--

211=========
->Original Input:
Convert array `a` into a list
->Original Target:
numpy.array(a).reshape(-1).tolist()
->Reconstructed Target:
sorted(d)
->Reconstructed Predication:
sorted(d, key=lambda d: d[::-1])
->Raw Input:
implement: get sorted list of keys of dict d
->Raw Target:
sorted(d)
--

212=========
->Original Input:
Convert the first row of numpy matrix `a` to a list
->Original Target:
numpy.array(a)[0].tolist()
->Reconstructed Target:
int('1')
->Reconstructed Predication:
int('1', 16)
->Raw Input:
implement: convert string "1" into integer
->Raw Target:
int('1')
--

213=========
->Original Input:
In `soup`, get the content of the sibling of the `td`  tag with text content `Address:`
->Original Target:
print(soup.find(text='Address:').findNext('td').contents[0])
->Reconstructed Target:
int()
->Reconstructed Predication:
int('0:.1f'.format(string))
->Raw Input:
implement: function to convert strings into integers
->Raw Target:
int()
--

214=========
->Original Input:
convert elements of each tuple in list `l` into a string  separated by character `@`
->Original Target:
""" """.join([('%d@%d' % t) for t in l])
->Reconstructed Target:
T2 = [map(int, x) for x in T1]
->Reconstructed Predication:
int('1:1'.join(str(i) for i in T1))
->Raw Input:
implement: convert items in T1 to integers
->Raw Target:
T2 = [map(int, x) for x in T1]
--

215=========
->Original Input:
convert each tuple in list `l` to a string with '@' separating the tuples' elements
->Original Target:
""" """.join([('%d@%d' % (t[0], t[1])) for t in l])
->Reconstructed Target:
subprocess.call(['./test.sh'])
->Reconstructed Predication:
subprocess.call('./test.sh', shell=True)
->Raw Input:
implement: call a shell script./test.sh using subprocess
->Raw Target:
subprocess.call(['./test.sh'])
--

216=========
->Original Input:
get the html from the current web page of a Selenium driver
->Original Target:
driver.execute_script('return document.documentElement.outerHTML;')
->Reconstructed Target:
subprocess.call(['notepad'])
->Reconstructed Predication:
subprocess.call('notepad', shell=True)
->Raw Input:
implement: call a shell script notepad using subprocess
->Raw Target:
subprocess.call(['notepad'])
--

217=========
->Original Input:
Get all matches with regex pattern `\\d+[xX]` in list of string `teststr`
->Original Target:
[i for i in teststr if re.search('\\d+[xX]', i)]
->Reconstructed Target:
[val for pair in zip(l1, l2) for val in pair]
->Reconstructed Predication:
[x for x in l1 for x in l2]
->Raw Input:
implement: combine lists l1 and l2 by alternating their elements
->Raw Target:
[val for pair in zip(l1, l2) for val in pair]
--

218=========
->Original Input:
select values from column 'A' for which corresponding values in column 'B' will be greater than 50, and in column 'C' - equal 900 in dataframe `df`
->Original Target:
df['A'][(df['B'] > 50) & (df['C'] == 900)]
->Reconstructed Target:
encoded = base64.b64encode('data to be encoded')
->Reconstructed Predication:
'data to be encoded'.encode('data to be encoded')
->Raw Input:
implement: encode string 'data to be encoded'
->Raw Target:
encoded = base64.b64encode('data to be encoded')
--

219=========
->Original Input:
Sort dictionary `o` in ascending order based on its keys and items
->Original Target:
sorted(o.items())
->Reconstructed Target:
encoded = 'data to be encoded'.encode('ascii')
->Reconstructed Predication:
ascii = encoding('data to be encoded')
->Raw Input:
implement: encode a string data to be encoded to ascii encoding
->Raw Target:
encoded = 'data to be encoded'.encode('ascii')
--

220=========
->Original Input:
get sorted list of keys of dict `d`
->Original Target:
sorted(d)
->Reconstructed Target:
lol = list(csv.reader(open('text.txt', 'rb'), delimiter='t'))
->Reconstructed Predication:
csv.read_csv('text.txt', 'r')
->Raw Input:
implement: parse tab-delimited CSV file 'text.txt' into a list
->Raw Target:
lol = list(csv.reader(open('text.txt', 'rb'), delimiter='t'))
--

221=========
->Original Input:
None
->Original Target:
sorted(d.items())
->Reconstructed Target:
getattr(my_object, my_str)
->Reconstructed Predication:
my_object.getattr(my_str)
->Raw Input:
implement: Get attribute my_str of object my_object
->Raw Target:
getattr(my_object, my_str)
--

222=========
->Original Input:
convert string "1" into integer
->Original Target:
int('1')
->Reconstructed Target:
print(dict(zip(LD[0], zip(*[list(d.values()) for d in LD]))))
->Reconstructed Predication:
dict((k, v) for k, v in LD.items())
->Raw Input:
implement: group a list of dicts LD into one dict by key
->Raw Target:
print(dict(zip(LD[0], zip(*[list(d.values()) for d in LD]))))
--

223=========
->Original Input:
function to convert strings into integers
->Original Target:
int()
->Reconstructed Target:
d = ast.literal_eval("'code1':1,'code2':1")
->Reconstructed Predication:
dict((k, v) for k, v in ''code1':1,'code2':1')
->Raw Input:
implement: convert unicode string u"'code1':1,'code2':1" into dictionary
->Raw Target:
d = ast.literal_eval("'code1':1,'code2':1")
--

224=========
->Original Input:
convert items in `T1` to integers
->Original Target:
T2 = [map(int, x) for x in T1]
->Reconstructed Target:
[word for word in mystring.split() if word.startswith('$')]
->Reconstructed Predication:
mystring.findall('$')
->Raw Input:
implement: find all words in a string mystring that start with the $ sign
->Raw Target:
[word for word in mystring.split() if word.startswith('$')]
--

225=========
->Original Input:
call a shell script `./test.sh` using subprocess
->Original Target:
subprocess.call(['./test.sh'])
->Reconstructed Target:
text = re.sub('https?://.*[rn]*', '', text, flags=re.MULTILINE)
->Reconstructed Predication:
urllib.replace('', text)
->Raw Input:
implement: remove any url within string text
->Raw Target:
text = re.sub('https?://.*[rn]*', '', text, flags=re.MULTILINE)
--

226=========
->Original Input:
call a shell script `notepad` using subprocess
->Original Target:
subprocess.call(['notepad'])
->Reconstructed Target:
np.where(np.in1d(A, [1, 3, 4]).reshape(A.shape), A, 0)
->Reconstructed Predication:
A[1, 3, 4] = np.replace(np.all(A, axis=0))
->Raw Input:
implement: replace all elements in array A that are not present in array [1, 3, 4] with zeros
->Raw Target:
np.where(np.in1d(A, [1, 3, 4]).reshape(A.shape), A, 0)
--

227=========
->Original Input:
combine lists `l1` and `l2`  by alternating their elements
->Original Target:
[val for pair in zip(l1, l2) for val in pair]
->Reconstructed Target:
np.mean(a, axis=1)
->Reconstructed Predication:
a.mean()
->Raw Input:
implement: calculate mean across dimension in a 2d array a
->Raw Target:
np.mean(a, axis=1)
--

228=========
->Original Input:
encode string 'data to be encoded'
->Original Target:
encoded = base64.b64encode('data to be encoded')
->Reconstructed Target:
subprocess.call(['/usr/bin/Rscript', '--vanilla', '/pathto/MyrScript.r'])
->Reconstructed Predication:
r = os.system('/pathto/MyrScript.r')
->Raw Input:
implement: running r script '/pathto/MyrScript.r' from python
->Raw Target:
subprocess.call(['/usr/bin/Rscript', '--vanilla', '/pathto/MyrScript.r'])
--

229=========
->Original Input:
encode a string `data to be encoded` to `ascii` encoding
->Original Target:
encoded = 'data to be encoded'.encode('ascii')
->Reconstructed Target:
subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)
->Reconstructed Predication:
r = r.run('/usr/bin/Rscript --vanilla /pathto/MyrScript.r')
->Raw Input:
implement: run r script '/usr/bin/Rscript --vanilla /pathto/MyrScript.r'
->Raw Target:
subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)
--

230=========
->Original Input:
parse tab-delimited CSV file 'text.txt' into a list
->Original Target:
lol = list(csv.reader(open('text.txt', 'rb'), delimiter='\t'))
->Reconstructed Target:
writer.writeheader()
->Reconstructed Predication:
csv.headers.add_headers()
->Raw Input:
implement: add a header to a csv file
->Raw Target:
writer.writeheader()
--

231=========
->Original Input:
Get attribute `my_str` of object `my_object`
->Original Target:
getattr(my_object, my_str)
->Reconstructed Target:
df.fillna(df.mean(axis=1), axis=1)
->Reconstructed Predication:
df.replace(nan, row=0, row=0)
->Raw Input:
implement: replacing nan in the dataframe df with row average
->Raw Target:
df.fillna(df.mean(axis=1), axis=1)
--

232=========
->Original Input:
group a list of dicts `LD` into one dict by key
->Original Target:
print(dict(zip(LD[0], zip(*[list(d.values()) for d in LD]))))
->Reconstructed Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1347517370))
->Reconstructed Predication:
time.strptime('1347517370', '%Y-%m-%d %H:%M:%S')
->Raw Input:
implement: Convert unix timestamp '1347517370' to formatted string '%Y-%m-%d %H:%M:%S'
->Raw Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1347517370))
--

233=========
->Original Input:
None
->Original Target:
sum([pair[0] for pair in list_of_pairs])
->Reconstructed Target:
super(Derived, cls).do(a)
->Reconstructed Predication:
do = derived(Derived)
->Raw Input:
implement: Call a base class's class method do from derived class Derived
->Raw Target:
super(Derived, cls).do(a)
--

234=========
->Original Input:
convert unicode string u"{'code1':1,'code2':1}" into dictionary
->Original Target:
d = ast.literal_eval("{'code1':1,'code2':1}")
->Reconstructed Target:
a[np.where((a[:, (0)] == 0) * (a[:, (1)] == 1))]
->Reconstructed Predication:
np.select('a', a[0], a[1])
->Raw Input:
implement: selecting rows in Numpy ndarray 'a', where the value in the first column is 0 and value in the second column is 1
->Raw Target:
a[np.where((a[:, (0)] == 0) * (a[:, (1)] == 1))]
--

235=========
->Original Input:
find all words in a string `mystring` that start with the `$` sign
->Original Target:
[word for word in mystring.split() if word.startswith('$')]
->Reconstructed Target:
re.split(' +', 'hello world sample text')
->Reconstructed Predication:
list(itertools.product('w+'))
->Raw Input:
implement: separate words delimited by one or more spaces into a list
->Raw Target:
re.split(' +', 'hello world sample text')
--

236=========
->Original Input:
remove any url within string `text`
->Original Target:
text = re.sub('^https?:\\/\\/.*[\\r\\n]*', '', text, flags=re.MULTILINE)
->Reconstructed Target:
len(max(words, key=len))
->Reconstructed Predication:
length(len(words))
->Raw Input:
implement: length of longest element in list words
->Raw Target:
len(max(words, key=len))
--

237=========
->Original Input:
replace all elements in array `A` that are not present in array `[1, 3, 4]` with zeros
->Original Target:
np.where(np.in1d(A, [1, 3, 4]).reshape(A.shape), A, 0)
->Reconstructed Target:
result[0]['from_user']
->Reconstructed Predication:
result = [item['from_user'] for item in result]
->Raw Input:
implement: get the value associated with unicode key 'from_user' of first dictionary in list result
->Raw Target:
result[0]['from_user']
--

238=========
->Original Input:
calculate mean across dimension in a 2d array `a`
->Original Target:
np.mean(a, axis=1)
->Reconstructed Target:
[line.split() for line in open('File.txt')]
->Reconstructed Predication:
os.path.join('File.txt', 'r')
->Raw Input:
implement: Retrieve each line from a file 'File.txt' as a list
->Raw Target:
[line.split() for line in open('File.txt')]
--

239=========
->Original Input:
running r script '/pathto/MyrScript.r' from python
->Original Target:
subprocess.call(['/usr/bin/Rscript', '--vanilla', '/pathto/MyrScript.r'])
->Reconstructed Target:
res = dict((v, k) for k, v in a.items())
->Reconstructed Predication:
dict((k, v) for k, v in a)
->Raw Input:
implement: swap keys with values in a dictionary a
->Raw Target:
res = dict((v, k) for k, v in a.items())
--

240=========
->Original Input:
run r script '/usr/bin/Rscript --vanilla /pathto/MyrScript.r'
->Original Target:
subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)
->Reconstructed Target:
new_file = open('path/to/FILE_NAME.ext', 'w')
->Reconstructed Predication:
os.path.to/FILE_NAME.ext
->Raw Input:
implement: Open a file path/to/FILE_NAME.ext in write mode
->Raw Target:
new_file = open('path/to/FILE_NAME.ext', 'w')
--

241=========
->Original Input:
add a header to a csv file
->Original Target:
writer.writeheader()
->Reconstructed Target:
any(key.startswith('EMP$$') for key in dict1)
->Reconstructed Predication:
any(dict1, key=dict1.startswith('EMP$$'))
->Raw Input:
implement: Check if any key in the dictionary dict1 starts with the string EMP$$
->Raw Target:
any(key.startswith('EMP$$') for key in dict1)
--

242=========
->Original Input:
replacing nan in the dataframe `df` with row average
->Original Target:
df.fillna(df.mean(axis=1), axis=1)
->Reconstructed Target:
[value for key, value in list(dict1.items()) if key.startswith('EMP$$')]
->Reconstructed Predication:
[value for key in list(dict1.items()) if key == 'EMP$$']
->Raw Input:
implement: create list of values from dictionary dict1 that have a key that starts with 'EMP$$'
->Raw Target:
[value for key, value in list(dict1.items()) if key.startswith('EMP$$')]
--

243=========
->Original Input:
Convert unix timestamp '1347517370' to formatted string '%Y-%m-%d %H:%M:%S'
->Original Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1347517370))
->Reconstructed Target:
pd.DataFrame('email': sf.index, 'list': sf.values)
->Reconstructed Predication:
df = pd.DataFrame(sf, columns=['email', 'list'])
->Raw Input:
implement: convert a pandas series sf into a pandas dataframe df with columns email and list
->Raw Target:
pd.DataFrame('email': sf.index, 'list': sf.values)
--

244=========
->Original Input:
Call a base class's class method `do` from derived class `Derived`
->Original Target:
super(Derived, cls).do(a)
->Reconstructed Target:
print('t'.join(map(str, list)))
->Reconstructed Predication:
print(list, key=lambda x: x[1])
->Raw Input:
implement: print elements of list list seperated by tabs t
->Raw Target:
print('t'.join(map(str, list)))
--

245=========
->Original Input:
selecting rows in Numpy ndarray 'a', where the value in the first column is 0 and value in the second column is 1
->Original Target:
a[np.where((a[:, (0)] == 0) * (a[:, (1)] == 1))]
->Reconstructed Target:
print('xd0xbfxd1x80xd0xb8'.encode('raw_unicode_escape'))
->Reconstructed Predication:
print('xd0xbfxd1x80xd0xb8'.encode('utf-8'))
->Raw Input:
implement: print unicode string 'xd0xbfxd1x80xd0xb8' with utf-8
->Raw Target:
print('xd0xbfxd1x80xd0xb8'.encode('raw_unicode_escape'))
--

246=========
->Original Input:
separate words delimited by one or more spaces into a list
->Original Target:
re.split(' +', 'hello world sample text')
->Reconstructed Target:
'Sopetxc3xb3n'.encode('latin-1').decode('utf-8')
->Reconstructed Predication:
re.sub('xc3xb3n', '', re.split('xc3xb3n'))
->Raw Input:
implement: Encode a latin character in string Sopetxc3xb3n properly
->Raw Target:
'Sopetxc3xb3n'.encode('latin-1').decode('utf-8')
--

247=========
->Original Input:
length of longest element in list `words`
->Original Target:
len(max(words, key=len))
->Reconstructed Target:
image = image.resize((x, y), Image.ANTIALIAS)
->Reconstructed Predication:
image.resize(width, height) == (x, y)
->Raw Input:
implement: resized image image to width, height of (x, y) with filter of ANTIALIAS
->Raw Target:
image = image.resize((x, y), Image.ANTIALIAS)
--

248=========
->Original Input:
get the value associated with unicode key 'from_user' of first dictionary in list `result`
->Original Target:
result[0]['from_user']
->Reconstructed Target:
re.findall('n(?=[n]n)n+(?=[n])(?i)', s)
->Reconstructed Predication:
re.findall('n', s)
->Raw Input:
implement: regex, find "n"s only in the middle of string s
->Raw Target:
re.findall('n(?=[n]n)n+(?=[n])(?i)', s)
--

249=========
->Original Input:
Retrieve each line from a file 'File.txt' as a list
->Original Target:
[line.split() for line in open('File.txt')]
->Reconstructed Target:
print('0:.0f%'.format(1.0 / 3 * 100))
->Reconstructed Predication:
float('%.3*100')
->Raw Input:
implement: display the float 1/3*100 as a percentage
->Raw Target:
print('0:.0f%'.format(1.0 / 3 * 100))
--

250=========
->Original Input:
swap keys with values in a dictionary `a`
->Original Target:
res = dict((v, k) for k, v in a.items())
->Reconstructed Target:
mylist.sort(key=lambda x: x['title'])
->Reconstructed Predication:
mylist.sort(key=lambda x: title[x])
->Raw Input:
implement: sort a list of dictionary mylist by the key title
->Raw Target:
mylist.sort(key=lambda x: x['title'])
--

251=========
->Original Input:
Open a file `path/to/FILE_NAME.ext` in write mode
->Original Target:
new_file = open('path/to/FILE_NAME.ext', 'w')
->Reconstructed Target:
l.sort(key=lambda x: x['title'])
->Reconstructed Predication:
sorted(l, key=lambda x: ('title', x[1]))
->Raw Input:
implement: sort a list l of dicts by dict value 'title'
->Raw Target:
l.sort(key=lambda x: x['title'])
--

252=========
->Original Input:
None
->Original Target:
df.groupby(['col1', 'col2'])['col3'].nunique().reset_index()
->Reconstructed Target:
l.sort(key=lambda x: (x['title'], x['title_url'], x['id']))
->Reconstructed Predication:
sorted(list(key=lambda x: x['title'], 'title_url', 'id'])
->Raw Input:
implement: sort a list of dictionaries by the value of keys 'title', 'title_url', 'id' in ascending order.
->Raw Target:
l.sort(key=lambda x: (x['title'], x['title_url'], x['id']))
--

253=========
->Original Input:
Check if any key in the dictionary `dict1` starts with the string `EMP$$`
->Original Target:
any(key.startswith('EMP$$') for key in dict1)
->Reconstructed Target:
heapq.nlargest(10, range(len(l1)), key=lambda i: abs(l1[i] - l2[i]))
->Reconstructed Predication:
[(x, y) for x, y in zip(l1, l2)]
->Raw Input:
implement: find 10 largest differences between each respective elements of list l1 and list l2
->Raw Target:
heapq.nlargest(10, range(len(l1)), key=lambda i: abs(l1[i] - l2[i]))
--

254=========
->Original Input:
create list of values from dictionary `dict1` that have a key that starts with 'EMP$$'
->Original Target:
[value for key, value in list(dict1.items()) if key.startswith('EMP$$')]
->Reconstructed Target:
soup.find_all('span', 'class':'starGryB sp')
->Reconstructed Predication:
soup.findAll('span', class='starGryB sp')
->Raw Input:
implement: BeautifulSoup find all'span' elements in HTML string soup with class of'starGryB sp'
->Raw Target:
soup.find_all('span', 'class':'starGryB sp')
--

255=========
->Original Input:
convert a pandas series `sf` into a pandas dataframe `df` with columns `email` and `list`
->Original Target:
pd.DataFrame({'email': sf.index, 'list': sf.values})
->Reconstructed Target:
df.to_sql('test', engine, schema='a_schema')
->Reconstructed Predication:
df.write('test', df.a_schema)
->Raw Input:
implement: write records in dataframe df to table 'test' in schema 'a_schema'
->Raw Target:
df.to_sql('test', engine, schema='a_schema')
--

256=========
->Original Input:
print elements of list `list` seperated by tabs `\t`
->Original Target:
print('\t'.join(map(str, list)))
->Reconstructed Target:
brackets = re.sub('[()[]]', '', s)
->Reconstructed Predication:
s.replace('', '')
->Raw Input:
implement: Extract brackets from string s
->Raw Target:
brackets = re.sub('[()[]]', '', s)
--

257=========
->Original Input:
print unicode string '\xd0\xbf\xd1\x80\xd0\xb8' with utf-8
->Original Target:
print('\xd0\xbf\xd1\x80\xd0\xb8'.encode('raw_unicode_escape'))
->Reconstructed Target:
list(dict((x[0], x) for x in L).values())
->Reconstructed Predication:
[x for x in L if x is duplicated]
->Raw Input:
implement: remove duplicate elements from list 'L'
->Raw Target:
list(dict((x[0], x) for x in L).values())
--

258=========
->Original Input:
Encode a latin character in string `Sopet\xc3\xb3n` properly
->Original Target:
'Sopet\xc3\xb3n'.encode('latin-1').decode('utf-8')
->Reconstructed Target:
[line.rstrip('n') for line in file]
->Reconstructed Predication:
os.read(file)
->Raw Input:
implement: read a file file without newlines
->Raw Target:
[line.rstrip('n') for line in file]
--

259=========
->Original Input:
resized image `image` to width, height of `(x, y)` with filter of `ANTIALIAS`
->Original Target:
image = image.resize((x, y), Image.ANTIALIAS)
->Reconstructed Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
->Reconstructed Predication:
print(operator.itemgetter(1))
->Raw Input:
implement: get the position of item 1 in testlist
->Raw Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
--

260=========
->Original Input:
regex, find "n"s only in the middle of string `s`
->Original Target:
re.findall('n(?<=[^n]n)n+(?=[^n])(?i)', s)
->Reconstructed Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
->Reconstructed Predication:
print(operator.itemgetter(1))
->Raw Input:
implement: get the position of item 1 in testlist
->Raw Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
--

261=========
->Original Input:
display the float `1/3*100` as a percentage
->Original Target:
print('{0:.0f}%'.format(1.0 / 3 * 100))
->Reconstructed Target:
for i in [i for (i, x) in enumerate(testlist) if (x == 1)]: pass
->Reconstructed Predication:
print(operator.itemgetter(1))
->Raw Input:
implement: get the position of item 1 in testlist
->Raw Target:
for i in [i for (i, x) in enumerate(testlist) if (x == 1)]: pass
--

262=========
->Original Input:
sort a list of dictionary `mylist` by the key `title`
->Original Target:
mylist.sort(key=lambda x: x['title'])
->Reconstructed Target:
for i in (i for (i, x) in enumerate(testlist) if (x == 1)): pass
->Reconstructed Predication:
print(operator.itemgetter(1))
->Raw Input:
implement: get the position of item 1 in testlist
->Raw Target:
for i in (i for (i, x) in enumerate(testlist) if (x == 1)): pass
--

263=========
->Original Input:
sort a list `l` of dicts by dict value 'title'
->Original Target:
l.sort(key=lambda x: x['title'])
->Reconstructed Target:
gen = (i for (i, x) in enumerate(testlist) if (x == 1)) for i in gen: pass
->Reconstructed Predication:
print(operator.itemgetter(1))
->Raw Input:
implement: get the position of item 1 in testlist
->Raw Target:
gen = (i for (i, x) in enumerate(testlist) if (x == 1)) for i in gen: pass
--

264=========
->Original Input:
sort a list of dictionaries by the value of keys 'title', 'title_url', 'id' in ascending order.
->Original Target:
l.sort(key=lambda x: (x['title'], x['title_url'], x['id']))
->Reconstructed Target:
print(testlist.index(element))
->Reconstructed Predication:
print((os.getposition(element)) for os in testlist)
->Raw Input:
implement: get the position of item element in list testlist
->Raw Target:
print(testlist.index(element))
--

265=========
->Original Input:
find 10 largest differences between each respective elements of list `l1` and list `l2`
->Original Target:
heapq.nlargest(10, range(len(l1)), key=lambda i: abs(l1[i] - l2[i]))
->Reconstructed Target:
try: print(testlist.index(element)) except ValueError: pass
->Reconstructed Predication:
print((os.getposition(element)) for os in testlist)
->Raw Input:
implement: get the position of item element in list testlist
->Raw Target:
try: print(testlist.index(element)) except ValueError: pass
--

266=========
->Original Input:
BeautifulSoup find all 'span' elements in HTML string `soup` with class of 'starGryB sp'
->Original Target:
soup.find_all('span', {'class': 'starGryB sp'})
->Reconstructed Target:
max(lis, key=lambda item: item[1])[0]
->Reconstructed Predication:
max(lis, key=lambda x: x[1])
->Raw Input:
implement: find the first element of the tuple with the maximum second element in a list of tuples lis
->Raw Target:
max(lis, key=lambda item: item[1])[0]
--

267=========
->Original Input:
write records in dataframe `df` to table 'test' in schema 'a_schema'
->Original Target:
df.to_sql('test', engine, schema='a_schema')
->Reconstructed Target:
max(lis, key=itemgetter(1))[0]
->Reconstructed Predication:
max(lis, key=lambda x: x[1])
->Raw Input:
implement: get the item at index 0 from the tuple that has maximum value at index 1 in list lis
->Raw Target:
max(lis, key=itemgetter(1))[0]
--

268=========
->Original Input:
Extract brackets from string `s`
->Original Target:
brackets = re.sub('[^(){}[\\]]', '', s)
->Reconstructed Target:
time.sleep(1)
->Reconstructed Predication:
delay((1:.1f))
->Raw Input:
implement: Make a delay of 1 second
->Raw Target:
time.sleep(1)
--

269=========
->Original Input:
remove duplicate elements from list 'L'
->Original Target:
list(dict((x[0], x) for x in L).values())
->Reconstructed Target:
""", """.join('(' + ', '.join(i) + ')' for i in L)
->Reconstructed Predication:
"""""".join([(str(x) for x in L]))
->Raw Input:
implement: convert list of tuples L to a string
->Raw Target:
""", """.join('(' + ', '.join(i) + ')' for i in L)
--

270=========
->Original Input:
read a file `file` without newlines
->Original Target:
[line.rstrip('\n') for line in file]
->Reconstructed Target:
b = models.CharField(max_length=7, default='0000000', editable=False)
->Reconstructed Predication:
b.setDefaultValue('0000000')
->Raw Input:
implement: Django set default value of field b equal to '0000000'
->Raw Target:
b = models.CharField(max_length=7, default='0000000', editable=False)
--

271=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
->Reconstructed Target:
sorted(list5, lambda x: (degree(x), x))
->Reconstructed Predication:
list5.sort(key=lambda x: x[1])
->Raw Input:
implement: Sort lis list5 in ascending order based on the degrees value of its elements
->Raw Target:
sorted(list5, lambda x: (degree(x), x))
--

272=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
->Reconstructed Target:
(n for n in [1, 2, 3, 5])
->Reconstructed Predication:
generator.get_elements()
->Raw Input:
implement: convert a list into a generator object
->Raw Target:
(n for n in [1, 2, 3, 5])
--

273=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
for i in [i for (i, x) in enumerate(testlist) if (x == 1)]:
    pass
->Reconstructed Target:
newlist = [v for i, v in enumerate(oldlist) if i not in removelist]
->Reconstructed Predication:
remove(oldlist, key=lambda x: remove(x[1]) for key in removelist)
->Raw Input:
implement: remove elements from list oldlist that have an index number mentioned in list removelist
->Raw Target:
newlist = [v for i, v in enumerate(oldlist) if i not in removelist]
--

274=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
for i in (i for (i, x) in enumerate(testlist) if (x == 1)):
    pass
->Reconstructed Target:
f = open('yourfile.txt', 'w')
->Reconstructed Predication:
os.write('yourfile.txt')
->Raw Input:
implement: Open a file yourfile.txt in write mode
->Raw Target:
f = open('yourfile.txt', 'w')
--

275=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
gen = (i for (i, x) in enumerate(testlist) if (x == 1))
for i in gen:
    pass
->Reconstructed Target:
getattr(obj, 'attr')
->Reconstructed Predication:
print(obj.getattr('attr'))
->Raw Input:
implement: get attribute 'attr' from object obj
->Raw Target:
getattr(obj, 'attr')
--

276=========
->Original Input:
get the position of item `element` in list `testlist`
->Original Target:
print(testlist.index(element))
->Reconstructed Target:
from functools import reduce reduce(lambda a, b: a + b, (('aa',), ('bb',), ('cc',)))
->Reconstructed Predication:
tuple((('aa',), ('bb',), ('cc',))
->Raw Input:
implement: convert tuple of tuples (('aa',), ('bb',), ('cc',)) to tuple
->Raw Target:
from functools import reduce reduce(lambda a, b: a + b, (('aa',), ('bb',), ('cc',)))
--

277=========
->Original Input:
get the position of item `element` in list `testlist`
->Original Target:
try:
    print(testlist.index(element))
except ValueError:
    pass
->Reconstructed Target:
map(lambda a: a[0], (('aa',), ('bb',), ('cc',)))
->Reconstructed Predication:
list((('aa',), ('bb',), ('cc',)))
->Raw Input:
implement: convert tuple of tuples (('aa',), ('bb',), ('cc',)) to list in one line
->Raw Target:
map(lambda a: a[0], (('aa',), ('bb',), ('cc',)))
--

278=========
->Original Input:
find the first element of the tuple with the maximum second element in a list of tuples `lis`
->Original Target:
max(lis, key=lambda item: item[1])[0]
->Reconstructed Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Reconstructed Predication:
zip([('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Raw Input:
implement: unzip the list [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
->Raw Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
--

279=========
->Original Input:
get the item at index 0 from the tuple that has maximum value at index 1 in list `lis`
->Original Target:
max(lis, key=itemgetter(1))[0]
->Reconstructed Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Reconstructed Predication:
zip([('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Raw Input:
implement: unzip the list [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
->Raw Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
--

280=========
->Original Input:
Make a delay of 1 second
->Original Target:
time.sleep(1)
->Reconstructed Target:
result = ([a for (a, b) in original], [b for (a, b) in original])
->Reconstructed Predication:
original.unpack()
->Raw Input:
implement: unzip list original
->Raw Target:
result = ([a for (a, b) in original], [b for (a, b) in original])
--

281=========
->Original Input:
convert list of tuples `L` to a string
->Original Target:
""", """.join('(' + ', '.join(i) + ')' for i in L)
->Reconstructed Target:
result = ((a for (a, b) in original), (b for (a, b) in original))
->Reconstructed Predication:
generator = zip(original, key=operator.itemgetter(1))
->Raw Input:
implement: unzip list original and return a generator
->Raw Target:
result = ((a for (a, b) in original), (b for (a, b) in original))
--

282=========
->Original Input:
Django set default value of field `b` equal to '0000000'
->Original Target:
b = models.CharField(max_length=7, default='0000000', editable=False)
->Reconstructed Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
->Reconstructed Predication:
zip([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )])
->Raw Input:
implement: unzip list [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]
->Raw Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
--

283=========
->Original Input:
Sort lis `list5` in ascending order based on the degrees value of its elements
->Original Target:
sorted(list5, lambda x: (degree(x), x))
->Reconstructed Target:
map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
->Reconstructed Predication:
[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]
->Raw Input:
implement: unzip list [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )] and fill empty results with None
->Raw Target:
map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
--

284=========
->Original Input:
None
->Original Target:
sorted(list5, key=lambda vertex: (degree(vertex), vertex))
->Reconstructed Target:
json.dumps(Decimal('3.9'))
->Reconstructed Predication:
json.encode('Decimal('3.9'))
->Raw Input:
implement: encode Decimal('3.9') to a JSON string
->Raw Target:
json.dumps(Decimal('3.9'))
--

285=========
->Original Input:
convert a list  into a generator object
->Original Target:
(n for n in [1, 2, 3, 5])
->Reconstructed Target:
d['mynewkey'] ='mynewvalue'
->Reconstructed Predication:
d = k: v for k, v in list(d.items()) if v!='mynewkey'
->Raw Input:
implement: Add key "mynewkey" to dictionary d with value "mynewvalue"
->Raw Target:
d['mynewkey'] ='mynewvalue'
--

286=========
->Original Input:
remove elements from list `oldlist` that have an index number mentioned in list `removelist`
->Original Target:
newlist = [v for i, v in enumerate(oldlist) if i not in removelist]
->Reconstructed Target:
data.update('a': 1, )
->Reconstructed Predication:
data['a'] = 1
->Raw Input:
implement: Add key 'a' to dictionary data with value 1
->Raw Target:
data.update('a': 1, )
--

287=========
->Original Input:
Open a file `yourfile.txt` in write mode
->Original Target:
f = open('yourfile.txt', 'w')
->Reconstructed Target:
data.update(dict(a=1))
->Reconstructed Predication:
data['a'] = 1
->Raw Input:
implement: Add key 'a' to dictionary data with value 1
->Raw Target:
data.update(dict(a=1))
--

288=========
->Original Input:
get attribute 'attr' from object `obj`
->Original Target:
getattr(obj, 'attr')
->Reconstructed Target:
data.update(a=1)
->Reconstructed Predication:
data['a'] = 1
->Raw Input:
implement: Add key 'a' to dictionary data with value 1
->Raw Target:
data.update(a=1)
--

289=========
->Original Input:
convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to tuple
->Original Target:
from functools import reduce
reduce(lambda a, b: a + b, (('aa',), ('bb',), ('cc',)))
->Reconstructed Target:
max([max(i) for i in matrix])
->Reconstructed Predication:
max(matrix)
->Raw Input:
implement: find maximal value in matrix matrix
->Raw Target:
max([max(i) for i in matrix])
--

290=========
->Original Input:
convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to list in one line
->Original Target:
map(lambda a: a[0], (('aa',), ('bb',), ('cc',)))
->Reconstructed Target:
answer = str(round(answer, 2))
->Reconstructed Predication:
answer.round('%.2f')
->Raw Input:
implement: Round number answer to 2 precision after the decimal point
->Raw Target:
answer = str(round(answer, 2))
--

291=========
->Original Input:
None
->Original Target:
df['range'].replace(',', '-', inplace=True)
->Reconstructed Target:
ip = re.findall('[0-9]+(?:.[0-9]+)3', s)
->Reconstructed Predication:
html.replace('', '')
->Raw Input:
implement: extract ip address from an html string
->Raw Target:
ip = re.findall('[0-9]+(?:.[0-9]+)3', s)
--

292=========
->Original Input:
unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`
->Original Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Reconstructed Target:
df.groupby('A').filter(lambda x: len(x) > 1)
->Reconstructed Predication:
df.filter(['A'] for i in range(0, len(df.agg))]
->Raw Input:
implement: filter dataframe df by values in column A that appear more than once
->Raw Target:
df.groupby('A').filter(lambda x: len(x) > 1)
--

293=========
->Original Input:
unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`
->Original Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Reconstructed Target:
[x for x in myfile.splitlines() if x!= '']
->Reconstructed Predication:
[x for x in myfile if x.append('n')]
->Raw Input:
implement: append each line in file myfile into a list
->Raw Target:
[x for x in myfile.splitlines() if x!= '']
--

294=========
->Original Input:
unzip list `original`
->Original Target:
result = ([a for (a, b) in original], [b for (a, b) in original])
->Reconstructed Target:
lst = map(int, open('filename.txt').readlines())
->Reconstructed Predication:
lst = [int(x) for x in filename.txt]
->Raw Input:
implement: Get a list of integers lst from a file filename.txt
->Raw Target:
lst = map(int, open('filename.txt').readlines())
--

295=========
->Original Input:
unzip list `original` and return a generator
->Original Target:
result = ((a for (a, b) in original), (b for (a, b) in original))
->Reconstructed Target:
plt.colorbar(mappable=mappable, cax=ax3)
->Reconstructed Predication:
plt.colorbar('mappable')
->Raw Input:
implement: add color bar with image mappable to plot plt
->Raw Target:
plt.colorbar(mappable=mappable, cax=ax3)
--

296=========
->Original Input:
unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]`
->Original Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
->Reconstructed Target:
Counter(' '.join(df['text']).split()).most_common(100)
->Reconstructed Predication:
df['text'].count_words()
->Raw Input:
implement: count most frequent 100 words in column 'text' of dataframe df
->Raw Target:
Counter(' '.join(df['text']).split()).most_common(100)
--

297=========
->Original Input:
unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]` and fill empty results with None
->Original Target:
map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
->Reconstructed Target:
list(itertools.combinations((1, 2, 3), 2))
->Reconstructed Predication:
tuple((1, 2, 3))
->Raw Input:
implement: generate all 2-element subsets of tuple (1, 2, 3)
->Raw Target:
list(itertools.combinations((1, 2, 3), 2))
--

298=========
->Original Input:
encode `Decimal('3.9')` to a JSON string
->Original Target:
json.dumps(Decimal('3.9'))
->Reconstructed Target:
datetime.now(pytz.utc)
->Reconstructed Predication:
datetime.today().timezone('UTC')
->Raw Input:
implement: get a value of datetime.today() in the UTC time zone
->Raw Target:
datetime.now(pytz.utc)
--

299=========
->Original Input:
Add key "mynewkey" to dictionary `d` with value "mynewvalue"
->Original Target:
d['mynewkey'] = 'mynewvalue'
->Reconstructed Target:
list2 = [x for x in list1 if x!= []]
->Reconstructed Predication:
list2 = [x for x in list1]
->Raw Input:
implement: Get a new list list2by removing empty list from a list of lists list1
->Raw Target:
list2 = [x for x in list1 if x!= []]
--

300=========
->Original Input:
Add key 'a' to dictionary `data` with value 1
->Original Target:
data.update({'a': 1, })
->Reconstructed Target:
list2 = [x for x in list1 if x]
->Reconstructed Predication:
list2 = [[x for x in list1 if x]]
->Raw Input:
implement: Create list2 to contain the lists from list list1 excluding the empty lists from list1
->Raw Target:
list2 = [x for x in list1 if x]
--

301=========
->Original Input:
Add key 'a' to dictionary `data` with value 1
->Original Target:
data.update(dict(a=1))
->Reconstructed Target:
return HttpResponse(data, mimetype='application/json')
->Reconstructed Predication:
response = JSON.response(data)
->Raw Input:
implement: Django response with JSON data
->Raw Target:
return HttpResponse(data, mimetype='application/json')
--

302=========
->Original Input:
Add key 'a' to dictionary `data` with value 1
->Original Target:
data.update(a=1)
->Reconstructed Target:
re.findall('(.*?)[.*?]', example_str)
->Reconstructed Predication:
print(re.sub('[a-zA-Z]', '', example_str))
->Raw Input:
implement: get all text that is not enclosed within square brackets in string example_str
->Raw Target:
re.findall('(.*?)[.*?]', example_str)
--

303=========
->Original Input:
find maximal value in matrix `matrix`
->Original Target:
max([max(i) for i in matrix])
->Reconstructed Target:
re.findall('(.*?)(?:[.*?]|$)', example_str)
->Reconstructed Predication:
print(re.sub('(?)(?)(?)(?)(?)(?)(?)(?)(?)(?)(?)(?)(?)(?
->Raw Input:
implement: Use a regex to get all text in a string example_str that is not surrounded by square brackets
->Raw Target:
re.findall('(.*?)(?:[.*?]|$)', example_str)
--

304=========
->Original Input:
Round number `answer` to 2 precision after the decimal point
->Original Target:
answer = str(round(answer, 2))
->Reconstructed Target:
re.findall('(.+?)|w', '(zyx)bc')
->Reconstructed Predication:
re.findall('(zyx)bc', '1')
->Raw Input:
implement: get whatever is between parentheses as a single match, and any char outside as an individual match in string '(zyx)bc'
->Raw Target:
re.findall('(.+?)|w', '(zyx)bc')
--

305=========
->Original Input:
extract ip address from an html string
->Original Target:
ip = re.findall('[0-9]+(?:\\.[0-9]+){3}', s)
->Reconstructed Target:
re.findall('((.*?))|(w)', '(zyx)bc')
->Reconstructed Predication:
re.match('((.*?))|(w)', '(zyx)bc')
->Raw Input:
implement: match regex '((.*?))|(w)' with string '(zyx)bc'
->Raw Target:
re.findall('((.*?))|(w)', '(zyx)bc')
--

306=========
->Original Input:
filter dataframe `df` by values in column `A` that appear more than once
->Original Target:
df.groupby('A').filter(lambda x: len(x) > 1)
->Reconstructed Target:
re.findall('(.*?)|w', '(zyx)bc')
->Reconstructed Predication:
re.findall('(zyx)bc', '|')
->Raw Input:
implement: match multiple regex patterns with the alternation operator | in a string (zyx)bc
->Raw Target:
re.findall('(.*?)|w', '(zyx)bc')
--

307=========
->Original Input:
append each line in file `myfile` into a list
->Original Target:
[x for x in myfile.splitlines() if x != '']
->Reconstructed Target:
elements = ['%0%'.format(element) for element in elements]
->Reconstructed Predication:
elements.format('%0%')
->Raw Input:
implement: formate each string cin list elements into pattern '%0%'
->Raw Target:
elements = ['%0%'.format(element) for element in elements]
--

308=========
->Original Input:
Get a list of integers `lst` from a file `filename.txt`
->Original Target:
lst = map(int, open('filename.txt').readlines())
->Reconstructed Target:
subprocess.Popen(['background-process', 'arguments'])
->Reconstructed Predication:
background.process.open('background-process', arguments)
->Raw Input:
implement: Open a background process 'background-process' with arguments 'arguments'
->Raw Target:
subprocess.Popen(['background-process', 'arguments'])
--

309=========
->Original Input:
add color bar with image `mappable` to plot `plt`
->Original Target:
plt.colorbar(mappable=mappable, cax=ax3)
->Reconstructed Target:
[mydict[x] for x in mykeys]
->Reconstructed Predication:
[v for v in list(mydict.values()) if v]
->Raw Input:
implement: get list of values from dictionary'mydict' w.r.t. list of keys'mykeys'
->Raw Target:
[mydict[x] for x in mykeys]
--

310=========
->Original Input:
count most frequent 100 words in column 'text' of dataframe `df`
->Original Target:
Counter(' '.join(df['text']).split()).most_common(100)
->Reconstructed Target:
dict([('Name', 'Joe'), ('Age', 22)])
->Reconstructed Predication:
dict(zip([('Name', 'Joe'), ('Age', 22)])
->Raw Input:
implement: convert list [('Name', 'Joe'), ('Age', 22)] into a dictionary
->Raw Target:
dict([('Name', 'Joe'), ('Age', 22)])
--

311=========
->Original Input:
None
->Original Target:
re.findall('(.+?):(.+?)\\b ?', text)
->Reconstructed Target:
data.reshape(-1, j).mean(axis=1).reshape(data.shape[0], -1)
->Reconstructed Predication:
data[:, (x + y) for x in data]
->Raw Input:
implement: average each two columns of array data
->Raw Target:
data.reshape(-1, j).mean(axis=1).reshape(data.shape[0], -1)
--

312=========
->Original Input:
generate all 2-element subsets of tuple `(1, 2, 3)`
->Original Target:
list(itertools.combinations((1, 2, 3), 2))
->Reconstructed Target:
print(s.encode('unicode-escape').replace('"', '"'))
->Reconstructed Predication:
re.sub('(?(?)(?)(?)(?)(?)(?)(?)(?)(?)(?)(?)(?)(?)(?
->Raw Input:
implement: double backslash escape all double quotes in string s
->Raw Target:
print(s.encode('unicode-escape').replace('"', '"'))
--

313=========
->Original Input:
get a value of datetime.today() in the UTC time zone
->Original Target:
datetime.now(pytz.utc)
->Reconstructed Target:
re.split('(W+)', s)
->Reconstructed Predication:
[x for x in re.findall('w+W+') if x.isswitch()]
->Raw Input:
implement: split a string into a list of words and whitespace
->Raw Target:
re.split('(W+)', s)
--

314=========
->Original Input:
Get a new list `list2`by removing empty list from a list of lists `list1`
->Original Target:
list2 = [x for x in list1 if x != []]
->Reconstructed Target:
i[1]: i[0] for i in list(myDictionary.items())
->Reconstructed Predication:
dict((k, v) for k, v in myDictionary.items())
->Raw Input:
implement: reverse the keys and values in a dictionary myDictionary
->Raw Target:
i[1]: i[0] for i in list(myDictionary.items())
--

315=========
->Original Input:
Create `list2` to contain the lists from list `list1` excluding the empty lists from `list1`
->Original Target:
list2 = [x for x in list1 if x]
->Reconstructed Target:
[i for i, j in enumerate(myList) if 'how' in j.lower() or 'what' in j.lower()]
->Reconstructed Predication:
[i for i, j in myList if j!= 'how', 'what']
->Raw Input:
implement: finding the index of elements containing substring 'how' and 'what' in a list of strings'myList'.
->Raw Target:
[i for i, j in enumerate(myList) if 'how' in j.lower() or 'what' in j.lower()]
--

316=========
->Original Input:
Django response with JSON `data`
->Original Target:
return HttpResponse(data, mimetype='application/json')
->Reconstructed Target:
isinstance(obj, str)
->Reconstructed Predication:
isinstance(obj)
->Raw Input:
implement: check if object obj is a string
->Raw Target:
isinstance(obj, str)
--

317=========
->Original Input:
get all text that is not enclosed within square brackets in string `example_str`
->Original Target:
re.findall('(.*?)\\[.*?\\]', example_str)
->Reconstructed Target:
isinstance(o, str)
->Reconstructed Predication:
o.isdigit()
->Raw Input:
implement: check if object o is a string
->Raw Target:
isinstance(o, str)
--

318=========
->Original Input:
Use a regex to get all text in a string `example_str` that is not surrounded by square brackets
->Original Target:
re.findall('(.*?)(?:\\[.*?\\]|$)', example_str)
->Reconstructed Target:
(type(o) is str)
->Reconstructed Predication:
o.isdigit()
->Raw Input:
implement: check if object o is a string
->Raw Target:
(type(o) is str)
--

319=========
->Original Input:
get whatever is between parentheses as a single match, and any char outside as an individual match in string '(zyx)bc'
->Original Target:
re.findall('\\(.+?\\)|\\w', '(zyx)bc')
->Reconstructed Target:
isinstance(o, str)
->Reconstructed Predication:
o.isdigit()
->Raw Input:
implement: check if object o is a string
->Raw Target:
isinstance(o, str)
--

320=========
->Original Input:
match regex '\\((.*?)\\)|(\\w)' with string '(zyx)bc'
->Original Target:
re.findall('\\((.*?)\\)|(\\w)', '(zyx)bc')
->Reconstructed Target:
isinstance(obj_to_test, str)
->Reconstructed Predication:
if ('obj_to_test' in a: pass
->Raw Input:
implement: check if obj_to_test is a string
->Raw Target:
isinstance(obj_to_test, str)
--

321=========
->Original Input:
match multiple regex patterns with the alternation operator `|` in a string `(zyx)bc`
->Original Target:
re.findall('\\(.*?\\)|\\w', '(zyx)bc')
->Reconstructed Target:
list2.extend(list1)
->Reconstructed Predication:
list2.append(list1)
->Raw Input:
implement: append list list1 to list2
->Raw Target:
list2.extend(list1)
--

322=========
->Original Input:
formate each string cin list `elements` into pattern '%{0}%'
->Original Target:
elements = ['%{0}%'.format(element) for element in elements]
->Reconstructed Target:
list1.extend(mylog)
->Reconstructed Predication:
list1.append(mylog, key=lambda x: x.append(x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x
->Raw Input:
implement: append list mylog to list1
->Raw Target:
list1.extend(mylog)
--

323=========
->Original Input:
Open a background process 'background-process' with arguments 'arguments'
->Original Target:
subprocess.Popen(['background-process', 'arguments'])
->Reconstructed Target:
c.extend(a)
->Reconstructed Predication:
c = [a[::-1] for a in a]
->Raw Input:
implement: append list a to c
->Raw Target:
c.extend(a)
--

324=========
->Original Input:
get list of values from dictionary 'mydict' w.r.t. list of keys 'mykeys'
->Original Target:
[mydict[x] for x in mykeys]
->Reconstructed Target:
for line in mylog: list1.append(line)
->Reconstructed Predication:
list1.append(mylog, key=lambda x: x[1])
->Raw Input:
implement: append items in list mylog to list1
->Raw Target:
for line in mylog: list1.append(line)
--

325=========
->Original Input:
convert list `[('Name', 'Joe'), ('Age', 22)]` into a dictionary
->Original Target:
dict([('Name', 'Joe'), ('Age', 22)])
->Reconstructed Target:
b.append((a[0][0], a[0][2]))
->Reconstructed Predication:
[i for i, j in zip(a, b) if j == [0][0] [0][2]]
->Raw Input:
implement: append a tuple of elements from list a with indexes '[0][0] [0][2]' to list b
->Raw Target:
b.append((a[0][0], a[0][2]))
--

326=========
->Original Input:
average each two columns of array `data`
->Original Target:
data.reshape(-1, j).mean(axis=1).reshape(data.shape[0], -1)
->Reconstructed Target:
app.config['SECRET_KEY'] = 'Your_secret_string'
->Reconstructed Predication:
config.set_secret_key('SECRET_KEY', Your_secret_string)
->Raw Input:
implement: Initialize SECRET_KEY in flask config with Your_secret_string 
->Raw Target:
app.config['SECRET_KEY'] = 'Your_secret_string'
--

327=========
->Original Input:
double backslash escape all double quotes in string `s`
->Original Target:
print(s.encode('unicode-escape').replace('"', '\\"'))
->Reconstructed Target:
pd.DataFrame(out.tolist(), columns=['out-1', 'out-2'], index=out.index)
->Reconstructed Predication:
df.unpack(['out-1', 'out-2'], axis=1)
->Raw Input:
implement: unpack a series of tuples in pandas into a DataFrame with column names 'out-1' and 'out-2'
->Raw Target:
pd.DataFrame(out.tolist(), columns=['out-1', 'out-2'], index=out.index)
--

328=========
->Original Input:
split a string into a list of words and whitespace
->Original Target:
re.split('(\\W+)', s)
->Reconstructed Target:
[x for x in range(len(stocks_list)) if stocks_list[x] == 'MSFT']
->Reconstructed Predication:
stocks_list['MSFT']
->Raw Input:
implement: find the index of an element 'MSFT' in a list stocks_list
->Raw Target:
[x for x in range(len(stocks_list)) if stocks_list[x] == 'MSFT']
--

329=========
->Original Input:
None
->Original Target:
df.plot(kind='barh', stacked=True)
->Reconstructed Target:
ax.set_xticklabels(labels, rotation=45)
->Reconstructed Predication:
ax.xtick(45)
->Raw Input:
implement: rotate the xtick labels of matplotlib plot ax by 45 degrees to make long labels readable
->Raw Target:
ax.set_xticklabels(labels, rotation=45)
--

330=========
->Original Input:
reverse the keys and values in a dictionary `myDictionary`
->Original Target:
{i[1]: i[0] for i in list(myDictionary.items())}
->Reconstructed Target:
re.sub('[w]','', s)
->Reconstructed Predication:
re.sub('([s])','s]', s)
->Raw Input:
implement: remove symbols from a string s
->Raw Target:
re.sub('[w]','', s)
--

331=========
->Original Input:
finding the index of elements containing substring 'how' and 'what' in a list of strings 'myList'.
->Original Target:
[i for i, j in enumerate(myList) if 'how' in j.lower() or 'what' in j.lower()]
->Reconstructed Target:
os.path.basename(os.path.dirname(os.path.realpath(__file__)))
->Reconstructed Predication:
os.chdir(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname)))
->Raw Input:
implement: Get the current directory of a script
->Raw Target:
os.path.basename(os.path.dirname(os.path.realpath(__file__)))
--

332=========
->Original Input:
check if object `obj` is a string
->Original Target:
isinstance(obj, str)
->Reconstructed Target:
print(re.findall("'[0-7]1,3'", str))
->Reconstructed Predication:
re.findall('octaveoctaveoctaveoctaveoctaveoctaveoctaveoctaveoctaveo
->Raw Input:
implement: Find octal characters matches from a string str using regex
->Raw Target:
print(re.findall("'[0-7]1,3'", str))
--

333=========
->Original Input:
check if object `o` is a string
->Original Target:
isinstance(o, str)
->Reconstructed Target:
re.split('[ ](?=[A-Z]+b)', input)
->Reconstructed Predication:
input.split('[ ](?=[A-Z]+b)')
->Raw Input:
implement: split string input based on occurrences of regex pattern '[ ](?=[A-Z]+b)'
->Raw Target:
re.split('[ ](?=[A-Z]+b)', input)
--

334=========
->Original Input:
check if object `o` is a string
->Original Target:
(type(o) is str)
->Reconstructed Target:
re.split('[ ](?=[A-Z])', input)
->Reconstructed Predication:
input.split(',')
->Raw Input:
implement: Split string input at every space followed by an upper-case letter
->Raw Target:
re.split('[ ](?=[A-Z])', input)
--

335=========
->Original Input:
check if object `o` is a string
->Original Target:
isinstance(o, str)
->Reconstructed Target:
r = requests.post(url, files=files, headers=headers, data=data)
->Reconstructed Predication:
send(url, files.encode('headers', data))
->Raw Input:
implement: send multipart encoded file files to url url with headers headers and metadata data
->Raw Target:
r = requests.post(url, files=files, headers=headers, data=data)
--

336=========
->Original Input:
check if `obj_to_test` is a string
->Original Target:
isinstance(obj_to_test, str)
->Reconstructed Target:
open('filename', 'wb').write(bytes_)
->Reconstructed Predication:
os.system(filename)
->Raw Input:
implement: write bytes bytes_ to a file filename in python 3
->Raw Target:
open('filename', 'wb').write(bytes_)
--

337=========
->Original Input:
append list `list1` to `list2`
->Original Target:
list2.extend(list1)
->Reconstructed Target:
[dct[k] for k in lst]
->Reconstructed Predication:
[x for x in lst if x[0] == dct]
->Raw Input:
implement: get a list from a list lst with values mapped into a dictionary dct
->Raw Target:
[dct[k] for k in lst]
--

338=========
->Original Input:
append list `mylog` to `list1`
->Original Target:
list1.extend(mylog)
->Reconstructed Target:
x.set_index('name').index.get_duplicates()
->Reconstructed Predication:
x.groupby('name').reset_index()
->Raw Input:
implement: find duplicate names in column 'name' of the dataframe x
->Raw Target:
x.set_index('name').index.get_duplicates()
--

339=========
->Original Input:
append list `a` to `c`
->Original Target:
c.extend(a)
->Reconstructed Target:
round(1.923328437452, 3)
->Reconstructed Predication:
re.sub('(.)', '', 1.923328437452, 3)
->Raw Input:
implement: truncate float 1.923328437452 to 3 decimal places
->Raw Target:
round(1.923328437452, 3)
--

340=========
->Original Input:
append items in list `mylog` to `list1`
->Original Target:
for line in mylog:
    list1.append(line)
->Reconstructed Target:
sorted(li, key=lambda x: datetime.strptime(x[1], '%d/%m/%Y'), reverse=True)
->Reconstructed Predication:
sorted(li, key=lambda x: (x[1])[2])
->Raw Input:
implement: sort list li in descending order based on the date value in second element of each list in list li
->Raw Target:
sorted(li, key=lambda x: datetime.strptime(x[1], '%d/%m/%Y'), reverse=True)
--

341=========
->Original Input:
append a tuple of elements from list `a` with indexes '[0][0] [0][2]' to list `b`
->Original Target:
b.append((a[0][0], a[0][2]))
->Reconstructed Target:
ax.set_rlabel_position(135)
->Reconstructed Predication:
ax.set_radial_ticks(135, axis=1)
->Raw Input:
implement: place the radial ticks in plot ax at 135 degrees
->Raw Target:
ax.set_rlabel_position(135)
--

342=========
->Original Input:
Initialize `SECRET_KEY` in flask config with `Your_secret_string `
->Original Target:
app.config['SECRET_KEY'] = 'Your_secret_string'
->Reconstructed Target:
os.path.isabs(my_path)
->Reconstructed Predication:
if (my_path.ispath() an absolute path): pass
->Raw Input:
implement: check if path my_path is an absolute path
->Raw Target:
os.path.isabs(my_path)
--

343=========
->Original Input:
unpack a series of tuples in pandas into a DataFrame with column names 'out-1' and 'out-2'
->Original Target:
pd.DataFrame(out.tolist(), columns=['out-1', 'out-2'], index=out.index)
->Reconstructed Target:
len(list(yourdict.keys()))
->Reconstructed Predication:
sum(len(yourdict.items()))
->Raw Input:
implement: get number of keys in dictionary yourdict
->Raw Target:
len(list(yourdict.keys()))
--

344=========
->Original Input:
find the index of an element 'MSFT' in a list `stocks_list`
->Original Target:
[x for x in range(len(stocks_list)) if stocks_list[x] == 'MSFT']
->Reconstructed Target:
len(set(open(yourdictfile).read().split()))
->Reconstructed Predication:
sum(len(yourdictfile.keys()))
->Raw Input:
implement: count the number of keys in dictionary yourdictfile
->Raw Target:
len(set(open(yourdictfile).read().split()))
--

345=========
->Original Input:
rotate the xtick labels of matplotlib plot `ax` by `45` degrees to make long labels readable
->Original Target:
ax.set_xticklabels(labels, rotation=45)
->Reconstructed Target:
df.groupby('id').first()
->Reconstructed Predication:
df['id'] = df['id'].group()
->Raw Input:
implement: pandas dataframe get first row of each group by 'id'
->Raw Target:
df.groupby('id').first()
--

346=========
->Original Input:
remove symbols from a string `s`
->Original Target:
re.sub('[^\\w]', ' ', s)
->Reconstructed Target:
pd.concat([df[0].apply(pd.Series), df[1]], axis=1)
->Reconstructed Predication:
df.groupby([df.items()], axis=1)
->Raw Input:
implement: split a list in first column into multiple columns keeping other columns as well in pandas data frame
->Raw Target:
pd.concat([df[0].apply(pd.Series), df[1]], axis=1)
--

347=========
->Original Input:
Get the current directory of a script
->Original Target:
os.path.basename(os.path.dirname(os.path.realpath(__file__)))
->Reconstructed Target:
re.findall('src="js/(["]*bjqueryb["]*)"', data)
->Reconstructed Predication:
data.split('src="js/(["]*bjqueryb["]*)', '')
->Raw Input:
implement: extract attributes'src="js/(["]*bjqueryb["]*)"' from string data
->Raw Target:
re.findall('src="js/(["]*bjqueryb["]*)"', data)
--

348=========
->Original Input:
Find octal characters matches from a string `str` using regex
->Original Target:
print(re.findall("'\\\\[0-7]{1,3}'", str))
->Reconstructed Target:
sum(int(float(item)) for item in [_f for _f in ['', '3.4', '', '', '1.0'] if _f])
->Reconstructed Predication:
sum(['', '3.4', '', '', '1.0'])
->Raw Input:
implement: Sum integers contained in strings in list ['', '3.4', '', '', '1.0']
->Raw Target:
sum(int(float(item)) for item in [_f for _f in ['', '3.4', '', '', '1.0'] if _f])
--

349=========
->Original Input:
split string `input` based on occurrences of regex pattern '[ ](?=[A-Z]+\\b)'
->Original Target:
re.split('[ ](?=[A-Z]+\\b)', input)
->Reconstructed Target:
subprocess.Popen(['c:Program FilesVMwareVMware Servervmware-cmd.bat'])
->Reconstructed Predication:
subprocess.call(['c:Program FilesVMwareVMware Servervmware-cmd.bat', '')
->Raw Input:
implement: Call a subprocess with arguments c:Program FilesVMwareVMware Servervmware-cmd.bat that may contain spaces
->Raw Target:
subprocess.Popen(['c:Program FilesVMwareVMware Servervmware-cmd.bat'])
--

350=========
->Original Input:
Split string `input` at every space followed by an upper-case letter
->Original Target:
re.split('[ ](?=[A-Z])', input)
->Reconstructed Target:
q.put((-n, n))
->Reconstructed Predication:
q.reverse()
->Raw Input:
implement: reverse a priority queue q in python without using classes
->Raw Target:
q.put((-n, n))
--

351=========
->Original Input:
send multipart encoded file `files` to url `url` with headers `headers` and metadata `data`
->Original Target:
r = requests.post(url, files=files, headers=headers, data=data)
->Reconstructed Target:
df['group'].plot(kind='bar', color=['r', 'g', 'b', 'r', 'g', 'b', 'r'])
->Reconstructed Predication:
df.groupby('group').color_code('color')
->Raw Input:
implement: make a barplot of data in column group of dataframe df colour-coded according to list color
->Raw Target:
df['group'].plot(kind='bar', color=['r', 'g', 'b', 'r', 'g', 'b', 'r'])
--

352=========
->Original Input:
write bytes `bytes_` to a file `filename` in python 3
->Original Target:
open('filename', 'wb').write(bytes_)
->Reconstructed Target:
re.findall('([a-fA-Fd]32)', data)
->Reconstructed Predication:
re.findall('([a-fA-Fd]32)', data)
->Raw Input:
implement: find all matches of regex pattern '([a-fA-Fd]32)' in string data
->Raw Target:
re.findall('([a-fA-Fd]32)', data)
--

353=========
->Original Input:
get a list from a list `lst` with values mapped into a dictionary `dct`
->Original Target:
[dct[k] for k in lst]
->Reconstructed Target:
len(my_list)
->Reconstructed Predication:
length(my_list)
->Raw Input:
implement: Get the length of list my_list
->Raw Target:
len(my_list)
--

354=========
->Original Input:
find duplicate names in column 'name' of the dataframe `x`
->Original Target:
x.set_index('name').index.get_duplicates()
->Reconstructed Target:
len(l)
->Reconstructed Predication:
l = l.shape
->Raw Input:
implement: Getting the length of array l
->Raw Target:
len(l)
--

355=========
->Original Input:
truncate float 1.923328437452 to 3 decimal places
->Original Target:
round(1.923328437452, 3)
->Reconstructed Target:
len(s)
->Reconstructed Predication:
s.len(s)
->Raw Input:
implement: Getting the length of array s
->Raw Target:
len(s)
--

356=========
->Original Input:
sort list `li` in descending order based on the date value in second element of each list in list `li`
->Original Target:
sorted(li, key=lambda x: datetime.strptime(x[1], '%d/%m/%Y'), reverse=True)
->Reconstructed Target:
len(my_tuple)
->Reconstructed Predication:
len(my_tuple)
->Raw Input:
implement: Getting the length of my_tuple
->Raw Target:
len(my_tuple)
--

357=========
->Original Input:
place the radial ticks in plot `ax` at 135 degrees
->Original Target:
ax.set_rlabel_position(135)
->Reconstructed Target:
len(my_string)
->Reconstructed Predication:
len(my_string)
->Raw Input:
implement: Getting the length of my_string
->Raw Target:
len(my_string)
--

358=========
->Original Input:
check if path `my_path` is an absolute path
->Original Target:
os.path.isabs(my_path)
->Reconstructed Target:
"""a""".decode('string_escape')
->Reconstructed Predication:
"""a""".join(replace('a', 'a'))
->Raw Input:
implement: remove escape character from string "a"
->Raw Target:
"""a""".decode('string_escape')
--

359=========
->Original Input:
get number of keys in dictionary `yourdict`
->Original Target:
len(list(yourdict.keys()))
->Reconstructed Target:
"""obama""".replace('a', '%temp%').replace('b', 'a').replace('%temp%', 'b')
->Reconstructed Predication:
re.sub('(?bb)', 'obama', 'a')
->Raw Input:
implement: replace each 'a' with 'b' and each 'b' with 'a' in the string 'obama' in a single pass.
->Raw Target:
"""obama""".replace('a', '%temp%').replace('b', 'a').replace('%temp%', 'b')
--

360=========
->Original Input:
count the number of keys in dictionary `yourdictfile`
->Original Target:
len(set(open(yourdictfile).read().split()))
->Reconstructed Target:
shutil.rmtree('/folder_name')
->Reconstructed Predication:
os.path.rmdir('/folder_name')
->Raw Input:
implement: remove directory tree '/folder_name'
->Raw Target:
shutil.rmtree('/folder_name')
--

361=========
->Original Input:
pandas dataframe get first row of each group by 'id'
->Original Target:
df.groupby('id').first()
->Reconstructed Target:
data['weekday'] = data['my_dt'].apply(lambda x: x.weekday())
->Reconstructed Predication:
data.groupby('my_dt').groupby('weekday').new()
->Raw Input:
implement: create a new column weekday in pandas data frame data based on the values in column my_dt
->Raw Target:
data['weekday'] = data['my_dt'].apply(lambda x: x.weekday())
--

362=========
->Original Input:
split a list in first column  into multiple columns keeping other columns as well in pandas data frame
->Original Target:
pd.concat([df[0].apply(pd.Series), df[1]], axis=1)
->Reconstructed Target:
sorted(x, key=x.get, reverse=True)
->Reconstructed Predication:
x.sort(key=lambda x: x[0])
->Raw Input:
implement: reverse sort Counter x by values
->Raw Target:
sorted(x, key=x.get, reverse=True)
--

363=========
->Original Input:
extract attributes 'src="js/([^"]*\\bjquery\\b[^"]*)"' from string `data`
->Original Target:
re.findall('src="js/([^"]*\\bjquery\\b[^"]*)"', data)
->Reconstructed Target:
sorted(list(x.items()), key=lambda pair: pair[1], reverse=True)
->Reconstructed Predication:
x.sort(key=lambda x: x[1])
->Raw Input:
implement: reverse sort counter x by value
->Raw Target:
sorted(list(x.items()), key=lambda pair: pair[1], reverse=True)
--

364=========
->Original Input:
Sum integers contained in strings in list `['', '3.4', '', '', '1.0']`
->Original Target:
sum(int(float(item)) for item in [_f for _f in ['', '3.4', '', '', '1.0'] if _f])
->Reconstructed Target:
np.vstack((a, b))
->Reconstructed Predication:
np.append(a, 'b')
->Raw Input:
implement: append a numpy array 'b' to a numpy array 'a'
->Raw Target:
np.vstack((a, b))
--

365=========
->Original Input:
Call a subprocess with arguments `c:\\Program Files\\VMware\\VMware Server\\vmware-cmd.bat` that may contain spaces
->Original Target:
subprocess.Popen(['c:\\Program Files\\VMware\\VMware Server\\vmware-cmd.bat'])
->Reconstructed Target:
print(concatenate((a, b), axis=0))
->Reconstructed Predication:
np.concat(a, b)
->Raw Input:
implement: numpy concatenate two arrays a and b along the first axis
->Raw Target:
print(concatenate((a, b), axis=0))
--

366=========
->Original Input:
reverse a priority queue `q` in python without using classes
->Original Target:
q.put((-n, n))
->Reconstructed Target:
print(concatenate((a, b), axis=1))
->Reconstructed Predication:
np.concat([a, b]).concat(np.arange(a, b))
->Raw Input:
implement: numpy concatenate two arrays a and b along the second axis
->Raw Target:
print(concatenate((a, b), axis=1))
--

367=========
->Original Input:
make a barplot of data in column `group` of dataframe `df` colour-coded according to list `color`
->Original Target:
df['group'].plot(kind='bar', color=['r', 'g', 'b', 'r', 'g', 'b', 'r'])
->Reconstructed Target:
c = np.r_[(a[None, :], b[None, :])]
->Reconstructed Predication:
np.concat(a, b)
->Raw Input:
implement: numpy concatenate two arrays a and b along the first axis
->Raw Target:
c = np.r_[(a[None, :], b[None, :])]
--

368=========
->Original Input:
find all matches of regex pattern '([a-fA-F\\d]{32})' in string `data`
->Original Target:
re.findall('([a-fA-F\\d]{32})', data)
->Reconstructed Target:
np.array((a, b))
->Reconstructed Predication:
np.concat(a, b)
->Raw Input:
implement: numpy concatenate two arrays a and b along the first axis
->Raw Target:
np.array((a, b))
--

369=========
->Original Input:
Get the length of list `my_list`
->Original Target:
len(my_list)
->Reconstructed Target:
print(socket.getaddrinfo('google.com', 80))
->Reconstructed Predication:
os.path.getaccount('google.com', 80)
->Raw Input:
implement: fetch address information for host 'google.com' ion port 80
->Raw Target:
print(socket.getaddrinfo('google.com', 80))
--

370=========
->Original Input:
Getting the length of array `l`
->Original Target:
len(l)
->Reconstructed Target:
df.xs('sat', level='day', drop_level=False)
->Reconstructed Predication:
df['day'].add_columns('sat')
->Raw Input:
implement: add a column 'day' with value'sat' to dataframe df
->Raw Target:
df.xs('sat', level='day', drop_level=False)
--

371=========
->Original Input:
Getting the length of array `s`
->Original Target:
len(s)
->Reconstructed Target:
return HttpResponse('Unauthorized', status=401)
->Reconstructed Predication:
return 401 'Unauthorized'
->Raw Input:
implement: return a 401 unauthorized in django
->Raw Target:
return HttpResponse('Unauthorized', status=401)
--

372=========
->Original Input:
Getting the length of `my_tuple`
->Original Target:
len(my_tuple)
->Reconstructed Target:
Flask(__name__, template_folder='wherever')
->Reconstructed Predication:
template.set_folder('wherever')
->Raw Input:
implement: Flask set folder 'wherever' as the default template folder
->Raw Target:
Flask(__name__, template_folder='wherever')
--

373=========
->Original Input:
Getting the length of `my_string`
->Original Target:
len(my_string)
->Reconstructed Target:
session.execute('INSERT INTO t1 (SELECT * FROM t2)')
->Reconstructed Predication:
SELECT_INTO_t1 = t2
->Raw Input:
implement: How do I INSERT INTO t1 (SELECT * FROM t2) in SQLAlchemy?
->Raw Target:
session.execute('INSERT INTO t1 (SELECT * FROM t2)')
--

374=========
->Original Input:
remove escape character from string "\\a"
->Original Target:
"""\\a""".decode('string_escape')
->Reconstructed Target:
c2.sort(key=lambda row: row[2])
->Reconstructed Predication:
sorted(c2, key=lambda x: x[1][2])
->Raw Input:
implement: sort a list of lists 'c2' such that third row comes first
->Raw Target:
c2.sort(key=lambda row: row[2])
--

375=========
->Original Input:
replace each 'a' with 'b' and each 'b' with 'a' in the string 'obama' in a single pass.
->Original Target:
"""obama""".replace('a', '%temp%').replace('b', 'a').replace('%temp%', 'b')
->Reconstructed Target:
matplotlib.rc('font', **'sans-serif': 'Arial', 'family':'sans-serif')
->Reconstructed Predication:
plt.plot('arial', font='ascii')
->Raw Input:
implement: set font Arial to display non-ascii characters in matplotlib
->Raw Target:
matplotlib.rc('font', **'sans-serif': 'Arial', 'family':'sans-serif')
--

376=========
->Original Input:
remove directory tree '/folder_name'
->Original Target:
shutil.rmtree('/folder_name')
->Reconstructed Target:
df['date'].apply(lambda x: x.toordinal())
->Reconstructed Predication:
df['date'].str.set_datetime('date')
->Raw Input:
implement: Convert DateTime column 'date' of pandas dataframe 'df' to ordinal
->Raw Target:
df['date'].apply(lambda x: x.toordinal())
--

377=========
->Original Input:
create a new column `weekday` in pandas data frame `data` based on the values in column `my_dt`
->Original Target:
data['weekday'] = data['my_dt'].apply(lambda x: x.weekday())
->Reconstructed Target:
element.get_attribute('innerHTML')
->Reconstructed Predication:
element.html
->Raw Input:
implement: get html source of Selenium WebElement element
->Raw Target:
element.get_attribute('innerHTML')
--

378=========
->Original Input:
reverse sort Counter `x` by values
->Original Target:
sorted(x, key=x.get, reverse=True)
->Reconstructed Target:
df.index.get_loc('bob')
->Reconstructed Predication:
df.loc['bob']
->Raw Input:
implement: Get the integer location of a key bob in a pandas data frame
->Raw Target:
df.index.get_loc('bob')
--

379=========
->Original Input:
reverse sort counter `x` by value
->Original Target:
sorted(list(x.items()), key=lambda pair: pair[1], reverse=True)
->Reconstructed Target:
os.system('gnome-terminal -e 'bash -c "sudo apt-get update; exec bash"'')
->Reconstructed Predication:
os.system('gnome')
->Raw Input:
implement: open a 'gnome' terminal from python script and run'sudo apt-get update' command.
->Raw Target:
os.system('gnome-terminal -e 'bash -c "sudo apt-get update; exec bash"'')
--

380=========
->Original Input:
append a numpy array 'b' to a numpy array 'a'
->Original Target:
np.vstack((a, b))
->Reconstructed Target:
my_dict.update('third_key': 1)
->Reconstructed Predication:
my_dict['third_key'] = 1
->Raw Input:
implement: add an item with key 'third_key' and value 1 to an dictionary my_dict
->Raw Target:
my_dict.update('third_key': 1)
--

381=========
->Original Input:
numpy concatenate two arrays `a` and `b` along the first axis
->Original Target:
print(concatenate((a, b), axis=0))
->Reconstructed Target:
my_list = []
->Reconstructed Predication:
np.array([item[0]) for item in array]
->Raw Input:
implement: declare an array
->Raw Target:
my_list = []
--

382=========
->Original Input:
numpy concatenate two arrays `a` and `b` along the second axis
->Original Target:
print(concatenate((a, b), axis=1))
->Reconstructed Target:
my_list.append(12)
->Reconstructed Predication:
my_list[12]
->Raw Input:
implement: Insert item 12 to a list my_list
->Raw Target:
my_list.append(12)
--

383=========
->Original Input:
numpy concatenate two arrays `a` and `b` along the first axis
->Original Target:
c = np.r_[(a[None, :], b[None, :])]
->Reconstructed Target:
myList.insert(0, 'wuggah')
->Reconstructed Predication:
myList['wuggah']
->Raw Input:
implement: add an entry 'wuggah' at the beginning of list myList
->Raw Target:
myList.insert(0, 'wuggah')
--

384=========
->Original Input:
numpy concatenate two arrays `a` and `b` along the first axis
->Original Target:
np.array((a, b))
->Reconstructed Target:
"""xF3xBEx80x80""".replace('x', '').decode('hex')
->Reconstructed Predication:
hex('0:.1f')
->Raw Input:
implement: convert a hex-string representation to actual bytes
->Raw Target:
"""xF3xBEx80x80""".replace('x', '').decode('hex')
--

385=========
->Original Input:
fetch address information for host 'google.com' ion port 80
->Original Target:
print(socket.getaddrinfo('google.com', 80))
->Reconstructed Target:
df[df.columns[-1]]
->Reconstructed Predication:
df.columns.last
->Raw Input:
implement: select the last column of dataframe df
->Raw Target:
df[df.columns[-1]]
--

386=========
->Original Input:
add a column 'day' with value 'sat' to dataframe `df`
->Original Target:
df.xs('sat', level='day', drop_level=False)
->Reconstructed Target:
df.loc[df['Letters'] == 'C', 'Letters'].values[0]
->Reconstructed Predication:
df['Letters'] == 'C'
->Raw Input:
implement: get the first value from dataframe df where column 'Letters' is equal to 'C'
->Raw Target:
df.loc[df['Letters'] == 'C', 'Letters'].values[0]
--

387=========
->Original Input:
return a 401 unauthorized in django
->Original Target:
return HttpResponse('Unauthorized', status=401)
->Reconstructed Target:
np.column_stack(([1, 2, 3], [4, 5, 6]))
->Reconstructed Predication:
matrice = pd.concat([1, 2, 3], [4, 5, 6])
->Raw Input:
implement: converting two lists [1, 2, 3] and [4, 5, 6] into a matrix
->Raw Target:
np.column_stack(([1, 2, 3], [4, 5, 6]))
--

388=========
->Original Input:
Flask set folder 'wherever' as the default template folder
->Original Target:
Flask(__name__, template_folder='wherever')
->Reconstructed Target:
type(i)
->Reconstructed Predication:
i.type
->Raw Input:
implement: get the type of i
->Raw Target:
type(i)
--

389=========
->Original Input:
How do I INSERT INTO t1 (SELECT * FROM t2) in SQLAlchemy?
->Original Target:
session.execute('INSERT INTO t1 (SELECT * FROM t2)')
->Reconstructed Target:
type(v)
->Reconstructed Predication:
v.type
->Raw Input:
implement: determine the type of variable v
->Raw Target:
type(v)
--

390=========
->Original Input:
sort a list of lists 'c2' such that third row comes first
->Original Target:
c2.sort(key=lambda row: row[2])
->Reconstructed Target:
type(v)
->Reconstructed Predication:
v.type
->Raw Input:
implement: determine the type of variable v
->Raw Target:
type(v)
--

391=========
->Original Input:
None
->Original Target:
c2.sort(key=lambda row: (row[2], row[1], row[0]))
->Reconstructed Target:
type(v)
->Reconstructed Predication:
v.type
->Raw Input:
implement: determine the type of variable v
->Raw Target:
type(v)
--

392=========
->Original Input:
None
->Original Target:
c2.sort(key=lambda row: (row[2], row[1]))
->Reconstructed Target:
type(v)
->Reconstructed Predication:
v.type
->Raw Input:
implement: determine the type of variable v
->Raw Target:
type(v)
--

393=========
->Original Input:
set font `Arial` to display non-ascii characters in matplotlib
->Original Target:
matplotlib.rc('font', **{'sans-serif': 'Arial', 'family': 'sans-serif'})
->Reconstructed Target:
print(type(variable_name))
->Reconstructed Predication:
print(type(variable_name))
->Raw Input:
implement: get the type of variable variable_name
->Raw Target:
print(type(variable_name))
--

394=========
->Original Input:
Convert  DateTime column 'date' of pandas dataframe 'df' to ordinal
->Original Target:
df['date'].apply(lambda x: x.toordinal())
->Reconstructed Target:
next(itertools.islice(range(10), 5, 5 + 1))
->Reconstructed Predication:
[5]
->Raw Input:
implement: get the 5th item of a generator
->Raw Target:
next(itertools.islice(range(10), 5, 5 + 1))
--

395=========
->Original Input:
get html source of Selenium WebElement `element`
->Original Target:
element.get_attribute('innerHTML')
->Reconstructed Target:
print('""'.format(word))
->Reconstructed Predication:
print('w'.format(word))
->Raw Input:
implement: Print a string word with string format
->Raw Target:
print('""'.format(word))
--

396=========
->Original Input:
Get the integer location of a key `bob` in a pandas data frame
->Original Target:
df.index.get_loc('bob')
->Reconstructed Target:
""" """.join(list)
->Reconstructed Predication:
list = [(x + y) for x in zip(list,'')]
->Raw Input:
implement: join a list of strings list using a space''
->Raw Target:
""" """.join(list)
--

397=========
->Original Input:
open a 'gnome' terminal from python script and run  'sudo apt-get update' command.
->Original Target:
os.system('gnome-terminal -e \'bash -c "sudo apt-get update; exec bash"\'')
->Reconstructed Target:
y = [[] for n in range(2)]
->Reconstructed Predication:
y = [[] for i in range(2)]
->Raw Input:
implement: create list y containing two empty lists
->Raw Target:
y = [[] for n in range(2)]
--

398=========
->Original Input:
add an item with key 'third_key' and value 1 to an dictionary `my_dict`
->Original Target:
my_dict.update({'third_key': 1})
->Reconstructed Target:
data = [line.strip() for line in open('C:/name/MyDocuments/numbers', 'r')]
->Reconstructed Predication:
data = [x for x in 'C:/name/MyDocuments/numbers']
->Raw Input:
implement: read a file 'C:/name/MyDocuments/numbers' into a list data
->Raw Target:
data = [line.strip() for line in open('C:/name/MyDocuments/numbers', 'r')]
--

399=========
->Original Input:
declare an array
->Original Target:
my_list = []
->Reconstructed Target:
"""""".join([char for char in 'it is icy' if char!= 'i'])
->Reconstructed Predication:
re.sub('(?...........................
->Raw Input:
implement: delete all occurrences of character 'i' in string 'it is icy'
->Raw Target:
"""""".join([char for char in 'it is icy' if char!= 'i'])
--

400=========
->Original Input:
Insert item `12` to a list `my_list`
->Original Target:
my_list.append(12)
->Reconstructed Target:
re.sub('i', '', 'it is icy')
->Reconstructed Predication:
re.sub('(?(?))', 'it is icy', 'i')
->Raw Input:
implement: delete all instances of a character 'i' in a string 'it is icy'
->Raw Target:
re.sub('i', '', 'it is icy')
--

401=========
->Original Input:
add an entry 'wuggah' at the beginning of list `myList`
->Original Target:
myList.insert(0, 'wuggah')
->Reconstructed Target:
"""it is icy""".replace('i', '')
->Reconstructed Predication:
"""it is icy""".replace('i', '')
->Raw Input:
implement: delete all characters "i" in string "it is icy"
->Raw Target:
"""it is icy""".replace('i', '')
--

402=========
->Original Input:
convert a hex-string representation to actual bytes
->Original Target:
"""\\xF3\\xBE\\x80\\x80""".replace('\\x', '').decode('hex')
->Reconstructed Target:
df.dropna(subset=[1])
->Reconstructed Predication:
df.loc[df[na[1]]]
->Raw Input:
implement: Drop rows of pandas dataframe df having NaN in column at index "1"
->Raw Target:
df.dropna(subset=[1])
--

403=========
->Original Input:
select the last column of dataframe `df`
->Original Target:
df[df.columns[-1]]
->Reconstructed Target:
[x for x in myList if x.n == 30]
->Reconstructed Predication:
[element for item in myList if item[n] == 30]
->Raw Input:
implement: get elements from list myList, that have a field n value 30
->Raw Target:
[x for x in myList if x.n == 30]
--

404=========
->Original Input:
get the first value from dataframe `df` where column 'Letters' is equal to 'C'
->Original Target:
df.loc[df['Letters'] == 'C', 'Letters'].values[0]
->Reconstructed Target:
nums = [int(x) for x in intstringlist]
->Reconstructed Predication:
numpy.join(nums, intstringlist)
->Raw Input:
implement: converting list of strings intstringlist to list of integer nums
->Raw Target:
nums = [int(x) for x in intstringlist]
--

405=========
->Original Input:
converting two lists `[1, 2, 3]` and `[4, 5, 6]` into a matrix
->Original Target:
np.column_stack(([1, 2, 3], [4, 5, 6]))
->Reconstructed Target:
map(int, eval(input('Enter the unfriendly numbers: ')))
->Reconstructed Predication:
[int(x) for x in zip('[1:]', '')]
->Raw Input:
implement: convert list of string numbers into list of integers
->Raw Target:
map(int, eval(input('Enter the unfriendly numbers: ')))
--

406=========
->Original Input:
get the type of `i`
->Original Target:
type(i)
->Reconstructed Target:
sys.stdout.write('.')
->Reconstructed Predication:
print('.'.
->Raw Input:
implement: print "." without newline
->Raw Target:
sys.stdout.write('.')
--

407=========
->Original Input:
determine the type of variable `v`
->Original Target:
type(v)
->Reconstructed Target:
int(round(2.51 * 100))
->Reconstructed Predication:
int('2.52 * 100', round(10))
->Raw Input:
implement: round off the float that is the product of 2.52 * 100 and convert it to an int
->Raw Target:
int(round(2.51 * 100))
--

408=========
->Original Input:
determine the type of variable `v`
->Original Target:
type(v)
->Reconstructed Target:
os.chdir('/mydir') for file in glob.glob('*.txt'): pass
->Reconstructed Predication:
os.path.find('/mydir', '.txt')
->Raw Input:
implement: Find all files in directory "/mydir" with extension ".txt"
->Raw Target:
os.chdir('/mydir') for file in glob.glob('*.txt'): pass
--

409=========
->Original Input:
determine the type of variable `v`
->Original Target:
type(v)
->Reconstructed Target:
for file in os.listdir('/mydir'): if file.endswith('.txt'): pass
->Reconstructed Predication:
os.path.find('/mydir', '.txt')
->Raw Input:
implement: Find all files in directory "/mydir" with extension ".txt"
->Raw Target:
for file in os.listdir('/mydir'): if file.endswith('.txt'): pass
--

410=========
->Original Input:
determine the type of variable `v`
->Original Target:
type(v)
->Reconstructed Target:
for (root, dirs, files) in os.walk('/mydir'): for file in files: if file.endswith('.txt'): pass
->Reconstructed Predication:
os.path.find('/mydir', '.txt')
->Raw Input:
implement: Find all files in directory "/mydir" with extension ".txt"
->Raw Target:
for (root, dirs, files) in os.walk('/mydir'): for file in files: if file.endswith('.txt'): pass
--

411=========
->Original Input:
get the type of variable `variable_name`
->Original Target:
print(type(variable_name))
->Reconstructed Target:
df.plot(legend=False)
->Reconstructed Predication:
df.plot(len(df.legend))
->Raw Input:
implement: plot dataframe df without a legend
->Raw Target:
df.plot(legend=False)
--

412=========
->Original Input:
get the 5th item of a generator
->Original Target:
next(itertools.islice(range(10), 5, 5 + 1))
->Reconstructed Target:
for i in range(256): for j in range(256): ip = ('192.168.%d.%d' % (i, j)) print(ip)
->Reconstructed Predication:
ip.strip().find_element_by_ip_ip('192.168.x.x').split()
->Raw Input:
implement: loop through the IP address range "192.168.x.x"
->Raw Target:
for i in range(256): for j in range(256): ip = ('192.168.%d.%d' % (i, j)) print(ip)
--

413=========
->Original Input:
Print a string `word` with string format
->Original Target:
print('"{}"'.format(word))
->Reconstructed Target:
for (i, j) in product(list(range(256)), list(range(256))): pass
->Reconstructed Predication:
ip.strip().find_element_by_ip_ip('192.168.x.x').split()
->Raw Input:
implement: loop through the IP address range "192.168.x.x"
->Raw Target:
for (i, j) in product(list(range(256)), list(range(256))): pass
--

414=========
->Original Input:
join a list of strings `list` using a space ' '
->Original Target:
""" """.join(list)
->Reconstructed Target:
generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)
->Reconstructed Predication:
ip.strip().find_element_by_ip_ip('192.168.x.x').split()
->Raw Input:
implement: loop through the IP address range "192.168.x.x"
->Raw Target:
generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)
--

415=========
->Original Input:
create list `y` containing two empty lists
->Original Target:
y = [[] for n in range(2)]
->Reconstructed Target:
sum(1  i for i, b in enumerate(x) if b)
->Reconstructed Predication:
sum(x, key=lambda x: x[0])
->Raw Input:
implement: Sum the corresponding decimal values for binary values of each boolean element in list x
->Raw Target:
sum(1  i for i, b in enumerate(x) if b)
--

416=========
->Original Input:
read a file 'C:/name/MyDocuments/numbers' into a list `data`
->Original Target:
data = [line.strip() for line in open('C:/name/MyDocuments/numbers', 'r')]
->Reconstructed Target:
target.write('%rn%rn%rn' % (line1, line2, line3))
->Reconstructed Predication:
target.write('n', line1)['line1', line2', line3']
->Raw Input:
implement: write multiple strings line1, line2 and line3 in one line in a file target
->Raw Target:
target.write('%rn%rn%rn' % (line1, line2, line3))
--

417=========
->Original Input:
delete all occurrences of character 'i' in string 'it is icy'
->Original Target:
"""""".join([char for char in 'it is icy' if char != 'i'])
->Reconstructed Target:
[y for x in data for y in (x if isinstance(x, list) else [x])]
->Reconstructed Predication:
[[x for x in data] for x in x]
->Raw Input:
implement: Convert list of lists data into a flat list
->Raw Target:
[y for x in data for y in (x if isinstance(x, list) else [x])]
--

418=========
->Original Input:
delete all instances of a character 'i' in a string 'it is icy'
->Original Target:
re.sub('i', '', 'it is icy')
->Reconstructed Target:
print('foonbar'.encode('string_escape'))
->Reconstructed Predication:
print('n'.join('foonbar'))
->Raw Input:
implement: Print new line character as n in a string foonbar
->Raw Target:
print('foonbar'.encode('string_escape'))
--

419=========
->Original Input:
delete all characters "i" in string "it is icy"
->Original Target:
"""it is icy""".replace('i', '')
->Reconstructed Target:
"""""".join(s.rsplit(',', 1))
->Reconstructed Predication:
re.sub(',', s)
->Raw Input:
implement: remove last comma character ',' in string s
->Raw Target:
"""""".join(s.rsplit(',', 1))
--

420=========
->Original Input:
None
->Original Target:
"""""".join([char for char in 'it is icy' if char != 'i'])
->Reconstructed Target:
(x[1:] + x[:-1]) / 2
->Reconstructed Predication:
x.mean(axis=0)
->Raw Input:
implement: calculate the mean of each element in array x with the element previous to it
->Raw Target:
(x[1:] + x[:-1]) / 2
--

421=========
->Original Input:
Drop rows of pandas dataframe `df` having NaN in column at index "1"
->Original Target:
df.dropna(subset=[1])
->Reconstructed Target:
x[:-1] + (x[1:] - x[:-1]) / 2
->Reconstructed Predication:
x[(np.mean(x)) for np in x]
->Raw Input:
implement: get an array of the mean of each two consecutive values in numpy array x
->Raw Target:
x[:-1] + (x[1:] - x[:-1]) / 2
--

422=========
->Original Input:
get elements from list `myList`, that have a field `n` value 30
->Original Target:
[x for x in myList if x.n == 30]
->Reconstructed Target:
arr = numpy.fromiter(codecs.open('new.txt', encoding='utf-8'), dtype='U2')
->Reconstructed Predication:
arr = np.array(['utf-8', 'new.txt']).read()
->Raw Input:
implement: load data containing utf-8 from file new.txt into numpy array arr
->Raw Target:
arr = numpy.fromiter(codecs.open('new.txt', encoding='utf-8'), dtype='U2')
--

423=========
->Original Input:
converting list of strings `intstringlist` to list of integer `nums`
->Original Target:
nums = [int(x) for x in intstringlist]
->Reconstructed Target:
l = sorted(l, key=itemgetter('time'), reverse=True)
->Reconstructed Predication:
sorted(l, key=lambda x: time.values())
->Raw Input:
implement: reverse sort list of dicts l by value for key time
->Raw Target:
l = sorted(l, key=itemgetter('time'), reverse=True)
--

424=========
->Original Input:
convert list of string numbers into list of integers
->Original Target:
map(int, eval(input('Enter the unfriendly numbers: ')))
->Reconstructed Target:
l = sorted(l, key=lambda a: a['time'], reverse=True)
->Reconstructed Predication:
sorted(l, key=lambda x: (x['time']))
->Raw Input:
implement: Sort a list of dictionary l based on key time in descending order
->Raw Target:
l = sorted(l, key=lambda a: a['time'], reverse=True)
--

425=========
->Original Input:
print "." without newline
->Original Target:
sys.stdout.write('.')
->Reconstructed Target:
df.loc[df[0].str.contains('(Hel|Just)')]
->Reconstructed Predication:
df.loc[df.match('(Hel|Just)')]
->Raw Input:
implement: get rows of dataframe df that match regex '(Hel|Just)'
->Raw Target:
df.loc[df[0].str.contains('(Hel|Just)')]
--

426=========
->Original Input:
round off the float that is the product of `2.52 * 100` and convert it to an int
->Original Target:
int(round(2.51 * 100))
->Reconstructed Target:
re.search('[(.*)]', your_string).group(1)
->Reconstructed Predication:
your_string.find('[" - ')
->Raw Input:
implement: find the string in your_string between two special characters "[" and "]"
->Raw Target:
re.search('[(.*)]', your_string).group(1)
--

427=========
->Original Input:
Find all files in directory "/mydir" with extension ".txt"
->Original Target:
os.chdir('/mydir')
for file in glob.glob('*.txt'):
    pass
->Reconstructed Target:
"""The big brown fox is brown""".count('brown')
->Reconstructed Predication:
re.findall('The big brown fox is brown', 'brown')
->Raw Input:
implement: count number of times string 'brown' occurred in string 'The big brown fox is brown'
->Raw Target:
"""The big brown fox is brown""".count('brown')
--

428=========
->Original Input:
Find all files in directory "/mydir" with extension ".txt"
->Original Target:
for file in os.listdir('/mydir'):
    if file.endswith('.txt'):
        pass
->Reconstructed Target:
json.loads(request.body)
->Reconstructed Predication:
json.decode('request.body')
->Raw Input:
implement: decode json string request.body to python dict
->Raw Target:
json.loads(request.body)
--

429=========
->Original Input:
Find all files in directory "/mydir" with extension ".txt"
->Original Target:
for (root, dirs, files) in os.walk('/mydir'):
    for file in files:
        if file.endswith('.txt'):
            pass
->Reconstructed Target:
urllib.request.urlretrieve(url, file_name)
->Reconstructed Predication:
os.path.get(url, file_name)
->Raw Input:
implement: download the file from url url and save it under file file_name
->Raw Target:
urllib.request.urlretrieve(url, file_name)
--

430=========
->Original Input:
plot dataframe `df` without a legend
->Original Target:
df.plot(legend=False)
->Reconstructed Target:
text.split()
->Reconstructed Predication:
re.split('[]+', text)
->Raw Input:
implement: split string text by space
->Raw Target:
text.split()
--

431=========
->Original Input:
loop through the IP address range "192.168.x.x"
->Original Target:
for i in range(256):
    for j in range(256):
        ip = ('192.168.%d.%d' % (i, j))
        print(ip)
->Reconstructed Target:
text.split(',')
->Reconstructed Predication:
""",""".split(',')
->Raw Input:
implement: split string text by ","
->Raw Target:
text.split(',')
--

432=========
->Original Input:
loop through the IP address range "192.168.x.x"
->Original Target:
for (i, j) in product(list(range(256)), list(range(256))):
    pass
->Reconstructed Target:
line.split()
->Reconstructed Predication:
list(line.split())
->Raw Input:
implement: Split string line into a list by whitespace
->Raw Target:
line.split()
--

433=========
->Original Input:
loop through the IP address range "192.168.x.x"
->Original Target:
generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)
->Reconstructed Target:
[re.sub('(?!d).(?!d)','', i) for i in s]
->Reconstructed Predication:
re.sub('.','', s)
->Raw Input:
implement: replace dot characters '.' associated with ascii letters in list s with space''
->Raw Target:
[re.sub('(?!d).(?!d)','', i) for i in s]
--

434=========
->Original Input:
Sum the corresponding decimal values for binary values of each boolean element in list `x`
->Original Target:
sum(1 << i for i, b in enumerate(x) if b)
->Reconstructed Target:
sorted(list_of_strings, key=lambda s: s.split(',')[1])
->Reconstructed Predication:
list_of_strings.sort(key=lambda x: x[1])
->Raw Input:
implement: sort list list_of_strings based on second index of each string s
->Raw Target:
sorted(list_of_strings, key=lambda s: s.split(',')[1])
--

435=========
->Original Input:
write multiple strings `line1`, `line2` and `line3` in one line in a file `target`
->Original Target:
target.write('%r\n%r\n%r\n' % (line1, line2, line3))
->Reconstructed Target:
subprocess.check_call('vasp | tee tee_output', shell=True)
->Reconstructed Predication:
os.system('vasp', 'tee tee_output',|)
->Raw Input:
implement: call multiple bash function vasp and tee tee_output using |
->Raw Target:
subprocess.check_call('vasp | tee tee_output', shell=True)
--

436=========
->Original Input:
Convert list of lists `data` into a flat list
->Original Target:
[y for x in data for y in (x if isinstance(x, list) else [x])]
->Reconstructed Target:
[element for element in lst if isinstance(element, int)]
->Reconstructed Predication:
lst.remove('n')
->Raw Input:
implement: eliminate all strings from list lst
->Raw Target:
[element for element in lst if isinstance(element, int)]
--

437=========
->Original Input:
Print new line character as `\n` in a string `foo\nbar`
->Original Target:
print('foo\nbar'.encode('string_escape'))
->Reconstructed Target:
[element for element in lst if not isinstance(element, str)]
->Reconstructed Predication:
[x for x in lst if x not in x]
->Raw Input:
implement: get all the elements except strings from the list 'lst'.
->Raw Target:
[element for element in lst if not isinstance(element, str)]
--

438=========
->Original Input:
remove last comma character ',' in string `s`
->Original Target:
"""""".join(s.rsplit(',', 1))
->Reconstructed Target:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])
->Reconstructed Predication:
sorted(list_to_be_sorted, key=lambda x: name)
->Raw Input:
implement: Sort a list of dictionaries list_to_be_sorted by the value of the dictionary key name
->Raw Target:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])
--

439=========
->Original Input:
calculate the mean of each element in array `x` with the element previous to it
->Original Target:
(x[1:] + x[:-1]) / 2
->Reconstructed Target:
newlist = sorted(l, key=itemgetter('name'), reverse=True)
->Reconstructed Predication:
sorted(l, key=lambda x: (x['name']))
->Raw Input:
implement: sort a list of dictionaries l by values in key name in descending order
->Raw Target:
newlist = sorted(l, key=itemgetter('name'), reverse=True)
--

440=========
->Original Input:
get an array of the mean of each two consecutive values in numpy array `x`
->Original Target:
x[:-1] + (x[1:] - x[:-1]) / 2
->Reconstructed Target:
""",""".join(trans['category'])
->Reconstructed Predication:
dict((k, v) for k, v in tran['category'])
->Raw Input:
implement: join together with "," elements inside a list indexed with 'category' within a dictionary trans
->Raw Target:
""",""".join(trans['category'])
--

441=========
->Original Input:
load data containing `utf-8` from file `new.txt` into numpy array `arr`
->Original Target:
arr = numpy.fromiter(codecs.open('new.txt', encoding='utf-8'), dtype='<U2')
->Reconstructed Target:
"""""".join(['A', 'B', 'C', 'D'])
->Reconstructed Predication:
re.concat(['A', 'B', 'C', 'D'])
->Raw Input:
implement: concatenate array of strings ['A', 'B', 'C', 'D'] into a string
->Raw Target:
"""""".join(['A', 'B', 'C', 'D'])
--

442=========
->Original Input:
reverse sort list of dicts `l` by value for key `time`
->Original Target:
l = sorted(l, key=itemgetter('time'), reverse=True)
->Reconstructed Target:
json.load(urllib.request.urlopen('url'))
->Reconstructed Predication:
json.loads(url)
->Raw Input:
implement: get json data from restful service 'url'
->Raw Target:
json.load(urllib.request.urlopen('url'))
--

443=========
->Original Input:
Sort a list of dictionary `l` based on key `time` in descending order
->Original Target:
l = sorted(l, key=lambda a: a['time'], reverse=True)
->Reconstructed Target:
[x for x in sents if not x.startswith('@$t') and not x.startswith('#')]
->Reconstructed Predication:
sents.replace('@$t', '#')
->Raw Input:
implement: Remove all strings from a list a strings sents where the values starts with @$t or #
->Raw Target:
[x for x in sents if not x.startswith('@$t') and not x.startswith('#')]
--

444=========
->Original Input:
get rows of dataframe `df` that match regex '(Hel|Just)'
->Original Target:
df.loc[df[0].str.contains('(Hel|Just)')]
->Reconstructed Target:
Entry.objects.filter(pub_date__contains='08:00')
->Reconstructed Predication:
django.filter(hours=1, min=1, filter=True)
->Raw Input:
implement: django filter by hour
->Raw Target:
Entry.objects.filter(pub_date__contains='08:00')
--

445=========
->Original Input:
find the string in `your_string` between two special characters "[" and "]"
->Original Target:
re.search('\\[(.*)\\]', your_string).group(1)
->Reconstructed Target:
list.sort(key=lambda item: (item['points'], item['time']))
->Reconstructed Predication:
list.sort(key=lambda x: x[1])
->Raw Input:
implement: sort a list of dictionary list first by key points and then by time
->Raw Target:
list.sort(key=lambda item: (item['points'], item['time']))
--

446=========
->Original Input:
None
->Original Target:
[d.strftime('%Y%m%d') for d in pandas.date_range('20130226', '20130302')]
->Reconstructed Target:
(t - datetime.datetime(1970, 1, 1)).total_seconds()
->Reconstructed Predication:
datetime.datetime.strptime((1970, 1, 1))
->Raw Input:
implement: convert datetime object (1970, 1, 1) to seconds
->Raw Target:
(t - datetime.datetime(1970, 1, 1)).total_seconds()
--

447=========
->Original Input:
count number of times string 'brown' occurred in string 'The big brown fox is brown'
->Original Target:
"""The big brown fox is brown""".count('brown')
->Reconstructed Target:
re.sub('(_a)?.([.]*)$', '_suff.2', 'long.file.name.jpg')
->Reconstructed Predication:
os.path.insert('long.file.name.jpg', _a)
->Raw Input:
implement: insert _suff before the file extension in long.file.name.jpg or replace _a with suff if it precedes the extension.
->Raw Target:
re.sub('(_a)?.([.]*)$', '_suff.2', 'long.file.name.jpg')
--

448=========
->Original Input:
decode json string `request.body` to python dict
->Original Target:
json.loads(request.body)
->Reconstructed Target:
import imp imp.reload(module)
->Reconstructed Predication:
module.reload()
->Raw Input:
implement: reload a module module
->Raw Target:
import imp imp.reload(module)
--

449=========
->Original Input:
download the file from url `url` and save it under file `file_name`
->Original Target:
urllib.request.urlretrieve(url, file_name)
->Reconstructed Target:
struct.unpack('H', struct.pack('h', number))
->Reconstructed Predication:
int(number)
->Raw Input:
implement: Convert integer number into an unassigned integer
->Raw Target:
struct.unpack('H', struct.pack('h', number))
--

450=========
->Original Input:
split string `text` by space
->Original Target:
text.split()
->Reconstructed Target:
numlist = [float(x) for x in numlist]
->Reconstructed Predication:
float(numlist)
->Raw Input:
implement: convert int values in list numlist to float
->Raw Target:
numlist = [float(x) for x in numlist]
--

451=========
->Original Input:
split string `text` by ","
->Original Target:
text.split(',')
->Reconstructed Target:
df.to_csv(filename, index=False)
->Reconstructed Predication:
df.writecsv(index=False)
->Raw Input:
implement: write dataframe df, excluding index, to a csv file
->Raw Target:
df.to_csv(filename, index=False)
--

452=========
->Original Input:
Split string `line` into a list by whitespace
->Original Target:
line.split()
->Reconstructed Target:
json_data = json.loads(unescaped)
->Reconstructed Predication:
json_data = json.read_url(unescaped, unescaped)
->Raw Input:
implement: convert a urllib unquoted string unescaped to a json data json_data
->Raw Target:
json_data = json.loads(unescaped)
--

453=========
->Original Input:
replace dot characters  '.' associated with ascii letters in list `s` with space ' '
->Original Target:
[re.sub('(?<!\\d)\\.(?!\\d)', ' ', i) for i in s]
->Reconstructed Target:
[chr(i) for i in range(127)]
->Reconstructed Predication:
[x for x in zip('ascii') for x in x]
->Raw Input:
implement: Create a list containing all ascii characters as its elements
->Raw Target:
[chr(i) for i in range(127)]
--

454=========
->Original Input:
sort list `list_of_strings` based on second index of each string `s`
->Original Target:
sorted(list_of_strings, key=lambda s: s.split(',')[1])
->Reconstructed Target:
newFile.write(struct.pack('5B', *newFileBytes))
->Reconstructed Predication:
newFile = os.write('newFileBytes')
->Raw Input:
implement: write newFileBytes to a binary file newFile
->Raw Target:
newFile.write(struct.pack('5B', *newFileBytes))
--

455=========
->Original Input:
call multiple bash function vasp and tee tee_output using |
->Original Target:
subprocess.check_call('vasp | tee tee_output', shell=True)
->Reconstructed Target:
re.sub('[A-Z0-9]*(?![a-z])', '', string)
->Reconstructed Predication:
re.findall('(?))', string)
->Raw Input:
implement: python regex - check for a capital letter with a following lowercase in string string
->Raw Target:
re.sub('[A-Z0-9]*(?![a-z])', '', string)
--

456=========
->Original Input:
eliminate all strings from list `lst`
->Original Target:
[element for element in lst if isinstance(element, int)]
->Reconstructed Target:
list(dict.keys())[-1]
->Reconstructed Predication:
dict[(k, v) for k, v in list(dict.items())]
->Raw Input:
implement: get the last key of dictionary dict
->Raw Target:
list(dict.keys())[-1]
--

457=========
->Original Input:
get all the elements except strings from the list 'lst'.
->Original Target:
[element for element in lst if not isinstance(element, str)]
->Reconstructed Target:
print('hi there', file=f)
->Reconstructed Predication:
f.write('hi there')
->Raw Input:
implement: write line "hi there" to file f
->Raw Target:
print('hi there', file=f)
--

458=========
->Original Input:
Sort a list of dictionaries `list_to_be_sorted` by the value of the dictionary key `name`
->Original Target:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])
->Reconstructed Target:
f = open('myfile', 'w') f.write('hi theren') f.close()
->Reconstructed Predication:
myfile.write('hi there')
->Raw Input:
implement: write line "hi there" to file myfile
->Raw Target:
f = open('myfile', 'w') f.write('hi theren') f.close()
--

459=========
->Original Input:
sort a list of dictionaries `l` by values in key `name` in descending order
->Original Target:
newlist = sorted(l, key=itemgetter('name'), reverse=True)
->Reconstructed Target:
with open('somefile.txt', 'a') as the_file: the_file.write('Hellon')
->Reconstructed Predication:
os.path.write('Hello')
->Raw Input:
implement: write line "Hello" to file somefile.txt
->Raw Target:
with open('somefile.txt', 'a') as the_file: the_file.write('Hellon')
--

460=========
->Original Input:
None
->Original Target:
list_of_dicts.sort(key=operator.itemgetter('name'))
->Reconstructed Target:
s.encode('iso-8859-15')
->Reconstructed Predication:
s.encode('unicode_escape')
->Raw Input:
implement: convert unicode string s to ascii
->Raw Target:
s.encode('iso-8859-15')
--

461=========
->Original Input:
None
->Original Target:
list_of_dicts.sort(key=operator.itemgetter('age'))
->Reconstructed Target:
AuthorizedEmail.objects.filter(group=group).order_by('-added')[0]
->Reconstructed Predication:
AutorizedEmail.max('added')
->Raw Input:
implement: Django get maximum value associated with field 'added' in model AuthorizedEmail
->Raw Target:
AuthorizedEmail.objects.filter(group=group).order_by('-added')[0]
--

462=========
->Original Input:
None
->Original Target:
df.groupby('prots').sum().sort('scores', ascending=False)
->Reconstructed Target:
re.findall('Test([0-9.]*[0-9]+)', text)
->Reconstructed Predication:
re.findall('d+d+d+d+d+d+d+d+d+d+d+d+d+d+d+d+d+d+d
->Raw Input:
implement: Find all numbers and dots from a string text using regex
->Raw Target:
re.findall('Test([0-9.]*[0-9]+)', text)
--

463=========
->Original Input:
join together with "," elements inside a list indexed with 'category' within a dictionary `trans`
->Original Target:
""",""".join(trans['category'])
->Reconstructed Target:
re.findall('Test([d.]*d+)', text)
->Reconstructed Predication:
re.findall('d+', text)
->Raw Input:
implement: python regex to find all numbers and dots from 'text'
->Raw Target:
re.findall('Test([d.]*d+)', text)
--

464=========
->Original Input:
concatenate array of strings `['A', 'B', 'C', 'D']` into a string
->Original Target:
"""""".join(['A', 'B', 'C', 'D'])
->Reconstructed Target:
os.system('powershell.exe','script.ps1')
->Reconstructed Predication:
sys.exit('script.ps1', 'powershell.exe')
->Raw Input:
implement: execute script'script.ps1' using 'powershell.exe' shell
->Raw Target:
os.system('powershell.exe','script.ps1')
--

465=========
->Original Input:
get json data from restful service 'url'
->Original Target:
json.load(urllib.request.urlopen('url'))
->Reconstructed Target:
b.sort(key=lambda x: x[1][2])
->Reconstructed Predication:
sorted(b, key=lambda x: (x[1])[2])
->Raw Input:
implement: Sort a list of tuples b by third item in the tuple
->Raw Target:
b.sort(key=lambda x: x[1][2])
--

466=========
->Original Input:
Remove all strings from a list a strings `sents` where the values starts with `@$\t` or `#`
->Original Target:
[x for x in sents if not x.startswith('@$\t') and not x.startswith('#')]
->Reconstructed Target:
list(cf.get_range().get_keys())
->Reconstructed Predication:
[cf[::-1] for cf in cf]
->Raw Input:
implement: get a list of all keys in Cassandra database cf with pycassa
->Raw Target:
list(cf.get_range().get_keys())
--

467=========
->Original Input:
django filter by hour
->Original Target:
Entry.objects.filter(pub_date__contains='08:00')
->Reconstructed Target:
datetime.datetime.now()
->Reconstructed Predication:
datetime.datetime.now().strftime('%Y-%m-%d %H:%M')
->Raw Input:
implement: create a datetime with the current date & time
->Raw Target:
datetime.datetime.now()
--

468=========
->Original Input:
sort a list of dictionary `list` first by key `points` and then by `time`
->Original Target:
list.sort(key=lambda item: (item['points'], item['time']))
->Reconstructed Target:
next(i for i, x in enumerate(lst) if not isinstance(x, bool) and x == 1)
->Reconstructed Predication:
[1 for i in lst if i also contains boolean]
->Raw Input:
implement: get the index of an integer 1 from a list lst if the list also contains boolean items
->Raw Target:
next(i for i, x in enumerate(lst) if not isinstance(x, bool) and x == 1)
--

469=========
->Original Input:
convert datetime object `(1970, 1, 1)` to seconds
->Original Target:
(t - datetime.datetime(1970, 1, 1)).total_seconds()
->Reconstructed Target:
a[:] = [(x - 13) for x in a]
->Reconstructed Predication:
[(x + 13) for x in a]
->Raw Input:
implement: subtract 13 from every number in a list a
->Raw Target:
a[:] = [(x - 13) for x in a]
--

470=========
->Original Input:
insert `_suff` before the file extension in `long.file.name.jpg` or replace `_a` with `suff` if it precedes the extension.
->Original Target:
re.sub('(\\_a)?\\.([^\\.]*)$', '_suff.\\2', 'long.file.name.jpg')
->Reconstructed Target:
random.choice(os.listdir('C:'))
->Reconstructed Predication:
random.choice(C:, 'r')
->Raw Input:
implement: choose a random file from the directory contents of the C drive, C:
->Raw Target:
random.choice(os.listdir('C:'))
--

471=========
->Original Input:
reload a module `module`
->Original Target:
import imp
imp.reload(module)
->Reconstructed Target:
max(x.min(), x.max(), key=abs)
->Reconstructed Predication:
max(x, key=lambda x: x[1])
->Raw Input:
implement: get the highest element in absolute value in a numpy matrix x
->Raw Target:
max(x.min(), x.max(), key=abs)
--

472=========
->Original Input:
Convert integer `number` into an unassigned integer
->Original Target:
struct.unpack('H', struct.pack('h', number))
->Reconstructed Target:
re.findall('"(http.*?)"', s, re.MULTILINE | re.DOTALL)
->Reconstructed Predication:
urllib.find_all('url>', s)
->Raw Input:
implement: Get all urls within text s
->Raw Target:
re.findall('"(http.*?)"', s, re.MULTILINE | re.DOTALL)
--

473=========
->Original Input:
convert int values in list `numlist` to float
->Original Target:
numlist = [float(x) for x in numlist]
->Reconstructed Target:
re.findall('http://[t][s"]+.html', document)
->Reconstructed Predication:
re.findall('tttttttttttttttttttttttttttt
->Raw Input:
implement: match urls whose domain doesn't start with t from string document using regex
->Raw Target:
re.findall('http://[t][s"]+.html', document)
--

474=========
->Original Input:
write dataframe `df`, excluding index, to a csv file
->Original Target:
df.to_csv(filename, index=False)
->Reconstructed Target:
mystring.replace(' ', '!!').split('!')
->Reconstructed Predication:
mystring.split(' ')
->Raw Input:
implement: split a string mystring considering the spaces''
->Raw Target:
mystring.replace(' ', '!!').split('!')
--

475=========
->Original Input:
convert a urllib unquoted string `unescaped` to a json data `json_data`
->Original Target:
json_data = json.loads(unescaped)
->Reconstructed Target:
open(path, 'r')
->Reconstructed Predication:
os.path.open(path)
->Raw Input:
implement: open file path with mode 'r'
->Raw Target:
open(path, 'r')
--

476=========
->Original Input:
Create a list containing all ascii characters as its elements
->Original Target:
[chr(i) for i in range(127)]
->Reconstructed Target:
[[sum(item) for item in zip(*items)] for items in zip(*data)]
->Reconstructed Predication:
sum(x + y for x, y in data)
->Raw Input:
implement: sum elements at the same index in list data
->Raw Target:
[[sum(item) for item in zip(*items)] for items in zip(*data)]
--

477=========
->Original Input:
write `newFileBytes` to a binary file `newFile`
->Original Target:
newFile.write(struct.pack('5B', *newFileBytes))
->Reconstructed Target:
a[:, (np.newaxis)]
->Reconstructed Predication:
a[::(-1)]
->Raw Input:
implement: add a new axis to array a
->Raw Target:
a[:, (np.newaxis)]
--
