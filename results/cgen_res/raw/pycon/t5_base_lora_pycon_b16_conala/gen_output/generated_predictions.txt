1=========
->Original Input:
send a signal `signal.SIGUSR1` to the current process
->Original Target:
os.kill(os.getpid(), signal.SIGUSR1)
->Reconstructed Target:
os.kill(os.getpid(), signal.SIGUSR1)
->Reconstructed Predication:
syslog.signal.SIGUSR1
->Raw Input:
summarize:send a signal signal.SIGUSR1 to the current process
->Raw Target:
os.kill(os.getpid(), signal.SIGUSR1)
--

2=========
->Original Input:
decode a hex string '4a4b4c' to UTF-8.
->Original Target:
bytes.fromhex('4a4b4c').decode('utf-8')
->Reconstructed Target:
bytes.fromhex('4a4b4c').decode('utf-8')
->Reconstructed Predication:
'4a4b4c' decodes a hex string to UTF-8.
->Raw Input:
summarize:decode a hex string '4a4b4c' to UTF-8.
->Raw Target:
bytes.fromhex('4a4b4c').decode('utf-8')
--

3=========
->Original Input:
check if all elements in list `myList` are identical
->Original Target:
all(x == myList[0] for x in myList)
->Reconstructed Target:
all(x == myList[0] for x in myList)
->Reconstructed Predication:
'myList'
->Raw Input:
summarize:check if all elements in list myList are identical
->Raw Target:
all(x == myList[0] for x in myList)
--

4=========
->Original Input:
format number of spaces between strings `Python`, `:` and `Very Good` to be `20`
->Original Target:
print('%*s : %*s' % (20, 'Python', 20, 'Very Good'))
->Reconstructed Target:
print('%*s : %*s' % (20, 'Python', 20, 'Very Good'))
->Reconstructed Predication:
.formatnumber('Python', ':' and 'Very Good')
->Raw Input:
summarize:format number of spaces between strings Python, : and Very Good to be 20
->Raw Target:
print('%*s : %*s' % (20, 'Python', 20, 'Very Good'))
--

5=========
->Original Input:
None
->Original Target:
d.decode('cp1251').encode('utf8')
->Reconstructed Target:
res = k: v for k, v in list(kwargs.items()) if v is not None
->Reconstructed Predication:
kwargs.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid
->Raw Input:
summarize:get rid of None values in dictionary kwargs
->Raw Target:
res = k: v for k, v in list(kwargs.items()) if v is not None
--

6=========
->Original Input:
get rid of None values in dictionary `kwargs`
->Original Target:
res = {k: v for k, v in list(kwargs.items()) if v is not None}
->Reconstructed Target:
res = dict((k, v) for k, v in kwargs.items() if v is not None)
->Reconstructed Predication:
kwargs.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid of None.get rid
->Raw Input:
summarize:get rid of None values in dictionary kwargs
->Raw Target:
res = dict((k, v) for k, v in kwargs.items() if v is not None)
--

7=========
->Original Input:
get rid of None values in dictionary `kwargs`
->Original Target:
res = dict((k, v) for k, v in kwargs.items() if v is not None)
->Reconstructed Target:
subprocess.check_output('ps -ef | grep something | wc -l', shell=True)
->Reconstructed Predication:
ps -ef | grep something | wc -l
->Raw Input:
summarize:capture final output of a chain of system commands ps -ef | grep something | wc -l
->Raw Target:
subprocess.check_output('ps -ef | grep something | wc -l', shell=True)
--

8=========
->Original Input:
capture final output of a chain of system commands `ps -ef | grep something | wc -l`
->Original Target:
subprocess.check_output('ps -ef | grep something | wc -l', shell=True)
->Reconstructed Target:
"""""".join(['a', 'b', 'c'])
->Reconstructed Predication:
a('a', 'b', 'c')
->Raw Input:
summarize:concatenate a list of strings ['a', 'b', 'c']
->Raw Target:
"""""".join(['a', 'b', 'c'])
--

9=========
->Original Input:
concatenate a list of strings `['a', 'b', 'c']`
->Original Target:
"""""".join(['a', 'b', 'c'])
->Reconstructed Target:
pd.Series(list(set(s1).intersection(set(s2))))
->Reconstructed Predication:
s1 and s2
->Raw Input:
summarize:find intersection data between series s1 and series s2
->Raw Target:
pd.Series(list(set(s1).intersection(set(s2))))
--

10=========
->Original Input:
find intersection data between series `s1` and series `s2`
->Original Target:
pd.Series(list(set(s1).intersection(set(s2))))
->Reconstructed Target:
client.send('HTTP/1.0 200 OKrn')
->Reconstructed Predication:
clients headers.sending.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.send.
->Raw Input:
summarize:sending http headers to client
->Raw Target:
client.send('HTTP/1.0 200 OKrn')
--

11=========
->Original Input:
sending http headers to `client`
->Original Target:
client.send('HTTP/1.0 200 OK\r\n')
->Reconstructed Target:
then = datetime.datetime.strptime(when, '%Y-%m-%d').date()
->Reconstructed Predication:
.datetime(when))
->Raw Input:
summarize:Format a datetime string when to extract date only
->Raw Target:
then = datetime.datetime.strptime(when, '%Y-%m-%d').date()
--

12=========
->Original Input:
Format a datetime string `when` to extract date only
->Original Target:
then = datetime.datetime.strptime(when, '%Y-%m-%d').date()
->Reconstructed Target:
inputString.split('n')
->Reconstructed Predication:
.split(inputString)
->Raw Input:
summarize:split a multi-line string inputString into separate strings
->Raw Target:
inputString.split('n')
--

13=========
->Original Input:
split a multi-line string `inputString` into separate strings
->Original Target:
inputString.split('\n')
->Reconstructed Target:
' a n b rn c '.split('n')
->Reconstructed Predication:
a n b rn c  by new line character n.
->Raw Input:
summarize:Split a multi-line string  a n b rn c  by new line character n
->Raw Target:
' a n b rn c '.split('n')
--

14=========
->Original Input:
Split a multi-line string ` a \n b \r\n c ` by new line character `\n`
->Original Target:
' a \n b \r\n c '.split('\n')
->Reconstructed Target:
""":""".join(str(x) for x in b)
->Reconstructed Predication:
b('')
->Raw Input:
summarize:concatenate elements of list b by a colon ":"
->Raw Target:
""":""".join(str(x) for x in b)
--

15=========
->Original Input:
concatenate elements of list `b` by a colon ":"
->Original Target:
""":""".join(str(x) for x in b)
->Reconstructed Target:
Entry.objects.filter()[:1].get()
->Reconstructed Predication:
django model Entrygets the first object from a queryset
->Raw Input:
summarize:get the first object from a queryset in django model Entry
->Raw Target:
Entry.objects.filter()[:1].get()
--

16=========
->Original Input:
get the first object from a queryset in django model `Entry`
->Original Target:
Entry.objects.filter()[:1].get()
->Reconstructed Target:
a.sum(axis=1)
->Reconstructed Predication:
..calculates sum over all rows of 2D numpy array.
->Raw Input:
summarize:Calculate sum over all rows of 2D numpy array
->Raw Target:
a.sum(axis=1)
--

17=========
->Original Input:
Calculate sum over all rows of 2D numpy array
->Original Target:
a.sum(axis=1)
->Reconstructed Target:
warnings.simplefilter('always')
->Reconstructed Predication:
warnings use action 'always'
->Raw Input:
summarize:enable warnings using action 'always'
->Raw Target:
warnings.simplefilter('always')
--

18=========
->Original Input:
enable warnings using action 'always'
->Original Target:
warnings.simplefilter('always')
->Reconstructed Target:
print(' '.join(map(str, l)))
->Reconstructed Predication:
l('l')
->Raw Input:
summarize:concatenate items of list l with a space''
->Raw Target:
print(' '.join(map(str, l)))
--

19=========
->Original Input:
concatenate items of list `l` with a space ' '
->Original Target:
print(' '.join(map(str, l)))
->Reconstructed Target:
subprocess.call(['python.exe', 'hello.py', 'htmlfilename.htm'])
->Reconstructed Predication:
'hello.py' runs python executable on terminal.
->Raw Input:
summarize:run script 'hello.py' with argument 'htmlfilename.htm' on terminal using python executable
->Raw Target:
subprocess.call(['python.exe', 'hello.py', 'htmlfilename.htm'])
--

20=========
->Original Input:
run script 'hello.py' with argument 'htmlfilename.htm' on terminal using python executable
->Original Target:
subprocess.call(['python.exe', 'hello.py', 'htmlfilename.htm'])
->Reconstructed Target:
my_float = float(my_string.replace(',', ''))
->Reconstructed Predication:
float(my_float)
->Raw Input:
summarize:convert a string my_string with dot and comma into a float number my_float
->Raw Target:
my_float = float(my_string.replace(',', ''))
--

21=========
->Original Input:
None
->Original Target:
time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S.%f')
->Reconstructed Target:
float('123,456.908'.replace(',', ''))
->Reconstructed Predication:
123,456.908.comma.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.std.
->Raw Input:
summarize:convert a string 123,456.908 with dot and comma into a floating number
->Raw Target:
float('123,456.908'.replace(',', ''))
--

22=========
->Original Input:
convert a string `my_string` with dot and comma into a float number `my_float`
->Original Target:
my_float = float(my_string.replace(',', ''))
->Reconstructed Target:
sys.path.append('/path/to/whatever')
->Reconstructed Predication:
set pythonpath in python script.
->Raw Input:
summarize:set pythonpath in python script.
->Raw Target:
sys.path.append('/path/to/whatever')
--

23=========
->Original Input:
convert a string `123,456.908` with dot and comma into a floating number
->Original Target:
float('123,456.908'.replace(',', ''))
->Reconstructed Target:
re.split('(W+)', 'Words, words, words.')
->Reconstructed Predication:
'(W+)'
->Raw Input:
summarize:split string 'Words, words, words.' using a regex '(W+)'
->Raw Target:
re.split('(W+)', 'Words, words, words.')
--

24=========
->Original Input:
set pythonpath in python script.
->Original Target:
sys.path.append('/path/to/whatever')
->Reconstructed Target:
file = open('Output.txt', 'a')
->Reconstructed Predication:
Output.txt
->Raw Input:
summarize:open a file Output.txt in append mode
->Raw Target:
file = open('Output.txt', 'a')
--

25=========
->Original Input:
split string 'Words, words, words.' using a regex '(\\W+)'
->Original Target:
re.split('(\\W+)', 'Words, words, words.')
->Reconstructed Target:
urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3','mp3.mp3')
->Reconstructed Predication:
mp3.mp3
->Raw Input:
summarize:download a file "http://www.example.com/songs/mp3.mp3" over HTTP and save to "mp3.mp3"
->Raw Target:
urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3','mp3.mp3')
--

26=========
->Original Input:
open a file `Output.txt` in append mode
->Original Target:
file = open('Output.txt', 'a')
->Reconstructed Target:
u = urllib.request.urlopen(url) f = open(file_name, 'wb') meta = u.info() file_size = int(meta.getheaders('Content-Length')[0]) print(('Downloading: %s Bytes: %s' % (file_name, file_size))) file_size_dl = 0 block_sz = 8192 while True: buffer = u.read(block_sz) if (not buffer): break file_size_dl += len(buffer) f.write(buffer) status = ('%10d [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size))) status = (status + (chr(8) * (len(status) + 1))) print(status, end=' ') f.close()
->Reconstructed Predication:
url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.
->Raw Input:
summarize:download a file url over HTTP and save to file_name
->Raw Target:
u = urllib.request.urlopen(url) f = open(file_name, 'wb') meta = u.info() file_size = int(meta.getheaders('Content-Length')[0]) print(('Downloading: %s Bytes: %s' % (file_name, file_size))) file_size_dl = 0 block_sz = 8192 while True: buffer = u.read(block_sz) if (not buffer): break file_size_dl += len(buffer) f.write(buffer) status = ('%10d [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size))) status = (status + (chr(8) * (len(status) + 1))) print(status, end=' ') f.close()
--

27=========
->Original Input:
download a file "http://www.example.com/songs/mp3.mp3" over HTTP and save to "mp3.mp3"
->Original Target:
urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')
->Reconstructed Target:
response = urllib.request.urlopen('http://www.example.com/') html = response.read()
->Reconstructed Predication:
download a file 'http://www.example.com/' over HTTP
->Raw Input:
summarize:download a file 'http://www.example.com/' over HTTP
->Raw Target:
response = urllib.request.urlopen('http://www.example.com/') html = response.read()
--

28=========
->Original Input:
download a file `url` over HTTP and save to `file_name`
->Original Target:
u = urllib.request.urlopen(url)
f = open(file_name, 'wb')
meta = u.info()
file_size = int(meta.getheaders('Content-Length')[0])
print(('Downloading: %s Bytes: %s' % (file_name, file_size)))
file_size_dl = 0
block_sz = 8192
while True:
    buffer = u.read(block_sz)
    if (not buffer):
        break
    file_size_dl += len(buffer)
    f.write(buffer)
    status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))
    status = (status + (chr(8) * (len(status) + 1)))
    print(status, end=' ')
f.close()
->Reconstructed Target:
r = requests.get(url)
->Reconstructed Predication:
download a file url over HTTP
->Raw Input:
summarize:download a file url over HTTP
->Raw Target:
r = requests.get(url)
--

29=========
->Original Input:
download a file 'http://www.example.com/' over HTTP
->Original Target:
response = urllib.request.urlopen('http://www.example.com/')
html = response.read()
->Reconstructed Target:
response = requests.get(url, stream=True) with open('10MB', 'wb') as handle: for data in tqdm(response.iter_content()): handle.write(data)
->Reconstructed Predication:
url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.url.
->Raw Input:
summarize:download a file url over HTTP and save to "10MB"
->Raw Target:
response = requests.get(url, stream=True) with open('10MB', 'wb') as handle: for data in tqdm(response.iter_content()): handle.write(data)
--

30=========
->Original Input:
download a file `url` over HTTP
->Original Target:
r = requests.get(url)
->Reconstructed Target:
parser.add_argument('--version', action='version', version='%(prog)s 2.0')
->Reconstructed Predication:
argparse add argument with flag '--version' and version action of '%(prog)s 2.0' to parser parser
->Raw Input:
summarize:argparse add argument with flag '--version' and version action of '%(prog)s 2.0' to parser parser
->Raw Target:
parser.add_argument('--version', action='version', version='%(prog)s 2.0')
--

31=========
->Original Input:
download a file `url` over HTTP and save to "10MB"
->Original Target:
response = requests.get(url, stream=True)
with open('10MB', 'wb') as handle:
    for data in tqdm(response.iter_content()):
        handle.write(data)
->Reconstructed Target:
i: d[i] for i in d if i!= 'c'
->Reconstructed Predication:
d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.
->Raw Input:
summarize:remove key 'c' from dictionary d
->Raw Target:
i: d[i] for i in d if i!= 'c'
--

32=========
->Original Input:
argparse add argument with flag '--version' and version action of '%(prog)s 2.0' to parser `parser`
->Original Target:
parser.add_argument('--version', action='version', version='%(prog)s 2.0')
->Reconstructed Target:
pd.merge(split_df, csv_df, on=['key'], suffixes=('_left', '_right'))
->Reconstructed Predication:
rename the columns from dataframes split_df and csv_df with suffix _left and _right respectively.
->Raw Input:
summarize:Create new DataFrame object by merging columns "key" of dataframes split_df and csv_df and rename the columns from dataframes split_df and csv_df with suffix _left and _right respectively
->Raw Target:
pd.merge(split_df, csv_df, on=['key'], suffixes=('_left', '_right'))
--

33=========
->Original Input:
remove key 'c' from dictionary `d`
->Original Target:
{i: d[i] for i in d if i != 'c'}
->Reconstructed Target:
s.split(' ', 4)
->Reconstructed Predication:
s(s): splits(s)
->Raw Input:
summarize:Split a string s by space with 4 splits
->Raw Target:
s.split(' ', 4)
--

34=========
->Original Input:
Create new DataFrame object by merging columns "key" of  dataframes `split_df` and `csv_df` and rename the columns from dataframes `split_df` and `csv_df` with suffix `_left` and `_right` respectively
->Original Target:
pd.merge(split_df, csv_df, on=['key'], suffixes=('_left', '_right'))
->Reconstructed Target:
input('Enter your input:')
->Reconstructed Predication:
'read keyboard-input'
->Raw Input:
summarize:read keyboard-input
->Raw Target:
input('Enter your input:')
--

35=========
->Original Input:
Split a string `s` by space with `4` splits
->Original Target:
s.split(' ', 4)
->Reconstructed Target:
app.run(debug=True)
->Reconstructed Predication:
debug_app_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_debug_
->Raw Input:
summarize:enable debug mode on Flask application app
->Raw Target:
app.run(debug=True)
--

36=========
->Original Input:
read keyboard-input
->Original Target:
input('Enter your input:')
->Reconstructed Target:
pickle.dump(mylist, open('save.txt', 'wb'))
->Reconstructed Predication:
python save list'mylist'
->Raw Input:
summarize:python save list mylist to file object'save.txt'
->Raw Target:
pickle.dump(mylist, open('save.txt', 'wb'))
--

37=========
->Original Input:
enable debug mode on Flask application `app`
->Original Target:
app.run(debug=True)
->Reconstructed Target:
scipy.tensordot(P, T, axes=[1, 1]).swapaxes(0, 1)
->Reconstructed Predication:
scipy:multiply a matrix P with a 3d tensor T in scipy:multiply a matrix P with a 3d tensor T in scipy:multiply a matrix P with a 3d tensor T in scipy:multiply a matrix P with a 3d tensor 
->Raw Input:
summarize:Multiply a matrix P with a 3d tensor T in scipy
->Raw Target:
scipy.tensordot(P, T, axes=[1, 1]).swapaxes(0, 1)
--

38=========
->Original Input:
python save list `mylist` to file object 'save.txt'
->Original Target:
pickle.dump(mylist, open('save.txt', 'wb'))
->Reconstructed Target:
numpy.zeros((3, 3, 3))
->Reconstructed Predication:
.(3,3,3).0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.
->Raw Input:
summarize:Create 3d array of zeroes of size (3,3,3)
->Raw Target:
numpy.zeros((3, 3, 3))
--

39=========
->Original Input:
Multiply a matrix `P` with a 3d tensor `T` in scipy
->Original Target:
scipy.tensordot(P, T, axes=[1, 1]).swapaxes(0, 1)
->Reconstructed Target:
""" """.join(content.split(' ')[:-1])
->Reconstructed Predication:
content.cut off.
->Raw Input:
summarize:cut off the last word of a sentence content
->Raw Target:
""" """.join(content.split(' ')[:-1])
--

40=========
->Original Input:
Create 3d array of zeroes of size `(3,3,3)`
->Original Target:
numpy.zeros((3, 3, 3))
->Reconstructed Target:
x = np.asarray(x).reshape(1, -1)[(0), :]
->Reconstructed Predication:
xx.Array.convert(xx) to array.Array.convert(x)
->Raw Input:
summarize:convert scalar x to array
->Raw Target:
x = np.asarray(x).reshape(1, -1)[(0), :]
--

41=========
->Original Input:
cut off the last word of a sentence `content`
->Original Target:
""" """.join(content.split(' ')[:-1])
->Reconstructed Target:
sum(sum(i) if isinstance(i, list) else i for i in L)
->Reconstructed Predication:
L(L)
->Raw Input:
summarize:sum all elements of nested list L
->Raw Target:
sum(sum(i) if isinstance(i, list) else i for i in L)
--

42=========
->Original Input:
convert scalar `x` to array
->Original Target:
x = np.asarray(x).reshape(1, -1)[(0), :]
->Reconstructed Target:
struct.unpack('!f', '470FC614'.decode('hex'))[0]
->Reconstructed Predication:
'470FC614'
->Raw Input:
summarize:convert hex string '470FC614' to a float number
->Raw Target:
struct.unpack('!f', '470FC614'.decode('hex'))[0]
--

43=========
->Original Input:
sum all elements of nested list `L`
->Original Target:
sum(sum(i) if isinstance(i, list) else i for i in L)
->Reconstructed Target:
my_dict.update((x, y * 2) for x, y in list(my_dict.items()))
->Reconstructed Predication:
.my_dict.multiple(2)
->Raw Input:
summarize:Multiple each value by 2 for all keys in a dictionary my_dict
->Raw Target:
my_dict.update((x, y * 2) for x, y in list(my_dict.items()))
--

44=========
->Original Input:
convert hex string '470FC614' to a float number
->Original Target:
struct.unpack('!f', '470FC614'.decode('hex'))[0]
->Reconstructed Target:
subprocess.call('sleep.sh', shell=True)
->Reconstructed Predication:
'sleep.sh'
->Raw Input:
summarize:running bash script'sleep.sh'
->Raw Target:
subprocess.call('sleep.sh', shell=True)
--

45=========
->Original Input:
Multiple each value by `2` for all keys in a dictionary `my_dict`
->Original Target:
my_dict.update((x, y * 2) for x, y in list(my_dict.items()))
->Reconstructed Target:
""",""".join(l)
->Reconstructed Predication:
l('l')
->Raw Input:
summarize:Join elements of list l with a comma,
->Raw Target:
""",""".join(l)
--

46=========
->Original Input:
running bash script 'sleep.sh'
->Original Target:
subprocess.call('sleep.sh', shell=True)
->Reconstructed Target:
myList = ','.join(map(str, myList))
->Reconstructed Predication:
comma-separated string(myList)
->Raw Input:
summarize:make a comma-separated string from a list myList
->Raw Target:
myList = ','.join(map(str, myList))
--

47=========
->Original Input:
Join elements of list `l` with a comma `,`
->Original Target:
""",""".join(l)
->Reconstructed Target:
list(reversed(list(range(10))))
->Reconstructed Predication:
revers(1 to 10)
->Raw Input:
summarize:reverse the list that contains 1 to 10
->Raw Target:
list(reversed(list(range(10))))
--

48=========
->Original Input:
make a comma-separated string from a list `myList`
->Original Target:
myList = ','.join(map(str, myList))
->Reconstructed Target:
print('lamp, bag, mirror'.replace('bag,', ''))
->Reconstructed Predication:
'lamp,' is a substring.
->Raw Input:
summarize:remove substring 'bag,' from a string 'lamp, bag, mirror'
->Raw Target:
print('lamp, bag, mirror'.replace('bag,', ''))
--

49=========
->Original Input:
reverse the list that contains 1 to 10
->Original Target:
list(reversed(list(range(10))))
->Reconstructed Target:
""".""".join(s.split('.')[::-1])
->Reconstructed Predication:
'.'
->Raw Input:
summarize:Reverse the order of words, delimited by., in string s
->Raw Target:
""".""".join(s.split('.')[::-1])
--

50=========
->Original Input:
remove substring 'bag,' from a string 'lamp, bag, mirror'
->Original Target:
print('lamp, bag, mirror'.replace('bag,', ''))
->Reconstructed Target:
datetime.datetime.fromtimestamp(s).strftime('%Y-%m-%d %H:%M:%S.%f')
->Reconstructed Predication:
'%Y-%m-%d %H:%M:%S.%f'
->Raw Input:
summarize:convert epoch time represented as milliseconds s to string using format '%Y-%m-%d %H:%M:%S.%f'
->Raw Target:
datetime.datetime.fromtimestamp(s).strftime('%Y-%m-%d %H:%M:%S.%f')
--

51=========
->Original Input:
Reverse the order of words, delimited by `.`, in string `s`
->Original Target:
""".""".join(s.split('.')[::-1])
->Reconstructed Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807 / 1000.0))
->Reconstructed Predication:
epoch time:1236472051807.
->Raw Input:
summarize:parse milliseconds epoch time '1236472051807' to format '%Y-%m-%d %H:%M:%S'
->Raw Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807 / 1000.0))
--

52=========
->Original Input:
convert epoch time represented as milliseconds `s` to string using format '%Y-%m-%d %H:%M:%S.%f'
->Original Target:
datetime.datetime.fromtimestamp(s).strftime('%Y-%m-%d %H:%M:%S.%f')
->Reconstructed Target:
(datetime.datetime.now() - datetime.timedelta(days=7)).date()
->Reconstructed Predication:
.get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get_date().get
->Raw Input:
summarize:get the date 7 days before the current date
->Raw Target:
(datetime.datetime.now() - datetime.timedelta(days=7)).date()
--

53=========
->Original Input:
parse milliseconds epoch time '1236472051807' to format '%Y-%m-%d %H:%M:%S'
->Original Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807 / 1000.0))
->Reconstructed Target:
print(sum(row[column] for row in data))
->Reconstructed Predication:
.data('column')
->Raw Input:
summarize:sum elements at index column of each list in list data
->Raw Target:
print(sum(row[column] for row in data))
--

54=========
->Original Input:
get the date 7 days before the current date
->Original Target:
(datetime.datetime.now() - datetime.timedelta(days=7)).date()
->Reconstructed Target:
[sum(row[i] for row in array) for i in range(len(array[0]))]
->Reconstructed Predication:
.array.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.sum.
->Raw Input:
summarize:sum columns of a list array
->Raw Target:
[sum(row[i] for row in array) for i in range(len(array[0]))]
--

55=========
->Original Input:
sum elements at index `column` of each list in list `data`
->Original Target:
print(sum(row[column] for row in data))
->Reconstructed Target:
base64.b64encode(bytes('your string', 'utf-8'))
->Reconstructed Predication:
'your string'
->Raw Input:
summarize:encode binary string 'your string' to base64 code
->Raw Target:
base64.b64encode(bytes('your string', 'utf-8'))
--

56=========
->Original Input:
sum columns of a list `array`
->Original Target:
[sum(row[i] for row in array) for i in range(len(array[0]))]
->Reconstructed Target:
dict((k, [d[k] for d in dicts]) for k in dicts[0])
->Reconstructed Predication:
dictionaries dicts. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries. dictionaries
->Raw Input:
summarize:combine list of dictionaries dicts with the same keys in each list to a single dictionary
->Raw Target:
dict((k, [d[k] for d in dicts]) for k in dicts[0])
--

57=========
->Original Input:
encode binary string 'your string' to base64 code
->Original Target:
base64.b64encode(bytes('your string', 'utf-8'))
->Reconstructed Target:
k: [d[k] for d in dicts] for k in dicts[0]
->Reconstructed Predication:
k(k) = k(k)
->Raw Input:
summarize:Merge a nested dictionary dicts into a flat dictionary by concatenating nested values with the same key k
->Raw Target:
k: [d[k] for d in dicts] for k in dicts[0]
--

58=========
->Original Input:
combine list of dictionaries `dicts` with the same keys in each list to a single dictionary
->Original Target:
dict((k, [d[k] for d in dicts]) for k in dicts[0])
->Reconstructed Target:
[k for k, v in list(Counter(mylist).items()) if v > 1]
->Reconstructed Predication:
duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicates.identify.duplicate
->Raw Input:
summarize:identify duplicate values in list mylist
->Raw Target:
[k for k, v in list(Counter(mylist).items()) if v > 1]
--

59=========
->Original Input:
Merge a nested dictionary `dicts` into a flat dictionary by concatenating nested values with the same key `k`
->Original Target:
{k: [d[k] for d in dicts] for k in dicts[0]}
->Reconstructed Target:
sys.path.insert(1, os.path.join(os.path.dirname(__file__), 'apps'))
->Reconstructed Predication:
app_file__.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps.apps
->Raw Input:
summarize:Insert directory 'apps' into directory __file__
->Raw Target:
sys.path.insert(1, os.path.join(os.path.dirname(__file__), 'apps'))
--

60=========
->Original Input:
None
->Original Target:
request.args['myParam']
->Reconstructed Target:
sys.path.append(os.path.join(os.path.dirname(__file__),'subdir'))
->Reconstructed Predication:
python_subdir.modify_sys.path
->Raw Input:
summarize:modify sys.path for python module subdir
->Raw Target:
sys.path.append(os.path.join(os.path.dirname(__file__),'subdir'))
--

61=========
->Original Input:
identify duplicate values in list `mylist`
->Original Target:
[k for k, v in list(Counter(mylist).items()) if v > 1]
->Reconstructed Target:
db.execute("INSERT INTO present VALUES('test2',?, 10)", (None,))
->Reconstructed Predication:
'None' = 'None'
->Raw Input:
summarize:Insert a 'None' value into a SQLite3 table.
->Raw Target:
db.execute("INSERT INTO present VALUES('test2',?, 10)", (None,))
--

62=========
->Original Input:
Insert directory 'apps' into directory `__file__`
->Original Target:
sys.path.insert(1, os.path.join(os.path.dirname(__file__), 'apps'))
->Reconstructed Target:
[image for menuitem in list_of_menuitems for image in menuitem]
->Reconstructed Predication:
list_of_menuitems
->Raw Input:
summarize:flatten list list_of_menuitems
->Raw Target:
[image for menuitem in list_of_menuitems for image in menuitem]
--

63=========
->Original Input:
modify sys.path for python module `subdir`
->Original Target:
sys.path.append(os.path.join(os.path.dirname(__file__), 'subdir'))
->Reconstructed Target:
a.extend(b)
->Reconstructed Predication:
b(set(b)))
->Raw Input:
summarize:append elements of a set b to a list a
->Raw Target:
a.extend(b)
--

64=========
->Original Input:
Insert a 'None' value into a SQLite3 table.
->Original Target:
db.execute("INSERT INTO present VALUES('test2', ?, 10)", (None,))
->Reconstructed Target:
np.savetxt('c:datanp.txt', df.values, fmt='%d')
->Reconstructed Predication:
df.write(df.write(df.write(df.write)))
->Raw Input:
summarize:write the data of dataframe df into text file np.txt
->Raw Target:
np.savetxt('c:datanp.txt', df.values, fmt='%d')
--

65=========
->Original Input:
flatten list `list_of_menuitems`
->Original Target:
[image for menuitem in list_of_menuitems for image in menuitem]
->Reconstructed Target:
df.to_csv('c:datapandas.txt', header=None, index=None, sep=' ', mode='a')
->Reconstructed Predication:
df.write(c:datapandas.txt')
->Raw Input:
summarize:write content of DataFrame df into text file 'c:datapandas.txt'
->Raw Target:
df.to_csv('c:datapandas.txt', header=None, index=None, sep=' ', mode='a')
--

66=========
->Original Input:
append elements of a set `b` to a list `a`
->Original Target:
a.extend(b)
->Reconstructed Target:
print(x.rpartition('-')[0])
->Reconstructed Predication:
x(x))
->Raw Input:
summarize:Split a string x by last occurrence of character -
->Raw Target:
print(x.rpartition('-')[0])
--

67=========
->Original Input:
None
->Original Target:
a.extend(list(b))
->Reconstructed Target:
print(x.rsplit('-', 1)[0])
->Reconstructed Predication:
'-' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '' : '
->Raw Input:
summarize:get the last part of a string before the character '-'
->Raw Target:
print(x.rsplit('-', 1)[0])
--

68=========
->Original Input:
write the data of dataframe `df` into text file `np.txt`
->Original Target:
np.savetxt('c:\\data\\np.txt', df.values, fmt='%d')
->Reconstructed Target:
ftp.storlines('STOR'+ filename, open(filename, 'r'))
->Reconstructed Predication:
ftp.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.upload.
->Raw Input:
summarize:upload file using FTP
->Raw Target:
ftp.storlines('STOR'+ filename, open(filename, 'r'))
--

69=========
->Original Input:
write content of DataFrame `df` into text file 'c:\\data\\pandas.txt'
->Original Target:
df.to_csv('c:\\data\\pandas.txt', header=None, index=None, sep=' ', mode='a')
->Reconstructed Target:
browser.execute_script("document.getElementById('XYZ').value+='1'")
->Reconstructed Predication:
'XYZ' adds a new 'xyz' to the hidden web element.
->Raw Input:
summarize:add one to the hidden web element with id 'XYZ' with selenium python script
->Raw Target:
browser.execute_script("document.getElementById('XYZ').value+='1'")
--

70=========
->Original Input:
Split a string `x` by last occurrence of character `-`
->Original Target:
print(x.rpartition('-')[0])
->Reconstructed Target:
np.maximum([2, 3, 4], [1, 5, 2])
->Reconstructed Predication:
Array([2, 3, 4] and array[1, 5, 2])
->Raw Input:
summarize:create array containing the maximum value of respective elements of array [2, 3, 4] and array [1, 5, 2]
->Raw Target:
np.maximum([2, 3, 4], [1, 5, 2])
--

71=========
->Original Input:
get the last part of a string before the character '-'
->Original Target:
print(x.rsplit('-', 1)[0])
->Reconstructed Target:
print(l[3:] + l[:3])
->Reconstructed Predication:
l(l))
->Raw Input:
summarize:print a list l and move first 3 elements to the end of the list
->Raw Target:
print(l[3:] + l[:3])
--

72=========
->Original Input:
upload file using FTP
->Original Target:
ftp.storlines('STOR ' + filename, open(filename, 'r'))
->Reconstructed Target:
for fn in os.listdir('.'): if os.path.isfile(fn): pass
->Reconstructed Predication:
'.'
->Raw Input:
summarize:loop over files in directory '.'
->Raw Target:
for fn in os.listdir('.'): if os.path.isfile(fn): pass
--

73=========
->Original Input:
add one to the hidden web element with id 'XYZ' with selenium python script
->Original Target:
browser.execute_script("document.getElementById('XYZ').value+='1'")
->Reconstructed Target:
for (root, dirs, filenames) in os.walk(source): for f in filenames: pass
->Reconstructed Predication:
loop over files in directory source
->Raw Input:
summarize:loop over files in directory source
->Raw Target:
for (root, dirs, filenames) in os.walk(source): for f in filenames: pass
--

74=========
->Original Input:
create array containing the maximum value of respective elements of array `[2, 3, 4]` and array `[1, 5, 2]`
->Original Target:
np.maximum([2, 3, 4], [1, 5, 2])
->Reconstructed Target:
[int(1000 * random.random()) for i in range(10000)]
->Reconstructed Predication:
.add('')')
->Raw Input:
summarize:create a random list of integers
->Raw Target:
[int(1000 * random.random()) for i in range(10000)]
--

75=========
->Original Input:
print a list `l` and move first 3 elements to the end of the list
->Original Target:
print(l[3:] + l[:3])
->Reconstructed Target:
db.GqlQuery('SELECT * FROM Schedule WHERE station = $1', foo.key())
->Reconstructed Predication:
SELECT * FROM Schedule WHERE station = $1
->Raw Input:
summarize:Google App Engine execute GQL query 'SELECT * FROM Schedule WHERE station = $1' with parameter foo.key()
->Raw Target:
db.GqlQuery('SELECT * FROM Schedule WHERE station = $1', foo.key())
--

76=========
->Original Input:
loop over files in directory '.'
->Original Target:
for fn in os.listdir('.'):
    if os.path.isfile(fn):
        pass
->Reconstructed Target:
df.b.str.contains('f')
->Reconstructed Predication:
f('f') - f('f'))
->Raw Input:
summarize:filter rows in pandas starting with alphabet 'f' using regular expression.
->Raw Target:
df.b.str.contains('f')
--

77=========
->Original Input:
loop over files in directory `source`
->Original Target:
for (root, dirs, filenames) in os.walk(source):
    for f in filenames:
        pass
->Reconstructed Target:
print('n'.join('t'.join(str(col) for col in row) for row in tab))
->Reconstructed Predication:
.tab.print.print.tab.print.tab.print.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab.tab
->Raw Input:
summarize:print a 2 dimensional list tab as a table with delimiters
->Raw Target:
print('n'.join('t'.join(str(col) for col in row) for row in tab))
--

78=========
->Original Input:
create a random list of integers
->Original Target:
[int(1000 * random.random()) for i in range(10000)]
->Reconstructed Target:
df.set_index(list('BC')).drop(tuples, errors='ignore').reset_index()
->Reconstructed Predication:
df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.d
->Raw Input:
summarize:pandas: delete rows in dataframe df based on multiple columns values
->Raw Target:
df.set_index(list('BC')).drop(tuples, errors='ignore').reset_index()
--

79=========
->Original Input:
None
->Original Target:
datetime.datetime.now().strftime('%H:%M:%S.%f')
->Reconstructed Target:
"""(:d goals, $:d)""".format(self.goals, self.penalties)
->Reconstructed Predication:
.self.goals.self.penalties.self.goals.self.penalties.self.penalties.self.goals.self.penalties.self.penalties.self.self.penalties.self.self.goals.self.penalties.self.self.penalties.self.self.goals.self.penalties.self.self.penalties.self.self.goals.self.self.penalties.self
->Raw Input:
summarize:format the variables self.goals and self.penalties using string formatting
->Raw Target:
"""(:d goals, $:d)""".format(self.goals, self.penalties)
--

80=========
->Original Input:
Google App Engine execute GQL query 'SELECT * FROM Schedule WHERE station = $1' with parameter `foo.key()`
->Original Target:
db.GqlQuery('SELECT * FROM Schedule WHERE station = $1', foo.key())
->Reconstructed Target:
"""( goals, $)""".format(self.goals, self.penalties)
->Reconstructed Predication:
'( goals, $)'
->Raw Input:
summarize:format string "( goals, $)" with variables goals and penalties
->Raw Target:
"""( goals, $)""".format(self.goals, self.penalties)
--

81=========
->Original Input:
filter rows in pandas starting with alphabet 'f' using regular expression.
->Original Target:
df.b.str.contains('^f')
->Reconstructed Target:
"""(0.goals goals, $0.penalties)""".format(self)
->Reconstructed Predication:
'(0.goals goals, $0.penalties)'
->Raw Input:
summarize:format string "(0.goals goals, $0.penalties)"
->Raw Target:
"""(0.goals goals, $0.penalties)""".format(self)
--

82=========
->Original Input:
print a 2 dimensional list `tab` as a table with delimiters
->Original Target:
print('\n'.join('\t'.join(str(col) for col in row) for row in tab))
->Reconstructed Target:
[int(''.join(str(d) for d in x)) for x in L]
->Reconstructed Predication:
l(lists L) : l(lists L) : l(lists L) : l(lists L) : l(lists L) : l(lists L) : l(lists L) : l(lists L) : l(lists L) : l(lists
->Raw Input:
summarize:convert list of lists L to list of integers
->Raw Target:
[int(''.join(str(d) for d in x)) for x in L]
--

83=========
->Original Input:
pandas: delete rows in dataframe `df` based on multiple columns values
->Original Target:
df.set_index(list('BC')).drop(tuples, errors='ignore').reset_index()
->Reconstructed Target:
[''.join(str(d) for d in x) for x in L]
->Reconstructed Predication:
list L: 'l' = 'l'
->Raw Input:
summarize:combine elements of each list in list L into digits of a single integer
->Raw Target:
[''.join(str(d) for d in x) for x in L]
--

84=========
->Original Input:
format the variables `self.goals` and `self.penalties` using string formatting
->Original Target:
"""({:d} goals, ${:d})""".format(self.goals, self.penalties)
->Reconstructed Target:
L = [int(''.join([str(y) for y in x])) for x in L]
->Reconstructed Predication:
l(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::L(lists)::
->Raw Input:
summarize:convert a list of lists L to list of integers
->Raw Target:
L = [int(''.join([str(y) for y in x])) for x in L]
--

85=========
->Original Input:
format string "({} goals, ${})" with variables `goals` and `penalties`
->Original Target:
"""({} goals, ${})""".format(self.goals, self.penalties)
->Reconstructed Target:
myfile.write('n'.join(lines))
->Reconstructed Predication:
'n' :write('n'))
->Raw Input:
summarize:write the elements of list lines concatenated by special character 'n' to file myfile
->Raw Target:
myfile.write('n'.join(lines))
--

86=========
->Original Input:
format string "({0.goals} goals, ${0.penalties})"
->Original Target:
"""({0.goals} goals, ${0.penalties})""".format(self)
->Reconstructed Target:
[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if 'X' not in x and 'N' not in x]
->Reconstructed Predication:
removing an element from a list based on a predicate 'X' or 'N'
->Raw Input:
summarize:removing an element from a list based on a predicate 'X' or 'N'
->Raw Target:
[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if 'X' not in x and 'N' not in x]
--

87=========
->Original Input:
convert list of lists `L` to list of integers
->Original Target:
[int(''.join(str(d) for d in x)) for x in L]
->Reconstructed Target:
text = re.sub('b(w+)( 1b)+', '1', text)
->Reconstructed Predication:
.remove(text)
->Raw Input:
summarize:Remove duplicate words from a string text using regex
->Raw Target:
text = re.sub('b(w+)( 1b)+', '1', text)
--

88=========
->Original Input:
combine elements of each list in list `L` into digits of a single integer
->Original Target:
[''.join(str(d) for d in x) for x in L]
->Reconstructed Target:
df.astype(bool).sum(axis=1)
->Reconstructed Predication:
.count(non zero) in each column in pandas data frame
->Raw Input:
summarize:count non zero values in each column in pandas data frame
->Raw Target:
df.astype(bool).sum(axis=1)
--

89=========
->Original Input:
convert a list of lists `L` to list of integers
->Original Target:
L = [int(''.join([str(y) for y in x])) for x in L]
->Reconstructed Target:
re.search('(?!Distillr)AcroTray.exe', 'C:SomeDirAcroTray.exe')
->Reconstructed Predication:
'(?!Distillr)AcroTray.exe'
->Raw Input:
summarize:search for string that matches regular expression pattern '(?!Distillr)AcroTray.exe' in string 'C:SomeDirAcroTray.exe'
->Raw Target:
re.search('(?!Distillr)AcroTray.exe', 'C:SomeDirAcroTray.exe')
--

90=========
->Original Input:
write the elements of list `lines` concatenated by special character '\n' to file `myfile`
->Original Target:
myfile.write('\n'.join(lines))
->Reconstructed Target:
"""QH QD JC KD JS""".split()
->Reconstructed Predication:
'QH QD JC KD JS'
->Raw Input:
summarize:split string 'QH QD JC KD JS' into a list on white spaces
->Raw Target:
"""QH QD JC KD JS""".split()
--

91=========
->Original Input:
removing an element from a list based on a predicate 'X' or 'N'
->Original Target:
[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if 'X' not in x and 'N' not in x]
->Reconstructed Target:
print(re.search('>.*', line).group(0))
->Reconstructed Predication:
regex pattern '>.*' in xml string line
->Raw Input:
summarize:search for occurrences of regex pattern '>.*' in xml string line
->Raw Target:
print(re.search('>.*', line).group(0))
--

92=========
->Original Input:
Remove duplicate words from a string `text` using regex
->Original Target:
text = re.sub('\\b(\\w+)( \\1\\b)+', '\\1', text)
->Reconstructed Target:
open(filename, 'w').close()
->Reconstructed Predication:
erase all the contents of a file filename
->Raw Input:
summarize:erase all the contents of a file filename
->Raw Target:
open(filename, 'w').close()
--

93=========
->Original Input:
count non zero values in each column in pandas data frame
->Original Target:
df.astype(bool).sum(axis=1)
->Reconstructed Target:
datetime.datetime.strptime(string_date, '%Y-%m-%d %H:%M:%S.%f')
->Reconstructed Predication:
%Y-%m-%d %H:%M:%S.%f'
->Raw Input:
summarize:convert a string into datetime using the format '%Y-%m-%d %H:%M:%S.%f'
->Raw Target:
datetime.datetime.strptime(string_date, '%Y-%m-%d %H:%M:%S.%f')
--

94=========
->Original Input:
search for string that matches regular expression pattern '(?<!Distillr)\\\\AcroTray\\.exe' in string 'C:\\SomeDir\\AcroTray.exe'
->Original Target:
re.search('(?<!Distillr)\\\\AcroTray\\.exe', 'C:\\SomeDir\\AcroTray.exe')
->Reconstructed Target:
[index for index, item in enumerate(thelist) if item[0] == '332']
->Reconstructed Predication:
find the index of a list with the first element equal to '332' within the list of lists thelist
->Raw Input:
summarize:find the index of a list with the first element equal to '332' within the list of lists thelist
->Raw Target:
[index for index, item in enumerate(thelist) if item[0] == '332']
--

95=========
->Original Input:
split string 'QH QD JC KD JS' into a list on white spaces
->Original Target:
"""QH QD JC KD JS""".split()
->Reconstructed Target:
re.sub('[sa-zA-Z0-9]', '', text).lower().strip()
->Reconstructed Predication:
space.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text.text
->Raw Input:
summarize:lower a string text and remove non-alphanumeric characters aside from space
->Raw Target:
re.sub('[sa-zA-Z0-9]', '', text).lower().strip()
--

96=========
->Original Input:
search for occurrences of regex pattern '>.*<' in xml string `line`
->Original Target:
print(re.search('>.*<', line).group(0))
->Reconstructed Target:
re.sub('(?!s)[W_]', '', text).lower().strip()
->Reconstructed Predication:
.text.select(text))
->Raw Input:
summarize:remove all non-alphanumeric characters except space from a string text and lower it
->Raw Target:
re.sub('(?!s)[W_]', '', text).lower().strip()
--

97=========
->Original Input:
erase all the contents of a file `filename`
->Original Target:
open(filename, 'w').close()
->Reconstructed Target:
plt.plot(x, y, label='Hu2082O')
->Reconstructed Predication:
'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'
->Raw Input:
summarize:subscript text 'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
->Raw Target:
plt.plot(x, y, label='Hu2082O')
--

98=========
->Original Input:
convert a string into datetime using the format '%Y-%m-%d %H:%M:%S.%f'
->Original Target:
datetime.datetime.strptime(string_date, '%Y-%m-%d %H:%M:%S.%f')
->Reconstructed Target:
plt.plot(x, y, label='$H_2O$')
->Reconstructed Predication:
'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'
->Raw Input:
summarize:subscript text 'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
->Raw Target:
plt.plot(x, y, label='$H_2O$')
--

99=========
->Original Input:
find the index of a list with the first element equal to '332' within the list of lists `thelist`
->Original Target:
[index for index, item in enumerate(thelist) if item[0] == '332']
->Reconstructed Target:
[x for x in mylist if len(x) == 3]
->Reconstructed Predication:
sublists length = 3
->Raw Input:
summarize:loop over a list mylist if sublists length equals 3
->Raw Target:
[x for x in mylist if len(x) == 3]
--

100=========
->Original Input:
lower a string `text` and remove non-alphanumeric characters aside from space
->Original Target:
re.sub('[^\\sa-zA-Z0-9]', '', text).lower().strip()
->Reconstructed Target:
lst = [Object() for _ in range(100)]
->Reconstructed Predication:
Object(lst)::initialize(lst))
->Raw Input:
summarize:initialize a list lst of 100 objects Object()
->Raw Target:
lst = [Object() for _ in range(100)]
--

101=========
->Original Input:
remove all non-alphanumeric characters except space from a string `text` and lower it
->Original Target:
re.sub('(?!\\s)[\\W_]', '', text).lower().strip()
->Reconstructed Target:
lst = [Object() for i in range(100)]
->Reconstructed Predication:
lst('Object')
->Raw Input:
summarize:create list lst containing 100 instances of object Object
->Raw Target:
lst = [Object() for i in range(100)]
--

102=========
->Original Input:
subscript text 'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
->Original Target:
plt.plot(x, y, label='H\u2082O')
->Reconstructed Target:
self.driver.find_element_by_css_selector('.someclass a').get_attribute('href')
->Reconstructed Predication:
child tag withhref attribute whose parent has css someclass
->Raw Input:
summarize:get the content of child tag withhref attribute whose parent has css someclass
->Raw Target:
self.driver.find_element_by_css_selector('.someclass a').get_attribute('href')
--

103=========
->Original Input:
subscript text 'H20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
->Original Target:
plt.plot(x, y, label='$H_2O$')
->Reconstructed Target:
df1.merge(df2, on='Date_Time')
->Reconstructed Predication:
'date_time' = 'df1'
->Raw Input:
summarize:joining data from dataframe df1 with data from dataframe df2 based on matching values of column 'Date_Time' in both dataframes
->Raw Target:
df1.merge(df2, on='Date_Time')
--

104=========
->Original Input:
loop over a list `mylist` if sublists length equals 3
->Original Target:
[x for x in mylist if len(x) == 3]
->Reconstructed Target:
'first string is: %s, second one is: %s' % (str1, 'geo.tif')
->Reconstructed Predication:
%s(%s))
->Raw Input:
summarize:use %s operator to print variable values str1 inside a string
->Raw Target:
'first string is: %s, second one is: %s' % (str1, 'geo.tif')
--

105=========
->Original Input:
initialize a list `lst` of 100 objects Object()
->Original Target:
lst = [Object() for _ in range(100)]
->Reconstructed Target:
if (not os.path.exists(directory)): os.makedirs(directory)
->Reconstructed Predication:
.create(directory directory )
->Raw Input:
summarize:check if directory directory  exists and create it if necessary
->Raw Target:
if (not os.path.exists(directory)): os.makedirs(directory)
--

106=========
->Original Input:
create list `lst` containing 100 instances of object `Object`
->Original Target:
lst = [Object() for i in range(100)]
->Reconstructed Target:
try: os.makedirs(path) except OSError: if (not os.path.isdir(path)): raise
->Reconstructed Predication:
.path.create(path.path)
->Raw Input:
summarize:check if a directory path exists and create it if necessary
->Raw Target:
try: os.makedirs(path) except OSError: if (not os.path.isdir(path)): raise
--

107=========
->Original Input:
get the content of child tag with`href` attribute whose parent has css `someclass`
->Original Target:
self.driver.find_element_by_css_selector('.someclass a').get_attribute('href')
->Reconstructed Target:
distutils.dir_util.mkpath(path)
->Reconstructed Predication:
.path.create(path.path)
->Raw Input:
summarize:check if a directory path exists and create it if necessary
->Raw Target:
distutils.dir_util.mkpath(path)
--

108=========
->Original Input:
joining data from dataframe `df1` with data from dataframe `df2` based on matching values of column 'Date_Time' in both dataframes
->Original Target:
df1.merge(df2, on='Date_Time')
->Reconstructed Target:
try: os.makedirs(path) except OSError as exception: if (exception.errno!= errno.EEXIST): raise
->Reconstructed Predication:
.path.create(path.path)
->Raw Input:
summarize:check if a directory path exists and create it if necessary
->Raw Target:
try: os.makedirs(path) except OSError as exception: if (exception.errno!= errno.EEXIST): raise
--

109=========
->Original Input:
use `%s` operator to print variable values `str1` inside a string
->Original Target:
'first string is: %s, second one is: %s' % (str1, 'geo.tif')
->Reconstructed Target:
re.sub('bH3b', 'H1', text)
->Reconstructed Predication:
'text':Replace a separate word 'H3' by 'H1'
->Raw Input:
summarize:Replace a separate word 'H3' by 'H1' in a string 'text'
->Raw Target:
re.sub('bH3b', 'H1', text)
--

110=========
->Original Input:
None
->Original Target:
[x.strip() for x in '2.MATCHES $$TEXT$$ STRING'.split('$$TEXT$$')]
->Reconstructed Target:
re.sub('D', '', 'aas30dsa20')
->Reconstructed Predication:
'aas30dsa20'
->Raw Input:
summarize:substitute ASCII letters in string 'aas30dsa20' with empty string ''
->Raw Target:
re.sub('D', '', 'aas30dsa20')
--

111=========
->Original Input:
check if directory `directory ` exists and create it if necessary
->Original Target:
if (not os.path.exists(directory)):
    os.makedirs(directory)
->Reconstructed Target:
"""""".join([x for x in 'aas30dsa20' if x.isdigit()])
->Reconstructed Predication:
aas30dsa20.get_digits()
->Raw Input:
summarize:get digits only from a string aas30dsa20 using lambda function
->Raw Target:
"""""".join([x for x in 'aas30dsa20' if x.isdigit()])
--

112=========
->Original Input:
check if a directory `path` exists and create it if necessary
->Original Target:
try:
    os.makedirs(path)
except OSError:
    if (not os.path.isdir(path)):
        raise
->Reconstructed Target:
print(soup.find('name').string)
->Reconstructed Predication:
'name' in beautifulsoup.name'
->Raw Input:
summarize:access a tag called "name" in beautifulsoup soup
->Raw Target:
print(soup.find('name').string)
--

113=========
->Original Input:
check if a directory `path` exists and create it if necessary
->Original Target:
distutils.dir_util.mkpath(path)
->Reconstructed Target:
records = dict((record['_id'], record) for record in cursor)
->Reconstructed Predication:
'cursor'
->Raw Input:
summarize:get a dictionary records of key-value pairs in PyMongo cursor cursor
->Raw Target:
records = dict((record['_id'], record) for record in cursor)
--

114=========
->Original Input:
check if a directory `path` exists and create it if necessary
->Original Target:
try:
    os.makedirs(path)
except OSError as exception:
    if (exception.errno != errno.EEXIST):
        raise
->Reconstructed Target:
np.concatenate((A, B))
->Reconstructed Predication:
.add('')
->Raw Input:
summarize:Create new matrix object by concatenating data from matrix A and matrix B
->Raw Target:
np.concatenate((A, B))
--

115=========
->Original Input:
Replace a separate word 'H3' by 'H1' in a string 'text'
->Original Target:
re.sub('\\bH3\\b', 'H1', text)
->Reconstructed Target:
np.vstack((A, B))
->Reconstructed Predication:
..concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.b.concat_a.
->Raw Input:
summarize:concat two matrices A and B in numpy
->Raw Target:
np.vstack((A, B))
--

116=========
->Original Input:
substitute ASCII letters in string 'aas30dsa20' with empty string ''
->Original Target:
re.sub('\\D', '', 'aas30dsa20')
->Reconstructed Target:
os.stat(filepath).st_size
->Reconstructed Predication:
..gets the characters count in a file..
->Raw Input:
summarize:Get the characters count in a file filepath
->Raw Target:
os.stat(filepath).st_size
--

117=========
->Original Input:
get digits only from a string `aas30dsa20` using lambda function
->Original Target:
"""""".join([x for x in 'aas30dsa20' if x.isdigit()])
->Reconstructed Target:
l.count('a')
->Reconstructed Predication:
occurrence(a) = 0.
->Raw Input:
summarize:count the occurrences of item "a" in list l
->Raw Target:
l.count('a')
--

118=========
->Original Input:
access a tag called "name" in beautifulsoup `soup`
->Original Target:
print(soup.find('name').string)
->Reconstructed Target:
Counter(l)
->Reconstructed Predication:
list l(l)
->Raw Input:
summarize:count the occurrences of items in list l
->Raw Target:
Counter(l)
--

119=========
->Original Input:
get a dictionary `records` of key-value pairs in PyMongo cursor `cursor`
->Original Target:
records = dict((record['_id'], record) for record in cursor)
->Reconstructed Target:
[[x, l.count(x)] for x in set(l)]
->Reconstructed Predication:
list l(l)
->Raw Input:
summarize:count the occurrences of items in list l
->Raw Target:
[[x, l.count(x)] for x in set(l)]
--

120=========
->Original Input:
Create new matrix object  by concatenating data from matrix A and matrix B
->Original Target:
np.concatenate((A, B))
->Reconstructed Target:
dict(((x, l.count(x)) for x in set(l)))
->Reconstructed Predication:
list l(l)
->Raw Input:
summarize:count the occurrences of items in list l
->Raw Target:
dict(((x, l.count(x)) for x in set(l)))
--

121=========
->Original Input:
concat two matrices `A` and `B` in numpy
->Original Target:
np.vstack((A, B))
->Reconstructed Target:
l.count('b')
->Reconstructed Predication:
occurrence(b) in list l
->Raw Input:
summarize:count the occurrences of item "b" in list l
->Raw Target:
l.count('b')
--

122=========
->Original Input:
Get the characters count in a file `filepath`
->Original Target:
os.stat(filepath).st_size
->Reconstructed Target:
shutil.copy(srcfile, dstdir)
->Reconstructed Predication:
copy file srcfile to directory dstdir
->Raw Input:
summarize:copy file srcfile to directory dstdir
->Raw Target:
shutil.copy(srcfile, dstdir)
--

123=========
->Original Input:
count the occurrences of item "a" in list `l`
->Original Target:
l.count('a')
->Reconstructed Target:
max(k for k, v in x.items() if v!= 0)
->Reconstructed Predication:
x = x.find('x')
->Raw Input:
summarize:find the key associated with the largest value in dictionary x whilst key is non-zero value
->Raw Target:
max(k for k, v in x.items() if v!= 0)
--

124=========
->Original Input:
count the occurrences of items in list `l`
->Original Target:
Counter(l)
->Reconstructed Target:
(k for k, v in x.items() if v!= 0)
->Reconstructed Predication:
x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. x = 0. 
->Raw Input:
summarize:get the largest key whose not associated with value of 0 in dictionary x
->Raw Target:
(k for k, v in x.items() if v!= 0)
--

125=========
->Original Input:
count the occurrences of items in list `l`
->Original Target:
[[x, l.count(x)] for x in set(l)]
->Reconstructed Target:
max(k for k, v in x.items() if v!= 0)
->Reconstructed Predication:
x = x.gets the largest key in a dictionary.gets the largest key in a dictionary.gets the largest key in a dictionary.gets the largest key in a dictionary.gets the largest key in a dictionary.gets the largest key in a dictionary.gets the largest key in a dictionary.gets the largest key in a dictionary.gets the largest key in a dictionary.gets the largest key in a dictionary.gets the largest key in 
->Raw Input:
summarize:get the largest key in a dictionary x with non-zero value
->Raw Target:
max(k for k, v in x.items() if v!= 0)
--

126=========
->Original Input:
count the occurrences of items in list `l`
->Original Target:
dict(((x, l.count(x)) for x in set(l)))
->Reconstructed Target:
file.seek(0)
->Reconstructed Predication:
.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.ps.
->Raw Input:
summarize:Put the curser at beginning of the file
->Raw Target:
file.seek(0)
--

127=========
->Original Input:
count the occurrences of item "b" in list `l`
->Original Target:
l.count('b')
->Reconstructed Target:
df['c'] = np.where(df['a'].isnull, df['b'], df['a'])
->Reconstructed Predication:
df.combines values from column 'b' and column 'a' into c of datafram df
->Raw Input:
summarize:combine values from column 'b' and column 'a' of dataframe df into column 'c' of datafram df
->Raw Target:
df['c'] = np.where(df['a'].isnull, df['b'], df['a'])
--

128=========
->Original Input:
copy file `srcfile` to directory `dstdir`
->Original Target:
shutil.copy(srcfile, dstdir)
->Reconstructed Target:
del d['ele']
->Reconstructed Predication:
ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.ele.d.
->Raw Input:
summarize:remove key 'ele' from dictionary d
->Raw Target:
del d['ele']
--

129=========
->Original Input:
find the key associated with the largest value in dictionary `x` whilst key is non-zero value
->Original Target:
max(k for k, v in x.items() if v != 0)
->Reconstructed Target:
MyModel.objects.update(timestamp=F('timestamp') + timedelta(days=36524.25))
->Reconstructed Predication:
.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.datetime.
->Raw Input:
summarize:Update datetime field in MyModel to be the existing timestamp plus 100 years
->Raw Target:
MyModel.objects.update(timestamp=F('timestamp') + timedelta(days=36524.25))
--

130=========
->Original Input:
get the largest key whose not associated with value of 0 in dictionary `x`
->Original Target:
(k for k, v in x.items() if v != 0)
->Reconstructed Target:
['it'] + ['was'] + ['annoying']
->Reconstructed Predication:
list.merge('it'],'was'],'annoying']
->Raw Input:
summarize:merge list ['it'] and list ['was'] and list ['annoying'] into one list
->Raw Target:
['it'] + ['was'] + ['annoying']
--

131=========
->Original Input:
get the largest key in a dictionary `x` with non-zero value
->Original Target:
max(k for k, v in x.items() if v != 0)
->Reconstructed Target:
str(int(x) + 1).zfill(len(x))
->Reconstructed Predication:
x = x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x
->Raw Input:
summarize:increment a value with leading zeroes in a number x
->Raw Target:
str(int(x) + 1).zfill(len(x))
--

132=========
->Original Input:
Put the curser at beginning of the file
->Original Target:
file.seek(0)
->Reconstructed Target:
all(df.index[:-1] = df.index[1:])
->Reconstructed Predication:
df_index.sort()
->Raw Input:
summarize:check if a pandas dataframe df's index is sorted
->Raw Target:
all(df.index[:-1] = df.index[1:])
--

133=========
->Original Input:
combine values from column 'b' and column 'a' of dataframe `df`  into column 'c' of datafram `df`
->Original Target:
df['c'] = np.where(df['a'].isnull, df['b'], df['a'])
->Reconstructed Target:
list(t)
->Reconstructed Predication:
tuple(t): list(t)
->Raw Input:
summarize:Convert tuple t to list
->Raw Target:
list(t)
--

134=========
->Original Input:
remove key 'ele' from dictionary `d`
->Original Target:
del d['ele']
->Reconstructed Target:
tuple(l)
->Reconstructed Predication:
tuple(t)
->Raw Input:
summarize:Convert list t to tuple
->Raw Target:
tuple(l)
--

135=========
->Original Input:
Update datetime field in `MyModel` to be the existing `timestamp` plus 100 years
->Original Target:
MyModel.objects.update(timestamp=F('timestamp') + timedelta(days=36524.25))
->Reconstructed Target:
level1 = map(list, level1)
->Reconstructed Predication:
tuple(level1)
->Raw Input:
summarize:Convert tuple level1 to list
->Raw Target:
level1 = map(list, level1)
--

136=========
->Original Input:
merge list `['it']` and list `['was']` and list `['annoying']` into one list
->Original Target:
['it'] + ['was'] + ['annoying']
->Reconstructed Target:
pprint.pprint(dataobject, logFile)
->Reconstructed Predication:
pprint_dataobject.logFile.send('dataobject')
->Raw Input:
summarize:send the output of pprint object dataobject to file logFile
->Raw Target:
pprint.pprint(dataobject, logFile)
--

137=========
->Original Input:
increment a value with leading zeroes in a number `x`
->Original Target:
str(int(x) + 1).zfill(len(x))
->Reconstructed Target:
df.loc[df['BoolCol']]
->Reconstructed Predication:
'BoolCol'
->Raw Input:
summarize:get index of rows in column 'BoolCol'
->Raw Target:
df.loc[df['BoolCol']]
--

138=========
->Original Input:
check if a pandas dataframe `df`'s index is sorted
->Original Target:
all(df.index[:-1] <= df.index[1:])
->Reconstructed Target:
df.iloc[np.flatnonzero(df['BoolCol'])]
->Reconstructed Predication:
'BoolCol' = True.
->Raw Input:
summarize:Create a list containing the indexes of rows where the value of column 'BoolCol' in dataframe df are equal to True
->Raw Target:
df.iloc[np.flatnonzero(df['BoolCol'])]
--

139=========
->Original Input:
Convert tuple `t` to list
->Original Target:
list(t)
->Reconstructed Target:
df[df['BoolCol'] == True].index.tolist()
->Reconstructed Predication:
'BoolCol' = True
->Raw Input:
summarize:get list of indexes of rows where column 'BoolCol' values match True
->Raw Target:
df[df['BoolCol'] == True].index.tolist()
--

140=========
->Original Input:
Convert list `t` to tuple
->Original Target:
tuple(l)
->Reconstructed Target:
df[df['BoolCol']].index.tolist()
->Reconstructed Predication:
'BoolCol' matches value True
->Raw Input:
summarize:get index of rows in dataframe df which column 'BoolCol' matches value True
->Raw Target:
df[df['BoolCol']].index.tolist()
--

141=========
->Original Input:
Convert tuple `level1` to list
->Original Target:
level1 = map(list, level1)
->Reconstructed Target:
os.chdir(owd)
->Reconstructed Predication:
owd.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.sys.s
->Raw Input:
summarize:change working directory to the directory owd
->Raw Target:
os.chdir(owd)
--

142=========
->Original Input:
send the output of pprint object `dataobject` to file `logFile`
->Original Target:
pprint.pprint(dataobject, logFile)
->Reconstructed Target:
c.execute("INSERT INTO test VALUES (?, 'bar')", (testfield,))
->Reconstructed Predication:
db.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.testfield.test
->Raw Input:
summarize:insert data from a string testfield to sqlite db c
->Raw Target:
c.execute("INSERT INTO test VALUES (?, 'bar')", (testfield,))
--

143=========
->Original Input:
get index of rows in column 'BoolCol'
->Original Target:
df.loc[df['BoolCol']]
->Reconstructed Target:
"""x89n""".decode('string_escape')
->Reconstructed Predication:
x89.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.decode.de
->Raw Input:
summarize:decode string "x89n" into a normal string
->Raw Target:
"""x89n""".decode('string_escape')
--

144=========
->Original Input:
Create a list containing the indexes of rows where the value of column 'BoolCol' in dataframe `df` are equal to True
->Original Target:
df.iloc[np.flatnonzero(df['BoolCol'])]
->Reconstructed Target:
raw_string.decode('string_escape')
->Reconstructed Predication:
'raw_string'
->Raw Input:
summarize:convert a raw string raw_string into a normal string
->Raw Target:
raw_string.decode('string_escape')
--

145=========
->Original Input:
get list of indexes of rows where column 'BoolCol' values match True
->Original Target:
df[df['BoolCol'] == True].index.tolist()
->Reconstructed Target:
raw_byte_string.decode('unicode_escape')
->Reconstructed Predication:
'raw_byte_string'
->Raw Input:
summarize:convert a raw string raw_byte_string into a normal string
->Raw Target:
raw_byte_string.decode('unicode_escape')
--

146=========
->Original Input:
get index of rows in dataframe `df` which column 'BoolCol' matches value True
->Original Target:
df[df['BoolCol']].index.tolist()
->Reconstructed Target:
[m.group(0) for m in re.finditer('(d)1*', s)]
->Reconstructed Predication:
split(s) with into all strings of repeated characters
->Raw Input:
summarize:split a string s with into all strings of repeated characters
->Raw Target:
[m.group(0) for m in re.finditer('(d)1*', s)]
--

147=========
->Original Input:
change working directory to the directory `owd`
->Original Target:
os.chdir(owd)
->Reconstructed Target:
plt.scatter(np.random.randn(100), np.random.randn(100), facecolors='none')
->Reconstructed Predication:
np.random.randn(100))
->Raw Input:
summarize:scatter a plot with x, y position of np.random.randn(100) and face color equal to none
->Raw Target:
plt.scatter(np.random.randn(100), np.random.randn(100), facecolors='none')
--

148=========
->Original Input:
insert data from a string `testfield` to sqlite db `c`
->Original Target:
c.execute("INSERT INTO test VALUES (?, 'bar')", (testfield,))
->Reconstructed Target:
plt.plot(np.random.randn(100), np.random.randn(100), 'o', mfc='none')
->Reconstructed Predication:
do a scatter plot with empty circles
->Raw Input:
summarize:do a scatter plot with empty circles
->Raw Target:
plt.plot(np.random.randn(100), np.random.randn(100), 'o', mfc='none')
--

149=========
->Original Input:
decode string "\\x89\\n" into a normal string
->Original Target:
"""\\x89\\n""".decode('string_escape')
->Reconstructed Target:
soup.find('div', id='main-content').decompose()
->Reconstructed Predication:
div(main-content)
->Raw Input:
summarize:remove a div with a id main-content using beautifulsoup
->Raw Target:
soup.find('div', id='main-content').decompose()
--

150=========
->Original Input:
convert a raw string `raw_string` into a normal string
->Original Target:
raw_string.decode('string_escape')
->Reconstructed Target:
df[df['ids'].str.contains('ball')]
->Reconstructed Predication:
ids.ball.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.se
->Raw Input:
summarize:filter rows containing key word ball in column ids
->Raw Target:
df[df['ids'].str.contains('ball')]
--

151=========
->Original Input:
convert a raw string `raw_byte_string` into a normal string
->Original Target:
raw_byte_string.decode('unicode_escape')
->Reconstructed Target:
df.reset_index(level=0, inplace=True)
->Reconstructed Predication:
index at level 0 into a column in dataframe df.
->Raw Input:
summarize:convert index at level 0 into a column in dataframe df
->Raw Target:
df.reset_index(level=0, inplace=True)
--

152=========
->Original Input:
split a string `s` with into all strings of repeated characters
->Original Target:
[m.group(0) for m in re.finditer('(\\d)\\1*', s)]
->Reconstructed Target:
df['index1'] = df.index
->Reconstructed Predication:
index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1_index1
->Raw Input:
summarize:Add indexes in a data frame df to a column index1
->Raw Target:
df['index1'] = df.index
--

153=========
->Original Input:
scatter a plot with x, y position of `np.random.randn(100)` and face color equal to none
->Original Target:
plt.scatter(np.random.randn(100), np.random.randn(100), facecolors='none')
->Reconstructed Target:
df.reset_index(level=['tick', 'obs'])
->Reconstructed Predication:
.converts pandas index in a dataframe to columns.
->Raw Input:
summarize:convert pandas index in a dataframe to columns
->Raw Target:
df.reset_index(level=['tick', 'obs'])
--

154=========
->Original Input:
do a scatter plot with empty circles
->Original Target:
plt.plot(np.random.randn(100), np.random.randn(100), 'o', mfc='none')
->Reconstructed Target:
[x[::-1] for x in b]
->Reconstructed Predication:
'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' - 'b' 
->Raw Input:
summarize:Get reverse of list items from list 'b' using extended slicing
->Raw Target:
[x[::-1] for x in b]
--

155=========
->Original Input:
remove a div with a id `main-content` using beautifulsoup
->Original Target:
soup.find('div', id='main-content').decompose()
->Reconstructed Target:
np.array([zip(x, y) for x, y in zip(a, b)])
->Reconstructed Predication:
..((a)))
->Raw Input:
summarize:join each element in array a with element at the same index in array b as a tuple
->Raw Target:
np.array([zip(x, y) for x, y in zip(a, b)])
--

156=========
->Original Input:
filter rows containing key word `ball` in column `ids`
->Original Target:
df[df['ids'].str.contains('ball')]
->Reconstructed Target:
np.array(zip(a.ravel(), b.ravel()), dtype='i4,i4').reshape(a.shape)
->Reconstructed Predication:
a.zip and b.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip.zip
->Raw Input:
summarize:zip two 2-d arrays a and b
->Raw Target:
np.array(zip(a.ravel(), b.ravel()), dtype='i4,i4').reshape(a.shape)
--

157=========
->Original Input:
convert index at level 0 into a column in dataframe `df`
->Original Target:
df.reset_index(level=0, inplace=True)
->Reconstructed Target:
""",""".join([str(i) for i in list_of_ints])
->Reconstructed Predication:
list_of_ints.comma.list_of_ints.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.comma.com
->Raw Input:
summarize:convert list list_of_ints into a comma separated string
->Raw Target:
""",""".join([str(i) for i in list_of_ints])
--

158=========
->Original Input:
Add indexes in a data frame `df` to a column `index1`
->Original Target:
df['index1'] = df.index
->Reconstructed Target:
requests.post(url, data=DATA, headers=HEADERS_DICT, auth=(username, password))
->Reconstructed Predication:
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
->Raw Input:
summarize:Send a post request with raw data DATA and basic authentication with username and password
->Raw Target:
requests.post(url, data=DATA, headers=HEADERS_DICT, auth=(username, password))
--

159=========
->Original Input:
convert pandas index in a dataframe to columns
->Original Target:
df.reset_index(level=['tick', 'obs'])
->Reconstructed Target:
'abcddef'.rfind('')
->Reconstructed Predication:
''(''('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')('')(''
->Raw Input:
summarize:Find last occurrence of character '' in string "abcddef"
->Raw Target:
'abcddef'.rfind('')
--

160=========
->Original Input:
Get reverse of list items from list 'b' using extended slicing
->Original Target:
[x[::-1] for x in b]
->Reconstructed Target:
print([item for item in [1, 2, 3]])
->Reconstructed Predication:
.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate_ove_list.iterate
->Raw Input:
summarize:Iterate ove list [1, 2, 3] using list comprehension
->Raw Target:
print([item for item in [1, 2, 3]])
--

161=========
->Original Input:
join each element in array `a` with element at the same index in array `b` as a tuple
->Original Target:
np.array([zip(x, y) for x, y in zip(a, b)])
->Reconstructed Target:
[(x['x'], x['y']) for x in d]
->Reconstructed Predication:
'x' and 'y' are added to a list of tuples.
->Raw Input:
summarize:extract all the values with keys 'x' and 'y' from a list of dictionaries d to list of tuples
->Raw Target:
[(x['x'], x['y']) for x in d]
--

162=========
->Original Input:
zip two 2-d arrays `a` and `b`
->Original Target:
np.array(zip(a.ravel(), b.ravel()), dtype='i4,i4').reshape(a.shape)
->Reconstructed Target:
print(os.path.splitext(os.path.basename('hemanth.txt'))[0])
->Reconstructed Predication:
hemanth.txt.gets_filename.txt.gets_filename.txt.gets_filename.txt.gets_filename.txt.gets_filename.txt.gets_filename.txt.gets_filename.txt.gets_filename.txt.gets_filename.txt.gets_filename.txt.gets_file
->Raw Input:
summarize:get the filename without the extension from file 'hemanth.txt'
->Raw Target:
print(os.path.splitext(os.path.basename('hemanth.txt'))[0])
--

163=========
->Original Input:
convert list `list_of_ints` into a comma separated string
->Original Target:
""",""".join([str(i) for i in list_of_ints])
->Reconstructed Target:
dict(x[i:i + 2] for i in range(0, len(x), 2))
->Reconstructed Predication:
x = x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x.x
->Raw Input:
summarize:create a dictionary by adding each two adjacent elements in tuple x as key/value pair to it
->Raw Target:
dict(x[i:i + 2] for i in range(0, len(x), 2))
--

164=========
->Original Input:
Send a post request with raw data `DATA` and basic authentication with `username` and `password`
->Original Target:
requests.post(url, data=DATA, headers=HEADERS_DICT, auth=(username, password))
->Reconstructed Target:
values = sum([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], [])
->Reconstructed Predication:
''A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]
->Raw Input:
summarize:create a list containing flattened list [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]
->Raw Target:
values = sum([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], [])
--

165=========
->Original Input:
Find last occurrence of character '}' in string "abcd}def}"
->Original Target:
'abcd}def}'.rfind('}')
->Reconstructed Target:
df = df[(df['closing_price'] >= 99) & (df['closing_price'] = 101)]
->Reconstructed Predication:
df_closing_price.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.select.se
->Raw Input:
summarize:select rows in a dataframe df column 'closing_price' between two values 99 and 101
->Raw Target:
df = df[(df['closing_price'] >= 99) & (df['closing_price'] = 101)]
--

166=========
->Original Input:
Iterate ove list `[1, 2, 3]` using list comprehension
->Original Target:
print([item for item in [1, 2, 3]])
->Reconstructed Target:
df.replace('n': 'br>', regex=True)
->Reconstructed Predication:
.df.replaces all occurences of newlines n with.br>
->Raw Input:
summarize:replace all occurences of newlines n with br> in dataframe df
->Raw Target:
df.replace('n': 'br>', regex=True)
--

167=========
->Original Input:
extract all the values with keys 'x' and 'y' from a list of dictionaries `d` to list of tuples
->Original Target:
[(x['x'], x['y']) for x in d]
->Reconstructed Target:
df.replace('n': 'br>', regex=True)
->Reconstructed Predication:
n = n.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br.br
->Raw Input:
summarize:replace all occurrences of a string n by string br> in a pandas data frame df
->Raw Target:
df.replace('n': 'br>', regex=True)
--

168=========
->Original Input:
get the filename without the extension from file 'hemanth.txt'
->Original Target:
print(os.path.splitext(os.path.basename('hemanth.txt'))[0])
->Reconstructed Target:
[(x + y) for x, y in zip(word, word[1:])]
->Reconstructed Predication:
'word'
->Raw Input:
summarize:create a list containing each two adjacent letters in string word as its elements
->Raw Target:
[(x + y) for x, y in zip(word, word[1:])]
--

169=========
->Original Input:
create a dictionary by adding each two adjacent elements in tuple `x` as key/value pair to it
->Original Target:
dict(x[i:i + 2] for i in range(0, len(x), 2))
->Reconstructed Target:
list(map(lambda x, y: x + y, word[:-1], word[1:]))
->Reconstructed Predication:
.word('word')
->Raw Input:
summarize:Get a list of pairs from a string word using lambda function
->Raw Target:
list(map(lambda x, y: x + y, word[:-1], word[1:]))
--

170=========
->Original Input:
create a list containing flattened list `[['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]`
->Original Target:
values = sum([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], [])
->Reconstructed Target:
print(re.findall('(https?://[s]+)', myString))
->Reconstructed Predication:
url.extract(myString)
->Raw Input:
summarize:extract a url from a string myString
->Raw Target:
print(re.findall('(https?://[s]+)', myString))
--

171=========
->Original Input:
select rows in a dataframe `df` column 'closing_price' between two values 99 and 101
->Original Target:
df = df[(df['closing_price'] >= 99) & (df['closing_price'] <= 101)]
->Reconstructed Target:
print(re.search('(?Purl>https?://[s]+)', myString).group('url'))
->Reconstructed Predication:
url.extract(myString)
->Raw Input:
summarize:extract a url from a string myString
->Raw Target:
print(re.search('(?Purl>https?://[s]+)', myString).group('url'))
--

172=========
->Original Input:
replace all occurences of newlines `\n` with `<br>` in dataframe `df`
->Original Target:
df.replace({'\n': '<br>'}, regex=True)
->Reconstructed Target:
re.sub('[A-Za-z0-9]+', '', mystring)
->Reconstructed Predication:
.mystring.remove[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]
->Raw Input:
summarize:remove all special characters, punctuation and spaces from a string mystring using regex
->Raw Target:
re.sub('[A-Za-z0-9]+', '', mystring)
--

173=========
->Original Input:
replace all occurrences of a string `\n` by string `<br>` in a pandas data frame `df`
->Original Target:
df.replace({'\n': '<br>'}, regex=True)
->Reconstructed Target:
pd.date_range('2016-01-01', freq='WOM-2FRI', periods=13)
->Reconstructed Predication:
'2016-01-01'
->Raw Input:
summarize:create a DatetimeIndex containing 13 periods of the second friday of each month starting from date '2016-01-01'
->Raw Target:
pd.date_range('2016-01-01', freq='WOM-2FRI', periods=13)
--

174=========
->Original Input:
create a list containing each two adjacent letters in string `word` as its elements
->Original Target:
[(x + y) for x, y in zip(word, word[1:])]
->Reconstructed Target:
matrix = [[a, b], [c, d], [e, f]]
->Reconstructed Predication:
python::matrix.create(3 rows and 2 columns)
->Raw Input:
summarize:Create multidimensional array matrix with 3 rows and 2 columns in python
->Raw Target:
matrix = [[a, b], [c, d], [e, f]]
--

175=========
->Original Input:
Get a list of pairs from a string `word` using lambda function
->Original Target:
list(map(lambda x, y: x + y, word[:-1], word[1:]))
->Reconstructed Target:
mystring.replace(' ', '_')
->Reconstructed Predication:
replace spaces with underscore
->Raw Input:
summarize:replace spaces with underscore
->Raw Target:
mystring.replace(' ', '_')
--

176=========
->Original Input:
extract a url from a string `myString`
->Original Target:
print(re.findall('(https?://[^\\s]+)', myString))
->Reconstructed Target:
os.path.abspath('mydir/myfile.txt')
->Reconstructed Predication:
'mydir/myfile.txt'
->Raw Input:
summarize:get an absolute file path of file'mydir/myfile.txt'
->Raw Target:
os.path.abspath('mydir/myfile.txt')
--

177=========
->Original Input:
extract a url from a string `myString`
->Original Target:
print(re.search('(?P<url>https?://[^\\s]+)', myString).group('url'))
->Reconstructed Target:
""" """.join(my_string.split())
->Reconstructed Predication:
split(my_string) on white spaces
->Raw Input:
summarize:split string my_string on white spaces
->Raw Target:
""" """.join(my_string.split())
--

178=========
->Original Input:
remove all special characters, punctuation and spaces from a string `mystring` using regex
->Original Target:
re.sub('[^A-Za-z0-9]+', '', mystring)
->Reconstructed Target:
os.path.splitext(filename)[0]
->Reconstructed Predication:
filename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfilename.getfile
->Raw Input:
summarize:get filename without extension from file filename
->Raw Target:
os.path.splitext(filename)[0]
--

179=========
->Original Input:
create a DatetimeIndex containing 13 periods of the second friday of each month starting from date '2016-01-01'
->Original Target:
pd.date_range('2016-01-01', freq='WOM-2FRI', periods=13)
->Reconstructed Target:
[sum(l[:i]) for i, _ in enumerate(l)]
->Reconstructed Predication:
l(i) + l(i)
->Raw Input:
summarize:get a list containing the sum of each element i in list l plus the previous elements
->Raw Target:
[sum(l[:i]) for i, _ in enumerate(l)]
--

180=========
->Original Input:
Create multidimensional array `matrix` with 3 rows and 2 columns in python
->Original Target:
matrix = [[a, b], [c, d], [e, f]]
->Reconstructed Target:
"""Docs/src/Scripts/temp""".replace('/', '/x00/').split('x00')
->Reconstructed Predication:
.split(Docs/src/Scripts/temp)
->Raw Input:
summarize:split a string Docs/src/Scripts/temp by / keeping / in the result
->Raw Target:
"""Docs/src/Scripts/temp""".replace('/', '/x00/').split('x00')
--

181=========
->Original Input:
replace spaces with underscore
->Original Target:
mystring.replace(' ', '_')
->Reconstructed Target:
np.random.shuffle(np.transpose(r))
->Reconstructed Predication:
r_shuffle_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql_sql
->Raw Input:
summarize:shuffle columns of an numpy array 'r'
->Raw Target:
np.random.shuffle(np.transpose(r))
--

182=========
->Original Input:
get an absolute file path of file 'mydir/myfile.txt'
->Original Target:
os.path.abspath('mydir/myfile.txt')
->Reconstructed Target:
df['D'] = df['B']
->Reconstructed Predication:
df.copy('B')
->Raw Input:
summarize:copy all values in a column 'B' to a new column 'D' in a pandas data frame 'df'
->Raw Target:
df['D'] = df['B']
--

183=========
->Original Input:
split string `my_string` on white spaces
->Original Target:
""" """.join(my_string.split())
->Reconstructed Target:
list(data['A']['B'].values())[0]['maindata'][0]['Info']
->Reconstructed Predication:
'data':find a value within a nested json 'data' where the key inside another key 'B' is unknown.
->Raw Input:
summarize:find a value within nested json 'data' where the key inside another key 'B' is unknown.
->Raw Target:
list(data['A']['B'].values())[0]['maindata'][0]['Info']
--

184=========
->Original Input:
get filename without extension from file `filename`
->Original Target:
os.path.splitext(filename)[0]
->Reconstructed Target:
all(predicate(x) for x in string)
->Reconstructed Predication:
.check characters of string string are true predication of function predicate
->Raw Input:
summarize:check characters of string string are true predication of function predicate
->Raw Target:
all(predicate(x) for x in string)
--

185=========
->Original Input:
get a list containing the sum of each element `i` in list `l` plus the previous elements
->Original Target:
[sum(l[:i]) for i, _ in enumerate(l)]
->Reconstructed Target:
os.statvfs('/').f_files - os.statvfs('/').f_ffree
->Reconstructed Predication:
python::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
->Raw Input:
summarize:determine number of files on a drive with python
->Raw Target:
os.statvfs('/').f_files - os.statvfs('/').f_ffree
--

186=========
->Original Input:
split a string `Docs/src/Scripts/temp` by `/` keeping `/` in the result
->Original Target:
"""Docs/src/Scripts/temp""".replace('/', '/\x00/').split('\x00')
->Reconstructed Target:
user_list = [int(number) for number in user_input.split(',')]
->Reconstructed Predication:
user_input.list.list.input.list.input.list.input.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.
->Raw Input:
summarize:convert string user_input into a list of integers user_list
->Raw Target:
user_list = [int(number) for number in user_input.split(',')]
--

187=========
->Original Input:
shuffle columns of an numpy array 'r'
->Original Target:
np.random.shuffle(np.transpose(r))
->Reconstructed Target:
[int(s) for s in user.split(',')]
->Reconstructed Predication:
comma(user)
->Raw Input:
summarize:Get a list of integers by splitting a string user with comma
->Raw Target:
[int(s) for s in user.split(',')]
--

188=========
->Original Input:
copy all values in a column 'B' to a new column 'D' in a pandas data frame 'df'
->Original Target:
df['D'] = df['B']
->Reconstructed Target:
ut.sort(key=cmpfun, reverse=True)
->Reconstructed Predication:
cmpfun.sort(ut)
->Raw Input:
summarize:sort a list of objects ut, based on a function cmpfun in descending order
->Raw Target:
ut.sort(key=cmpfun, reverse=True)
--

189=========
->Original Input:
find a value within nested json 'data' where the key inside another key 'B' is unknown.
->Original Target:
list(data['A']['B'].values())[0]['maindata'][0]['Info']
->Reconstructed Target:
ut.sort(key=lambda x: x.count, reverse=True)
->Reconstructed Predication:
ut_count().reverse_list().count().reverse_list().count().reverse_list().count().reverse_list().count().reverse_list().count().reverse_list().count().reverse_list().count().reverse_list().count().reverse_list().count().reverse_list().count().reverse_list().count().reverse_list().count
->Raw Input:
summarize:reverse list ut based on the count attribute of each object
->Raw Target:
ut.sort(key=lambda x: x.count, reverse=True)
--

190=========
->Original Input:
check characters of string `string` are true predication of function `predicate`
->Original Target:
all(predicate(x) for x in string)
->Reconstructed Target:
ut.sort(key=lambda x: x.count, reverse=True)
->Reconstructed Predication:
ut_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count
->Raw Input:
summarize:sort a list of objects ut in reverse order by their count property
->Raw Target:
ut.sort(key=lambda x: x.count, reverse=True)
--

191=========
->Original Input:
determine number of files on a drive with python
->Original Target:
os.statvfs('/').f_files - os.statvfs('/').f_ffree
->Reconstructed Target:
driver.find_element_by_partial_link_text('Send').click()
->Reconstructed Predication:
href('Send')
->Raw Input:
summarize:click a href button 'Send' with selenium
->Raw Target:
driver.find_element_by_partial_link_text('Send').click()
--

192=========
->Original Input:
None
->Original Target:
cursor.fetchone()[0]
->Reconstructed Target:
driver.findElement(By.linkText('Send InMail')).click()
->Reconstructed Predication:
href:sendinmail.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href.href
->Raw Input:
summarize:click a href button having text Send InMail with selenium
->Raw Target:
driver.findElement(By.linkText('Send InMail')).click()
--

193=========
->Original Input:
convert string `user_input` into a list of integers `user_list`
->Original Target:
user_list = [int(number) for number in user_input.split(',')]
->Reconstructed Target:
driver.find_element_by_link_text('Send InMail').click()
->Reconstructed Predication:
'Send InMail'
->Raw Input:
summarize:click a href button with text 'Send InMail' with selenium
->Raw Target:
driver.find_element_by_link_text('Send InMail').click()
--

194=========
->Original Input:
Get a list of integers by splitting  a string `user` with comma
->Original Target:
[int(s) for s in user.split(',')]
->Reconstructed Target:
'ME' + str(i)
->Reconstructed Predication:
'ME' - 'i'
->Raw Input:
summarize:cast an int i to a string and concat to string 'ME'
->Raw Target:
'ME' + str(i)
--

195=========
->Original Input:
None
->Original Target:
sorted(list, key=lambda x: (x[0], -x[1]))
->Reconstructed Target:
open('outfile', 'w').write('#test firstlinen' + open('infile').read())
->Reconstructed Predication:
'#test firstlinen' is a.infile.save's.outfile.save's.infile.save's.outfile.save's.outfile.save's.outfile.save's.outfile.save's.outfile.save's.outfile.save's.outfile.save's 
->Raw Input:
summarize:prepend the line '#test firstlinen' to the contents of file 'infile' and save as the file 'outfile'
->Raw Target:
open('outfile', 'w').write('#test firstlinen' + open('infile').read())
--

196=========
->Original Input:
sort a list of objects `ut`, based on a function `cmpfun` in descending order
->Original Target:
ut.sort(key=cmpfun, reverse=True)
->Reconstructed Target:
l.sort(key=lambda t: len(t[1]), reverse=True)
->Reconstructed Predication:
l(l) = length of value in tuple
->Raw Input:
summarize:sort a list l by length of value in tuple
->Raw Target:
l.sort(key=lambda t: len(t[1]), reverse=True)
--

197=========
->Original Input:
reverse list `ut` based on the `count` attribute of each object
->Original Target:
ut.sort(key=lambda x: x.count, reverse=True)
->Reconstructed Target:
re.findall('b(w+)db', s)
->Reconstructed Predication:
split('d')
->Raw Input:
summarize:split string s by words that ends with 'd'
->Raw Target:
re.findall('b(w+)db', s)
--

198=========
->Original Input:
sort a list of objects `ut` in reverse order by their `count` property
->Original Target:
ut.sort(key=lambda x: x.count, reverse=True)
->Reconstructed Target:
bool(re.search('ba[rzd]', 'foobarrrr'))
->Reconstructed Predication:
if string foobarrrr contains regex ba[rzd]
->Raw Input:
summarize:return True if string foobarrrr contains regex ba[rzd]
->Raw Target:
bool(re.search('ba[rzd]', 'foobarrrr'))
--

199=========
->Original Input:
click a href button 'Send' with selenium
->Original Target:
driver.find_element_by_partial_link_text('Send').click()
->Reconstructed Target:
list(set(t))
->Reconstructed Predication:
duplicate(t)
->Raw Input:
summarize:Removing duplicates in list t
->Raw Target:
list(set(t))
--

200=========
->Original Input:
click a href button having text `Send InMail` with selenium
->Original Target:
driver.findElement(By.linkText('Send InMail')).click()
->Reconstructed Target:
list(set(source_list))
->Reconstructed Predication:
duplicate(source_list)
->Raw Input:
summarize:Removing duplicates in list source_list
->Raw Target:
list(set(source_list))
--

201=========
->Original Input:
click a href button with text 'Send InMail' with selenium
->Original Target:
driver.find_element_by_link_text('Send InMail').click()
->Reconstructed Target:
list(OrderedDict.fromkeys('abracadabra'))
->Reconstructed Predication:
duplicate('abracadabra')
->Raw Input:
summarize:Removing duplicates in list abracadabra
->Raw Target:
list(OrderedDict.fromkeys('abracadabra'))
--

202=========
->Original Input:
cast an int `i` to a string and concat to string 'ME'
->Original Target:
'ME' + str(i)
->Reconstructed Target:
numpy.array(a).reshape(-1).tolist()
->Reconstructed Predication:
a.list(a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, 
->Raw Input:
summarize:Convert array a into a list
->Raw Target:
numpy.array(a).reshape(-1).tolist()
--

203=========
->Original Input:
None
->Original Target:
df.sort_values(['System_num', 'Dis'])
->Reconstructed Target:
numpy.array(a)[0].tolist()
->Reconstructed Predication:
a.list(a)
->Raw Input:
summarize:Convert the first row of numpy matrix a to a list
->Raw Target:
numpy.array(a)[0].tolist()
--

204=========
->Original Input:
prepend the line '#test firstline\n' to the contents of file 'infile' and save as the file 'outfile'
->Original Target:
open('outfile', 'w').write('#test firstline\n' + open('infile').read())
->Reconstructed Target:
print(soup.find(text='Address:').findNext('td').contents[0])
->Reconstructed Predication:
td.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.address.add
->Raw Input:
summarize:In soup, get the content of the sibling of the td tag with text content Address:
->Raw Target:
print(soup.find(text='Address:').findNext('td').contents[0])
--

205=========
->Original Input:
sort a list `l` by length of value in tuple
->Original Target:
l.sort(key=lambda t: len(t[1]), reverse=True)
->Reconstructed Target:
""" """.join([('%d@%d' % t) for t in l])
->Reconstructed Predication:
l(list l) : l(list l) : l(list l) : l(list l) : l(list l) : l(list l) : l(list l) : l(list l) : l(list l) : l(list l) : l(list l) : l(list l) : l(list 
->Raw Input:
summarize:convert elements of each tuple in list l into a string separated by character @
->Raw Target:
""" """.join([('%d@%d' % t) for t in l])
--

206=========
->Original Input:
split string `s` by words that ends with 'd'
->Original Target:
re.findall('\\b(\\w+)d\\b', s)
->Reconstructed Target:
""" """.join([('%d@%d' % (t[0], t[1])) for t in l])
->Reconstructed Predication:
'@' separating the tuples' elements.
->Raw Input:
summarize:convert each tuple in list l to a string with '@' separating the tuples' elements
->Raw Target:
""" """.join([('%d@%d' % (t[0], t[1])) for t in l])
--

207=========
->Original Input:
return `True` if string `foobarrrr` contains regex `ba[rzd]`
->Original Target:
bool(re.search('ba[rzd]', 'foobarrrr'))
->Reconstructed Target:
driver.execute_script('return document.documentElement.outerHTML;')
->Reconstructed Predication:
.get(selenium.get())
->Raw Input:
summarize:get the html from the current web page of a Selenium driver
->Raw Target:
driver.execute_script('return document.documentElement.outerHTML;')
--

208=========
->Original Input:
Removing duplicates in list `t`
->Original Target:
list(set(t))
->Reconstructed Target:
[i for i in teststr if re.search('d+[xX]', i)]
->Reconstructed Predication:
d+[xX]
->Raw Input:
summarize:Get all matches with regex pattern d+[xX] in list of string teststr
->Raw Target:
[i for i in teststr if re.search('d+[xX]', i)]
--

209=========
->Original Input:
Removing duplicates in list `source_list`
->Original Target:
list(set(source_list))
->Reconstructed Target:
df['A'][(df['B'] > 50) & (df['C'] == 900)]
->Reconstructed Predication:
df.select('A', 'B', 'C') = 900 in dataframe.select('df')
->Raw Input:
summarize:select values from column 'A' for which corresponding values in column 'B' will be greater than 50, and in column 'C' - equal 900 in dataframe df
->Raw Target:
df['A'][(df['B'] > 50) & (df['C'] == 900)]
--

210=========
->Original Input:
Removing duplicates in list `abracadabra`
->Original Target:
list(OrderedDict.fromkeys('abracadabra'))
->Reconstructed Target:
sorted(o.items())
->Reconstructed Predication:
o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sort.o.sor
->Raw Input:
summarize:Sort dictionary o in ascending order based on its keys and items
->Raw Target:
sorted(o.items())
--

211=========
->Original Input:
Convert array `a` into a list
->Original Target:
numpy.array(a).reshape(-1).tolist()
->Reconstructed Target:
sorted(d)
->Reconstructed Predication:
d.getsorted.list(d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d.d
->Raw Input:
summarize:get sorted list of keys of dict d
->Raw Target:
sorted(d)
--

212=========
->Original Input:
Convert the first row of numpy matrix `a` to a list
->Original Target:
numpy.array(a)[0].tolist()
->Reconstructed Target:
int('1')
->Reconstructed Predication:
'1'
->Raw Input:
summarize:convert string "1" into integer
->Raw Target:
int('1')
--

213=========
->Original Input:
In `soup`, get the content of the sibling of the `td`  tag with text content `Address:`
->Original Target:
print(soup.find(text='Address:').findNext('td').contents[0])
->Reconstructed Target:
int()
->Reconstructed Predication:
..((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
->Raw Input:
summarize:function to convert strings into integers
->Raw Target:
int()
--

214=========
->Original Input:
convert elements of each tuple in list `l` into a string  separated by character `@`
->Original Target:
""" """.join([('%d@%d' % t) for t in l])
->Reconstructed Target:
T2 = [map(int, x) for x in T1]
->Reconstructed Predication:
t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1 - t1
->Raw Input:
summarize:convert items in T1 to integers
->Raw Target:
T2 = [map(int, x) for x in T1]
--

215=========
->Original Input:
convert each tuple in list `l` to a string with '@' separating the tuples' elements
->Original Target:
""" """.join([('%d@%d' % (t[0], t[1])) for t in l])
->Reconstructed Target:
subprocess.call(['./test.sh'])
->Reconstructed Predication:
test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.sh.test.s
->Raw Input:
summarize:call a shell script./test.sh using subprocess
->Raw Target:
subprocess.call(['./test.sh'])
--

216=========
->Original Input:
get the html from the current web page of a Selenium driver
->Original Target:
driver.execute_script('return document.documentElement.outerHTML;')
->Reconstructed Target:
subprocess.call(['notepad'])
->Reconstructed Predication:
..notepad.call(subprocess)
->Raw Input:
summarize:call a shell script notepad using subprocess
->Raw Target:
subprocess.call(['notepad'])
--

217=========
->Original Input:
Get all matches with regex pattern `\\d+[xX]` in list of string `teststr`
->Original Target:
[i for i in teststr if re.search('\\d+[xX]', i)]
->Reconstructed Target:
[val for pair in zip(l1, l2) for val in pair]
->Reconstructed Predication:
l1 and l2.
->Raw Input:
summarize:combine lists l1 and l2 by alternating their elements
->Raw Target:
[val for pair in zip(l1, l2) for val in pair]
--

218=========
->Original Input:
select values from column 'A' for which corresponding values in column 'B' will be greater than 50, and in column 'C' - equal 900 in dataframe `df`
->Original Target:
df['A'][(df['B'] > 50) & (df['C'] == 900)]
->Reconstructed Target:
encoded = base64.b64encode('data to be encoded')
->Reconstructed Predication:
data to be encoded.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.encode.data.data.encode.data.data.data.en
->Raw Input:
summarize:encode string 'data to be encoded'
->Raw Target:
encoded = base64.b64encode('data to be encoded')
--

219=========
->Original Input:
Sort dictionary `o` in ascending order based on its keys and items
->Original Target:
sorted(o.items())
->Reconstructed Target:
encoded = 'data to be encoded'.encode('ascii')
->Reconstructed Predication:
encoding(data to be encoded)
->Raw Input:
summarize:encode a string data to be encoded to ascii encoding
->Raw Target:
encoded = 'data to be encoded'.encode('ascii')
--

220=========
->Original Input:
get sorted list of keys of dict `d`
->Original Target:
sorted(d)
->Reconstructed Target:
lol = list(csv.reader(open('text.txt', 'rb'), delimiter='t'))
->Reconstructed Predication:
'text.txt'
->Raw Input:
summarize:parse tab-delimited CSV file 'text.txt' into a list
->Raw Target:
lol = list(csv.reader(open('text.txt', 'rb'), delimiter='t'))
--

221=========
->Original Input:
None
->Original Target:
sorted(d.items())
->Reconstructed Target:
getattr(my_object, my_str)
->Reconstructed Predication:
''my_str''
->Raw Input:
summarize:Get attribute my_str of object my_object
->Raw Target:
getattr(my_object, my_str)
--

222=========
->Original Input:
convert string "1" into integer
->Original Target:
int('1')
->Reconstructed Target:
print(dict(zip(LD[0], zip(*[list(d.values()) for d in LD]))))
->Reconstructed Predication:
LD(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)::key(LD)
->Raw Input:
summarize:group a list of dicts LD into one dict by key
->Raw Target:
print(dict(zip(LD[0], zip(*[list(d.values()) for d in LD]))))
--

223=========
->Original Input:
function to convert strings into integers
->Original Target:
int()
->Reconstructed Target:
d = ast.literal_eval("'code1':1,'code2':1")
->Reconstructed Predication:
u"'code1':1,'code2':1"
->Raw Input:
summarize:convert unicode string u"'code1':1,'code2':1" into dictionary
->Raw Target:
d = ast.literal_eval("'code1':1,'code2':1")
--

224=========
->Original Input:
convert items in `T1` to integers
->Original Target:
T2 = [map(int, x) for x in T1]
->Reconstructed Target:
[word for word in mystring.split() if word.startswith('$')]
->Reconstructed Predication:
'mystring'
->Raw Input:
summarize:find all words in a string mystring that start with the $ sign
->Raw Target:
[word for word in mystring.split() if word.startswith('$')]
--

225=========
->Original Input:
call a shell script `./test.sh` using subprocess
->Original Target:
subprocess.call(['./test.sh'])
->Reconstructed Target:
text = re.sub('https?://.*[rn]*', '', text, flags=re.MULTILINE)
->Reconstructed Predication:
url(text)
->Raw Input:
summarize:remove any url within string text
->Raw Target:
text = re.sub('https?://.*[rn]*', '', text, flags=re.MULTILINE)
--

226=========
->Original Input:
call a shell script `notepad` using subprocess
->Original Target:
subprocess.call(['notepad'])
->Reconstructed Target:
np.where(np.in1d(A, [1, 3, 4]).reshape(A.shape), A, 0)
->Reconstructed Predication:
.([1, 3, 4])
->Raw Input:
summarize:replace all elements in array A that are not present in array [1, 3, 4] with zeros
->Raw Target:
np.where(np.in1d(A, [1, 3, 4]).reshape(A.shape), A, 0)
--

227=========
->Original Input:
combine lists `l1` and `l2`  by alternating their elements
->Original Target:
[val for pair in zip(l1, l2) for val in pair]
->Reconstructed Target:
np.mean(a, axis=1)
->Reconstructed Predication:
a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.
->Raw Input:
summarize:calculate mean across dimension in a 2d array a
->Raw Target:
np.mean(a, axis=1)
--

228=========
->Original Input:
encode string 'data to be encoded'
->Original Target:
encoded = base64.b64encode('data to be encoded')
->Reconstructed Target:
subprocess.call(['/usr/bin/Rscript', '--vanilla', '/pathto/MyrScript.r'])
->Reconstructed Predication:
r script '/pathto/MyrScript.r'
->Raw Input:
summarize:running r script '/pathto/MyrScript.r' from python
->Raw Target:
subprocess.call(['/usr/bin/Rscript', '--vanilla', '/pathto/MyrScript.r'])
--

229=========
->Original Input:
encode a string `data to be encoded` to `ascii` encoding
->Original Target:
encoded = 'data to be encoded'.encode('ascii')
->Reconstructed Target:
subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)
->Reconstructed Predication:
r script '/usr/bin/Rscript --vanilla /pathto/MyrScript.r'
->Raw Input:
summarize:run r script '/usr/bin/Rscript --vanilla /pathto/MyrScript.r'
->Raw Target:
subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)
--

230=========
->Original Input:
parse tab-delimited CSV file 'text.txt' into a list
->Original Target:
lol = list(csv.reader(open('text.txt', 'rb'), delimiter='\t'))
->Reconstructed Target:
writer.writeheader()
->Reconstructed Predication:
csv:add a header to a csv file
->Raw Input:
summarize:add a header to a csv file
->Raw Target:
writer.writeheader()
--

231=========
->Original Input:
Get attribute `my_str` of object `my_object`
->Original Target:
getattr(my_object, my_str)
->Reconstructed Target:
df.fillna(df.mean(axis=1), axis=1)
->Reconstructed Predication:
df.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.nan.replaces.
->Raw Input:
summarize:replacing nan in the dataframe df with row average
->Raw Target:
df.fillna(df.mean(axis=1), axis=1)
--

232=========
->Original Input:
group a list of dicts `LD` into one dict by key
->Original Target:
print(dict(zip(LD[0], zip(*[list(d.values()) for d in LD]))))
->Reconstructed Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1347517370))
->Reconstructed Predication:
'%Y-%m-%d %H:%M:%S'
->Raw Input:
summarize:Convert unix timestamp '1347517370' to formatted string '%Y-%m-%d %H:%M:%S'
->Raw Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1347517370))
--

233=========
->Original Input:
None
->Original Target:
sum([pair[0] for pair in list_of_pairs])
->Reconstructed Target:
super(Derived, cls).do(a)
->Reconstructed Predication:
do.call('do'))
->Raw Input:
summarize:Call a base class's class method do from derived class Derived
->Raw Target:
super(Derived, cls).do(a)
--

234=========
->Original Input:
convert unicode string u"{'code1':1,'code2':1}" into dictionary
->Original Target:
d = ast.literal_eval("{'code1':1,'code2':1}")
->Reconstructed Target:
a[np.where((a[:, (0)] == 0) * (a[:, (1)] == 1))]
->Reconstructed Predication:
ndarray_a_selecting_rows_value_in_first_column_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_1_
->Raw Input:
summarize:selecting rows in Numpy ndarray 'a', where the value in the first column is 0 and value in the second column is 1
->Raw Target:
a[np.where((a[:, (0)] == 0) * (a[:, (1)] == 1))]
--

235=========
->Original Input:
find all words in a string `mystring` that start with the `$` sign
->Original Target:
[word for word in mystring.split() if word.startswith('$')]
->Reconstructed Target:
re.split(' +', 'hello world sample text')
->Reconstructed Predication:
..((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
->Raw Input:
summarize:separate words delimited by one or more spaces into a list
->Raw Target:
re.split(' +', 'hello world sample text')
--

236=========
->Original Input:
remove any url within string `text`
->Original Target:
text = re.sub('^https?:\\/\\/.*[\\r\\n]*', '', text, flags=re.MULTILINE)
->Reconstructed Target:
len(max(words, key=len))
->Reconstructed Predication:
wordslength of longest element in list
->Raw Input:
summarize:length of longest element in list words
->Raw Target:
len(max(words, key=len))
--

237=========
->Original Input:
replace all elements in array `A` that are not present in array `[1, 3, 4]` with zeros
->Original Target:
np.where(np.in1d(A, [1, 3, 4]).reshape(A.shape), A, 0)
->Reconstructed Target:
result[0]['from_user']
->Reconstructed Predication:
'from_user' is a key associated with unicode key 'from_user' in first dictionary in list result
->Raw Input:
summarize:get the value associated with unicode key 'from_user' of first dictionary in list result
->Raw Target:
result[0]['from_user']
--

238=========
->Original Input:
calculate mean across dimension in a 2d array `a`
->Original Target:
np.mean(a, axis=1)
->Reconstructed Target:
[line.split() for line in open('File.txt')]
->Reconstructed Predication:
'File.txt': ''File.txt'': ''File.txt'': ''File.txt'': ''File.txt'': ''File.txt'': ''File.txt'': ''File.txt'': ''File.txt'': ''File.t
->Raw Input:
summarize:Retrieve each line from a file 'File.txt' as a list
->Raw Target:
[line.split() for line in open('File.txt')]
--

239=========
->Original Input:
running r script '/pathto/MyrScript.r' from python
->Original Target:
subprocess.call(['/usr/bin/Rscript', '--vanilla', '/pathto/MyrScript.r'])
->Reconstructed Target:
res = dict((v, k) for k, v in a.items())
->Reconstructed Predication:
a.keys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.swapkeys.sw
->Raw Input:
summarize:swap keys with values in a dictionary a
->Raw Target:
res = dict((v, k) for k, v in a.items())
--

240=========
->Original Input:
run r script '/usr/bin/Rscript --vanilla /pathto/MyrScript.r'
->Original Target:
subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)
->Reconstructed Target:
new_file = open('path/to/FILE_NAME.ext', 'w')
->Reconstructed Predication:
.fs.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.write.
->Raw Input:
summarize:Open a file path/to/FILE_NAME.ext in write mode
->Raw Target:
new_file = open('path/to/FILE_NAME.ext', 'w')
--

241=========
->Original Input:
add a header to a csv file
->Original Target:
writer.writeheader()
->Reconstructed Target:
any(key.startswith('EMP$$') for key in dict1)
->Reconstructed Predication:
dict1::start('EMP$$')
->Raw Input:
summarize:Check if any key in the dictionary dict1 starts with the string EMP$$
->Raw Target:
any(key.startswith('EMP$$') for key in dict1)
--

242=========
->Original Input:
replacing nan in the dataframe `df` with row average
->Original Target:
df.fillna(df.mean(axis=1), axis=1)
->Reconstructed Target:
[value for key, value in list(dict1.items()) if key.startswith('EMP$$')]
->Reconstructed Predication:
dict1:creates a list of values that have a key that starts with 'EMP$$'
->Raw Input:
summarize:create list of values from dictionary dict1 that have a key that starts with 'EMP$$'
->Raw Target:
[value for key, value in list(dict1.items()) if key.startswith('EMP$$')]
--

243=========
->Original Input:
Convert unix timestamp '1347517370' to formatted string '%Y-%m-%d %H:%M:%S'
->Original Target:
time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1347517370))
->Reconstructed Target:
pd.DataFrame('email': sf.index, 'list': sf.values)
->Reconstructed Predication:
sf.sf.sf.list.sf.list.sf.list.sf.list.sf.list.sf.list.sf.list.sf.list.sf.list.sf.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.
->Raw Input:
summarize:convert a pandas series sf into a pandas dataframe df with columns email and list
->Raw Target:
pd.DataFrame('email': sf.index, 'list': sf.values)
--

244=========
->Original Input:
Call a base class's class method `do` from derived class `Derived`
->Original Target:
super(Derived, cls).do(a)
->Reconstructed Target:
print('t'.join(map(str, list)))
->Reconstructed Predication:
.print(list) seperated by tabs.t.
->Raw Input:
summarize:print elements of list list seperated by tabs t
->Raw Target:
print('t'.join(map(str, list)))
--

245=========
->Original Input:
selecting rows in Numpy ndarray 'a', where the value in the first column is 0 and value in the second column is 1
->Original Target:
a[np.where((a[:, (0)] == 0) * (a[:, (1)] == 1))]
->Reconstructed Target:
print('xd0xbfxd1x80xd0xb8'.encode('raw_unicode_escape'))
->Reconstructed Predication:
'xd0xbfxd1x80xd0xb8'
->Raw Input:
summarize:print unicode string 'xd0xbfxd1x80xd0xb8' with utf-8
->Raw Target:
print('xd0xbfxd1x80xd0xb8'.encode('raw_unicode_escape'))
--

246=========
->Original Input:
separate words delimited by one or more spaces into a list
->Original Target:
re.split(' +', 'hello world sample text')
->Reconstructed Target:
'Sopetxc3xb3n'.encode('latin-1').decode('utf-8')
->Reconstructed Predication:
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
->Raw Input:
summarize:Encode a latin character in string Sopetxc3xb3n properly
->Raw Target:
'Sopetxc3xb3n'.encode('latin-1').decode('utf-8')
--

247=========
->Original Input:
length of longest element in list `words`
->Original Target:
len(max(words, key=len))
->Reconstructed Target:
image = image.resize((x, y), Image.ANTIALIAS)
->Reconstructed Predication:
ANTIALIAS:resize(x, y))
->Raw Input:
summarize:resized image image to width, height of (x, y) with filter of ANTIALIAS
->Raw Target:
image = image.resize((x, y), Image.ANTIALIAS)
--

248=========
->Original Input:
get the value associated with unicode key 'from_user' of first dictionary in list `result`
->Original Target:
result[0]['from_user']
->Reconstructed Target:
re.findall('n(?=[n]n)n+(?=[n])(?i)', s)
->Reconstructed Predication:
regex, find "n"s only in the middle of string s
->Raw Input:
summarize:regex, find "n"s only in the middle of string s
->Raw Target:
re.findall('n(?=[n]n)n+(?=[n])(?i)', s)
--

249=========
->Original Input:
Retrieve each line from a file 'File.txt' as a list
->Original Target:
[line.split() for line in open('File.txt')]
->Reconstructed Target:
print('0:.0f%'.format(1.0 / 3 * 100))
->Reconstructed Predication:
float(1*100)
->Raw Input:
summarize:display the float 1/3*100 as a percentage
->Raw Target:
print('0:.0f%'.format(1.0 / 3 * 100))
--

250=========
->Original Input:
swap keys with values in a dictionary `a`
->Original Target:
res = dict((v, k) for k, v in a.items())
->Reconstructed Target:
mylist.sort(key=lambda x: x['title'])
->Reconstructed Predication:
.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.mylist.title.my
->Raw Input:
summarize:sort a list of dictionary mylist by the key title
->Raw Target:
mylist.sort(key=lambda x: x['title'])
--

251=========
->Original Input:
Open a file `path/to/FILE_NAME.ext` in write mode
->Original Target:
new_file = open('path/to/FILE_NAME.ext', 'w')
->Reconstructed Target:
l.sort(key=lambda x: x['title'])
->Reconstructed Predication:
l('title')
->Raw Input:
summarize:sort a list l of dicts by dict value 'title'
->Raw Target:
l.sort(key=lambda x: x['title'])
--

252=========
->Original Input:
None
->Original Target:
df.groupby(['col1', 'col2'])['col3'].nunique().reset_index()
->Reconstructed Target:
l.sort(key=lambda x: (x['title'], x['title_url'], x['id']))
->Reconstructed Predication:
'title', 'title_url', 'id'
->Raw Input:
summarize:sort a list of dictionaries by the value of keys 'title', 'title_url', 'id' in ascending order.
->Raw Target:
l.sort(key=lambda x: (x['title'], x['title_url'], x['id']))
--

253=========
->Original Input:
Check if any key in the dictionary `dict1` starts with the string `EMP$$`
->Original Target:
any(key.startswith('EMP$$') for key in dict1)
->Reconstructed Target:
heapq.nlargest(10, range(len(l1)), key=lambda i: abs(l1[i] - l2[i]))
->Reconstructed Predication:
l1 - l2 - l1 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2 - l2
->Raw Input:
summarize:find 10 largest differences between each respective elements of list l1 and list l2
->Raw Target:
heapq.nlargest(10, range(len(l1)), key=lambda i: abs(l1[i] - l2[i]))
--

254=========
->Original Input:
create list of values from dictionary `dict1` that have a key that starts with 'EMP$$'
->Original Target:
[value for key, value in list(dict1.items()) if key.startswith('EMP$$')]
->Reconstructed Target:
soup.find_all('span', 'class':'starGryB sp')
->Reconstructed Predication:
'starGryB sp'
->Raw Input:
summarize:BeautifulSoup find all'span' elements in HTML string soup with class of'starGryB sp'
->Raw Target:
soup.find_all('span', 'class':'starGryB sp')
--

255=========
->Original Input:
convert a pandas series `sf` into a pandas dataframe `df` with columns `email` and `list`
->Original Target:
pd.DataFrame({'email': sf.index, 'list': sf.values})
->Reconstructed Target:
df.to_sql('test', engine, schema='a_schema')
->Reconstructed Predication:
df_test.write('a_schema')
->Raw Input:
summarize:write records in dataframe df to table 'test' in schema 'a_schema'
->Raw Target:
df.to_sql('test', engine, schema='a_schema')
--

256=========
->Original Input:
print elements of list `list` seperated by tabs `\t`
->Original Target:
print('\t'.join(map(str, list)))
->Reconstructed Target:
brackets = re.sub('[()[]]', '', s)
->Reconstructed Predication:
brackets.s.extract(s))
->Raw Input:
summarize:Extract brackets from string s
->Raw Target:
brackets = re.sub('[()[]]', '', s)
--

257=========
->Original Input:
print unicode string '\xd0\xbf\xd1\x80\xd0\xb8' with utf-8
->Original Target:
print('\xd0\xbf\xd1\x80\xd0\xb8'.encode('raw_unicode_escape'))
->Reconstructed Target:
list(dict((x[0], x) for x in L).values())
->Reconstructed Predication:
'L'
->Raw Input:
summarize:remove duplicate elements from list 'L'
->Raw Target:
list(dict((x[0], x) for x in L).values())
--

258=========
->Original Input:
Encode a latin character in string `Sopet\xc3\xb3n` properly
->Original Target:
'Sopet\xc3\xb3n'.encode('latin-1').decode('utf-8')
->Reconstructed Target:
[line.rstrip('n') for line in file]
->Reconstructed Predication:
.reads.file.read.file.read.file.read.file.read.file.read.file.read.file.read.file.read.file.read.file.read.file.read.file.read.file.file.read.file.file.read.file.file.read.file.file.read.file.file.read.file.file.file.read.file.file.file.read.file.file.file.read.file.file.file.
->Raw Input:
summarize:read a file file without newlines
->Raw Target:
[line.rstrip('n') for line in file]
--

259=========
->Original Input:
resized image `image` to width, height of `(x, y)` with filter of `ANTIALIAS`
->Original Target:
image = image.resize((x, y), Image.ANTIALIAS)
->Reconstructed Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
->Reconstructed Predication:
testlistposition(1 in testlistposition(1 in testlistposition(1 in testlist)]
->Raw Input:
summarize:get the position of item 1 in testlist
->Raw Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
--

260=========
->Original Input:
regex, find "n"s only in the middle of string `s`
->Original Target:
re.findall('n(?<=[^n]n)n+(?=[^n])(?i)', s)
->Reconstructed Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
->Reconstructed Predication:
testlistposition(1 in testlistposition(1 in testlistposition(1 in testlist)]
->Raw Input:
summarize:get the position of item 1 in testlist
->Raw Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
--

261=========
->Original Input:
display the float `1/3*100` as a percentage
->Original Target:
print('{0:.0f}%'.format(1.0 / 3 * 100))
->Reconstructed Target:
for i in [i for (i, x) in enumerate(testlist) if (x == 1)]: pass
->Reconstructed Predication:
testlistposition(1 in testlistposition(1 in testlistposition(1 in testlist)]
->Raw Input:
summarize:get the position of item 1 in testlist
->Raw Target:
for i in [i for (i, x) in enumerate(testlist) if (x == 1)]: pass
--

262=========
->Original Input:
sort a list of dictionary `mylist` by the key `title`
->Original Target:
mylist.sort(key=lambda x: x['title'])
->Reconstructed Target:
for i in (i for (i, x) in enumerate(testlist) if (x == 1)): pass
->Reconstructed Predication:
testlistposition(1 in testlistposition(1 in testlistposition(1 in testlist)]
->Raw Input:
summarize:get the position of item 1 in testlist
->Raw Target:
for i in (i for (i, x) in enumerate(testlist) if (x == 1)): pass
--

263=========
->Original Input:
sort a list `l` of dicts by dict value 'title'
->Original Target:
l.sort(key=lambda x: x['title'])
->Reconstructed Target:
gen = (i for (i, x) in enumerate(testlist) if (x == 1)) for i in gen: pass
->Reconstructed Predication:
testlistposition(1 in testlistposition(1 in testlistposition(1 in testlist)]
->Raw Input:
summarize:get the position of item 1 in testlist
->Raw Target:
gen = (i for (i, x) in enumerate(testlist) if (x == 1)) for i in gen: pass
--

264=========
->Original Input:
sort a list of dictionaries by the value of keys 'title', 'title_url', 'id' in ascending order.
->Original Target:
l.sort(key=lambda x: (x['title'], x['title_url'], x['id']))
->Reconstructed Target:
print(testlist.index(element))
->Reconstructed Predication:
'element' in list 'testlist'
->Raw Input:
summarize:get the position of item element in list testlist
->Raw Target:
print(testlist.index(element))
--

265=========
->Original Input:
find 10 largest differences between each respective elements of list `l1` and list `l2`
->Original Target:
heapq.nlargest(10, range(len(l1)), key=lambda i: abs(l1[i] - l2[i]))
->Reconstructed Target:
try: print(testlist.index(element)) except ValueError: pass
->Reconstructed Predication:
'element' in list 'testlist'
->Raw Input:
summarize:get the position of item element in list testlist
->Raw Target:
try: print(testlist.index(element)) except ValueError: pass
--

266=========
->Original Input:
BeautifulSoup find all 'span' elements in HTML string `soup` with class of 'starGryB sp'
->Original Target:
soup.find_all('span', {'class': 'starGryB sp'})
->Reconstructed Target:
max(lis, key=lambda item: item[1])[0]
->Reconstructed Predication:
lis.find('lis'))
->Raw Input:
summarize:find the first element of the tuple with the maximum second element in a list of tuples lis
->Raw Target:
max(lis, key=lambda item: item[1])[0]
--

267=========
->Original Input:
write records in dataframe `df` to table 'test' in schema 'a_schema'
->Original Target:
df.to_sql('test', engine, schema='a_schema')
->Reconstructed Target:
max(lis, key=itemgetter(1))[0]
->Reconstructed Predication:
lis_get(index 0)
->Raw Input:
summarize:get the item at index 0 from the tuple that has maximum value at index 1 in list lis
->Raw Target:
max(lis, key=itemgetter(1))[0]
--

268=========
->Original Input:
Extract brackets from string `s`
->Original Target:
brackets = re.sub('[^(){}[\\]]', '', s)
->Reconstructed Target:
time.sleep(1)
->Reconstructed Predication:
delay(delay(delay)): 1 second)
->Raw Input:
summarize:Make a delay of 1 second
->Raw Target:
time.sleep(1)
--

269=========
->Original Input:
remove duplicate elements from list 'L'
->Original Target:
list(dict((x[0], x) for x in L).values())
->Reconstructed Target:
""", """.join('(' + ', '.join(i) + ')' for i in L)
->Reconstructed Predication:
l.list(L)
->Raw Input:
summarize:convert list of tuples L to a string
->Raw Target:
""", """.join('(' + ', '.join(i) + ')' for i in L)
--

270=========
->Original Input:
read a file `file` without newlines
->Original Target:
[line.rstrip('\n') for line in file]
->Reconstructed Target:
b = models.CharField(max_length=7, default='0000000', editable=False)
->Reconstructed Predication:
default value of field b = '0000000'
->Raw Input:
summarize:Django set default value of field b equal to '0000000'
->Raw Target:
b = models.CharField(max_length=7, default='0000000', editable=False)
--

271=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
->Reconstructed Target:
sorted(list5, lambda x: (degree(x), x))
->Reconstructed Predication:
lis.list5('')
->Raw Input:
summarize:Sort lis list5 in ascending order based on the degrees value of its elements
->Raw Target:
sorted(list5, lambda x: (degree(x), x))
--

272=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
[i for (i, x) in enumerate(testlist) if (x == 1)]
->Reconstructed Target:
(n for n in [1, 2, 3, 5])
->Reconstructed Predication:
list.list.generator.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list
->Raw Input:
summarize:convert a list into a generator object
->Raw Target:
(n for n in [1, 2, 3, 5])
--

273=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
for i in [i for (i, x) in enumerate(testlist) if (x == 1)]:
    pass
->Reconstructed Target:
newlist = [v for i, v in enumerate(oldlist) if i not in removelist]
->Reconstructed Predication:
removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.removelist.list.
->Raw Input:
summarize:remove elements from list oldlist that have an index number mentioned in list removelist
->Raw Target:
newlist = [v for i, v in enumerate(oldlist) if i not in removelist]
--

274=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
for i in (i for (i, x) in enumerate(testlist) if (x == 1)):
    pass
->Reconstructed Target:
f = open('yourfile.txt', 'w')
->Reconstructed Predication:
yourfile.txt
->Raw Input:
summarize:Open a file yourfile.txt in write mode
->Raw Target:
f = open('yourfile.txt', 'w')
--

275=========
->Original Input:
get the position of item 1 in `testlist`
->Original Target:
gen = (i for (i, x) in enumerate(testlist) if (x == 1))
for i in gen:
    pass
->Reconstructed Target:
getattr(obj, 'attr')
->Reconstructed Predication:
get attribute 'attr' from object obj
->Raw Input:
summarize:get attribute 'attr' from object obj
->Raw Target:
getattr(obj, 'attr')
--

276=========
->Original Input:
get the position of item `element` in list `testlist`
->Original Target:
print(testlist.index(element))
->Reconstructed Target:
from functools import reduce reduce(lambda a, b: a + b, (('aa',), ('bb',), ('cc',)))
->Reconstructed Predication:
tuple(('aa',), ('bb',), ('cc',))
->Raw Input:
summarize:convert tuple of tuples (('aa',), ('bb',), ('cc',)) to tuple
->Raw Target:
from functools import reduce reduce(lambda a, b: a + b, (('aa',), ('bb',), ('cc',)))
--

277=========
->Original Input:
get the position of item `element` in list `testlist`
->Original Target:
try:
    print(testlist.index(element))
except ValueError:
    pass
->Reconstructed Target:
map(lambda a: a[0], (('aa',), ('bb',), ('cc',)))
->Reconstructed Predication:
'aa','bb','cc','aa','cc','aa','cc','aa','cc','aa','cc','aa','cc','aa','cc','aa','cc','aa','cc','aa','aa','aa','b
->Raw Input:
summarize:convert tuple of tuples (('aa',), ('bb',), ('cc',)) to list in one line
->Raw Target:
map(lambda a: a[0], (('aa',), ('bb',), ('cc',)))
--

278=========
->Original Input:
find the first element of the tuple with the maximum second element in a list of tuples `lis`
->Original Target:
max(lis, key=lambda item: item[1])[0]
->Reconstructed Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Reconstructed Predication:
'a', 1), ('b', 2), ('c', 3), ('d', 4)
->Raw Input:
summarize:unzip the list [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
->Raw Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
--

279=========
->Original Input:
get the item at index 0 from the tuple that has maximum value at index 1 in list `lis`
->Original Target:
max(lis, key=itemgetter(1))[0]
->Reconstructed Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Reconstructed Predication:
'a', 1), ('b', 2), ('c', 3), ('d', 4)
->Raw Input:
summarize:unzip the list [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
->Raw Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
--

280=========
->Original Input:
Make a delay of 1 second
->Original Target:
time.sleep(1)
->Reconstructed Target:
result = ([a for (a, b) in original], [b for (a, b) in original])
->Reconstructed Predication:
originalunzip(originalunzip(originalunzip(originalunzip(original)))]
->Raw Input:
summarize:unzip list original
->Raw Target:
result = ([a for (a, b) in original], [b for (a, b) in original])
--

281=========
->Original Input:
convert list of tuples `L` to a string
->Original Target:
""", """.join('(' + ', '.join(i) + ')' for i in L)
->Reconstructed Target:
result = ((a for (a, b) in original), (b for (a, b) in original))
->Reconstructed Predication:
generator(original and return a generator)
->Raw Input:
summarize:unzip list original and return a generator
->Raw Target:
result = ((a for (a, b) in original), (b for (a, b) in original))
--

282=========
->Original Input:
Django set default value of field `b` equal to '0000000'
->Original Target:
b = models.CharField(max_length=7, default='0000000', editable=False)
->Reconstructed Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
->Reconstructed Predication:
'a', 1), 'b', 2), 'c', 3), 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', '
->Raw Input:
summarize:unzip list [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]
->Raw Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
--

283=========
->Original Input:
Sort lis `list5` in ascending order based on the degrees value of its elements
->Original Target:
sorted(list5, lambda x: (degree(x), x))
->Reconstructed Target:
map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
->Reconstructed Predication:
'a', 1), 'b', 2), 'c', 3), 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', 'e', '
->Raw Input:
summarize:unzip list [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )] and fill empty results with None
->Raw Target:
map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
--

284=========
->Original Input:
None
->Original Target:
sorted(list5, key=lambda vertex: (degree(vertex), vertex))
->Reconstructed Target:
json.dumps(Decimal('3.9'))
->Reconstructed Predication:
encode('3.9'))
->Raw Input:
summarize:encode Decimal('3.9') to a JSON string
->Raw Target:
json.dumps(Decimal('3.9'))
--

285=========
->Original Input:
convert a list  into a generator object
->Original Target:
(n for n in [1, 2, 3, 5])
->Reconstructed Target:
d['mynewkey'] ='mynewvalue'
->Reconstructed Predication:
d(mynewkey)
->Raw Input:
summarize:Add key "mynewkey" to dictionary d with value "mynewvalue"
->Raw Target:
d['mynewkey'] ='mynewvalue'
--

286=========
->Original Input:
remove elements from list `oldlist` that have an index number mentioned in list `removelist`
->Original Target:
newlist = [v for i, v in enumerate(oldlist) if i not in removelist]
->Reconstructed Target:
data.update('a': 1, )
->Reconstructed Predication:
'a' = 1
->Raw Input:
summarize:Add key 'a' to dictionary data with value 1
->Raw Target:
data.update('a': 1, )
--

287=========
->Original Input:
Open a file `yourfile.txt` in write mode
->Original Target:
f = open('yourfile.txt', 'w')
->Reconstructed Target:
data.update(dict(a=1))
->Reconstructed Predication:
'a' = 1
->Raw Input:
summarize:Add key 'a' to dictionary data with value 1
->Raw Target:
data.update(dict(a=1))
--

288=========
->Original Input:
get attribute 'attr' from object `obj`
->Original Target:
getattr(obj, 'attr')
->Reconstructed Target:
data.update(a=1)
->Reconstructed Predication:
'a' = 1
->Raw Input:
summarize:Add key 'a' to dictionary data with value 1
->Raw Target:
data.update(a=1)
--

289=========
->Original Input:
convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to tuple
->Original Target:
from functools import reduce
reduce(lambda a, b: a + b, (('aa',), ('bb',), ('cc',)))
->Reconstructed Target:
max([max(i) for i in matrix])
->Reconstructed Predication:
''(''(''(''(''(''(''(''(''(''(''(''(''(''(''(''(''(''(''(''')))))))
->Raw Input:
summarize:find maximal value in matrix matrix
->Raw Target:
max([max(i) for i in matrix])
--

290=========
->Original Input:
convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to list in one line
->Original Target:
map(lambda a: a[0], (('aa',), ('bb',), ('cc',)))
->Reconstructed Target:
answer = str(round(answer, 2))
->Reconstructed Predication:
.('')
->Raw Input:
summarize:Round number answer to 2 precision after the decimal point
->Raw Target:
answer = str(round(answer, 2))
--

291=========
->Original Input:
None
->Original Target:
df['range'].replace(',', '-', inplace=True)
->Reconstructed Target:
ip = re.findall('[0-9]+(?:.[0-9]+)3', s)
->Reconstructed Predication:
ip address(ip address(ip address))
->Raw Input:
summarize:extract ip address from an html string
->Raw Target:
ip = re.findall('[0-9]+(?:.[0-9]+)3', s)
--

292=========
->Original Input:
unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`
->Original Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Reconstructed Target:
df.groupby('A').filter(lambda x: len(x) > 1)
->Reconstructed Predication:
df_filter_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.filter_df_a.
->Raw Input:
summarize:filter dataframe df by values in column A that appear more than once
->Raw Target:
df.groupby('A').filter(lambda x: len(x) > 1)
--

293=========
->Original Input:
unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`
->Original Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
->Reconstructed Target:
[x for x in myfile.splitlines() if x!= '']
->Reconstructed Predication:
.myfile.list.add(myfile.list.add(myfile.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.
->Raw Input:
summarize:append each line in file myfile into a list
->Raw Target:
[x for x in myfile.splitlines() if x!= '']
--

294=========
->Original Input:
unzip list `original`
->Original Target:
result = ([a for (a, b) in original], [b for (a, b) in original])
->Reconstructed Target:
lst = map(int, open('filename.txt').readlines())
->Reconstructed Predication:
lst.list().get(lst)
->Raw Input:
summarize:Get a list of integers lst from a file filename.txt
->Raw Target:
lst = map(int, open('filename.txt').readlines())
--

295=========
->Original Input:
unzip list `original` and return a generator
->Original Target:
result = ((a for (a, b) in original), (b for (a, b) in original))
->Reconstructed Target:
plt.colorbar(mappable=mappable, cax=ax3)
->Reconstructed Predication:
plt.add_colorbar(mappable)
->Raw Input:
summarize:add color bar with image mappable to plot plt
->Raw Target:
plt.colorbar(mappable=mappable, cax=ax3)
--

296=========
->Original Input:
unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]`
->Original Target:
zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
->Reconstructed Target:
Counter(' '.join(df['text']).split()).most_common(100)
->Reconstructed Predication:
df_text.count_100_words.text.count_100_words.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.df_text.d
->Raw Input:
summarize:count most frequent 100 words in column 'text' of dataframe df
->Raw Target:
Counter(' '.join(df['text']).split()).most_common(100)
--

297=========
->Original Input:
unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]` and fill empty results with None
->Original Target:
map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
->Reconstructed Target:
list(itertools.combinations((1, 2, 3), 2))
->Reconstructed Predication:
tuple(1, 2, 3)
->Raw Input:
summarize:generate all 2-element subsets of tuple (1, 2, 3)
->Raw Target:
list(itertools.combinations((1, 2, 3), 2))
--

298=========
->Original Input:
encode `Decimal('3.9')` to a JSON string
->Original Target:
json.dumps(Decimal('3.9'))
->Reconstructed Target:
datetime.now(pytz.utc)
->Reconstructed Predication:
datetime.today() in the UTC time zone
->Raw Input:
summarize:get a value of datetime.today() in the UTC time zone
->Raw Target:
datetime.now(pytz.utc)
--

299=========
->Original Input:
Add key "mynewkey" to dictionary `d` with value "mynewvalue"
->Original Target:
d['mynewkey'] = 'mynewvalue'
->Reconstructed Target:
list2 = [x for x in list1 if x!= []]
->Reconstructed Predication:
list2: Remove empty list from a list of lists list1
->Raw Input:
summarize:Get a new list list2by removing empty list from a list of lists list1
->Raw Target:
list2 = [x for x in list1 if x!= []]
--

300=========
->Original Input:
Add key 'a' to dictionary `data` with value 1
->Original Target:
data.update({'a': 1, })
->Reconstructed Target:
list2 = [x for x in list1 if x]
->Reconstructed Predication:
list2_list2_list1_list1_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2_list2
->Raw Input:
summarize:Create list2 to contain the lists from list list1 excluding the empty lists from list1
->Raw Target:
list2 = [x for x in list1 if x]
--

301=========
->Original Input:
Add key 'a' to dictionary `data` with value 1
->Original Target:
data.update(dict(a=1))
->Reconstructed Target:
return HttpResponse(data, mimetype='application/json')
->Reconstructed Predication:
django response with JSON data
->Raw Input:
summarize:Django response with JSON data
->Raw Target:
return HttpResponse(data, mimetype='application/json')
--

302=========
->Original Input:
Add key 'a' to dictionary `data` with value 1
->Original Target:
data.update(a=1)
->Reconstructed Target:
re.findall('(.*?)[.*?]', example_str)
->Reconstructed Predication:
'example_str'
->Raw Input:
summarize:get all text that is not enclosed within square brackets in string example_str
->Raw Target:
re.findall('(.*?)[.*?]', example_str)
--

303=========
->Original Input:
find maximal value in matrix `matrix`
->Original Target:
max([max(i) for i in matrix])
->Reconstructed Target:
re.findall('(.*?)(?:[.*?]|$)', example_str)
->Reconstructed Predication:
.example_str.get(example_str))
->Raw Input:
summarize:Use a regex to get all text in a string example_str that is not surrounded by square brackets
->Raw Target:
re.findall('(.*?)(?:[.*?]|$)', example_str)
--

304=========
->Original Input:
Round number `answer` to 2 precision after the decimal point
->Original Target:
answer = str(round(answer, 2))
->Reconstructed Target:
re.findall('(.+?)|w', '(zyx)bc')
->Reconstructed Predication:
'(zyx)bc'
->Raw Input:
summarize:get whatever is between parentheses as a single match, and any char outside as an individual match in string '(zyx)bc'
->Raw Target:
re.findall('(.+?)|w', '(zyx)bc')
--

305=========
->Original Input:
extract ip address from an html string
->Original Target:
ip = re.findall('[0-9]+(?:\\.[0-9]+){3}', s)
->Reconstructed Target:
re.findall('((.*?))|(w)', '(zyx)bc')
->Reconstructed Predication:
'(((.*?))|(w)'
->Raw Input:
summarize:match regex '((.*?))|(w)' with string '(zyx)bc'
->Raw Target:
re.findall('((.*?))|(w)', '(zyx)bc')
--

306=========
->Original Input:
filter dataframe `df` by values in column `A` that appear more than once
->Original Target:
df.groupby('A').filter(lambda x: len(x) > 1)
->Reconstructed Target:
re.findall('(.*?)|w', '(zyx)bc')
->Reconstructed Predication:
.match(zyx)bc)
->Raw Input:
summarize:match multiple regex patterns with the alternation operator | in a string (zyx)bc
->Raw Target:
re.findall('(.*?)|w', '(zyx)bc')
--

307=========
->Original Input:
append each line in file `myfile` into a list
->Original Target:
[x for x in myfile.splitlines() if x != '']
->Reconstructed Target:
elements = ['%0%'.format(element) for element in elements]
->Reconstructed Predication:
cin_list_elements.formate(%0%)
->Raw Input:
summarize:formate each string cin list elements into pattern '%0%'
->Raw Target:
elements = ['%0%'.format(element) for element in elements]
--

308=========
->Original Input:
Get a list of integers `lst` from a file `filename.txt`
->Original Target:
lst = map(int, open('filename.txt').readlines())
->Reconstructed Target:
subprocess.Popen(['background-process', 'arguments'])
->Reconstructed Predication:
'arguments'
->Raw Input:
summarize:Open a background process 'background-process' with arguments 'arguments'
->Raw Target:
subprocess.Popen(['background-process', 'arguments'])
--

309=========
->Original Input:
add color bar with image `mappable` to plot `plt`
->Original Target:
plt.colorbar(mappable=mappable, cax=ax3)
->Reconstructed Target:
[mydict[x] for x in mykeys]
->Reconstructed Predication:
list of keys'mykeys'
->Raw Input:
summarize:get list of values from dictionary'mydict' w.r.t. list of keys'mykeys'
->Raw Target:
[mydict[x] for x in mykeys]
--

310=========
->Original Input:
count most frequent 100 words in column 'text' of dataframe `df`
->Original Target:
Counter(' '.join(df['text']).split()).most_common(100)
->Reconstructed Target:
dict([('Name', 'Joe'), ('Age', 22)])
->Reconstructed Predication:
'Name', 'Joe', ('Age', 22)'
->Raw Input:
summarize:convert list [('Name', 'Joe'), ('Age', 22)] into a dictionary
->Raw Target:
dict([('Name', 'Joe'), ('Age', 22)])
--

311=========
->Original Input:
None
->Original Target:
re.findall('(.+?):(.+?)\\b ?', text)
->Reconstructed Target:
data.reshape(-1, j).mean(axis=1).reshape(data.shape[0], -1)
->Reconstructed Predication:
.average(data)
->Raw Input:
summarize:average each two columns of array data
->Raw Target:
data.reshape(-1, j).mean(axis=1).reshape(data.shape[0], -1)
--

312=========
->Original Input:
generate all 2-element subsets of tuple `(1, 2, 3)`
->Original Target:
list(itertools.combinations((1, 2, 3), 2))
->Reconstructed Target:
print(s.encode('unicode-escape').replace('"', '"'))
->Reconstructed Predication:
s('')
->Raw Input:
summarize:double backslash escape all double quotes in string s
->Raw Target:
print(s.encode('unicode-escape').replace('"', '"'))
--

313=========
->Original Input:
get a value of datetime.today() in the UTC time zone
->Original Target:
datetime.now(pytz.utc)
->Reconstructed Target:
re.split('(W+)', s)
->Reconstructed Predication:
.split('')
->Raw Input:
summarize:split a string into a list of words and whitespace
->Raw Target:
re.split('(W+)', s)
--

314=========
->Original Input:
Get a new list `list2`by removing empty list from a list of lists `list1`
->Original Target:
list2 = [x for x in list1 if x != []]
->Reconstructed Target:
i[1]: i[0] for i in list(myDictionary.items())
->Reconstructed Predication:
revers.reverse.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.revers.re
->Raw Input:
summarize:reverse the keys and values in a dictionary myDictionary
->Raw Target:
i[1]: i[0] for i in list(myDictionary.items())
--

315=========
->Original Input:
Create `list2` to contain the lists from list `list1` excluding the empty lists from `list1`
->Original Target:
list2 = [x for x in list1 if x]
->Reconstructed Target:
[i for i, j in enumerate(myList) if 'how' in j.lower() or 'what' in j.lower()]
->Reconstructed Predication:
'how' and 'what' in a list of strings'myList'
->Raw Input:
summarize:finding the index of elements containing substring 'how' and 'what' in a list of strings'myList'.
->Raw Target:
[i for i, j in enumerate(myList) if 'how' in j.lower() or 'what' in j.lower()]
--

316=========
->Original Input:
Django response with JSON `data`
->Original Target:
return HttpResponse(data, mimetype='application/json')
->Reconstructed Target:
isinstance(obj, str)
->Reconstructed Predication:
object obj is a string.
->Raw Input:
summarize:check if object obj is a string
->Raw Target:
isinstance(obj, str)
--

317=========
->Original Input:
get all text that is not enclosed within square brackets in string `example_str`
->Original Target:
re.findall('(.*?)\\[.*?\\]', example_str)
->Reconstructed Target:
isinstance(o, str)
->Reconstructed Predication:
object o is a string.
->Raw Input:
summarize:check if object o is a string
->Raw Target:
isinstance(o, str)
--

318=========
->Original Input:
Use a regex to get all text in a string `example_str` that is not surrounded by square brackets
->Original Target:
re.findall('(.*?)(?:\\[.*?\\]|$)', example_str)
->Reconstructed Target:
(type(o) is str)
->Reconstructed Predication:
object o is a string.
->Raw Input:
summarize:check if object o is a string
->Raw Target:
(type(o) is str)
--

319=========
->Original Input:
get whatever is between parentheses as a single match, and any char outside as an individual match in string '(zyx)bc'
->Original Target:
re.findall('\\(.+?\\)|\\w', '(zyx)bc')
->Reconstructed Target:
isinstance(o, str)
->Reconstructed Predication:
object o is a string.
->Raw Input:
summarize:check if object o is a string
->Raw Target:
isinstance(o, str)
--

320=========
->Original Input:
match regex '\\((.*?)\\)|(\\w)' with string '(zyx)bc'
->Original Target:
re.findall('\\((.*?)\\)|(\\w)', '(zyx)bc')
->Reconstructed Target:
isinstance(obj_to_test, str)
->Reconstructed Predication:
obj_to_test.check.obj_to_test.check.obj_to_test.check.obj_to_test.check.obj_to_test.check.obj_to_test.check.obj_to_test.check.obj_to_test.check.obj_to_test.check.obj_to_test.check.obj_to_test.check.ob
->Raw Input:
summarize:check if obj_to_test is a string
->Raw Target:
isinstance(obj_to_test, str)
--

321=========
->Original Input:
match multiple regex patterns with the alternation operator `|` in a string `(zyx)bc`
->Original Target:
re.findall('\\(.*?\\)|\\w', '(zyx)bc')
->Reconstructed Target:
list2.extend(list1)
->Reconstructed Predication:
.append list list1 to.list2
->Raw Input:
summarize:append list list1 to list2
->Raw Target:
list2.extend(list1)
--

322=========
->Original Input:
formate each string cin list `elements` into pattern '%{0}%'
->Original Target:
elements = ['%{0}%'.format(element) for element in elements]
->Reconstructed Target:
list1.extend(mylog)
->Reconstructed Predication:
.append list mylog to.list1
->Raw Input:
summarize:append list mylog to list1
->Raw Target:
list1.extend(mylog)
--

323=========
->Original Input:
Open a background process 'background-process' with arguments 'arguments'
->Original Target:
subprocess.Popen(['background-process', 'arguments'])
->Reconstructed Target:
c.extend(a)
->Reconstructed Predication:
a('a')
->Raw Input:
summarize:append list a to c
->Raw Target:
c.extend(a)
--

324=========
->Original Input:
get list of values from dictionary 'mydict' w.r.t. list of keys 'mykeys'
->Original Target:
[mydict[x] for x in mykeys]
->Reconstructed Target:
for line in mylog: list1.append(line)
->Reconstructed Predication:
'mylog'
->Raw Input:
summarize:append items in list mylog to list1
->Raw Target:
for line in mylog: list1.append(line)
--

325=========
->Original Input:
convert list `[('Name', 'Joe'), ('Age', 22)]` into a dictionary
->Original Target:
dict([('Name', 'Joe'), ('Age', 22)])
->Reconstructed Target:
b.append((a[0][0], a[0][2]))
->Reconstructed Predication:
'[0][0][0] [0][2]'
->Raw Input:
summarize:append a tuple of elements from list a with indexes '[0][0] [0][2]' to list b
->Raw Target:
b.append((a[0][0], a[0][2]))
--

326=========
->Original Input:
average each two columns of array `data`
->Original Target:
data.reshape(-1, j).mean(axis=1).reshape(data.shape[0], -1)
->Reconstructed Target:
app.config['SECRET_KEY'] = 'Your_secret_string'
->Reconstructed Predication:
'Your_secret_string'
->Raw Input:
summarize:Initialize SECRET_KEY in flask config with Your_secret_string 
->Raw Target:
app.config['SECRET_KEY'] = 'Your_secret_string'
--

327=========
->Original Input:
double backslash escape all double quotes in string `s`
->Original Target:
print(s.encode('unicode-escape').replace('"', '\\"'))
->Reconstructed Target:
pd.DataFrame(out.tolist(), columns=['out-1', 'out-2'], index=out.index)
->Reconstructed Predication:
'out-1' and 'out-2'
->Raw Input:
summarize:unpack a series of tuples in pandas into a DataFrame with column names 'out-1' and 'out-2'
->Raw Target:
pd.DataFrame(out.tolist(), columns=['out-1', 'out-2'], index=out.index)
--

328=========
->Original Input:
split a string into a list of words and whitespace
->Original Target:
re.split('(\\W+)', s)
->Reconstructed Target:
[x for x in range(len(stocks_list)) if stocks_list[x] == 'MSFT']
->Reconstructed Predication:
index of an element 'MSFT' in a list.
->Raw Input:
summarize:find the index of an element 'MSFT' in a list stocks_list
->Raw Target:
[x for x in range(len(stocks_list)) if stocks_list[x] == 'MSFT']
--

329=========
->Original Input:
None
->Original Target:
df.plot(kind='barh', stacked=True)
->Reconstructed Target:
ax.set_xticklabels(labels, rotation=45)
->Reconstructed Predication:
xtick(ax) = 45 degrees, xtick(ax) = 45 degrees)
->Raw Input:
summarize:rotate the xtick labels of matplotlib plot ax by 45 degrees to make long labels readable
->Raw Target:
ax.set_xticklabels(labels, rotation=45)
--

330=========
->Original Input:
reverse the keys and values in a dictionary `myDictionary`
->Original Target:
{i[1]: i[0] for i in list(myDictionary.items())}
->Reconstructed Target:
re.sub('[w]','', s)
->Reconstructed Predication:
s.remove(s)
->Raw Input:
summarize:remove symbols from a string s
->Raw Target:
re.sub('[w]','', s)
--

331=========
->Original Input:
finding the index of elements containing substring 'how' and 'what' in a list of strings 'myList'.
->Original Target:
[i for i, j in enumerate(myList) if 'how' in j.lower() or 'what' in j.lower()]
->Reconstructed Target:
os.path.basename(os.path.dirname(os.path.realpath(__file__)))
->Reconstructed Predication:
.get('')'')
->Raw Input:
summarize:Get the current directory of a script
->Raw Target:
os.path.basename(os.path.dirname(os.path.realpath(__file__)))
--

332=========
->Original Input:
check if object `obj` is a string
->Original Target:
isinstance(obj, str)
->Reconstructed Target:
print(re.findall("'[0-7]1,3'", str))
->Reconstructed Predication:
regex.str.match(str))
->Raw Input:
summarize:Find octal characters matches from a string str using regex
->Raw Target:
print(re.findall("'[0-7]1,3'", str))
--

333=========
->Original Input:
check if object `o` is a string
->Original Target:
isinstance(o, str)
->Reconstructed Target:
re.split('[ ](?=[A-Z]+b)', input)
->Reconstructed Predication:
'[ ](?=[A-Z]+b)'
->Raw Input:
summarize:split string input based on occurrences of regex pattern '[ ](?=[A-Z]+b)'
->Raw Target:
re.split('[ ](?=[A-Z]+b)', input)
--

334=========
->Original Input:
check if object `o` is a string
->Original Target:
(type(o) is str)
->Reconstructed Target:
re.split('[ ](?=[A-Z])', input)
->Reconstructed Predication:
'input'
->Raw Input:
summarize:Split string input at every space followed by an upper-case letter
->Raw Target:
re.split('[ ](?=[A-Z])', input)
--

335=========
->Original Input:
check if object `o` is a string
->Original Target:
isinstance(o, str)
->Reconstructed Target:
r = requests.post(url, files=files, headers=headers, data=data)
->Reconstructed Predication:
url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url url 
->Raw Input:
summarize:send multipart encoded file files to url url with headers headers and metadata data
->Raw Target:
r = requests.post(url, files=files, headers=headers, data=data)
--

336=========
->Original Input:
check if `obj_to_test` is a string
->Original Target:
isinstance(obj_to_test, str)
->Reconstructed Target:
open('filename', 'wb').write(bytes_)
->Reconstructed Predication:
python 3:write bytes bytes_ to a file filename
->Raw Input:
summarize:write bytes bytes_ to a file filename in python 3
->Raw Target:
open('filename', 'wb').write(bytes_)
--

337=========
->Original Input:
append list `list1` to `list2`
->Original Target:
list2.extend(list1)
->Reconstructed Target:
[dct[k] for k in lst]
->Reconstructed Predication:
dct_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list_
->Raw Input:
summarize:get a list from a list lst with values mapped into a dictionary dct
->Raw Target:
[dct[k] for k in lst]
--

338=========
->Original Input:
append list `mylog` to `list1`
->Original Target:
list1.extend(mylog)
->Reconstructed Target:
x.set_index('name').index.get_duplicates()
->Reconstructed Predication:
duplicate names in column 'name' of dataframe x.
->Raw Input:
summarize:find duplicate names in column 'name' of the dataframe x
->Raw Target:
x.set_index('name').index.get_duplicates()
--

339=========
->Original Input:
append list `a` to `c`
->Original Target:
c.extend(a)
->Reconstructed Target:
round(1.923328437452, 3)
->Reconstructed Predication:
float(1.923328437452)
->Raw Input:
summarize:truncate float 1.923328437452 to 3 decimal places
->Raw Target:
round(1.923328437452, 3)
--

340=========
->Original Input:
append items in list `mylog` to `list1`
->Original Target:
for line in mylog:
    list1.append(line)
->Reconstructed Target:
sorted(li, key=lambda x: datetime.strptime(x[1], '%d/%m/%Y'), reverse=True)
->Reconstructed Predication:
li:sort list based on the date value in second element of each list in list li
->Raw Input:
summarize:sort list li in descending order based on the date value in second element of each list in list li
->Raw Target:
sorted(li, key=lambda x: datetime.strptime(x[1], '%d/%m/%Y'), reverse=True)
--

341=========
->Original Input:
append a tuple of elements from list `a` with indexes '[0][0] [0][2]' to list `b`
->Original Target:
b.append((a[0][0], a[0][2]))
->Reconstructed Target:
ax.set_rlabel_position(135)
->Reconstructed Predication:
ax = 135 degrees.
->Raw Input:
summarize:place the radial ticks in plot ax at 135 degrees
->Raw Target:
ax.set_rlabel_position(135)
--

342=========
->Original Input:
Initialize `SECRET_KEY` in flask config with `Your_secret_string `
->Original Target:
app.config['SECRET_KEY'] = 'Your_secret_string'
->Reconstructed Target:
os.path.isabs(my_path)
->Reconstructed Predication:
.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path.my_path
->Raw Input:
summarize:check if path my_path is an absolute path
->Raw Target:
os.path.isabs(my_path)
--

343=========
->Original Input:
unpack a series of tuples in pandas into a DataFrame with column names 'out-1' and 'out-2'
->Original Target:
pd.DataFrame(out.tolist(), columns=['out-1', 'out-2'], index=out.index)
->Reconstructed Target:
len(list(yourdict.keys()))
->Reconstructed Predication:
yourdict''
->Raw Input:
summarize:get number of keys in dictionary yourdict
->Raw Target:
len(list(yourdict.keys()))
--

344=========
->Original Input:
find the index of an element 'MSFT' in a list `stocks_list`
->Original Target:
[x for x in range(len(stocks_list)) if stocks_list[x] == 'MSFT']
->Reconstructed Target:
len(set(open(yourdictfile).read().split()))
->Reconstructed Predication:
.count(yourdictfile)
->Raw Input:
summarize:count the number of keys in dictionary yourdictfile
->Raw Target:
len(set(open(yourdictfile).read().split()))
--

345=========
->Original Input:
rotate the xtick labels of matplotlib plot `ax` by `45` degrees to make long labels readable
->Original Target:
ax.set_xticklabels(labels, rotation=45)
->Reconstructed Target:
df.groupby('id').first()
->Reconstructed Predication:
id = 'id'.
->Raw Input:
summarize:pandas dataframe get first row of each group by 'id'
->Raw Target:
df.groupby('id').first()
--

346=========
->Original Input:
remove symbols from a string `s`
->Original Target:
re.sub('[^\\w]', ' ', s)
->Reconstructed Target:
pd.concat([df[0].apply(pd.Series), df[1]], axis=1)
->Reconstructed Predication:
.splits a list in first column into multiple columns keeping other columns as well in pandas data frame.splits a list in first column into multiple columns.splits a list in first column into multiple columns.splits a list in first column.splits a list in first column.splits a list in first column.splits a list in first column.splits a list in first column.splits
->Raw Input:
summarize:split a list in first column into multiple columns keeping other columns as well in pandas data frame
->Raw Target:
pd.concat([df[0].apply(pd.Series), df[1]], axis=1)
--

347=========
->Original Input:
Get the current directory of a script
->Original Target:
os.path.basename(os.path.dirname(os.path.realpath(__file__)))
->Reconstructed Target:
re.findall('src="js/(["]*bjqueryb["]*)"', data)
->Reconstructed Predication:
'src="js/(["]*bjqueryb["]*)'
->Raw Input:
summarize:extract attributes'src="js/(["]*bjqueryb["]*)"' from string data
->Raw Target:
re.findall('src="js/(["]*bjqueryb["]*)"', data)
--

348=========
->Original Input:
Find octal characters matches from a string `str` using regex
->Original Target:
print(re.findall("'\\\\[0-7]{1,3}'", str))
->Reconstructed Target:
sum(int(float(item)) for item in [_f for _f in ['', '3.4', '', '', '1.0'] if _f])
->Reconstructed Predication:
'', '3.4', '', '', '1.0'
->Raw Input:
summarize:Sum integers contained in strings in list ['', '3.4', '', '', '1.0']
->Raw Target:
sum(int(float(item)) for item in [_f for _f in ['', '3.4', '', '', '1.0'] if _f])
--

349=========
->Original Input:
split string `input` based on occurrences of regex pattern '[ ](?=[A-Z]+\\b)'
->Original Target:
re.split('[ ](?=[A-Z]+\\b)', input)
->Reconstructed Target:
subprocess.Popen(['c:Program FilesVMwareVMware Servervmware-cmd.bat'])
->Reconstructed Predication:
vmware-cmd.bat
->Raw Input:
summarize:Call a subprocess with arguments c:Program FilesVMwareVMware Servervmware-cmd.bat that may contain spaces
->Raw Target:
subprocess.Popen(['c:Program FilesVMwareVMware Servervmware-cmd.bat'])
--

350=========
->Original Input:
Split string `input` at every space followed by an upper-case letter
->Original Target:
re.split('[ ](?=[A-Z])', input)
->Reconstructed Target:
q.put((-n, n))
->Reconstructed Predication:
q:reverse a priority queue q
->Raw Input:
summarize:reverse a priority queue q in python without using classes
->Raw Target:
q.put((-n, n))
--

351=========
->Original Input:
send multipart encoded file `files` to url `url` with headers `headers` and metadata `data`
->Original Target:
r = requests.post(url, files=files, headers=headers, data=data)
->Reconstructed Target:
df['group'].plot(kind='bar', color=['r', 'g', 'b', 'r', 'g', 'b', 'r'])
->Reconstructed Predication:
df.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color.color
->Raw Input:
summarize:make a barplot of data in column group of dataframe df colour-coded according to list color
->Raw Target:
df['group'].plot(kind='bar', color=['r', 'g', 'b', 'r', 'g', 'b', 'r'])
--

352=========
->Original Input:
write bytes `bytes_` to a file `filename` in python 3
->Original Target:
open('filename', 'wb').write(bytes_)
->Reconstructed Target:
re.findall('([a-fA-Fd]32)', data)
->Reconstructed Predication:
regex pattern '([a-fA-Fd]32)'
->Raw Input:
summarize:find all matches of regex pattern '([a-fA-Fd]32)' in string data
->Raw Target:
re.findall('([a-fA-Fd]32)', data)
--

353=========
->Original Input:
get a list from a list `lst` with values mapped into a dictionary `dct`
->Original Target:
[dct[k] for k in lst]
->Reconstructed Target:
len(my_list)
->Reconstructed Predication:
'my_list'
->Raw Input:
summarize:Get the length of list my_list
->Raw Target:
len(my_list)
--

354=========
->Original Input:
find duplicate names in column 'name' of the dataframe `x`
->Original Target:
x.set_index('name').index.get_duplicates()
->Reconstructed Target:
len(l)
->Reconstructed Predication:
l(l)
->Raw Input:
summarize:Getting the length of array l
->Raw Target:
len(l)
--

355=========
->Original Input:
truncate float 1.923328437452 to 3 decimal places
->Original Target:
round(1.923328437452, 3)
->Reconstructed Target:
len(s)
->Reconstructed Predication:
s('s')
->Raw Input:
summarize:Getting the length of array s
->Raw Target:
len(s)
--

356=========
->Original Input:
sort list `li` in descending order based on the date value in second element of each list in list `li`
->Original Target:
sorted(li, key=lambda x: datetime.strptime(x[1], '%d/%m/%Y'), reverse=True)
->Reconstructed Target:
len(my_tuple)
->Reconstructed Predication:
my_tuple
->Raw Input:
summarize:Getting the length of my_tuple
->Raw Target:
len(my_tuple)
--

357=========
->Original Input:
place the radial ticks in plot `ax` at 135 degrees
->Original Target:
ax.set_rlabel_position(135)
->Reconstructed Target:
len(my_string)
->Reconstructed Predication:
Getting the length of my_string
->Raw Input:
summarize:Getting the length of my_string
->Raw Target:
len(my_string)
--

358=========
->Original Input:
check if path `my_path` is an absolute path
->Original Target:
os.path.isabs(my_path)
->Reconstructed Target:
"""a""".decode('string_escape')
->Reconstructed Predication:
remove escape character from string "a"
->Raw Input:
summarize:remove escape character from string "a"
->Raw Target:
"""a""".decode('string_escape')
--

359=========
->Original Input:
get number of keys in dictionary `yourdict`
->Original Target:
len(list(yourdict.keys()))
->Reconstructed Target:
"""obama""".replace('a', '%temp%').replace('b', 'a').replace('%temp%', 'b')
->Reconstructed Predication:
'obama' is a single pass.
->Raw Input:
summarize:replace each 'a' with 'b' and each 'b' with 'a' in the string 'obama' in a single pass.
->Raw Target:
"""obama""".replace('a', '%temp%').replace('b', 'a').replace('%temp%', 'b')
--

360=========
->Original Input:
count the number of keys in dictionary `yourdictfile`
->Original Target:
len(set(open(yourdictfile).read().split()))
->Reconstructed Target:
shutil.rmtree('/folder_name')
->Reconstructed Predication:
'/folder_name'
->Raw Input:
summarize:remove directory tree '/folder_name'
->Raw Target:
shutil.rmtree('/folder_name')
--

361=========
->Original Input:
pandas dataframe get first row of each group by 'id'
->Original Target:
df.groupby('id').first()
->Reconstructed Target:
data['weekday'] = data['my_dt'].apply(lambda x: x.weekday())
->Reconstructed Predication:
.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_weekday.dt_
->Raw Input:
summarize:create a new column weekday in pandas data frame data based on the values in column my_dt
->Raw Target:
data['weekday'] = data['my_dt'].apply(lambda x: x.weekday())
--

362=========
->Original Input:
split a list in first column  into multiple columns keeping other columns as well in pandas data frame
->Original Target:
pd.concat([df[0].apply(pd.Series), df[1]], axis=1)
->Reconstructed Target:
sorted(x, key=x.get, reverse=True)
->Reconstructed Predication:
x(x)
->Raw Input:
summarize:reverse sort Counter x by values
->Raw Target:
sorted(x, key=x.get, reverse=True)
--

363=========
->Original Input:
extract attributes 'src="js/([^"]*\\bjquery\\b[^"]*)"' from string `data`
->Original Target:
re.findall('src="js/([^"]*\\bjquery\\b[^"]*)"', data)
->Reconstructed Target:
sorted(list(x.items()), key=lambda pair: pair[1], reverse=True)
->Reconstructed Predication:
x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x 
->Raw Input:
summarize:reverse sort counter x by value
->Raw Target:
sorted(list(x.items()), key=lambda pair: pair[1], reverse=True)
--

364=========
->Original Input:
Sum integers contained in strings in list `['', '3.4', '', '', '1.0']`
->Original Target:
sum(int(float(item)) for item in [_f for _f in ['', '3.4', '', '', '1.0'] if _f])
->Reconstructed Target:
np.vstack((a, b))
->Reconstructed Predication:
'b', 'a', 'b', 'a'
->Raw Input:
summarize:append a numpy array 'b' to a numpy array 'a'
->Raw Target:
np.vstack((a, b))
--

365=========
->Original Input:
Call a subprocess with arguments `c:\\Program Files\\VMware\\VMware Server\\vmware-cmd.bat` that may contain spaces
->Original Target:
subprocess.Popen(['c:\\Program Files\\VMware\\VMware Server\\vmware-cmd.bat'])
->Reconstructed Target:
print(concatenate((a, b), axis=0))
->Reconstructed Predication:
numpy concatenates two arrays along the first axis a and b.
->Raw Input:
summarize:numpy concatenate two arrays a and b along the first axis
->Raw Target:
print(concatenate((a, b), axis=0))
--

366=========
->Original Input:
reverse a priority queue `q` in python without using classes
->Original Target:
q.put((-n, n))
->Reconstructed Target:
print(concatenate((a, b), axis=1))
->Reconstructed Predication:
numpy concatenates two arrays a and b along the second axis.
->Raw Input:
summarize:numpy concatenate two arrays a and b along the second axis
->Raw Target:
print(concatenate((a, b), axis=1))
--

367=========
->Original Input:
make a barplot of data in column `group` of dataframe `df` colour-coded according to list `color`
->Original Target:
df['group'].plot(kind='bar', color=['r', 'g', 'b', 'r', 'g', 'b', 'r'])
->Reconstructed Target:
c = np.r_[(a[None, :], b[None, :])]
->Reconstructed Predication:
numpy concatenates two arrays along the first axis a and b.
->Raw Input:
summarize:numpy concatenate two arrays a and b along the first axis
->Raw Target:
c = np.r_[(a[None, :], b[None, :])]
--

368=========
->Original Input:
find all matches of regex pattern '([a-fA-F\\d]{32})' in string `data`
->Original Target:
re.findall('([a-fA-F\\d]{32})', data)
->Reconstructed Target:
np.array((a, b))
->Reconstructed Predication:
numpy concatenates two arrays along the first axis a and b.
->Raw Input:
summarize:numpy concatenate two arrays a and b along the first axis
->Raw Target:
np.array((a, b))
--

369=========
->Original Input:
Get the length of list `my_list`
->Original Target:
len(my_list)
->Reconstructed Target:
print(socket.getaddrinfo('google.com', 80))
->Reconstructed Predication:
'google.com' ion port 80
->Raw Input:
summarize:fetch address information for host 'google.com' ion port 80
->Raw Target:
print(socket.getaddrinfo('google.com', 80))
--

370=========
->Original Input:
Getting the length of array `l`
->Original Target:
len(l)
->Reconstructed Target:
df.xs('sat', level='day', drop_level=False)
->Reconstructed Predication:
'day' ='sat'
->Raw Input:
summarize:add a column 'day' with value'sat' to dataframe df
->Raw Target:
df.xs('sat', level='day', drop_level=False)
--

371=========
->Original Input:
Getting the length of array `s`
->Original Target:
len(s)
->Reconstructed Target:
return HttpResponse('Unauthorized', status=401)
->Reconstructed Predication:
django::return(401 unauthorized)
->Raw Input:
summarize:return a 401 unauthorized in django
->Raw Target:
return HttpResponse('Unauthorized', status=401)
--

372=========
->Original Input:
Getting the length of `my_tuple`
->Original Target:
len(my_tuple)
->Reconstructed Target:
Flask(__name__, template_folder='wherever')
->Reconstructed Predication:
'wherever' is the default template.
->Raw Input:
summarize:Flask set folder 'wherever' as the default template folder
->Raw Target:
Flask(__name__, template_folder='wherever')
--

373=========
->Original Input:
Getting the length of `my_string`
->Original Target:
len(my_string)
->Reconstructed Target:
session.execute('INSERT INTO t1 (SELECT * FROM t2)')
->Reconstructed Predication:
t1 (SELECT * FROM t2)
->Raw Input:
summarize:How do I INSERT INTO t1 (SELECT * FROM t2) in SQLAlchemy?
->Raw Target:
session.execute('INSERT INTO t1 (SELECT * FROM t2)')
--

374=========
->Original Input:
remove escape character from string "\\a"
->Original Target:
"""\\a""".decode('string_escape')
->Reconstructed Target:
c2.sort(key=lambda row: row[2])
->Reconstructed Predication:
c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2 - c2
->Raw Input:
summarize:sort a list of lists 'c2' such that third row comes first
->Raw Target:
c2.sort(key=lambda row: row[2])
--

375=========
->Original Input:
replace each 'a' with 'b' and each 'b' with 'a' in the string 'obama' in a single pass.
->Original Target:
"""obama""".replace('a', '%temp%').replace('b', 'a').replace('%temp%', 'b')
->Reconstructed Target:
matplotlib.rc('font', **'sans-serif': 'Arial', 'family':'sans-serif')
->Reconstructed Predication:
.set font Arial to display non-ascii characters in matplotlib
->Raw Input:
summarize:set font Arial to display non-ascii characters in matplotlib
->Raw Target:
matplotlib.rc('font', **'sans-serif': 'Arial', 'family':'sans-serif')
--

376=========
->Original Input:
remove directory tree '/folder_name'
->Original Target:
shutil.rmtree('/folder_name')
->Reconstructed Target:
df['date'].apply(lambda x: x.toordinal())
->Reconstructed Predication:
df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date().df_date
->Raw Input:
summarize:Convert DateTime column 'date' of pandas dataframe 'df' to ordinal
->Raw Target:
df['date'].apply(lambda x: x.toordinal())
--

377=========
->Original Input:
create a new column `weekday` in pandas data frame `data` based on the values in column `my_dt`
->Original Target:
data['weekday'] = data['my_dt'].apply(lambda x: x.weekday())
->Reconstructed Target:
element.get_attribute('innerHTML')
->Reconstructed Predication:
html source of Selenium WebElement element
->Raw Input:
summarize:get html source of Selenium WebElement element
->Raw Target:
element.get_attribute('innerHTML')
--

378=========
->Original Input:
reverse sort Counter `x` by values
->Original Target:
sorted(x, key=x.get, reverse=True)
->Reconstructed Target:
df.index.get_loc('bob')
->Reconstructed Predication:
bob_key()('bob')
->Raw Input:
summarize:Get the integer location of a key bob in a pandas data frame
->Raw Target:
df.index.get_loc('bob')
--

379=========
->Original Input:
reverse sort counter `x` by value
->Original Target:
sorted(list(x.items()), key=lambda pair: pair[1], reverse=True)
->Reconstructed Target:
os.system('gnome-terminal -e 'bash -c "sudo apt-get update; exec bash"'')
->Reconstructed Predication:
'sudo apt-get update'
->Raw Input:
summarize:open a 'gnome' terminal from python script and run'sudo apt-get update' command.
->Raw Target:
os.system('gnome-terminal -e 'bash -c "sudo apt-get update; exec bash"'')
--

380=========
->Original Input:
append a numpy array 'b' to a numpy array 'a'
->Original Target:
np.vstack((a, b))
->Reconstructed Target:
my_dict.update('third_key': 1)
->Reconstructed Predication:
'third_key' and value 1
->Raw Input:
summarize:add an item with key 'third_key' and value 1 to an dictionary my_dict
->Raw Target:
my_dict.update('third_key': 1)
--

381=========
->Original Input:
numpy concatenate two arrays `a` and `b` along the first axis
->Original Target:
print(concatenate((a, b), axis=0))
->Reconstructed Target:
my_list = []
->Reconstructed Predication:
Array(declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_array.declare_arra
->Raw Input:
summarize:declare an array
->Raw Target:
my_list = []
--

382=========
->Original Input:
numpy concatenate two arrays `a` and `b` along the second axis
->Original Target:
print(concatenate((a, b), axis=1))
->Reconstructed Target:
my_list.append(12)
->Reconstructed Predication:
.list(12))
->Raw Input:
summarize:Insert item 12 to a list my_list
->Raw Target:
my_list.append(12)
--

383=========
->Original Input:
numpy concatenate two arrays `a` and `b` along the first axis
->Original Target:
c = np.r_[(a[None, :], b[None, :])]
->Reconstructed Target:
myList.insert(0, 'wuggah')
->Reconstructed Predication:
'wuggah' at the beginning of list'myList'
->Raw Input:
summarize:add an entry 'wuggah' at the beginning of list myList
->Raw Target:
myList.insert(0, 'wuggah')
--

384=========
->Original Input:
numpy concatenate two arrays `a` and `b` along the first axis
->Original Target:
np.array((a, b))
->Reconstructed Target:
"""xF3xBEx80x80""".replace('x', '').decode('hex')
->Reconstructed Predication:
hex-string.convert('')
->Raw Input:
summarize:convert a hex-string representation to actual bytes
->Raw Target:
"""xF3xBEx80x80""".replace('x', '').decode('hex')
--

385=========
->Original Input:
fetch address information for host 'google.com' ion port 80
->Original Target:
print(socket.getaddrinfo('google.com', 80))
->Reconstructed Target:
df[df.columns[-1]]
->Reconstructed Predication:
df_select_last_column_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last_df_last
->Raw Input:
summarize:select the last column of dataframe df
->Raw Target:
df[df.columns[-1]]
--

386=========
->Original Input:
add a column 'day' with value 'sat' to dataframe `df`
->Original Target:
df.xs('sat', level='day', drop_level=False)
->Reconstructed Target:
df.loc[df['Letters'] == 'C', 'Letters'].values[0]
->Reconstructed Predication:
'Letters' = 'C'
->Raw Input:
summarize:get the first value from dataframe df where column 'Letters' is equal to 'C'
->Raw Target:
df.loc[df['Letters'] == 'C', 'Letters'].values[0]
--

387=========
->Original Input:
return a 401 unauthorized in django
->Original Target:
return HttpResponse('Unauthorized', status=401)
->Reconstructed Target:
np.column_stack(([1, 2, 3], [4, 5, 6]))
->Reconstructed Predication:
converting two lists [1, 2, 3] and [4, 5, 6] into a matrix
->Raw Input:
summarize:converting two lists [1, 2, 3] and [4, 5, 6] into a matrix
->Raw Target:
np.column_stack(([1, 2, 3], [4, 5, 6]))
--

388=========
->Original Input:
Flask set folder 'wherever' as the default template folder
->Original Target:
Flask(__name__, template_folder='wherever')
->Reconstructed Target:
type(i)
->Reconstructed Predication:
i(i)
->Raw Input:
summarize:get the type of i
->Raw Target:
type(i)
--

389=========
->Original Input:
How do I INSERT INTO t1 (SELECT * FROM t2) in SQLAlchemy?
->Original Target:
session.execute('INSERT INTO t1 (SELECT * FROM t2)')
->Reconstructed Target:
type(v)
->Reconstructed Predication:
v(variable v)
->Raw Input:
summarize:determine the type of variable v
->Raw Target:
type(v)
--

390=========
->Original Input:
sort a list of lists 'c2' such that third row comes first
->Original Target:
c2.sort(key=lambda row: row[2])
->Reconstructed Target:
type(v)
->Reconstructed Predication:
v(variable v)
->Raw Input:
summarize:determine the type of variable v
->Raw Target:
type(v)
--

391=========
->Original Input:
None
->Original Target:
c2.sort(key=lambda row: (row[2], row[1], row[0]))
->Reconstructed Target:
type(v)
->Reconstructed Predication:
v(variable v)
->Raw Input:
summarize:determine the type of variable v
->Raw Target:
type(v)
--

392=========
->Original Input:
None
->Original Target:
c2.sort(key=lambda row: (row[2], row[1]))
->Reconstructed Target:
type(v)
->Reconstructed Predication:
v(variable v)
->Raw Input:
summarize:determine the type of variable v
->Raw Target:
type(v)
--

393=========
->Original Input:
set font `Arial` to display non-ascii characters in matplotlib
->Original Target:
matplotlib.rc('font', **{'sans-serif': 'Arial', 'family': 'sans-serif'})
->Reconstructed Target:
print(type(variable_name))
->Reconstructed Predication:
'variable_name'
->Raw Input:
summarize:get the type of variable variable_name
->Raw Target:
print(type(variable_name))
--

394=========
->Original Input:
Convert  DateTime column 'date' of pandas dataframe 'df' to ordinal
->Original Target:
df['date'].apply(lambda x: x.toordinal())
->Reconstructed Target:
next(itertools.islice(range(10), 5, 5 + 1))
->Reconstructed Predication:
generator.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th.get5th
->Raw Input:
summarize:get the 5th item of a generator
->Raw Target:
next(itertools.islice(range(10), 5, 5 + 1))
--

395=========
->Original Input:
get html source of Selenium WebElement `element`
->Original Target:
element.get_attribute('innerHTML')
->Reconstructed Target:
print('""'.format(word))
->Reconstructed Predication:
'word'
->Raw Input:
summarize:Print a string word with string format
->Raw Target:
print('""'.format(word))
--

396=========
->Original Input:
Get the integer location of a key `bob` in a pandas data frame
->Original Target:
df.index.get_loc('bob')
->Reconstructed Target:
""" """.join(list)
->Reconstructed Predication:
'list'
->Raw Input:
summarize:join a list of strings list using a space''
->Raw Target:
""" """.join(list)
--

397=========
->Original Input:
open a 'gnome' terminal from python script and run  'sudo apt-get update' command.
->Original Target:
os.system('gnome-terminal -e \'bash -c "sudo apt-get update; exec bash"\'')
->Reconstructed Target:
y = [[] for n in range(2)]
->Reconstructed Predication:
y_list_create_list_y_list_y_list_create_list_y_list_y_list_create_list_y_list_y_list_create_list_y_list_y_list_create_list_y_list_y_list_create_list_y_list_y_list_y_list_create_list_y_list_y_list_y_list_y_list_y_list_y_list_y_list_
->Raw Input:
summarize:create list y containing two empty lists
->Raw Target:
y = [[] for n in range(2)]
--

398=========
->Original Input:
add an item with key 'third_key' and value 1 to an dictionary `my_dict`
->Original Target:
my_dict.update({'third_key': 1})
->Reconstructed Target:
data = [line.strip() for line in open('C:/name/MyDocuments/numbers', 'r')]
->Reconstructed Predication:
'name/MyDocuments/numbers'
->Raw Input:
summarize:read a file 'C:/name/MyDocuments/numbers' into a list data
->Raw Target:
data = [line.strip() for line in open('C:/name/MyDocuments/numbers', 'r')]
--

399=========
->Original Input:
declare an array
->Original Target:
my_list = []
->Reconstructed Target:
"""""".join([char for char in 'it is icy' if char!= 'i'])
->Reconstructed Predication:
'it is icy'
->Raw Input:
summarize:delete all occurrences of character 'i' in string 'it is icy'
->Raw Target:
"""""".join([char for char in 'it is icy' if char!= 'i'])
--

400=========
->Original Input:
Insert item `12` to a list `my_list`
->Original Target:
my_list.append(12)
->Reconstructed Target:
re.sub('i', '', 'it is icy')
->Reconstructed Predication:
'it is icy' is a character that is a character in a string.
->Raw Input:
summarize:delete all instances of a character 'i' in a string 'it is icy'
->Raw Target:
re.sub('i', '', 'it is icy')
--

401=========
->Original Input:
add an entry 'wuggah' at the beginning of list `myList`
->Original Target:
myList.insert(0, 'wuggah')
->Reconstructed Target:
"""it is icy""".replace('i', '')
->Reconstructed Predication:
i(it is icy)
->Raw Input:
summarize:delete all characters "i" in string "it is icy"
->Raw Target:
"""it is icy""".replace('i', '')
--

402=========
->Original Input:
convert a hex-string representation to actual bytes
->Original Target:
"""\\xF3\\xBE\\x80\\x80""".replace('\\x', '').decode('hex')
->Reconstructed Target:
df.dropna(subset=[1])
->Reconstructed Predication:
df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.df.d
->Raw Input:
summarize:Drop rows of pandas dataframe df having NaN in column at index "1"
->Raw Target:
df.dropna(subset=[1])
--

403=========
->Original Input:
select the last column of dataframe `df`
->Original Target:
df[df.columns[-1]]
->Reconstructed Target:
[x for x in myList if x.n == 30]
->Reconstructed Predication:
n = 30
->Raw Input:
summarize:get elements from list myList, that have a field n value 30
->Raw Target:
[x for x in myList if x.n == 30]
--

404=========
->Original Input:
get the first value from dataframe `df` where column 'Letters' is equal to 'C'
->Original Target:
df.loc[df['Letters'] == 'C', 'Letters'].values[0]
->Reconstructed Target:
nums = [int(x) for x in intstringlist]
->Reconstructed Predication:
'intstringlist'
->Raw Input:
summarize:converting list of strings intstringlist to list of integer nums
->Raw Target:
nums = [int(x) for x in intstringlist]
--

405=========
->Original Input:
converting two lists `[1, 2, 3]` and `[4, 5, 6]` into a matrix
->Original Target:
np.column_stack(([1, 2, 3], [4, 5, 6]))
->Reconstructed Target:
map(int, eval(input('Enter the unfriendly numbers: ')))
->Reconstructed Predication:
.list(string(string(string))))
->Raw Input:
summarize:convert list of string numbers into list of integers
->Raw Target:
map(int, eval(input('Enter the unfriendly numbers: ')))
--

406=========
->Original Input:
get the type of `i`
->Original Target:
type(i)
->Reconstructed Target:
sys.stdout.write('.')
->Reconstructed Predication:
print ". without newline
->Raw Input:
summarize:print "." without newline
->Raw Target:
sys.stdout.write('.')
--

407=========
->Original Input:
determine the type of variable `v`
->Original Target:
type(v)
->Reconstructed Target:
int(round(2.51 * 100))
->Reconstructed Predication:
float(2.52 * 100)
->Raw Input:
summarize:round off the float that is the product of 2.52 * 100 and convert it to an int
->Raw Target:
int(round(2.51 * 100))
--

408=========
->Original Input:
determine the type of variable `v`
->Original Target:
type(v)
->Reconstructed Target:
os.chdir('/mydir') for file in glob.glob('*.txt'): pass
->Reconstructed Predication:
.txt('.txt')
->Raw Input:
summarize:Find all files in directory "/mydir" with extension ".txt"
->Raw Target:
os.chdir('/mydir') for file in glob.glob('*.txt'): pass
--

409=========
->Original Input:
determine the type of variable `v`
->Original Target:
type(v)
->Reconstructed Target:
for file in os.listdir('/mydir'): if file.endswith('.txt'): pass
->Reconstructed Predication:
.txt('.txt')
->Raw Input:
summarize:Find all files in directory "/mydir" with extension ".txt"
->Raw Target:
for file in os.listdir('/mydir'): if file.endswith('.txt'): pass
--

410=========
->Original Input:
determine the type of variable `v`
->Original Target:
type(v)
->Reconstructed Target:
for (root, dirs, files) in os.walk('/mydir'): for file in files: if file.endswith('.txt'): pass
->Reconstructed Predication:
.txt('.txt')
->Raw Input:
summarize:Find all files in directory "/mydir" with extension ".txt"
->Raw Target:
for (root, dirs, files) in os.walk('/mydir'): for file in files: if file.endswith('.txt'): pass
--

411=========
->Original Input:
get the type of variable `variable_name`
->Original Target:
print(type(variable_name))
->Reconstructed Target:
df.plot(legend=False)
->Reconstructed Predication:
df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.dataframe.df.data
->Raw Input:
summarize:plot dataframe df without a legend
->Raw Target:
df.plot(legend=False)
--

412=========
->Original Input:
get the 5th item of a generator
->Original Target:
next(itertools.islice(range(10), 5, 5 + 1))
->Reconstructed Target:
for i in range(256): for j in range(256): ip = ('192.168.%d.%d' % (i, j)) print(ip)
->Reconstructed Predication:
loop through the IP address range "192.168.x.x"
->Raw Input:
summarize:loop through the IP address range "192.168.x.x"
->Raw Target:
for i in range(256): for j in range(256): ip = ('192.168.%d.%d' % (i, j)) print(ip)
--

413=========
->Original Input:
Print a string `word` with string format
->Original Target:
print('"{}"'.format(word))
->Reconstructed Target:
for (i, j) in product(list(range(256)), list(range(256))): pass
->Reconstructed Predication:
loop through the IP address range "192.168.x.x"
->Raw Input:
summarize:loop through the IP address range "192.168.x.x"
->Raw Target:
for (i, j) in product(list(range(256)), list(range(256))): pass
--

414=========
->Original Input:
join a list of strings `list` using a space ' '
->Original Target:
""" """.join(list)
->Reconstructed Target:
generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)
->Reconstructed Predication:
loop through the IP address range "192.168.x.x"
->Raw Input:
summarize:loop through the IP address range "192.168.x.x"
->Raw Target:
generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)
--

415=========
->Original Input:
create list `y` containing two empty lists
->Original Target:
y = [[] for n in range(2)]
->Reconstructed Target:
sum(1  i for i, b in enumerate(x) if b)
->Reconstructed Predication:
x('')
->Raw Input:
summarize:Sum the corresponding decimal values for binary values of each boolean element in list x
->Raw Target:
sum(1  i for i, b in enumerate(x) if b)
--

416=========
->Original Input:
read a file 'C:/name/MyDocuments/numbers' into a list `data`
->Original Target:
data = [line.strip() for line in open('C:/name/MyDocuments/numbers', 'r')]
->Reconstructed Target:
target.write('%rn%rn%rn' % (line1, line2, line3))
->Reconstructed Predication:
.write(line1,.line2 and.line3)
->Raw Input:
summarize:write multiple strings line1, line2 and line3 in one line in a file target
->Raw Target:
target.write('%rn%rn%rn' % (line1, line2, line3))
--

417=========
->Original Input:
delete all occurrences of character 'i' in string 'it is icy'
->Original Target:
"""""".join([char for char in 'it is icy' if char != 'i'])
->Reconstructed Target:
[y for x in data for y in (x if isinstance(x, list) else [x])]
->Reconstructed Predication:
.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data.data
->Raw Input:
summarize:Convert list of lists data into a flat list
->Raw Target:
[y for x in data for y in (x if isinstance(x, list) else [x])]
--

418=========
->Original Input:
delete all instances of a character 'i' in a string 'it is icy'
->Original Target:
re.sub('i', '', 'it is icy')
->Reconstructed Target:
print('foonbar'.encode('string_escape'))
->Reconstructed Predication:
new line character(foonbar)
->Raw Input:
summarize:Print new line character as n in a string foonbar
->Raw Target:
print('foonbar'.encode('string_escape'))
--

419=========
->Original Input:
delete all characters "i" in string "it is icy"
->Original Target:
"""it is icy""".replace('i', '')
->Reconstructed Target:
"""""".join(s.rsplit(',', 1))
->Reconstructed Predication:
',' in string's'
->Raw Input:
summarize:remove last comma character ',' in string s
->Raw Target:
"""""".join(s.rsplit(',', 1))
--

420=========
->Original Input:
None
->Original Target:
"""""".join([char for char in 'it is icy' if char != 'i'])
->Reconstructed Target:
(x[1:] + x[:-1]) / 2
->Reconstructed Predication:
x = x.calculates the mean of each element in array x.
->Raw Input:
summarize:calculate the mean of each element in array x with the element previous to it
->Raw Target:
(x[1:] + x[:-1]) / 2
--

421=========
->Original Input:
Drop rows of pandas dataframe `df` having NaN in column at index "1"
->Original Target:
df.dropna(subset=[1])
->Reconstructed Target:
x[:-1] + (x[1:] - x[:-1]) / 2
->Reconstructed Predication:
x = x.get(x)
->Raw Input:
summarize:get an array of the mean of each two consecutive values in numpy array x
->Raw Target:
x[:-1] + (x[1:] - x[:-1]) / 2
--

422=========
->Original Input:
get elements from list `myList`, that have a field `n` value 30
->Original Target:
[x for x in myList if x.n == 30]
->Reconstructed Target:
arr = numpy.fromiter(codecs.open('new.txt', encoding='utf-8'), dtype='U2')
->Reconstructed Predication:
.load(utf-8)
->Raw Input:
summarize:load data containing utf-8 from file new.txt into numpy array arr
->Raw Target:
arr = numpy.fromiter(codecs.open('new.txt', encoding='utf-8'), dtype='U2')
--

423=========
->Original Input:
converting list of strings `intstringlist` to list of integer `nums`
->Original Target:
nums = [int(x) for x in intstringlist]
->Reconstructed Target:
l = sorted(l, key=itemgetter('time'), reverse=True)
->Reconstructed Predication:
l(time)
->Raw Input:
summarize:reverse sort list of dicts l by value for key time
->Raw Target:
l = sorted(l, key=itemgetter('time'), reverse=True)
--

424=========
->Original Input:
convert list of string numbers into list of integers
->Original Target:
map(int, eval(input('Enter the unfriendly numbers: ')))
->Reconstructed Target:
l = sorted(l, key=lambda a: a['time'], reverse=True)
->Reconstructed Predication:
l(time)
->Raw Input:
summarize:Sort a list of dictionary l based on key time in descending order
->Raw Target:
l = sorted(l, key=lambda a: a['time'], reverse=True)
--

425=========
->Original Input:
print "." without newline
->Original Target:
sys.stdout.write('.')
->Reconstructed Target:
df.loc[df[0].str.contains('(Hel|Just)')]
->Reconstructed Predication:
df_get_rows()
->Raw Input:
summarize:get rows of dataframe df that match regex '(Hel|Just)'
->Raw Target:
df.loc[df[0].str.contains('(Hel|Just)')]
--

426=========
->Original Input:
round off the float that is the product of `2.52 * 100` and convert it to an int
->Original Target:
int(round(2.51 * 100))
->Reconstructed Target:
re.search('[(.*)]', your_string).group(1)
->Reconstructed Predication:
'[' and '''
->Raw Input:
summarize:find the string in your_string between two special characters "[" and "]"
->Raw Target:
re.search('[(.*)]', your_string).group(1)
--

427=========
->Original Input:
Find all files in directory "/mydir" with extension ".txt"
->Original Target:
os.chdir('/mydir')
for file in glob.glob('*.txt'):
    pass
->Reconstructed Target:
"""The big brown fox is brown""".count('brown')
->Reconstructed Predication:
'The big brown fox is brown'
->Raw Input:
summarize:count number of times string 'brown' occurred in string 'The big brown fox is brown'
->Raw Target:
"""The big brown fox is brown""".count('brown')
--

428=========
->Original Input:
Find all files in directory "/mydir" with extension ".txt"
->Original Target:
for file in os.listdir('/mydir'):
    if file.endswith('.txt'):
        pass
->Reconstructed Target:
json.loads(request.body)
->Reconstructed Predication:
dict(request.body)
->Raw Input:
summarize:decode json string request.body to python dict
->Raw Target:
json.loads(request.body)
--

429=========
->Original Input:
Find all files in directory "/mydir" with extension ".txt"
->Original Target:
for (root, dirs, files) in os.walk('/mydir'):
    for file in files:
        if file.endswith('.txt'):
            pass
->Reconstructed Target:
urllib.request.urlretrieve(url, file_name)
->Reconstructed Predication:
..file_name.save.file_name.save.file_name.save.file_name.save.file_name.save.file_name.save.file_name.save.file_name.save.file_name.save.file_name.save.file_name.save.file_name.save.file_name.save.file_name.sa
->Raw Input:
summarize:download the file from url url and save it under file file_name
->Raw Target:
urllib.request.urlretrieve(url, file_name)
--

430=========
->Original Input:
plot dataframe `df` without a legend
->Original Target:
df.plot(legend=False)
->Reconstructed Target:
text.split()
->Reconstructed Predication:
space.split(text)
->Raw Input:
summarize:split string text by space
->Raw Target:
text.split()
--

431=========
->Original Input:
loop through the IP address range "192.168.x.x"
->Original Target:
for i in range(256):
    for j in range(256):
        ip = ('192.168.%d.%d' % (i, j))
        print(ip)
->Reconstructed Target:
text.split(',')
->Reconstructed Predication:
split(text) by ","
->Raw Input:
summarize:split string text by ","
->Raw Target:
text.split(',')
--

432=========
->Original Input:
loop through the IP address range "192.168.x.x"
->Original Target:
for (i, j) in product(list(range(256)), list(range(256))):
    pass
->Reconstructed Target:
line.split()
->Reconstructed Predication:
.split(line) in a list.split(line) in a list.split(line) in a list.split(line) in a list.split(line) in a list.split(line) in a list.split(line) in a list.split(line) in a list.split(line) in a list.split(line) in a list.s
->Raw Input:
summarize:Split string line into a list by whitespace
->Raw Target:
line.split()
--

433=========
->Original Input:
loop through the IP address range "192.168.x.x"
->Original Target:
generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)
->Reconstructed Target:
[re.sub('(?!d).(?!d)','', i) for i in s]
->Reconstructed Predication:
'.' associated with ascii letters in list s with space '.
->Raw Input:
summarize:replace dot characters '.' associated with ascii letters in list s with space''
->Raw Target:
[re.sub('(?!d).(?!d)','', i) for i in s]
--

434=========
->Original Input:
Sum the corresponding decimal values for binary values of each boolean element in list `x`
->Original Target:
sum(1 << i for i, b in enumerate(x) if b)
->Reconstructed Target:
sorted(list_of_strings, key=lambda s: s.split(',')[1])
->Reconstructed Predication:
s(list_of_strings)
->Raw Input:
summarize:sort list list_of_strings based on second index of each string s
->Raw Target:
sorted(list_of_strings, key=lambda s: s.split(',')[1])
--

435=========
->Original Input:
write multiple strings `line1`, `line2` and `line3` in one line in a file `target`
->Original Target:
target.write('%r\n%r\n%r\n' % (line1, line2, line3))
->Reconstructed Target:
subprocess.check_call('vasp | tee tee_output', shell=True)
->Reconstructed Predication:
'|'
->Raw Input:
summarize:call multiple bash function vasp and tee tee_output using |
->Raw Target:
subprocess.check_call('vasp | tee tee_output', shell=True)
--

436=========
->Original Input:
Convert list of lists `data` into a flat list
->Original Target:
[y for x in data for y in (x if isinstance(x, list) else [x])]
->Reconstructed Target:
[element for element in lst if isinstance(element, int)]
->Reconstructed Predication:
lst.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.
->Raw Input:
summarize:eliminate all strings from list lst
->Raw Target:
[element for element in lst if isinstance(element, int)]
--

437=========
->Original Input:
Print new line character as `\n` in a string `foo\nbar`
->Original Target:
print('foo\nbar'.encode('string_escape'))
->Reconstructed Target:
[element for element in lst if not isinstance(element, str)]
->Reconstructed Predication:
lst_get(lst)
->Raw Input:
summarize:get all the elements except strings from the list 'lst'.
->Raw Target:
[element for element in lst if not isinstance(element, str)]
--

438=========
->Original Input:
remove last comma character ',' in string `s`
->Original Target:
"""""".join(s.rsplit(',', 1))
->Reconstructed Target:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])
->Reconstructed Predication:
.list_to_be_sorted.list_to_be_sorted.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name.name
->Raw Input:
summarize:Sort a list of dictionaries list_to_be_sorted by the value of the dictionary key name
->Raw Target:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])
--

439=========
->Original Input:
calculate the mean of each element in array `x` with the element previous to it
->Original Target:
(x[1:] + x[:-1]) / 2
->Reconstructed Target:
newlist = sorted(l, key=itemgetter('name'), reverse=True)
->Reconstructed Predication:
l_sort_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_name_
->Raw Input:
summarize:sort a list of dictionaries l by values in key name in descending order
->Raw Target:
newlist = sorted(l, key=itemgetter('name'), reverse=True)
--

440=========
->Original Input:
get an array of the mean of each two consecutive values in numpy array `x`
->Original Target:
x[:-1] + (x[1:] - x[:-1]) / 2
->Reconstructed Target:
""",""".join(trans['category'])
->Reconstructed Predication:
'category' in a list indexed with 'category' within a dictionary.
->Raw Input:
summarize:join together with "," elements inside a list indexed with 'category' within a dictionary trans
->Raw Target:
""",""".join(trans['category'])
--

441=========
->Original Input:
load data containing `utf-8` from file `new.txt` into numpy array `arr`
->Original Target:
arr = numpy.fromiter(codecs.open('new.txt', encoding='utf-8'), dtype='<U2')
->Reconstructed Target:
"""""".join(['A', 'B', 'C', 'D'])
->Reconstructed Predication:
'a', 'b', 'c', 'd'
->Raw Input:
summarize:concatenate array of strings ['A', 'B', 'C', 'D'] into a string
->Raw Target:
"""""".join(['A', 'B', 'C', 'D'])
--

442=========
->Original Input:
reverse sort list of dicts `l` by value for key `time`
->Original Target:
l = sorted(l, key=itemgetter('time'), reverse=True)
->Reconstructed Target:
json.load(urllib.request.urlopen('url'))
->Reconstructed Predication:
url(url)
->Raw Input:
summarize:get json data from restful service 'url'
->Raw Target:
json.load(urllib.request.urlopen('url'))
--

443=========
->Original Input:
Sort a list of dictionary `l` based on key `time` in descending order
->Original Target:
l = sorted(l, key=lambda a: a['time'], reverse=True)
->Reconstructed Target:
[x for x in sents if not x.startswith('@$t') and not x.startswith('#')]
->Reconstructed Predication:
..((@$t) or..#)
->Raw Input:
summarize:Remove all strings from a list a strings sents where the values starts with @$t or #
->Raw Target:
[x for x in sents if not x.startswith('@$t') and not x.startswith('#')]
--

444=========
->Original Input:
get rows of dataframe `df` that match regex '(Hel|Just)'
->Original Target:
df.loc[df[0].str.contains('(Hel|Just)')]
->Reconstructed Target:
Entry.objects.filter(pub_date__contains='08:00')
->Reconstructed Predication:
django_hour_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_str_st
->Raw Input:
summarize:django filter by hour
->Raw Target:
Entry.objects.filter(pub_date__contains='08:00')
--

445=========
->Original Input:
find the string in `your_string` between two special characters "[" and "]"
->Original Target:
re.search('\\[(.*)\\]', your_string).group(1)
->Reconstructed Target:
list.sort(key=lambda item: (item['points'], item['time']))
->Reconstructed Predication:
list('points')
->Raw Input:
summarize:sort a list of dictionary list first by key points and then by time
->Raw Target:
list.sort(key=lambda item: (item['points'], item['time']))
--

446=========
->Original Input:
None
->Original Target:
[d.strftime('%Y%m%d') for d in pandas.date_range('20130226', '20130302')]
->Reconstructed Target:
(t - datetime.datetime(1970, 1, 1)).total_seconds()
->Reconstructed Predication:
.datetime(1970, 1, 1) to seconds.
->Raw Input:
summarize:convert datetime object (1970, 1, 1) to seconds
->Raw Target:
(t - datetime.datetime(1970, 1, 1)).total_seconds()
--

447=========
->Original Input:
count number of times string 'brown' occurred in string 'The big brown fox is brown'
->Original Target:
"""The big brown fox is brown""".count('brown')
->Reconstructed Target:
re.sub('(_a)?.([.]*)$', '_suff.2', 'long.file.name.jpg')
->Reconstructed Predication:
.long.file.name.jpg
->Raw Input:
summarize:insert _suff before the file extension in long.file.name.jpg or replace _a with suff if it precedes the extension.
->Raw Target:
re.sub('(_a)?.([.]*)$', '_suff.2', 'long.file.name.jpg')
--

448=========
->Original Input:
decode json string `request.body` to python dict
->Original Target:
json.loads(request.body)
->Reconstructed Target:
import imp imp.reload(module)
->Reconstructed Predication:
reload a module module
->Raw Input:
summarize:reload a module module
->Raw Target:
import imp imp.reload(module)
--

449=========
->Original Input:
download the file from url `url` and save it under file `file_name`
->Original Target:
urllib.request.urlretrieve(url, file_name)
->Reconstructed Target:
struct.unpack('H', struct.pack('h', number))
->Reconstructed Predication:
'number'
->Raw Input:
summarize:Convert integer number into an unassigned integer
->Raw Target:
struct.unpack('H', struct.pack('h', number))
--

450=========
->Original Input:
split string `text` by space
->Original Target:
text.split()
->Reconstructed Target:
numlist = [float(x) for x in numlist]
->Reconstructed Predication:
float(int)
->Raw Input:
summarize:convert int values in list numlist to float
->Raw Target:
numlist = [float(x) for x in numlist]
--

451=========
->Original Input:
split string `text` by ","
->Original Target:
text.split(',')
->Reconstructed Target:
df.to_csv(filename, index=False)
->Reconstructed Predication:
df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df.write.df
->Raw Input:
summarize:write dataframe df, excluding index, to a csv file
->Raw Target:
df.to_csv(filename, index=False)
--

452=========
->Original Input:
Split string `line` into a list by whitespace
->Original Target:
line.split()
->Reconstructed Target:
json_data = json.loads(unescaped)
->Reconstructed Predication:
urllib.unescaped.json_data.unescaped.unescaped.json_data.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.unescaped.
->Raw Input:
summarize:convert a urllib unquoted string unescaped to a json data json_data
->Raw Target:
json_data = json.loads(unescaped)
--

453=========
->Original Input:
replace dot characters  '.' associated with ascii letters in list `s` with space ' '
->Original Target:
[re.sub('(?<!\\d)\\.(?!\\d)', ' ', i) for i in s]
->Reconstructed Target:
[chr(i) for i in range(127)]
->Reconstructed Predication:
..ascii.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.list.
->Raw Input:
summarize:Create a list containing all ascii characters as its elements
->Raw Target:
[chr(i) for i in range(127)]
--

454=========
->Original Input:
sort list `list_of_strings` based on second index of each string `s`
->Original Target:
sorted(list_of_strings, key=lambda s: s.split(',')[1])
->Reconstructed Target:
newFile.write(struct.pack('5B', *newFileBytes))
->Reconstructed Predication:
.write(newFileBytes)
->Raw Input:
summarize:write newFileBytes to a binary file newFile
->Raw Target:
newFile.write(struct.pack('5B', *newFileBytes))
--

455=========
->Original Input:
call multiple bash function vasp and tee tee_output using |
->Original Target:
subprocess.check_call('vasp | tee tee_output', shell=True)
->Reconstructed Target:
re.sub('[A-Z0-9]*(?![a-z])', '', string)
->Reconstructed Predication:
python regex - check for a capital letter with a following lowercase in string string
->Raw Input:
summarize:python regex - check for a capital letter with a following lowercase in string string
->Raw Target:
re.sub('[A-Z0-9]*(?![a-z])', '', string)
--

456=========
->Original Input:
eliminate all strings from list `lst`
->Original Target:
[element for element in lst if isinstance(element, int)]
->Reconstructed Target:
list(dict.keys())[-1]
->Reconstructed Predication:
dict('dict')
->Raw Input:
summarize:get the last key of dictionary dict
->Raw Target:
list(dict.keys())[-1]
--

457=========
->Original Input:
get all the elements except strings from the list 'lst'.
->Original Target:
[element for element in lst if not isinstance(element, str)]
->Reconstructed Target:
print('hi there', file=f)
->Reconstructed Predication:
f(hi there)
->Raw Input:
summarize:write line "hi there" to file f
->Raw Target:
print('hi there', file=f)
--

458=========
->Original Input:
Sort a list of dictionaries `list_to_be_sorted` by the value of the dictionary key `name`
->Original Target:
newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])
->Reconstructed Target:
f = open('myfile', 'w') f.write('hi theren') f.close()
->Reconstructed Predication:
.write(hi there) to file myfile
->Raw Input:
summarize:write line "hi there" to file myfile
->Raw Target:
f = open('myfile', 'w') f.write('hi theren') f.close()
--

459=========
->Original Input:
sort a list of dictionaries `l` by values in key `name` in descending order
->Original Target:
newlist = sorted(l, key=itemgetter('name'), reverse=True)
->Reconstructed Target:
with open('somefile.txt', 'a') as the_file: the_file.write('Hellon')
->Reconstructed Predication:
.write(Hello) to file somefile.txt
->Raw Input:
summarize:write line "Hello" to file somefile.txt
->Raw Target:
with open('somefile.txt', 'a') as the_file: the_file.write('Hellon')
--

460=========
->Original Input:
None
->Original Target:
list_of_dicts.sort(key=operator.itemgetter('name'))
->Reconstructed Target:
s.encode('iso-8859-15')
->Reconstructed Predication:
s(unicode): s(s)
->Raw Input:
summarize:convert unicode string s to ascii
->Raw Target:
s.encode('iso-8859-15')
--

461=========
->Original Input:
None
->Original Target:
list_of_dicts.sort(key=operator.itemgetter('age'))
->Reconstructed Target:
AuthorizedEmail.objects.filter(group=group).order_by('-added')[0]
->Reconstructed Predication:
'added' in model 'AuthorizedEmail'
->Raw Input:
summarize:Django get maximum value associated with field 'added' in model AuthorizedEmail
->Raw Target:
AuthorizedEmail.objects.filter(group=group).order_by('-added')[0]
--

462=========
->Original Input:
None
->Original Target:
df.groupby('prots').sum().sort('scores', ascending=False)
->Reconstructed Target:
re.findall('Test([0-9.]*[0-9]+)', text)
->Reconstructed Predication:
regex.text.findall('text')
->Raw Input:
summarize:Find all numbers and dots from a string text using regex
->Raw Target:
re.findall('Test([0-9.]*[0-9]+)', text)
--

463=========
->Original Input:
join together with "," elements inside a list indexed with 'category' within a dictionary `trans`
->Original Target:
""",""".join(trans['category'])
->Reconstructed Target:
re.findall('Test([d.]*d+)', text)
->Reconstructed Predication:
'text'
->Raw Input:
summarize:python regex to find all numbers and dots from 'text'
->Raw Target:
re.findall('Test([d.]*d+)', text)
--

464=========
->Original Input:
concatenate array of strings `['A', 'B', 'C', 'D']` into a string
->Original Target:
"""""".join(['A', 'B', 'C', 'D'])
->Reconstructed Target:
os.system('powershell.exe','script.ps1')
->Reconstructed Predication:
execute script'script.ps1' using 'powershell.exe'
->Raw Input:
summarize:execute script'script.ps1' using 'powershell.exe' shell
->Raw Target:
os.system('powershell.exe','script.ps1')
--

465=========
->Original Input:
get json data from restful service 'url'
->Original Target:
json.load(urllib.request.urlopen('url'))
->Reconstructed Target:
b.sort(key=lambda x: x[1][2])
->Reconstructed Predication:
b.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sort.tuple.sor
->Raw Input:
summarize:Sort a list of tuples b by third item in the tuple
->Raw Target:
b.sort(key=lambda x: x[1][2])
--

466=========
->Original Input:
Remove all strings from a list a strings `sents` where the values starts with `@$\t` or `#`
->Original Target:
[x for x in sents if not x.startswith('@$\t') and not x.startswith('#')]
->Reconstructed Target:
list(cf.get_range().get_keys())
->Reconstructed Predication:
pycassa::get a list of all keys in Cassandra database cf
->Raw Input:
summarize:get a list of all keys in Cassandra database cf with pycassa
->Raw Target:
list(cf.get_range().get_keys())
--

467=========
->Original Input:
django filter by hour
->Original Target:
Entry.objects.filter(pub_date__contains='08:00')
->Reconstructed Target:
datetime.datetime.now()
->Reconstructed Predication:
.datetime(datetime))
->Raw Input:
summarize:create a datetime with the current date & time
->Raw Target:
datetime.datetime.now()
--

468=========
->Original Input:
sort a list of dictionary `list` first by key `points` and then by `time`
->Original Target:
list.sort(key=lambda item: (item['points'], item['time']))
->Reconstructed Target:
next(i for i, x in enumerate(lst) if not isinstance(x, bool) and x == 1)
->Reconstructed Predication:
lst_index.get(1)
->Raw Input:
summarize:get the index of an integer 1 from a list lst if the list also contains boolean items
->Raw Target:
next(i for i, x in enumerate(lst) if not isinstance(x, bool) and x == 1)
--

469=========
->Original Input:
convert datetime object `(1970, 1, 1)` to seconds
->Original Target:
(t - datetime.datetime(1970, 1, 1)).total_seconds()
->Reconstructed Target:
a[:] = [(x - 13) for x in a]
->Reconstructed Predication:
a.subtract(13)
->Raw Input:
summarize:subtract 13 from every number in a list a
->Raw Target:
a[:] = [(x - 13) for x in a]
--

470=========
->Original Input:
insert `_suff` before the file extension in `long.file.name.jpg` or replace `_a` with `suff` if it precedes the extension.
->Original Target:
re.sub('(\\_a)?\\.([^\\.]*)$', '_suff.\\2', 'long.file.name.jpg')
->Reconstructed Target:
random.choice(os.listdir('C:'))
->Reconstructed Predication:
C:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:.c:
->Raw Input:
summarize:choose a random file from the directory contents of the C drive, C:
->Raw Target:
random.choice(os.listdir('C:'))
--

471=========
->Original Input:
reload a module `module`
->Original Target:
import imp
imp.reload(module)
->Reconstructed Target:
max(x.min(), x.max(), key=abs)
->Reconstructed Predication:
x = x.get(x)
->Raw Input:
summarize:get the highest element in absolute value in a numpy matrix x
->Raw Target:
max(x.min(), x.max(), key=abs)
--

472=========
->Original Input:
Convert integer `number` into an unassigned integer
->Original Target:
struct.unpack('H', struct.pack('h', number))
->Reconstructed Target:
re.findall('"(http.*?)"', s, re.MULTILINE | re.DOTALL)
->Reconstructed Predication:
s(urls)
->Raw Input:
summarize:Get all urls within text s
->Raw Target:
re.findall('"(http.*?)"', s, re.MULTILINE | re.DOTALL)
--

473=========
->Original Input:
convert int values in list `numlist` to float
->Original Target:
numlist = [float(x) for x in numlist]
->Reconstructed Target:
re.findall('http://[t][s"]+.html', document)
->Reconstructed Predication:
urls whose domain doesn't start with t match urls whose domain doesn't start with t from string document
->Raw Input:
summarize:match urls whose domain doesn't start with t from string document using regex
->Raw Target:
re.findall('http://[t][s"]+.html', document)
--

474=========
->Original Input:
write dataframe `df`, excluding index, to a csv file
->Original Target:
df.to_csv(filename, index=False)
->Reconstructed Target:
mystring.replace(' ', '!!').split('!')
->Reconstructed Predication:
'mystring'
->Raw Input:
summarize:split a string mystring considering the spaces''
->Raw Target:
mystring.replace(' ', '!!').split('!')
--

475=========
->Original Input:
convert a urllib unquoted string `unescaped` to a json data `json_data`
->Original Target:
json_data = json.loads(unescaped)
->Reconstructed Target:
open(path, 'r')
->Reconstructed Predication:
open file path with mode 'r'
->Raw Input:
summarize:open file path with mode 'r'
->Raw Target:
open(path, 'r')
--

476=========
->Original Input:
Create a list containing all ascii characters as its elements
->Original Target:
[chr(i) for i in range(127)]
->Reconstructed Target:
[[sum(item) for item in zip(*items)] for items in zip(*data)]
->Reconstructed Predication:
.data.sum(data.sum(data.sum(data.sum))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
->Raw Input:
summarize:sum elements at the same index in list data
->Raw Target:
[[sum(item) for item in zip(*items)] for items in zip(*data)]
--

477=========
->Original Input:
write `newFileBytes` to a binary file `newFile`
->Original Target:
newFile.write(struct.pack('5B', *newFileBytes))
->Reconstructed Target:
a[:, (np.newaxis)]
->Reconstructed Predication:
a.add(a)
->Raw Input:
summarize:add a new axis to array a
->Raw Target:
a[:, (np.newaxis)]
--
