1=========
->Original Input:
['def', 'print_summary', '(', 'status', ')', 'status_string', '=', 'status', '.', 'to_s', '.', 'humanize', '.', 'upcase', 'if', 'status', '==', ':success', 'heading', '(', '"Result: "', ',', 'status_string', ',', ':green', ')', 'level', '=', ':info', 'elsif', 'status', '==', ':timed_out', 'heading', '(', '"Result: "', ',', 'status_string', ',', ':yellow', ')', 'level', '=', ':fatal', 'else', 'heading', '(', '"Result: "', ',', 'status_string', ',', ':red', ')', 'level', '=', ':fatal', 'end', 'if', '(', 'actions_sentence', '=', 'summary', '.', 'actions_sentence', '.', 'presence', ')', 'public_send', '(', 'level', ',', 'actions_sentence', ')', 'blank_line', '(', 'level', ')', 'end', 'summary', '.', 'paragraphs', '.', 'each', 'do', '|', 'para', '|', 'msg_lines', '=', 'para', '.', 'split', '(', '"\\n"', ')', 'msg_lines', '.', 'each', '{', '|', 'line', '|', 'public_send', '(', 'level', ',', 'line', ')', '}', 'blank_line', '(', 'level', ')', 'unless', 'para', '==', 'summary', '.', 'paragraphs', '.', 'last', 'end', 'end']
->Original Target:
['Outputs', 'the', 'deferred', 'summary', 'information', 'saved', 'via']
->Reconstructed Target:
Outputs the deferred summary information saved via
->Reconstructed Predication:
summary.summary.
->Raw Input:
summarize:def print_summary ( status ) status_string = status. to_s. humanize. upcase if status == :success heading ( "Result: ", status_string, :green ) level = :info elsif status == :timed_out heading ( "Result: ", status_string, :yellow ) level = :fatal else heading ( "Result: ", status_string, :red ) level = :fatal end if ( actions_sentence = summary. actions_sentence. presence ) public_send ( level, actions_sentence ) blank_line ( level ) end summary. paragraphs. each do | para | msg_lines = para. split ( "\n" ) msg_lines. each { | line | public_send ( level, line ) } blank_line ( level ) unless para == summary. paragraphs. last end end
->Raw Target:
Outputs the deferred summary information saved via
--

2=========
->Original Input:
['def', 'find_bad_files_from_kubectl_output', '(', 'line', ')', 'line', '.', 'scan', '(', '%r{', '\\S', '\\.', '\\S', '}', ')', '.', 'each_with_object', '(', '[', ']', ')', 'do', '|', 'matches', ',', 'bad_files', '|', 'matches', '.', 'each', 'do', '|', 'path', '|', 'content', '=', 'File', '.', 'read', '(', 'path', ')', 'if', 'File', '.', 'file?', '(', 'path', ')', 'bad_files', '<<', '{', 'filename', ':', 'File', '.', 'basename', '(', 'path', ')', ',', 'err', ':', 'line', ',', 'content', ':', 'content', '}', 'end', 'end', 'end']
->Original Target:
['Inspect', 'the', 'file', 'referenced', 'in', 'the', 'kubectl', 'stderr', 'to', 'make', 'it', 'easier', 'for', 'developer', 'to', 'understand', 'what', 's', 'going', 'on']
->Reconstructed Target:
Inspect the file referenced in the kubectl stderr to make it easier for developer to understand what s going on
->Reconstructed Predication:
the files that are notthe files that are not
->Raw Input:
summarize:def find_bad_files_from_kubectl_output ( line ) line. scan ( %r{ \S \. \S } ). each_with_object ( [ ] ) do | matches, bad_files | matches. each do | path | content = File. read ( path ) if File. file? ( path ) bad_files << { filename : File. basename ( path ), err : line, content : content } end end end
->Raw Target:
Inspect the file referenced in the kubectl stderr to make it easier for developer to understand what s going on
--

3=========
->Original Input:
['def', 'confirm_ejson_keys_not_prunable', 'secret', '=', 'ejson_provisioner', '.', 'ejson_keys_secret', 'return', 'unless', 'secret', '.', 'dig', '(', '"metadata"', ',', '"annotations"', ',', 'KubernetesResource', '::', 'LAST_APPLIED_ANNOTATION', ')', '@logger', '.', 'error', '(', '"Deploy cannot proceed because protected resource "', '"Secret/#{EjsonSecretProvisioner::EJSON_KEYS_SECRET} would be pruned."', ')', 'raise', 'EjsonPrunableError', 'rescue', 'Kubectl', '::', 'ResourceNotFoundError', '=>', 'e', '@logger', '.', 'debug', '(', '"Secret/#{EjsonSecretProvisioner::EJSON_KEYS_SECRET} does not exist: #{e}"', ')', 'end']
->Original Target:
['make', 'sure', 'to', 'never', 'prune', 'the', 'ejson', '-', 'keys', 'secret']
->Reconstructed Target:
make sure to never prune the ejson - keys secret
->Reconstructed Predication:
the secret is not prunable
->Raw Input:
summarize:def confirm_ejson_keys_not_prunable secret = ejson_provisioner. ejson_keys_secret return unless secret. dig ( "metadata", "annotations", KubernetesResource :: LAST_APPLIED_ANNOTATION ) @logger. error ( "Deploy cannot proceed because protected resource " "Secret/#{EjsonSecretProvisioner::EJSON_KEYS_SECRET} would be pruned." ) raise EjsonPrunableError rescue Kubectl :: ResourceNotFoundError => e @logger. debug ( "Secret/#{EjsonSecretProvisioner::EJSON_KEYS_SECRET} does not exist: #{e}" ) end
->Raw Target:
make sure to never prune the ejson - keys secret
--

4=========
->Original Input:
['def', 'for_current_system', '(', 'compressors', ')', 'family', '=', 'Ohai', '[', '"platform_family"', ']', 'if', 'family', '==', '"mac_os_x"', 'if', 'compressors', '.', 'include?', '(', ':dmg', ')', 'return', 'DMG', 'end', 'if', 'compressors', '.', 'include?', '(', ':tgz', ')', 'return', 'TGZ', 'end', 'end', 'if', 'compressors', '.', 'include?', '(', ':tgz', ')', 'return', 'TGZ', 'else', 'log', '.', 'info', '(', 'log_key', ')', '{', '"No compressor defined for `#{family}\'."', '}', 'return', 'Null', 'end', 'end']
->Original Target:
['Determine', 'the', 'best', 'compressor', 'for', 'the', 'current', 'system', '.', 'This', 'method', 'returns', 'the', 'class', 'not', 'an', 'instance', 'of', 'the', 'class', '.']
->Reconstructed Target:
Determine the best compressor for the current system. This method returns the class not an instance of the class.
->Reconstructed Predication:
the current system compressors.
->Raw Input:
summarize:def for_current_system ( compressors ) family = Ohai [ "platform_family" ] if family == "mac_os_x" if compressors. include? ( :dmg ) return DMG end if compressors. include? ( :tgz ) return TGZ end end if compressors. include? ( :tgz ) return TGZ else log. info ( log_key ) { "No compressor defined for `#{family}'." } return Null end end
->Raw Target:
Determine the best compressor for the current system. This method returns the class not an instance of the class.
--

5=========
->Original Input:
['def', 'create_bff_file', 'shellout!', '(', '"sudo chown -Rh 0:0 #{File.join(staging_dir, project.install_dir.match(/^\\/?(\\w+)/).to_s)}"', ')', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Creating .bff file"', '}', 'shellout!', '(', '"sudo /usr/sbin/mkinstallp -d #{staging_dir} -T #{File.join(staging_dir, \'gen.template\')}"', ')', 'log', '.', 'debug', '(', 'log_key', ')', 'do', '"With .inventory file of:\\n"', '+', 'File', '.', 'read', '(', '"#{File.join( staging_dir, \'.info\', "#{safe_base_package_name}.inventory" )}"', ')', 'end', 'FileSyncer', '.', 'glob', '(', 'File', '.', 'join', '(', 'staging_dir', ',', '"tmp/*.bff"', ')', ')', '.', 'each', 'do', '|', 'bff', '|', 'copy_file', '(', 'bff', ',', 'File', '.', 'join', '(', 'Config', '.', 'package_dir', ',', 'create_bff_file_name', ')', ')', 'end', 'ensure', 'original_uid', '=', 'shellout!', '(', '"id -u"', ')', '.', 'stdout', '.', 'chomp', 'original_gid', '=', 'shellout!', '(', '"id -g"', ')', '.', 'stdout', '.', 'chomp', 'shellout!', '(', '"sudo chown -Rh #{original_uid}:#{original_gid} #{staging_dir}"', ')', 'end']
->Original Target:
['Create', 'the', 'bff', 'file', 'using', '+', 'mkinstallp', '+', '.']
->Reconstructed Target:
Create the bff file using + mkinstallp +.
->Reconstructed Predication:
. info ( log_key )"With.inventory file of:\n" +. info ( log_key )"With.inventory file of:\n" + FileSyncer.glob(File.join(staging_dir,"#{File.join(staging_dir, "tmp/bff"),"#{File.join(staging_dir, "tmp/bff", "tmp/bff")}" )
->Raw Input:
summarize:def create_bff_file shellout! ( "sudo chown -Rh 0:0 #{File.join(staging_dir, project.install_dir.match(/^\/?(\w+)/).to_s)}" ) log. info ( log_key ) { "Creating.bff file" } shellout! ( "sudo /usr/sbin/mkinstallp -d #{staging_dir} -T #{File.join(staging_dir, 'gen.template')}" ) log. debug ( log_key ) do "With.inventory file of:\n" + File. read ( "#{File.join( staging_dir, '.info', "#{safe_base_package_name}.inventory" )}" ) end FileSyncer. glob ( File. join ( staging_dir, "tmp/*.bff" ) ). each do | bff | copy_file ( bff, File. join ( Config. package_dir, create_bff_file_name ) ) end ensure original_uid = shellout! ( "id -u" ). stdout. chomp original_gid = shellout! ( "id -g" ). stdout. chomp shellout! ( "sudo chown -Rh #{original_uid}:#{original_gid} #{staging_dir}" ) end
->Raw Target:
Create the bff file using + mkinstallp +.
--

6=========
->Original Input:
['def', 'glob', '(', 'pattern', ')', 'pattern', '=', 'Pathname', '.', 'new', '(', 'pattern', ')', '.', 'cleanpath', '.', 'to_s', 'Dir', '.', 'glob', '(', 'pattern', ',', 'File', '::', 'FNM_DOTMATCH', ')', '.', 'sort', '.', 'reject', 'do', '|', 'file', '|', 'basename', '=', 'File', '.', 'basename', '(', 'file', ')', 'IGNORED_FILES', '.', 'include?', '(', 'basename', ')', 'end', 'end']
->Original Target:
['Glob', 'across', 'the', 'given', 'pattern', 'accounting', 'for', 'dotfiles', 'removing', 'Ruby', 's', 'dumb', 'idea', 'to', 'include', '+', '.', '+', 'and', '+', '..', '+', 'as', 'entries', '.']
->Reconstructed Target:
Glob across the given pattern accounting for dotfiles removing Ruby s dumb idea to include +. + and +.. + as entries.
->Reconstructed Predication:
the files that match the given
->Raw Input:
summarize:def glob ( pattern ) pattern = Pathname. new ( pattern ). cleanpath. to_s Dir. glob ( pattern, File :: FNM_DOTMATCH ). sort. reject do | file | basename = File. basename ( file ) IGNORED_FILES. include? ( basename ) end end
->Raw Target:
Glob across the given pattern accounting for dotfiles removing Ruby s dumb idea to include +. + and +.. + as entries.
--

7=========
->Original Input:
['def', 'sync', '(', 'source', ',', 'destination', ',', 'options', '=', '{', '}', ')', 'unless', 'File', '.', 'directory?', '(', 'source', ')', 'raise', 'ArgumentError', ',', '"`source\' must be a directory, but was a "', '"`#{File.ftype(source)}\'! If you just want to sync a file, use "', '"the `copy\' method instead."', 'end', 'source_files', '=', 'all_files_under', '(', 'source', ',', 'options', ')', 'FileUtils', '.', 'mkdir_p', '(', 'destination', ')', 'unless', 'File', '.', 'directory?', '(', 'destination', ')', 'source_files', '.', 'each', 'do', '|', 'source_file', '|', 'relative_path', '=', 'relative_path_for', '(', 'source_file', ',', 'source', ')', 'parent', '=', 'File', '.', 'join', '(', 'destination', ',', 'File', '.', 'dirname', '(', 'relative_path', ')', ')', 'FileUtils', '.', 'mkdir_p', '(', 'parent', ')', 'unless', 'File', '.', 'directory?', '(', 'parent', ')', 'case', 'File', '.', 'ftype', '(', 'source_file', ')', '.', 'to_sym', 'when', ':directory', 'FileUtils', '.', 'mkdir_p', '(', '"#{destination}/#{relative_path}"', ')', 'when', ':link', 'target', '=', 'File', '.', 'readlink', '(', 'source_file', ')', 'Dir', '.', 'chdir', '(', 'destination', ')', 'do', 'FileUtils', '.', 'ln_sf', '(', 'target', ',', '"#{destination}/#{relative_path}"', ')', 'end', 'when', ':file', 'source_stat', '=', 'File', '.', 'stat', '(', 'source_file', ')', 'if', 'hardlink?', 'source_stat', 'if', 'existing', '=', 'hardlink_sources', '[', '[', 'source_stat', '.', 'dev', ',', 'source_stat', '.', 'ino', ']', ']', 'FileUtils', '.', 'ln', '(', 'existing', ',', '"#{destination}/#{relative_path}"', ',', 'force', ':', 'true', ')', 'else', 'begin', 'FileUtils', '.', 'cp', '(', 'source_file', ',', '"#{destination}/#{relative_path}"', ')', 'rescue', 'Errno', '::', 'EACCES', 'FileUtils', '.', 'cp_r', '(', 'source_file', ',', '"#{destination}/#{relative_path}"', ',', 'remove_destination', ':', 'true', ')', 'end', 'hardlink_sources', '.', 'store', '(', '[', 'source_stat', '.', 'dev', ',', 'source_stat', '.', 'ino', ']', ',', '"#{destination}/#{relative_path}"', ')', 'end', 'else', 'begin', 'FileUtils', '.', 'cp', '(', 'source_file', ',', '"#{destination}/#{relative_path}"', ')', 'rescue', 'Errno', '::', 'EACCES', 'FileUtils', '.', 'cp_r', '(', 'source_file', ',', '"#{destination}/#{relative_path}"', ',', 'remove_destination', ':', 'true', ')', 'end', 'end', 'else', 'raise', '"Unknown file type: `File.ftype(source_file)\' at `#{source_file}\'!"', 'end', 'end', 'destination_files', '=', 'glob', '(', '"#{destination}/**/*"', ')', 'relative_source_files', '=', 'source_files', '.', 'map', 'do', '|', 'file', '|', 'relative_path_for', '(', 'file', ',', 'source', ')', 'end', 'relative_destination_files', '=', 'destination_files', '.', 'map', 'do', '|', 'file', '|', 'relative_path_for', '(', 'file', ',', 'destination', ')', 'end', 'extra_files', '=', 'relative_destination_files', '-', 'relative_source_files', 'extra_files', '.', 'each', 'do', '|', 'file', '|', 'FileUtils', '.', 'rm_rf', '(', 'File', '.', 'join', '(', 'destination', ',', 'file', ')', ')', 'end', 'true', 'end']
->Original Target:
['Copy', 'the', 'files', 'from', '+', 'source', '+', 'to', '+', 'destination', '+', 'while', 'removing', 'any', 'files', 'in', '+', 'destination', '+', 'that', 'are', 'not', 'present', 'in', '+', 'source', '+', '.']
->Reconstructed Target:
Copy the files from + source + to + destination + while removing any files in + destination + that are not present in + source +.
->Reconstructed Predication:
.source_files..source_files...source_files..source_files..source_files..source_files..source_files..source_files..source_files.source_files.source_files.source_files.source_files.source_files.source_files.source_
->Raw Input:
summarize:def sync ( source, destination, options = { } ) unless File. directory? ( source ) raise ArgumentError, "`source' must be a directory, but was a " "`#{File.ftype(source)}'! If you just want to sync a file, use " "the `copy' method instead." end source_files = all_files_under ( source, options ) FileUtils. mkdir_p ( destination ) unless File. directory? ( destination ) source_files. each do | source_file | relative_path = relative_path_for ( source_file, source ) parent = File. join ( destination, File. dirname ( relative_path ) ) FileUtils. mkdir_p ( parent ) unless File. directory? ( parent ) case File. ftype ( source_file ). to_sym when :directory FileUtils. mkdir_p ( "#{destination}/#{relative_path}" ) when :link target = File. readlink ( source_file ) Dir. chdir ( destination ) do FileUtils. ln_sf ( target, "#{destination}/#{relative_path}" ) end when :file source_stat = File. stat ( source_file ) if hardlink? source_stat if existing = hardlink_sources [ [ source_stat. dev, source_stat. ino ] ] FileUtils. ln ( existing, "#{destination}/#{relative_path}", force : true ) else begin FileUtils. cp ( source_file, "#{destination}/#{relative_path}" ) rescue Errno :: EACCES FileUtils. cp_r ( source_file, "#{destination}/#{relative_path}", remove_destination : true ) end hardlink_sources. store ( [ source_stat. dev, source_stat. ino ], "#{destination}/#{relative_path}" ) end else begin FileUtils. cp ( source_file, "#{destination}/#{relative_path}" ) rescue Errno :: EACCES FileUtils. cp_r ( source_file, "#{destination}/#{relative_path}", remove_destination : true ) end end else raise "Unknown file type: `File.ftype(source_file)' at `#{source_file}'!" end end destination_files = glob ( "#{destination}/**/*" ) relative_source_files = source_files. map do | file | relative_path_for ( file, source ) end relative_destination_files = destination_files. map do | file | relative_path_for ( file, destination
->Raw Target:
Copy the files from + source + to + destination + while removing any files in + destination + that are not present in + source +.
--

8=========
->Original Input:
['def', 'relative_path_for', '(', 'path', ',', 'parent', ')', 'Pathname', '.', 'new', '(', 'path', ')', '.', 'relative_path_from', '(', 'Pathname', '.', 'new', '(', 'parent', ')', ')', '.', 'to_s', 'end']
->Original Target:
['The', 'relative', 'path', 'of', 'the', 'given', '+', 'path', '+', 'to', 'the', '+', 'parent', '+', '.']
->Reconstructed Target:
The relative path of the given + path + to the + parent +.
->Reconstructed Predication:
path relative to parent path
->Raw Input:
summarize:def relative_path_for ( path, parent ) Pathname. new ( path ). relative_path_from ( Pathname. new ( parent ) ). to_s end
->Raw Target:
The relative path of the given + path + to the + parent +.
--

9=========
->Original Input:
['def', 'clean_disks', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Cleaning previously mounted disks"', '}', 'existing_disks', '=', 'shellout!', '(', '"mount | grep \\"/Volumes/#{volume_name}\\" | awk \'{print $1}\'"', ')', 'existing_disks', '.', 'stdout', '.', 'lines', '.', 'each', 'do', '|', 'existing_disk', '|', 'existing_disk', '.', 'chomp!', 'Omnibus', '.', 'logger', '.', 'debug', '(', 'log_key', ')', 'do', '"Detaching disk `#{existing_disk}\' before starting dmg packaging."', 'end', 'shellout!', '(', '"hdiutil detach \'#{existing_disk}\'"', ')', 'end', 'end']
->Original Target:
['Cleans', 'any', 'previously', 'left', 'over', 'mounted', 'disks', '.']
->Reconstructed Target:
Cleans any previously left over mounted disks.
->Reconstructed Predication:
the existing disks that havethe existing disks that have
->Raw Input:
summarize:def clean_disks log. info ( log_key ) { "Cleaning previously mounted disks" } existing_disks = shellout! ( "mount | grep \"/Volumes/#{volume_name}\" | awk '{print $1}'" ) existing_disks. stdout. lines. each do | existing_disk | existing_disk. chomp! Omnibus. logger. debug ( log_key ) do "Detaching disk `#{existing_disk}' before starting dmg packaging." end shellout! ( "hdiutil detach '#{existing_disk}'" ) end end
->Raw Target:
Cleans any previously left over mounted disks.
--

10=========
->Original Input:
['def', 'copy_assets_to_dmg', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Copying assets into dmg"', '}', 'FileSyncer', '.', 'glob', '(', '"#{resources_dir}/*"', ')', '.', 'each', 'do', '|', 'file', '|', 'FileUtils', '.', 'cp_r', '(', 'file', ',', '"/Volumes/#{volume_name}"', ')', 'end', 'end']
->Original Target:
['Copy', 'assets', 'to', 'dmg']
->Reconstructed Target:
Copy assets to dmg
->Reconstructed Predication:
copy assets to dmg
->Raw Input:
summarize:def copy_assets_to_dmg log. info ( log_key ) { "Copying assets into dmg" } FileSyncer. glob ( "#{resources_dir}/*" ). each do | file | FileUtils. cp_r ( file, "/Volumes/#{volume_name}" ) end end
->Raw Target:
Copy assets to dmg
--

11=========
->Original Input:
['def', 'write_transform_file', 'render_template', '(', 'resource_path', '(', '"doc-transform.erb"', ')', ',', 'destination', ':', 'transform_file', ',', 'variables', ':', '{', 'pathdir', ':', 'project', '.', 'install_dir', '.', 'split', '(', '"/"', ')', '[', '1', ']', ',', '}', ')', 'end']
->Original Target:
['A', 'set', 'of', 'transform', 'rules', 'that', 'pkgmogrify', 'will', 'apply', 'to', 'the', 'package', 'manifest', '.']
->Reconstructed Target:
A set of transform rules that pkgmogrify will apply to the package manifest.
->Reconstructed Predication:
end  def write_transform_file
->Raw Input:
summarize:def write_transform_file render_template ( resource_path ( "doc-transform.erb" ), destination : transform_file, variables : { pathdir : project. install_dir. split ( "/" ) [ 1 ], } ) end
->Raw Target:
A set of transform rules that pkgmogrify will apply to the package manifest.
--

12=========
->Original Input:
['def', 'write_pkg_metadata', 'render_template', '(', 'resource_path', '(', '"gen.manifestfile.erb"', ')', ',', 'destination', ':', 'pkg_metadata_file', ',', 'variables', ':', '{', 'name', ':', 'safe_base_package_name', ',', 'fmri_package_name', ':', 'fmri_package_name', ',', 'description', ':', 'project', '.', 'description', ',', 'summary', ':', 'project', '.', 'friendly_name', ',', 'arch', ':', 'safe_architecture', ',', '}', ')', 'if', 'symlinks_file', 'File', '.', 'open', '(', 'pkg_metadata_file', ',', '"a"', ')', 'do', '|', 'symlink', '|', 'symlink', '.', 'write', '(', 'render_symlinks', ')', 'end', 'end', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Rendered Template:\\n"', '+', 'File', '.', 'read', '(', 'pkg_metadata_file', ')', '}', 'end']
->Original Target:
['Generate', 'package', 'metadata']
->Reconstructed Target:
Generate package metadata
->Reconstructed Predication:
. write ( pkg_metadata_file )
->Raw Input:
summarize:def write_pkg_metadata render_template ( resource_path ( "gen.manifestfile.erb" ), destination : pkg_metadata_file, variables : { name : safe_base_package_name, fmri_package_name : fmri_package_name, description : project. description, summary : project. friendly_name, arch : safe_architecture, } ) if symlinks_file File. open ( pkg_metadata_file, "a" ) do | symlink | symlink. write ( render_symlinks ) end end log. debug ( log_key ) { "Rendered Template:\n" + File. read ( pkg_metadata_file ) } end
->Raw Target:
Generate package metadata
--

13=========
->Original Input:
['def', 'health_check_otool', 'current_library', '=', 'nil', 'bad_libs', '=', '{', '}', 'read_shared_libs', '(', '"find #{project.install_dir}/ -type f | egrep \'\\.(dylib|bundle)$\' | xargs otool -L"', ')', 'do', '|', 'line', '|', 'case', 'line', 'when', '/', '/', 'current_library', '=', 'Regexp', '.', 'last_match', '[', '1', ']', 'when', '/', '\\s', '\\(', '\\)', '/', 'linked', '=', 'Regexp', '.', 'last_match', '[', '1', ']', 'name', '=', 'File', '.', 'basename', '(', 'linked', ')', 'bad_libs', '=', 'check_for_bad_library', '(', 'bad_libs', ',', 'current_library', ',', 'name', ',', 'linked', ')', 'end', 'end', 'bad_libs', 'end']
->Original Target:
['Run', 'healthchecks', 'against', 'otool', '.']
->Reconstructed Target:
Run healthchecks against otool.
->Reconstructed Predication:
the current library and thethe current library and the
->Raw Input:
summarize:def health_check_otool current_library = nil bad_libs = { } read_shared_libs ( "find #{project.install_dir}/ -type f | egrep '\.(dylib|bundle)$' | xargs otool -L" ) do | line | case line when / / current_library = Regexp. last_match [ 1 ] when / \s \( \) / linked = Regexp. last_match [ 1 ] name = File. basename ( linked ) bad_libs = check_for_bad_library ( bad_libs, current_library, name, linked ) end end bad_libs end
->Raw Target:
Run healthchecks against otool.
--

14=========
->Original Input:
['def', 'health_check_aix', 'current_library', '=', 'nil', 'bad_libs', '=', '{', '}', 'read_shared_libs', '(', '"find #{project.install_dir}/ -type f | xargs file | grep \\"RISC System\\" | awk -F: \'{print $1}\' | xargs -n 1 ldd"', ')', 'do', '|', 'line', '|', 'case', 'line', 'when', '/', '/', 'current_library', '=', 'Regexp', '.', 'last_match', '[', '1', ']', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Analyzing dependencies for #{current_library}"', '}', 'when', '/', '\\s', '/', 'name', '=', 'Regexp', '.', 'last_match', '[', '1', ']', 'linked', '=', 'Regexp', '.', 'last_match', '[', '1', ']', 'bad_libs', '=', 'check_for_bad_library', '(', 'bad_libs', ',', 'current_library', ',', 'name', ',', 'linked', ')', 'when', '/', '/', 'else', 'log', '.', 'warn', '(', 'log_key', ')', '{', '"Line did not match for #{current_library}\\n#{line}"', '}', 'end', 'end', 'bad_libs', 'end']
->Original Target:
['Run', 'healthchecks', 'against', 'aix', '.']
->Reconstructed Target:
Run healthchecks against aix.
->Reconstructed Predication:
the dependencies for the currentcurrent_librarycurrent_library ) { bad_libs.
->Raw Input:
summarize:def health_check_aix current_library = nil bad_libs = { } read_shared_libs ( "find #{project.install_dir}/ -type f | xargs file | grep \"RISC System\" | awk -F: '{print $1}' | xargs -n 1 ldd" ) do | line | case line when / / current_library = Regexp. last_match [ 1 ] log. debug ( log_key ) { "Analyzing dependencies for #{current_library}" } when / \s / name = Regexp. last_match [ 1 ] linked = Regexp. last_match [ 1 ] bad_libs = check_for_bad_library ( bad_libs, current_library, name, linked ) when / / else log. warn ( log_key ) { "Line did not match for #{current_library}\n#{line}" } end end bad_libs end
->Raw Target:
Run healthchecks against aix.
--

15=========
->Original Input:
['def', 'health_check_ldd', 'regexp_ends', '=', '".*("', '+', 'IGNORED_ENDINGS', '.', 'map', '{', '|', 'e', '|', 'e', '.', 'gsub', '(', '/', '\\.', '/', ',', "'\\.'", ')', '}', '.', 'join', '(', '"|"', ')', '+', '")$"', 'regexp_patterns', '=', 'IGNORED_PATTERNS', '.', 'map', '{', '|', 'e', '|', '".*"', '+', 'e', '.', 'gsub', '(', '/', '\\/', '/', ',', "'\\/'", ')', '+', '".*"', '}', '.', 'join', '(', '"|"', ')', 'regexp', '=', 'regexp_ends', '+', '"|"', '+', 'regexp_patterns', 'current_library', '=', 'nil', 'bad_libs', '=', '{', '}', 'read_shared_libs', '(', '"find #{project.install_dir}/ -type f -regextype posix-extended ! -regex \'#{regexp}\' | xargs ldd"', ')', 'do', '|', 'line', '|', 'case', 'line', 'when', '/', '/', 'current_library', '=', 'Regexp', '.', 'last_match', '[', '1', ']', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Analyzing dependencies for #{current_library}"', '}', 'when', '/', '\\s', '\\=', '\\>', '\\s', '\\(', '\\)', '/', 'name', '=', 'Regexp', '.', 'last_match', '[', '1', ']', 'linked', '=', 'Regexp', '.', 'last_match', '[', '2', ']', 'bad_libs', '=', 'check_for_bad_library', '(', 'bad_libs', ',', 'current_library', ',', 'name', ',', 'linked', ')', 'when', '/', '\\s', '\\(', '\\)', '/', 'next', 'when', '/', '\\s', '/', 'next', 'when', '/', '\\s', '/', 'next', 'when', '/', '\\s', '/', 'next', 'when', '/', '\\s', '/', 'next', 'when', '/', '\\s', '/', 'else', 'log', '.', 'warn', '(', 'log_key', ')', 'do', '"Line did not match for #{current_library}\\n#{line}"', 'end', 'end', 'end', 'bad_libs', 'end']
->Original Target:
['Run', 'healthchecks', 'against', 'ldd', '.']
->Reconstructed Target:
Run healthchecks against ldd.
->Reconstructed Predication:
the list ofthethe list ofthethe list ofthe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe
->Raw Input:
summarize:def health_check_ldd regexp_ends = ".*(" + IGNORED_ENDINGS. map { | e | e. gsub ( / \. /, '\.' ) }. join ( "|" ) + ")$" regexp_patterns = IGNORED_PATTERNS. map { | e | ".*" + e. gsub ( / \/ /, '\/' ) + ".*" }. join ( "|" ) regexp = regexp_ends + "|" + regexp_patterns current_library = nil bad_libs = { } read_shared_libs ( "find #{project.install_dir}/ -type f -regextype posix-extended! -regex '#{regexp}' | xargs ldd" ) do | line | case line when / / current_library = Regexp. last_match [ 1 ] log. debug ( log_key ) { "Analyzing dependencies for #{current_library}" } when / \s \= \> \s \( \) / name = Regexp. last_match [ 1 ] linked = Regexp. last_match [ 2 ] bad_libs = check_for_bad_library ( bad_libs, current_library, name, linked ) when / \s \( \) / next when / \s / next when / \s / next when / \s / next when / \s / next when / \s / else log. warn ( log_key ) do "Line did not match for #{current_library}\n#{line}" end end end bad_libs end
->Raw Target:
Run healthchecks against ldd.
--

16=========
->Original Input:
['def', 'read_shared_libs', '(', 'command', ')', 'cmd', '=', 'shellout', '(', 'command', ')', 'cmd', '.', 'stdout', '.', 'each_line', 'do', '|', 'line', '|', 'yield', 'line', 'end', 'end']
->Original Target:
['Execute', 'the', 'given', 'command', 'yielding', 'each', 'line', '.']
->Reconstructed Target:
Execute the given command yielding each line.
->Reconstructed Predication:
the shared libs
->Raw Input:
summarize:def read_shared_libs ( command ) cmd = shellout ( command ) cmd. stdout. each_line do | line | yield line end end
->Raw Target:
Execute the given command yielding each line.
--

17=========
->Original Input:
['def', 'check_for_bad_library', '(', 'bad_libs', ',', 'current_library', ',', 'name', ',', 'linked', ')', 'safe', '=', 'nil', 'whitelist_libs', '=', 'case', 'Ohai', '[', '"platform"', ']', 'when', '"arch"', 'ARCH_WHITELIST_LIBS', 'when', '"mac_os_x"', 'MAC_WHITELIST_LIBS', 'when', '"solaris2"', 'SOLARIS_WHITELIST_LIBS', 'when', '"smartos"', 'SMARTOS_WHITELIST_LIBS', 'when', '"freebsd"', 'FREEBSD_WHITELIST_LIBS', 'when', '"aix"', 'AIX_WHITELIST_LIBS', 'else', 'WHITELIST_LIBS', 'end', 'whitelist_libs', '.', 'each', 'do', '|', 'reg', '|', 'safe', '||=', 'true', 'if', 'reg', '.', 'match', '(', 'name', ')', 'end', 'whitelist_files', '.', 'each', 'do', '|', 'reg', '|', 'safe', '||=', 'true', 'if', 'reg', '.', 'match', '(', 'current_library', ')', 'end', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"  ', '}', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"  ', '}', 'if', '!', 'safe', '&&', 'linked', '!~', 'Regexp', '.', 'new', '(', 'project', '.', 'install_dir', ')', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"    -> FAILED: #{current_library} has unsafe dependencies"', '}', 'bad_libs', '[', 'current_library', ']', '||=', '{', '}', 'bad_libs', '[', 'current_library', ']', '[', 'name', ']', '||=', '{', '}', 'if', 'bad_libs', '[', 'current_library', ']', '[', 'name', ']', '.', 'key?', '(', 'linked', ')', 'bad_libs', '[', 'current_library', ']', '[', 'name', ']', '[', 'linked', ']', '+=', '1', 'else', 'bad_libs', '[', 'current_library', ']', '[', 'name', ']', '[', 'linked', ']', '=', '1', 'end', 'else', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"    -> PASSED: #{name} is either whitelisted or safely provided."', '}', 'end', 'bad_libs', 'end']
->Original Target:
['Check', 'the', 'given', 'path', 'and', 'library', 'for', 'bad', 'libraries', '.']
->Reconstructed Target:
Check the given path and library for bad libraries.
->Reconstructed Predication:
current_library ] [ name ]] = { }[ current_library ] [ name] = { }[ current_library ] [ name] = { }] [ linked ]] = { }[ current_library ] [ name] = { }] [ linked ]] = { }] [ name ]] = { }] [ linked ]] = { }] [ name ]
->Raw Input:
summarize:def check_for_bad_library ( bad_libs, current_library, name, linked ) safe = nil whitelist_libs = case Ohai [ "platform" ] when "arch" ARCH_WHITELIST_LIBS when "mac_os_x" MAC_WHITELIST_LIBS when "solaris2" SOLARIS_WHITELIST_LIBS when "smartos" SMARTOS_WHITELIST_LIBS when "freebsd" FREEBSD_WHITELIST_LIBS when "aix" AIX_WHITELIST_LIBS else WHITELIST_LIBS end whitelist_libs. each do | reg | safe ||= true if reg. match ( name ) end whitelist_files. each do | reg | safe ||= true if reg. match ( current_library ) end log. debug ( log_key ) { "   } log. debug ( log_key ) { "   } if! safe && linked!~ Regexp. new ( project. install_dir ) log. debug ( log_key ) { "    -> FAILED: #{current_library} has unsafe dependencies" } bad_libs [ current_library ] ||= { } bad_libs [ current_library ] [ name ] ||= { } if bad_libs [ current_library ] [ name ]. key? ( linked ) bad_libs [ current_library ] [ name ] [ linked ] += 1 else bad_libs [ current_library ] [ name ] [ linked ] = 1 end else log. debug ( log_key ) { "    -> PASSED: #{name} is either whitelisted or safely provided." } end bad_libs end
->Raw Target:
Check the given path and library for bad libraries.
--

18=========
->Original Input:
['def', 'digest', '(', 'path', ',', 'type', '=', ':md5', ')', 'digest', '=', 'digest_from_type', '(', 'type', ')', 'update_with_file_contents', '(', 'digest', ',', 'path', ')', 'digest', '.', 'hexdigest', 'end']
->Original Target:
['Calculate', 'the', 'digest', 'of', 'the', 'file', 'at', 'the', 'given', 'path', '.', 'Files', 'are', 'read', 'in', 'binary', 'chunks', 'to', 'prevent', 'Ruby', 'from', 'exploding', '.']
->Reconstructed Target:
Calculate the digest of the file at the given path. Files are read in binary chunks to prevent Ruby from exploding.
->Reconstructed Predication:
path : path type :
->Raw Input:
summarize:def digest ( path, type = :md5 ) digest = digest_from_type ( type ) update_with_file_contents ( digest, path ) digest. hexdigest end
->Raw Target:
Calculate the digest of the file at the given path. Files are read in binary chunks to prevent Ruby from exploding.
--

19=========
->Original Input:
['def', 'update_with_file_contents', '(', 'digest', ',', 'filename', ')', 'File', '.', 'open', '(', 'filename', ')', 'do', '|', 'io', '|', 'while', '(', 'chunk', '=', 'io', '.', 'read', '(', '1024', '*', '8', ')', ')', 'digest', '.', 'update', '(', 'chunk', ')', 'end', 'end', 'end']
->Original Target:
['Update', 'the', 'digest', 'with', 'the', 'given', 'contents', 'of', 'the', 'file', 'reading', 'in', 'small', 'chunks', 'to', 'reduce', 'memory', '.', 'This', 'method', 'will', 'update', 'the', 'given', '+', 'digest', '+', 'parameter', 'but', 'returns', 'nothing', '.']
->Reconstructed Target:
Update the digest with the given contents of the file reading in small chunks to reduce memory. This method will update the given + digest + parameter but returns nothing.
->Reconstructed Predication:
the file contents of the digest
->Raw Input:
summarize:def update_with_file_contents ( digest, filename ) File. open ( filename ) do | io | while ( chunk = io. read ( 1024 * 8 ) ) digest. update ( chunk ) end end end
->Raw Target:
Update the digest with the given contents of the file reading in small chunks to reduce memory. This method will update the given + digest + parameter but returns nothing.
--

20=========
->Original Input:
['def', 'packages', '@packages', '||=', 'begin', 'publish_packages', '=', 'Array', '.', 'new', 'build_packages', '=', 'FileSyncer', '.', 'glob', '(', '@pattern', ')', '.', 'map', '{', '|', 'path', '|', 'Package', '.', 'new', '(', 'path', ')', '}', 'if', '@options', '[', ':platform_mappings', ']', '@options', '[', ':platform_mappings', ']', '.', 'each_pair', 'do', '|', 'build_platform', ',', 'publish_platforms', '|', 'build_platform', ',', 'build_platform_version', '=', 'build_platform', '.', 'rpartition', '(', '"-"', ')', '-', '%w{', '-', '}', 'packages', '=', 'build_packages', '.', 'select', 'do', '|', 'p', '|', 'p', '.', 'metadata', '[', ':platform', ']', '==', 'build_platform', '&&', 'p', '.', 'metadata', '[', ':platform_version', ']', '==', 'build_platform_version', 'end', 'if', 'packages', '.', 'empty?', 'log', '.', 'warn', '(', 'log_key', ')', 'do', '"Could not locate a package for build platform #{build_platform}-#{build_platform_version}. "', '"Publishing will be skipped for: #{publish_platforms.join(\', \')}"', 'end', 'end', 'publish_platforms', '.', 'each', 'do', '|', 'publish_platform', '|', 'publish_platform', ',', 'publish_platform_version', '=', 'publish_platform', '.', 'rpartition', '(', '"-"', ')', '-', '%w{', '-', '}', 'packages', '.', 'each', 'do', '|', 'p', '|', 'publish_package', '=', 'p', '.', 'dup', 'publish_metadata', '=', 'p', '.', 'metadata', '.', 'dup', '.', 'to_hash', 'publish_metadata', '[', ':platform', ']', '=', 'publish_platform', 'publish_metadata', '[', ':platform_version', ']', '=', 'publish_platform_version', 'publish_package', '.', 'metadata', '=', 'Metadata', '.', 'new', '(', 'publish_package', ',', 'publish_metadata', ')', 'publish_packages', '<<', 'publish_package', 'end', 'end', 'end', 'else', 'publish_packages', '.', 'concat', '(', 'build_packages', ')', 'end', 'if', 'publish_packages', '.', 'empty?', 'log', '.', 'info', '(', 'log_key', ')', '{', '"No packages found, skipping publish"', '}', 'end', 'publish_packages', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'publisher', 'from', 'the', 'given', 'pattern', '.']
->Reconstructed Target:
Create a new publisher from the given pattern.
->Reconstructed Predication:
packages. info ( log_key )packagepackage metadata forpackage metadata forpackage metadata for platform #{build_platform}-#{build_platform_version}. "package metadata for platform #{build_platform}-#{build_platform_version}. "package metadata for platform #{build_platform}-#{build_platform_version}.package metadata for platform #{build_platform}-#{build_platform_version}.package metadata for platform #{build_
->Raw Input:
summarize:def packages @packages ||= begin publish_packages = Array. new build_packages = FileSyncer. glob ( @pattern ). map { | path | Package. new ( path ) } if @options [ :platform_mappings ] @options [ :platform_mappings ]. each_pair do | build_platform, publish_platforms | build_platform, build_platform_version = build_platform. rpartition ( "-" ) - %w{ - } packages = build_packages. select do | p | p. metadata [ :platform ] == build_platform && p. metadata [ :platform_version ] == build_platform_version end if packages. empty? log. warn ( log_key ) do "Could not locate a package for build platform #{build_platform}-#{build_platform_version}. " "Publishing will be skipped for: #{publish_platforms.join(', ')}" end end publish_platforms. each do | publish_platform | publish_platform, publish_platform_version = publish_platform. rpartition ( "-" ) - %w{ - } packages. each do | p | publish_package = p. dup publish_metadata = p. metadata. dup. to_hash publish_metadata [ :platform ] = publish_platform publish_metadata [ :platform_version ] = publish_platform_version publish_package. metadata = Metadata. new ( publish_package, publish_metadata ) publish_packages << publish_package end end end else publish_packages. concat ( build_packages ) end if publish_packages. empty? log. info ( log_key ) { "No packages found, skipping publish" } end publish_packages end end
->Raw Target:
Create a new publisher from the given pattern.
--

21=========
->Original Input:
['def', 'write_distribution_file', 'render_template', '(', 'resource_path', '(', '"distribution.xml.erb"', ')', ',', 'destination', ':', '"#{staging_dir}/Distribution"', ',', 'mode', ':', '0600', ',', 'variables', ':', '{', 'friendly_name', ':', 'project', '.', 'friendly_name', ',', 'identifier', ':', 'safe_identifier', ',', 'version', ':', 'safe_version', ',', 'component_pkg', ':', 'component_pkg', ',', '}', ')', 'end']
->Original Target:
['Write', 'the', 'Distribution', 'file', 'to', 'the', 'staging', 'area', '.', 'This', 'method', 'generates', 'the', 'content', 'of', 'the', 'Distribution', 'file', 'which', 'is', 'used', 'by', '+', 'productbuild', '+', 'to', 'select', 'the', 'component', 'packages', 'to', 'include', 'in', 'the', 'product', 'package', '.']
->Reconstructed Target:
Write the Distribution file to the staging area. This method generates the content of the Distribution file which is used by + productbuild + to select the component packages to include in the product package.
->Reconstructed Predication:
 def write_distribution_file
->Raw Input:
summarize:def write_distribution_file render_template ( resource_path ( "distribution.xml.erb" ), destination : "#{staging_dir}/Distribution", mode : 0600, variables : { friendly_name : project. friendly_name, identifier : safe_identifier, version : safe_version, component_pkg : component_pkg, } ) end
->Raw Target:
Write the Distribution file to the staging area. This method generates the content of the Distribution file which is used by + productbuild + to select the component packages to include in the product package.
--

22=========
->Original Input:
['def', 'artifact_for', '(', 'artifact', ')', 'md5', '=', 'artifact', '.', 'respond_to?', '(', ':metadata', ')', '?', 'artifact', '.', 'metadata', '[', ':md5', ']', ':', 'digest', '(', 'artifact', '.', 'path', ',', ':md5', ')', 'sha1', '=', 'artifact', '.', 'respond_to?', '(', ':metadata', ')', '?', 'artifact', '.', 'metadata', '[', ':sha1', ']', ':', 'digest', '(', 'artifact', '.', 'path', ',', ':sha1', ')', 'Artifactory', '::', 'Resource', '::', 'Artifact', '.', 'new', '(', 'local_path', ':', 'artifact', '.', 'path', ',', 'client', ':', 'client', ',', 'checksums', ':', '{', '"md5"', '=>', 'md5', ',', '"sha1"', '=>', 'sha1', ',', '}', ')', 'end']
->Original Target:
['The', 'artifact', 'object', 'that', 'corresponds', 'to', 'this', 'package', '.']
->Reconstructed Target:
The artifact object that corresponds to this package.
->Reconstructed Predication:
the artifact. paththe artifact. metadata.
->Raw Input:
summarize:def artifact_for ( artifact ) md5 = artifact. respond_to? ( :metadata )? artifact. metadata [ :md5 ] : digest ( artifact. path, :md5 ) sha1 = artifact. respond_to? ( :metadata )? artifact. metadata [ :sha1 ] : digest ( artifact. path, :sha1 ) Artifactory :: Resource :: Artifact. new ( local_path : artifact. path, client : client, checksums : { "md5" => md5, "sha1" => sha1, } ) end
->Raw Target:
The artifact object that corresponds to this package.
--

23=========
->Original Input:
['def', 'build_for', '(', 'packages', ')', 'metadata', '=', 'packages', '.', 'first', '.', 'metadata', 'name', '=', 'metadata', '[', ':name', ']', 'manifest', '=', 'if', 'version_manifest', '=', 'metadata', '[', ':version_manifest', ']', 'Manifest', '.', 'from_hash', '(', 'version_manifest', ')', 'else', 'Manifest', '.', 'new', '(', 'metadata', '[', ':version', ']', ',', 'nil', ',', 'metadata', '[', ':license', ']', ')', 'end', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Saving build info for #{name}, Build ##{manifest.build_version}"', '}', 'Artifactory', '::', 'Resource', '::', 'Build', '.', 'new', '(', 'client', ':', 'client', ',', 'name', ':', 'name', ',', 'number', ':', 'manifest', '.', 'build_version', ',', 'vcs_revision', ':', 'manifest', '.', 'build_git_revision', ',', 'build_agent', ':', '{', 'name', ':', '"omnibus"', ',', 'version', ':', 'Omnibus', '::', 'VERSION', ',', '}', ',', 'modules', ':', '[', '{', 'id', ':', '[', 'Config', '.', 'artifactory_base_path', '.', 'tr', '(', '"/"', ',', '"."', ')', ',', 'name', ',', 'manifest', '.', 'build_version', ',', ']', '.', 'join', '(', '":"', ')', ',', 'artifacts', ':', 'packages', '.', 'map', 'do', '|', 'package', '|', '[', '{', 'type', ':', 'File', '.', 'extname', '(', 'package', '.', 'path', ')', '.', 'split', '(', '"."', ')', '.', 'last', ',', 'sha1', ':', 'package', '.', 'metadata', '[', ':sha1', ']', ',', 'md5', ':', 'package', '.', 'metadata', '[', ':md5', ']', ',', 'name', ':', 'package', '.', 'metadata', '[', ':basename', ']', ',', '}', ',', '{', 'type', ':', 'File', '.', 'extname', '(', 'package', '.', 'metadata', '.', 'path', ')', '.', 'split', '(', '"."', ')', '.', 'last', ',', 'sha1', ':', 'digest', '(', 'package', '.', 'metadata', '.', 'path', ',', ':sha1', ')', ',', 'md5', ':', 'digest', '(', 'package', '.', 'metadata', '.', 'path', ',', ':md5', ')', ',', 'name', ':', 'File', '.', 'basename', '(', 'package', '.', 'metadata', '.', 'path', ')', ',', '}', ',', ']', 'end', '.', 'flatten', ',', '}', ',', ']', ')', 'end']
->Original Target:
['The', 'build', 'object', 'that', 'corresponds', 'to', 'this', 'package', '.']
->Reconstructed Target:
The build object that corresponds to this package.
->Reconstructed Predication:
: name,: version,:::::::: manifest. build_git_revision,: manifest. build_git_revision,: manifest. build_git_revision,: manifest. build_git_revision,: manifest. build_git_revision,: manifest. build_git_revision,: manifest. build_git_revision,: manifest. build_
->Raw Input:
summarize:def build_for ( packages ) metadata = packages. first. metadata name = metadata [ :name ] manifest = if version_manifest = metadata [ :version_manifest ] Manifest. from_hash ( version_manifest ) else Manifest. new ( metadata [ :version ], nil, metadata [ :license ] ) end log. info ( log_key ) { "Saving build info for #{name}, Build ##{manifest.build_version}" } Artifactory :: Resource :: Build. new ( client : client, name : name, number : manifest. build_version, vcs_revision : manifest. build_git_revision, build_agent : { name : "omnibus", version : Omnibus :: VERSION, }, modules : [ { id : [ Config. artifactory_base_path. tr ( "/", "." ), name, manifest. build_version, ]. join ( ":" ), artifacts : packages. map do | package | [ { type : File. extname ( package. path ). split ( "." ). last, sha1 : package. metadata [ :sha1 ], md5 : package. metadata [ :md5 ], name : package. metadata [ :basename ], }, { type : File. extname ( package. metadata. path ). split ( "." ). last, sha1 : digest ( package. metadata. path, :sha1 ), md5 : digest ( package. metadata. path, :md5 ), name : File. basename ( package. metadata. path ), }, ] end. flatten, }, ] ) end
->Raw Target:
The build object that corresponds to this package.
--

24=========
->Original Input:
['def', 'client', '@client', '||=', 'Artifactory', '::', 'Client', '.', 'new', '(', 'endpoint', ':', 'Config', '.', 'artifactory_endpoint', ',', 'username', ':', 'Config', '.', 'artifactory_username', ',', 'password', ':', 'Config', '.', 'artifactory_password', ',', 'ssl_pem_file', ':', 'Config', '.', 'artifactory_ssl_pem_file', ',', 'ssl_verify', ':', 'Config', '.', 'artifactory_ssl_verify', ',', 'proxy_username', ':', 'Config', '.', 'artifactory_proxy_username', ',', 'proxy_password', ':', 'Config', '.', 'artifactory_proxy_password', ',', 'proxy_address', ':', 'Config', '.', 'artifactory_proxy_address', ',', 'proxy_port', ':', 'Config', '.', 'artifactory_proxy_port', ')', 'end']
->Original Target:
['The', 'Artifactory', 'client', 'object', 'to', 'communicate', 'with', 'the', 'Artifactory', 'API', '.']
->Reconstructed Target:
The Artifactory client object to communicate with the Artifactory API.
->Reconstructed Predication:
artifactory_endpointartifactory_ssl_pem_file : Config. artifactory_ssl_pem_file
->Raw Input:
summarize:def client @client ||= Artifactory :: Client. new ( endpoint : Config. artifactory_endpoint, username : Config. artifactory_username, password : Config. artifactory_password, ssl_pem_file : Config. artifactory_ssl_pem_file, ssl_verify : Config. artifactory_ssl_verify, proxy_username : Config. artifactory_proxy_username, proxy_password : Config. artifactory_proxy_password, proxy_address : Config. artifactory_proxy_address, proxy_port : Config. artifactory_proxy_port ) end
->Raw Target:
The Artifactory client object to communicate with the Artifactory API.
--

25=========
->Original Input:
['def', 'metadata_properties_for', '(', 'package', ')', 'metadata', '=', '{', '"omnibus.project"', '=>', 'package', '.', 'metadata', '[', ':name', ']', ',', '"omnibus.platform"', '=>', 'package', '.', 'metadata', '[', ':platform', ']', ',', '"omnibus.platform_version"', '=>', 'package', '.', 'metadata', '[', ':platform_version', ']', ',', '"omnibus.architecture"', '=>', 'package', '.', 'metadata', '[', ':arch', ']', ',', '"omnibus.version"', '=>', 'package', '.', 'metadata', '[', ':version', ']', ',', '"omnibus.iteration"', '=>', 'package', '.', 'metadata', '[', ':iteration', ']', ',', '"omnibus.license"', '=>', 'package', '.', 'metadata', '[', ':license', ']', ',', '"omnibus.md5"', '=>', 'package', '.', 'metadata', '[', ':md5', ']', ',', '"omnibus.sha1"', '=>', 'package', '.', 'metadata', '[', ':sha1', ']', ',', '"omnibus.sha256"', '=>', 'package', '.', 'metadata', '[', ':sha256', ']', ',', '"omnibus.sha512"', '=>', 'package', '.', 'metadata', '[', ':sha512', ']', ',', '"md5"', '=>', 'package', '.', 'metadata', '[', ':md5', ']', ',', '"sha1"', '=>', 'package', '.', 'metadata', '[', ':sha1', ']', ',', '"sha256"', '=>', 'package', '.', 'metadata', '[', ':sha256', ']', ',', '"sha512"', '=>', 'package', '.', 'metadata', '[', ':sha512', ']', ',', '}', '.', 'tap', 'do', '|', 'h', '|', 'if', 'build_record?', 'h', '[', '"build.name"', ']', '=', 'package', '.', 'metadata', '[', ':name', ']', 'h', '[', '"build.number"', ']', '=', 'package', '.', 'metadata', '[', ':version', ']', 'end', 'end', 'metadata', 'end']
->Original Target:
['The', 'metadata', 'for', 'this', 'package', '.']
->Reconstructed Target:
The metadata for this package.
->Reconstructed Predication:
metadata [ :project ]metadata [ :architecture ],metadata [ :architecture ],metadata [ :architecture ],metadata [ :architecture ],metadata [ :architecture ],metadata [ :architecture ],metadata [ :architecture ],metadata [ :architecture ],metadata [ :architecture ],metadata [ :architecture ],metadata [ :architecture ],metadata [ :
->Raw Input:
summarize:def metadata_properties_for ( package ) metadata = { "omnibus.project" => package. metadata [ :name ], "omnibus.platform" => package. metadata [ :platform ], "omnibus.platform_version" => package. metadata [ :platform_version ], "omnibus.architecture" => package. metadata [ :arch ], "omnibus.version" => package. metadata [ :version ], "omnibus.iteration" => package. metadata [ :iteration ], "omnibus.license" => package. metadata [ :license ], "omnibus.md5" => package. metadata [ :md5 ], "omnibus.sha1" => package. metadata [ :sha1 ], "omnibus.sha256" => package. metadata [ :sha256 ], "omnibus.sha512" => package. metadata [ :sha512 ], "md5" => package. metadata [ :md5 ], "sha1" => package. metadata [ :sha1 ], "sha256" => package. metadata [ :sha256 ], "sha512" => package. metadata [ :sha512 ], }. tap do | h | if build_record? h [ "build.name" ] = package. metadata [ :name ] h [ "build.number" ] = package. metadata [ :version ] end end metadata end
->Raw Target:
The metadata for this package.
--

26=========
->Original Input:
['def', 'remote_path_for', '(', 'package', ')', 'File', '.', 'join', '(', 'Config', '.', 'artifactory_base_path', ',', 'Config', '.', 'artifactory_publish_pattern', '%', 'package', '.', 'metadata', ')', 'end']
->Original Target:
['The', 'path', 'where', 'the', 'package', 'will', 'live', 'inside', 'of', 'the', 'Artifactory', 'repository', '.', 'This', 'is', 'dynamically', 'computed', 'from', 'the', 'values', 'in', 'the', 'project', 'definition', 'and', 'the', 'package', 'metadata', '.']
->Reconstructed Target:
The path where the package will live inside of the Artifactory repository. This is dynamically computed from the values in the project definition and the package metadata.
->Reconstructed Predication:
path to the remote file
->Raw Input:
summarize:def remote_path_for ( package ) File. join ( Config. artifactory_base_path, Config. artifactory_publish_pattern % package. metadata ) end
->Raw Target:
The path where the package will live inside of the Artifactory repository. This is dynamically computed from the values in the project definition and the package metadata.
--

27=========
->Original Input:
['def', 'parameters', '(', 'val', '=', 'NULL', ')', 'if', 'null?', '(', 'val', ')', '@parameters', '||', '{', '}', 'else', 'unless', 'val', '.', 'is_a?', '(', 'Hash', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':parameters', ',', '"be a Hash"', ')', 'end', '@parameters', '=', 'val', 'end', 'end']
->Original Target:
['Set', 'or', 'retrieve', 'the', 'custom', 'msi', 'building', 'parameters', '.']
->Reconstructed Target:
Set or retrieve the custom msi building parameters.
->Reconstructed Predication:
the parameters of the request
->Raw Input:
summarize:def parameters ( val = NULL ) if null? ( val ) @parameters || { } else unless val. is_a? ( Hash ) raise InvalidValue. new ( :parameters, "be a Hash" ) end @parameters = val end end
->Raw Target:
Set or retrieve the custom msi building parameters.
--

28=========
->Original Input:
['def', 'wix_light_extension', '(', 'extension', ')', 'unless', 'extension', '.', 'is_a?', '(', 'String', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':wix_light_extension', ',', '"be an String"', ')', 'end', 'wix_light_extensions', '<<', 'extension', 'end']
->Original Target:
['Set', 'the', 'wix', 'light', 'extensions', 'to', 'load']
->Reconstructed Target:
Set the wix light extensions to load
->Reconstructed Predication:
the wix light extension to be
->Raw Input:
summarize:def wix_light_extension ( extension ) unless extension. is_a? ( String ) raise InvalidValue. new ( :wix_light_extension, "be an String" ) end wix_light_extensions << extension end
->Raw Target:
Set the wix light extensions to load
--

29=========
->Original Input:
['def', 'wix_light_delay_validation', '(', 'val', '=', 'false', ')', 'unless', 'val', '.', 'is_a?', '(', 'TrueClass', ')', '||', 'val', '.', 'is_a?', '(', 'FalseClass', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':iwix_light_delay_validation', ',', '"be TrueClass or FalseClass"', ')', 'end', '@delay_validation', '||=', 'val', 'unless', '@delay_validation', 'return', '""', 'end', '"-sval"', 'end']
->Original Target:
['Signal', 'delay', 'validation', 'for', 'wix', 'light']
->Reconstructed Target:
Signal delay validation for wix light
->Reconstructed Predication:
the delay validation to be applied
->Raw Input:
summarize:def wix_light_delay_validation ( val = false ) unless val. is_a? ( TrueClass ) || val. is_a? ( FalseClass ) raise InvalidValue. new ( :iwix_light_delay_validation, "be TrueClass or FalseClass" ) end @delay_validation ||= val unless @delay_validation return "" end "-sval" end
->Raw Target:
Signal delay validation for wix light
--

30=========
->Original Input:
['def', 'wix_candle_extension', '(', 'extension', ')', 'unless', 'extension', '.', 'is_a?', '(', 'String', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':wix_candle_extension', ',', '"be an String"', ')', 'end', 'wix_candle_extensions', '<<', 'extension', 'end']
->Original Target:
['Set', 'the', 'wix', 'candle', 'extensions', 'to', 'load']
->Reconstructed Target:
Set the wix candle extensions to load
->Reconstructed Predication:
the extension to be used for
->Raw Input:
summarize:def wix_candle_extension ( extension ) unless extension. is_a? ( String ) raise InvalidValue. new ( :wix_candle_extension, "be an String" ) end wix_candle_extensions << extension end
->Raw Target:
Set the wix candle extensions to load
--

31=========
->Original Input:
['def', 'write_localization_file', 'render_template', '(', 'resource_path', '(', '"localization-#{localization}.wxl.erb"', ')', ',', 'destination', ':', '"#{staging_dir}/localization-#{localization}.wxl"', ',', 'variables', ':', '{', 'name', ':', 'project', '.', 'package_name', ',', 'friendly_name', ':', 'project', '.', 'friendly_name', ',', 'maintainer', ':', 'project', '.', 'maintainer', ',', '}', ')', 'end']
->Original Target:
['Write', 'the', 'localization', 'file', 'into', 'the', 'staging', 'directory', '.']
->Reconstructed Target:
Write the localization file into the staging directory.
->Reconstructed Predication:
end  def write_localization_file
->Raw Input:
summarize:def write_localization_file render_template ( resource_path ( "localization-#{localization}.wxl.erb" ), destination : "#{staging_dir}/localization-#{localization}.wxl", variables : { name : project. package_name, friendly_name : project. friendly_name, maintainer : project. maintainer, } ) end
->Raw Target:
Write the localization file into the staging directory.
--

32=========
->Original Input:
['def', 'write_parameters_file', 'render_template', '(', 'resource_path', '(', '"parameters.wxi.erb"', ')', ',', 'destination', ':', '"#{staging_dir}/parameters.wxi"', ',', 'variables', ':', '{', 'name', ':', 'project', '.', 'package_name', ',', 'friendly_name', ':', 'project', '.', 'friendly_name', ',', 'maintainer', ':', 'project', '.', 'maintainer', ',', 'upgrade_code', ':', 'upgrade_code', ',', 'parameters', ':', 'parameters', ',', 'version', ':', 'windows_package_version', ',', 'display_version', ':', 'msi_display_version', ',', '}', ')', 'end']
->Original Target:
['Write', 'the', 'parameters', 'file', 'into', 'the', 'staging', 'directory', '.']
->Reconstructed Target:
Write the parameters file into the staging directory.
->Reconstructed Predication:
end  def write_parameters_file
->Raw Input:
summarize:def write_parameters_file render_template ( resource_path ( "parameters.wxi.erb" ), destination : "#{staging_dir}/parameters.wxi", variables : { name : project. package_name, friendly_name : project. friendly_name, maintainer : project. maintainer, upgrade_code : upgrade_code, parameters : parameters, version : windows_package_version, display_version : msi_display_version, } ) end
->Raw Target:
Write the parameters file into the staging directory.
--

33=========
->Original Input:
['def', 'write_source_file', 'paths', '=', '[', ']', 'install_dir', '=', 'project', '.', 'install_dir', '.', 'split', '(', '"/"', ')', '[', '1', '..', '-', '1', ']', '.', 'join', '(', '"/"', ')', 'Pathname', '.', 'new', '(', 'install_dir', ')', '.', 'ascend', 'do', '|', 'path', '|', 'paths', '<<', 'path', '.', 'to_s', 'end', 'hierarchy', '=', 'paths', '.', 'reverse', '.', 'inject', '(', '{', '}', ')', 'do', '|', 'hash', ',', 'path', '|', 'hash', '[', 'File', '.', 'basename', '(', 'path', ')', ']', '=', 'path', '.', 'gsub', '(', '/', '/', ',', '""', ')', '.', 'upcase', '+', '"LOCATION"', 'hash', 'end', 'hierarchy', '[', 'hierarchy', '.', 'keys', '.', 'last', ']', '=', '"PROJECTLOCATION"', 'wix_install_dir', '=', 'if', 'hierarchy', '.', 'size', '>', '1', 'hierarchy', '.', 'to_a', '[', '-', '2', ']', '[', '1', ']', 'else', '"WINDOWSVOLUME"', 'end', 'render_template', '(', 'resource_path', '(', '"source.wxs.erb"', ')', ',', 'destination', ':', '"#{staging_dir}/source.wxs"', ',', 'variables', ':', '{', 'name', ':', 'project', '.', 'package_name', ',', 'friendly_name', ':', 'project', '.', 'friendly_name', ',', 'maintainer', ':', 'project', '.', 'maintainer', ',', 'hierarchy', ':', 'hierarchy', ',', 'fastmsi', ':', 'fast_msi', ',', 'wix_install_dir', ':', 'wix_install_dir', ',', '}', ')', 'end']
->Original Target:
['Write', 'the', 'source', 'file', 'into', 'the', 'staging', 'directory', '.']
->Reconstructed Target:
Write the source file into the staging directory.
->Reconstructed Predication:
: project. package_name,: project. friendly_name,: project.,: project. package_name,: project. package_name,: project.,: project. package_name,: project. package_name,: project.,: project. package_name,: project. package_name,: project. package_name,: project. package_name,
->Raw Input:
summarize:def write_source_file paths = [ ] install_dir = project. install_dir. split ( "/" ) [ 1.. - 1 ]. join ( "/" ) Pathname. new ( install_dir ). ascend do | path | paths << path. to_s end hierarchy = paths. reverse. inject ( { } ) do | hash, path | hash [ File. basename ( path ) ] = path. gsub ( / /, "" ). upcase + "LOCATION" hash end hierarchy [ hierarchy. keys. last ] = "PROJECTLOCATION" wix_install_dir = if hierarchy. size > 1 hierarchy. to_a [ - 2 ] [ 1 ] else "WINDOWSVOLUME" end render_template ( resource_path ( "source.wxs.erb" ), destination : "#{staging_dir}/source.wxs", variables : { name : project. package_name, friendly_name : project. friendly_name, maintainer : project. maintainer, hierarchy : hierarchy, fastmsi : fast_msi, wix_install_dir : wix_install_dir, } ) end
->Raw Target:
Write the source file into the staging directory.
--

34=========
->Original Input:
['def', 'write_bundle_file', 'render_template', '(', 'resource_path', '(', '"bundle.wxs.erb"', ')', ',', 'destination', ':', '"#{staging_dir}/bundle.wxs"', ',', 'variables', ':', '{', 'name', ':', 'project', '.', 'package_name', ',', 'friendly_name', ':', 'project', '.', 'friendly_name', ',', 'maintainer', ':', 'project', '.', 'maintainer', ',', 'upgrade_code', ':', 'upgrade_code', ',', 'parameters', ':', 'parameters', ',', 'version', ':', 'windows_package_version', ',', 'display_version', ':', 'msi_display_version', ',', 'msi', ':', 'windows_safe_path', '(', 'Config', '.', 'package_dir', ',', 'msi_name', ')', ',', '}', ')', 'end']
->Original Target:
['Write', 'the', 'bundle', 'file', 'into', 'the', 'staging', 'directory', '.']
->Reconstructed Target:
Write the bundle file into the staging directory.
->Reconstructed Predication:
.
->Raw Input:
summarize:def write_bundle_file render_template ( resource_path ( "bundle.wxs.erb" ), destination : "#{staging_dir}/bundle.wxs", variables : { name : project. package_name, friendly_name : project. friendly_name, maintainer : project. maintainer, upgrade_code : upgrade_code, parameters : parameters, version : windows_package_version, display_version : msi_display_version, msi : windows_safe_path ( Config. package_dir, msi_name ), } ) end
->Raw Target:
Write the bundle file into the staging directory.
--

35=========
->Original Input:
['def', 'resolve', '(', 'dependency', ')', 'if', 'from_dependency?', '&&', 'version_dependency', '==', 'dependency', '.', 'name', 'construct_build_version', '(', 'dependency', ')', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Build Version is set to \'#{build_version}\'"', '}', 'end', 'end']
->Original Target:
['Callback', 'that', 'is', 'called', 'by', 'software', 'objects', 'to', 'determine', 'the', 'version', '.']
->Reconstructed Target:
Callback that is called by software objects to determine the version.
->Reconstructed Predication:
dependency. name  defend end end
->Raw Input:
summarize:def resolve ( dependency ) if from_dependency? && version_dependency == dependency. name construct_build_version ( dependency ) log. info ( log_key ) { "Build Version is set to '#{build_version}'" } end end
->Raw Target:
Callback that is called by software objects to determine the version.
--

36=========
->Original Input:
['def', 'maybe_append_timestamp', '(', 'version', ')', 'if', 'Config', '.', 'append_timestamp', '&&', '!', 'has_timestamp?', '(', 'version', ')', '[', 'version', ',', 'Omnibus', '::', 'BuildVersion', '.', 'build_start_time', ']', '.', 'join', '(', '"+"', ')', 'else', 'version', 'end', 'end']
->Original Target:
['Append', 'the', 'build_start_time', 'to', 'the', 'given', 'string', 'if', 'Config', '.', 'append_timestamp', 'is', 'true']
->Reconstructed Target:
Append the build_start_time to the given string if Config. append_timestamp is true
->Reconstructed Predication:
append timestamp to the build version
->Raw Input:
summarize:def maybe_append_timestamp ( version ) if Config. append_timestamp &&! has_timestamp? ( version ) [ version, Omnibus :: BuildVersion. build_start_time ]. join ( "+" ) else version end end
->Raw Target:
Append the build_start_time to the given string if Config. append_timestamp is true
--

37=========
->Original Input:
['def', 'has_timestamp?', '(', 'version', ')', '_ver', ',', 'build_info', '=', 'version', '.', 'split', '(', '"+"', ')', 'return', 'false', 'if', 'build_info', '.', 'nil?', 'build_info', '.', 'split', '(', '"."', ')', '.', 'any?', 'do', '|', 'part', '|', 'begin', 'Time', '.', 'strptime', '(', 'part', ',', 'Omnibus', '::', 'BuildVersion', '::', 'TIMESTAMP_FORMAT', ')', 'true', 'rescue', 'ArgumentError', 'false', 'end', 'end', 'end']
->Original Target:
['Returns', 'true', 'if', 'a', 'given', 'version', 'string', 'Looks', 'like', 'it', 'was', 'already', 'created', 'with', 'a', 'function', 'that', 'added', 'a', 'timestamp', '.', 'The', 'goal', 'of', 'this', 'is', 'to', 'avoid', 'breaking', 'all', 'of', 'the', 'people', 'who', 'are', 'currently', 'using', 'BuildVersion', '.', 'semver', 'to', 'create', 'dates', '.']
->Reconstructed Target:
Returns true if a given version string Looks like it was already created with a function that added a timestamp. The goal of this is to avoid breaking all of the people who are currently using BuildVersion. semver to create dates.
->Reconstructed Predication:
the build timestamp for the given
->Raw Input:
summarize:def has_timestamp? ( version ) _ver, build_info = version. split ( "+" ) return false if build_info. nil? build_info. split ( "." ). any? do | part | begin Time. strptime ( part, Omnibus :: BuildVersion :: TIMESTAMP_FORMAT ) true rescue ArgumentError false end end end
->Raw Target:
Returns true if a given version string Looks like it was already created with a function that added a timestamp. The goal of this is to avoid breaking all of the people who are currently using BuildVersion. semver to create dates.
--

38=========
->Original Input:
['def', 'construct_build_version', '(', 'version_source', '=', 'nil', ')', 'case', 'source_type', 'when', ':git', 'version', '=', 'if', 'version_source', 'Omnibus', '::', 'BuildVersion', '.', 'new', '(', 'version_source', '.', 'project_dir', ')', 'else', 'Omnibus', '::', 'BuildVersion', '.', 'new', 'end', 'output', '=', 'output_method', '||', ':semver', 'self', '.', 'build_version', '=', 'version', '.', 'send', '(', 'output', ')', 'when', ':version', 'if', 'version_source', 'self', '.', 'build_version', '=', 'version_source', '.', 'version', 'else', 'raise', '"Please tell me the source to get the version from"', 'end', 'else', 'raise', '"I don\'t know how to construct a build_version using source \'#{source_type}\'"', 'end', 'end']
->Original Target:
['Determines', 'the', 'build_version', 'based', 'on', 'source_type', 'output_method', '.']
->Reconstructed Target:
Determines the build_version based on source_type output_method.
->Reconstructed Predication:
the build version for the
->Raw Input:
summarize:def construct_build_version ( version_source = nil ) case source_type when :git version = if version_source Omnibus :: BuildVersion. new ( version_source. project_dir ) else Omnibus :: BuildVersion. new end output = output_method || :semver self. build_version = version. send ( output ) when :version if version_source self. build_version = version_source. version else raise "Please tell me the source to get the version from" end else raise "I don't know how to construct a build_version using source '#{source_type}'" end end
->Raw Target:
Determines the build_version based on source_type output_method.
--

39=========
->Original Input:
['def', 'render_template_content', '(', 'source', ',', 'variables', '=', '{', '}', ')', 'template', '=', 'ERB', '.', 'new', '(', 'File', '.', 'read', '(', 'source', ')', ',', 'nil', ',', '"-"', ')', 'struct', '=', 'if', 'variables', '.', 'empty?', 'Struct', '.', 'new', '(', '"Empty"', ')', 'else', 'Struct', '.', 'new', '(', '*', 'variables', '.', 'keys', ')', '.', 'new', '(', '*', 'variables', '.', 'values', ')', 'end', 'template', '.', 'result', '(', 'struct', '.', 'instance_eval', '{', 'binding', '}', ')', 'end']
->Original Target:
['Render', 'an', 'erb', 'template', 'to', 'a', 'String', 'variable', '.']
->Reconstructed Target:
Render an erb template to a String variable.
->Reconstructed Predication:
template template template template template template
->Raw Input:
summarize:def render_template_content ( source, variables = { } ) template = ERB. new ( File. read ( source ), nil, "-" ) struct = if variables. empty? Struct. new ( "Empty" ) else Struct. new ( * variables. keys ). new ( * variables. values ) end template. result ( struct. instance_eval { binding } ) end
->Raw Target:
Render an erb template to a String variable.
--

40=========
->Original Input:
['def', 'deprecated', '(', 'progname', ',', '&', 'block', ')', 'meta', '=', 'Proc', '.', 'new', '{', '"DEPRECATED: #{yield}"', '}', 'add', '(', 'LEVELS', '.', 'index', '(', '"WARN"', ')', ',', 'progname', ',', '&', 'meta', ')', 'end']
->Original Target:
['Print', 'a', 'deprecation', 'warning', '.', 'This', 'actually', 'outputs', 'to', '+', 'WARN', '+', 'but', 'is', 'prefixed', 'with', 'the', 'string', 'DEPRECATED', 'first', '.']
->Reconstructed Target:
Print a deprecation warning. This actually outputs to + WARN + but is prefixed with the string DEPRECATED first.
->Reconstructed Predication:
The deprecated message is printed
->Raw Input:
summarize:def deprecated ( progname, & block ) meta = Proc. new { "DEPRECATED: #{yield}" } add ( LEVELS. index ( "WARN" ), progname, & meta ) end
->Raw Target:
Print a deprecation warning. This actually outputs to + WARN + but is prefixed with the string DEPRECATED first.
--

41=========
->Original Input:
['def', 'add', '(', 'severity', ',', 'progname', ',', '&', 'block', ')', 'return', 'true', 'if', 'io', '.', 'nil?', '||', 'severity', '<', 'level', 'message', '=', 'format_message', '(', 'severity', ',', 'progname', ',', 'yield', ')', 'MUTEX', '.', 'synchronize', '{', 'io', '.', 'write', '(', 'message', ')', '}', 'true', 'end']
->Original Target:
['Add', 'a', 'message', 'to', 'the', 'logger', 'with', 'the', 'given', 'severity', 'and', 'progname', '.']
->Reconstructed Target:
Add a message to the logger with the given severity and progname.
->Reconstructed Predication:
the message to the log
->Raw Input:
summarize:def add ( severity, progname, & block ) return true if io. nil? || severity < level message = format_message ( severity, progname, yield ) MUTEX. synchronize { io. write ( message ) } true end
->Raw Target:
Add a message to the logger with the given severity and progname.
--

42=========
->Original Input:
['def', 'command', '(', 'command', ',', 'options', '=', '{', '}', ')', 'warn_for_shell_commands', '(', 'command', ')', 'build_commands', '<<', 'BuildCommand', '.', 'new', '(', '"Execute: `#{command}\'"', ')', 'do', 'shellout!', '(', 'command', ',', 'options', ')', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'builder', 'object', 'for', 'evaluation', '.']
->Reconstructed Target:
Create a new builder object for evaluation.
->Reconstructed Predication:
the shell command to execute
->Raw Input:
summarize:def command ( command, options = { } ) warn_for_shell_commands ( command ) build_commands << BuildCommand. new ( "Execute: `#{command}'" ) do shellout! ( command, options ) end end
->Raw Target:
Create a new builder object for evaluation.
--

43=========
->Original Input:
['def', 'make', '(', '*', 'args', ')', 'options', '=', 'args', '.', 'last', '.', 'is_a?', '(', 'Hash', ')', '?', 'args', '.', 'pop', ':', '{', '}', 'make', '=', 'options', '.', 'delete', '(', ':bin', ')', '||', 'if', '!', 'windows?', '&&', 'Omnibus', '.', 'which', '(', '"gmake"', ')', 'env', '=', 'options', '.', 'delete', '(', ':env', ')', '||', '{', '}', 'env', '=', '{', '"MAKE"', '=>', '"gmake"', '}', '.', 'merge', '(', 'env', ')', 'options', '[', ':env', ']', '=', 'env', '"gmake"', 'else', '"make"', 'end', 'options', '[', ':in_msys_bash', ']', '=', 'true', 'make_cmd', '=', '(', '[', 'make', ']', '+', 'args', ')', '.', 'join', '(', '" "', ')', '.', 'strip', 'command', '(', 'make_cmd', ',', 'options', ')', 'end']
->Original Target:
['Execute', 'the', 'given', 'make', 'command', '.', 'When', 'present', 'this', 'method', 'will', 'prefer', 'the', 'use', 'of', '+', 'gmake', '+', 'over', '+', 'make', '+', '.', 'If', 'applicable', 'this', 'method', 'will', 'also', 'set', 'the', 'MAKE', '=', 'gmake', 'environment', 'variable', 'when', 'gmake', 'is', 'to', 'be', 'preferred', '.']
->Reconstructed Target:
Execute the given make command. When present this method will prefer the use of + gmake + over + make +. If applicable this method will also set the MAKE = gmake environment variable when gmake is to be preferred.
->Reconstructed Predication:
the command to run thethe command to run the commandthe command to run the commandthe command to run the command
->Raw Input:
summarize:def make ( * args ) options = args. last. is_a? ( Hash )? args. pop : { } make = options. delete ( :bin ) || if! windows? && Omnibus. which ( "gmake" ) env = options. delete ( :env ) || { } env = { "MAKE" => "gmake" }. merge ( env ) options [ :env ] = env "gmake" else "make" end options [ :in_msys_bash ] = true make_cmd = ( [ make ] + args ). join ( " " ). strip command ( make_cmd, options ) end
->Raw Target:
Execute the given make command. When present this method will prefer the use of + gmake + over + make +. If applicable this method will also set the MAKE = gmake environment variable when gmake is to be preferred.
--

44=========
->Original Input:
['def', 'appbundle', '(', 'software_name', ',', 'lockdir', ':', 'nil', ',', 'gem', ':', 'nil', ',', 'without', ':', 'nil', ',', 'extra_bin_files', ':', 'nil', ',', '**', 'options', ')', 'build_commands', '<<', 'BuildCommand', '.', 'new', '(', '"appbundle `#{software_name}\'"', ')', 'do', 'bin_dir', '=', '"#{install_dir}/bin"', 'appbundler_bin', '=', 'embedded_bin', '(', '"appbundler"', ')', 'lockdir', '||=', 'begin', 'app_software', '=', 'project', '.', 'softwares', '.', 'find', 'do', '|', 'p', '|', 'p', '.', 'name', '==', 'software_name', 'end', 'if', 'app_software', '.', 'nil?', 'raise', '"could not find software definition for #{software_name}, add a dependency to it, or pass a lockdir argument to appbundle command."', 'end', 'app_software', '.', 'project_dir', 'end', 'command', '=', '[', 'appbundler_bin', ',', '"\'#{lockdir}\'"', ',', '"\'#{bin_dir}\'"', ']', 'command', '<<', '[', '"\'#{gem}\'"', ']', 'if', 'gem', 'command', '<<', '[', '"--without"', ',', 'without', '.', 'join', '(', '","', ')', ']', 'unless', 'without', '.', 'nil?', 'command', '<<', '[', '"--extra-bin-files"', ',', 'extra_bin_files', '.', 'join', '(', '","', ')', ']', 'unless', 'extra_bin_files', '.', 'nil?', '||', 'extra_bin_files', '.', 'empty?', 'FileUtils', '.', 'mkdir_p', '(', 'bin_dir', ')', 'shellout!', '(', 'command', '.', 'join', '(', '" "', ')', ',', 'options', ')', 'end', 'end']
->Original Target:
['Execute', 'the', 'given', 'appbundler', 'command', 'against', 'the', 'embedded', 'Ruby', 's', 'appbundler', '.', 'This', 'command', 'assumes', 'the', '+', 'appbundle', '+', 'gem', 'is', 'installed', 'and', 'in', 'the', 'embedded', 'Ruby', '.', 'You', 'should', 'add', 'a', 'dependency', 'on', 'the', '+', 'appbundler', '+', 'software', 'definition', 'if', 'you', 'want', 'to', 'use', 'this', 'command', '.']
->Reconstructed Target:
Execute the given appbundler command against the embedded Ruby s appbundler. This command assumes the + appbundle + gem is installed and in the embedded Ruby. You should add a dependency on the + appbundler + software definition if you want to use this command.
->Reconstructed Predication:
. join ( " " )"--no-install", "--no-install-dir","--no-install-dir", "--no-install-dir", "--no-install-dir""--no-install-dir", "--no-install-dir", "--no-install-dir""--no-install-dir", "--no-install-dir", "--no-install-dir"
->Raw Input:
summarize:def appbundle ( software_name, lockdir : nil, gem : nil, without : nil, extra_bin_files : nil, ** options ) build_commands << BuildCommand. new ( "appbundle `#{software_name}'" ) do bin_dir = "#{install_dir}/bin" appbundler_bin = embedded_bin ( "appbundler" ) lockdir ||= begin app_software = project. softwares. find do | p | p. name == software_name end if app_software. nil? raise "could not find software definition for #{software_name}, add a dependency to it, or pass a lockdir argument to appbundle command." end app_software. project_dir end command = [ appbundler_bin, "'#{lockdir}'", "'#{bin_dir}'" ] command << [ "'#{gem}'" ] if gem command << [ "--without", without. join ( "," ) ] unless without. nil? command << [ "--extra-bin-files", extra_bin_files. join ( "," ) ] unless extra_bin_files. nil? || extra_bin_files. empty? FileUtils. mkdir_p ( bin_dir ) shellout! ( command. join ( " " ), options ) end end
->Raw Target:
Execute the given appbundler command against the embedded Ruby s appbundler. This command assumes the + appbundle + gem is installed and in the embedded Ruby. You should add a dependency on the + appbundler + software definition if you want to use this command.
--

45=========
->Original Input:
['def', 'rake', '(', 'command', ',', 'options', '=', '{', '}', ')', 'build_commands', '<<', 'BuildCommand', '.', 'new', '(', '"rake `#{command}\'"', ')', 'do', 'bin', '=', 'embedded_bin', '(', '"rake"', ')', 'shellout!', '(', '"#{bin} #{command}"', ',', 'options', ')', 'end', 'end']
->Original Target:
['Execute', 'the', 'given', 'Rake', 'command', 'against', 'the', 'embedded', 'Ruby', 's', 'rake', '.', 'This', 'command', 'assumes', 'the', '+', 'rake', '+', 'gem', 'has', 'been', 'installed', '.']
->Reconstructed Target:
Execute the given Rake command against the embedded Ruby s rake. This command assumes the + rake + gem has been installed.
->Reconstructed Predication:
The command to run the command
->Raw Input:
summarize:def rake ( command, options = { } ) build_commands << BuildCommand. new ( "rake `#{command}'" ) do bin = embedded_bin ( "rake" ) shellout! ( "#{bin} #{command}", options ) end end
->Raw Target:
Execute the given Rake command against the embedded Ruby s rake. This command assumes the + rake + gem has been installed.
--

46=========
->Original Input:
['def', 'touch', '(', 'file', ',', 'options', '=', '{', '}', ')', 'build_commands', '<<', 'BuildCommand', '.', 'new', '(', '"touch `#{file}\'"', ')', 'do', 'Dir', '.', 'chdir', '(', 'software', '.', 'project_dir', ')', 'do', 'parent', '=', 'File', '.', 'dirname', '(', 'file', ')', 'FileUtils', '.', 'mkdir_p', '(', 'parent', ')', 'unless', 'File', '.', 'directory?', '(', 'parent', ')', 'FileUtils', '.', 'touch', '(', 'file', ',', 'options', ')', 'end', 'end', 'end']
->Original Target:
['Touch', 'the', 'given', 'filepath', 'at', 'runtime', '.', 'This', 'method', 'will', 'also', 'ensure', 'the', 'containing', 'directory', 'exists', 'first', '.']
->Reconstructed Target:
Touch the given filepath at runtime. This method will also ensure the containing directory exists first.
->Reconstructed Predication:
 def touch ( filefile, options )
->Raw Input:
summarize:def touch ( file, options = { } ) build_commands << BuildCommand. new ( "touch `#{file}'" ) do Dir. chdir ( software. project_dir ) do parent = File. dirname ( file ) FileUtils. mkdir_p ( parent ) unless File. directory? ( parent ) FileUtils. touch ( file, options ) end end end
->Raw Target:
Touch the given filepath at runtime. This method will also ensure the containing directory exists first.
--

47=========
->Original Input:
['def', 'delete', '(', 'path', ',', 'options', '=', '{', '}', ')', 'build_commands', '<<', 'BuildCommand', '.', 'new', '(', '"delete `#{path}\'"', ')', 'do', 'Dir', '.', 'chdir', '(', 'software', '.', 'project_dir', ')', 'do', 'FileSyncer', '.', 'glob', '(', 'path', ')', '.', 'each', 'do', '|', 'file', '|', 'FileUtils', '.', 'rm_rf', '(', 'file', ',', 'options', ')', 'end', 'end', 'end', 'end']
->Original Target:
['Delete', 'the', 'given', 'file', 'or', 'directory', 'on', 'the', 'system', '.', 'This', 'method', 'uses', 'the', 'equivalent', 'of', '+', 'rm', '-', 'rf', '+', 'so', 'you', 'may', 'pass', 'in', 'a', 'specific', 'file', 'or', 'a', 'glob', 'of', 'files', '.']
->Reconstructed Target:
Delete the given file or directory on the system. This method uses the equivalent of + rm - rf + so you may pass in a specific file or a glob of files.
->Reconstructed Predication:
the file to delete.
->Raw Input:
summarize:def delete ( path, options = { } ) build_commands << BuildCommand. new ( "delete `#{path}'" ) do Dir. chdir ( software. project_dir ) do FileSyncer. glob ( path ). each do | file | FileUtils. rm_rf ( file, options ) end end end end
->Raw Target:
Delete the given file or directory on the system. This method uses the equivalent of + rm - rf + so you may pass in a specific file or a glob of files.
--

48=========
->Original Input:
['def', 'copy', '(', 'source', ',', 'destination', ',', 'options', '=', '{', '}', ')', 'command', '=', '"copy `#{source}\' to `#{destination}\'"', 'build_commands', '<<', 'BuildCommand', '.', 'new', '(', 'command', ')', 'do', 'Dir', '.', 'chdir', '(', 'software', '.', 'project_dir', ')', 'do', 'files', '=', 'FileSyncer', '.', 'glob', '(', 'source', ')', 'if', 'files', '.', 'empty?', 'log', '.', 'warn', '(', 'log_key', ')', '{', '"no matched files for glob #{command}"', '}', 'else', 'files', '.', 'each', 'do', '|', 'file', '|', 'FileUtils', '.', 'cp_r', '(', 'file', ',', 'destination', ',', 'options', ')', 'end', 'end', 'end', 'end', 'end']
->Original Target:
['Copy', 'the', 'given', 'source', 'to', 'the', 'destination', '.', 'This', 'method', 'accepts', 'a', 'single', 'file', 'or', 'a', 'file', 'pattern', 'to', 'match', '.']
->Reconstructed Target:
Copy the given source to the destination. This method accepts a single file or a file pattern to match.
->Reconstructed Predication:
copy files from thethe destination directory to thethe destination directory to thethe destination directory to thethe destination directory to thethe destination directory to the
->Raw Input:
summarize:def copy ( source, destination, options = { } ) command = "copy `#{source}' to `#{destination}'" build_commands << BuildCommand. new ( command ) do Dir. chdir ( software. project_dir ) do files = FileSyncer. glob ( source ) if files. empty? log. warn ( log_key ) { "no matched files for glob #{command}" } else files. each do | file | FileUtils. cp_r ( file, destination, options ) end end end end end
->Raw Target:
Copy the given source to the destination. This method accepts a single file or a file pattern to match.
--

49=========
->Original Input:
['def', 'update_config_guess', '(', 'target', ':', '"."', ',', 'install', ':', '[', ':config_guess', ',', ':config_sub', ']', ')', 'build_commands', '<<', 'BuildCommand', '.', 'new', '(', '"update_config_guess `target: #{target} install: #{install.inspect}\'"', ')', 'do', 'config_guess_dir', '=', '"#{install_dir}/embedded/lib/config_guess"', '%w{', 'config.guess', 'config.sub', '}', '.', 'each', 'do', '|', 'c', '|', 'unless', 'File', '.', 'exist?', '(', 'File', '.', 'join', '(', 'config_guess_dir', ',', 'c', ')', ')', 'raise', '"Can not find #{c}. Make sure you add a dependency on \'config_guess\' in your software definition"', 'end', 'end', 'destination', '=', 'File', '.', 'join', '(', 'software', '.', 'project_dir', ',', 'target', ')', 'FileUtils', '.', 'mkdir_p', '(', 'destination', ')', 'FileUtils', '.', 'cp_r', '(', '"#{config_guess_dir}/config.guess"', ',', 'destination', ')', 'if', 'install', '.', 'include?', ':config_guess', 'FileUtils', '.', 'cp_r', '(', '"#{config_guess_dir}/config.sub"', ',', 'destination', ')', 'if', 'install', '.', 'include?', ':config_sub', 'end', 'end']
->Original Target:
['Helper', 'method', 'to', 'update', 'config_guess', 'in', 'the', 'software', 's', 'source', 'directory', '.', 'You', 'should', 'add', 'a', 'dependency', 'on', 'the', '+', 'config_guess', '+', 'software', 'definition', 'if', 'you', 'want', 'to', 'use', 'this', 'command', '.']
->Reconstructed Target:
Helper method to update config_guess in the software s source directory. You should add a dependency on the + config_guess + software definition if you want to use this command.
->Reconstructed Predication:
install : [ :config_guess, :config_sub:config_sub ]install : [ :config_sub ]install : [ :config_guess,:config_sub ] end end
->Raw Input:
summarize:def update_config_guess ( target : ".", install : [ :config_guess, :config_sub ] ) build_commands << BuildCommand. new ( "update_config_guess `target: #{target} install: #{install.inspect}'" ) do config_guess_dir = "#{install_dir}/embedded/lib/config_guess" %w{ config.guess config.sub }. each do | c | unless File. exist? ( File. join ( config_guess_dir, c ) ) raise "Can not find #{c}. Make sure you add a dependency on 'config_guess' in your software definition" end end destination = File. join ( software. project_dir, target ) FileUtils. mkdir_p ( destination ) FileUtils. cp_r ( "#{config_guess_dir}/config.guess", destination ) if install. include? :config_guess FileUtils. cp_r ( "#{config_guess_dir}/config.sub", destination ) if install. include? :config_sub end end
->Raw Target:
Helper method to update config_guess in the software s source directory. You should add a dependency on the + config_guess + software definition if you want to use this command.
--

50=========
->Original Input:
['def', 'write_tgz', 'contents', '=', 'gzipped_tarball', 'File', '.', 'open', '(', '"#{staging_dir}/#{package_name}"', ',', '"wb"', ')', 'do', '|', 'tgz', '|', 'while', 'chunk', '=', 'contents', '.', 'read', '(', '1024', ')', 'tgz', '.', 'write', '(', 'chunk', ')', 'end', 'end', 'FileSyncer', '.', 'glob', '(', '"#{staging_dir}/*.tar.gz"', ')', '.', 'each', 'do', '|', 'tgz', '|', 'copy_file', '(', 'tgz', ',', 'Config', '.', 'package_dir', ')', 'end', 'end']
->Original Target:
['Write', 'the', 'tar', '.', 'gz', 'to', 'disk', 'reading', 'in', '1024', 'bytes', 'at', 'a', 'time', 'to', 'reduce', 'memory', 'usage', '.']
->Reconstructed Target:
Write the tar. gz to disk reading in 1024 bytes at a time to reduce memory usage.
->Reconstructed Predication:
package_name
->Raw Input:
summarize:def write_tgz contents = gzipped_tarball File. open ( "#{staging_dir}/#{package_name}", "wb" ) do | tgz | while chunk = contents. read ( 1024 ) tgz. write ( chunk ) end end FileSyncer. glob ( "#{staging_dir}/*.tar.gz" ). each do | tgz | copy_file ( tgz, Config. package_dir ) end end
->Raw Target:
Write the tar. gz to disk reading in 1024 bytes at a time to reduce memory usage.
--

51=========
->Original Input:
['def', 'tarball', 'tarfile', '=', 'StringIO', '.', 'new', '(', '""', ')', 'Gem', '::', 'Package', '::', 'TarWriter', '.', 'new', '(', 'tarfile', ')', 'do', '|', 'tar', '|', 'path', '=', '"#{staging_dir}/#{packager.package_name}"', 'name', '=', 'packager', '.', 'package_name', 'mode', '=', 'File', '.', 'stat', '(', 'path', ')', '.', 'mode', 'tar', '.', 'add_file', '(', 'name', ',', 'mode', ')', 'do', '|', 'tf', '|', 'File', '.', 'open', '(', 'path', ',', '"rb"', ')', 'do', '|', 'file', '|', 'tf', '.', 'write', '(', 'file', '.', 'read', ')', 'end', 'end', 'end', 'tarfile', '.', 'rewind', 'tarfile', 'end']
->Original Target:
['Create', 'an', 'in', '-', 'memory', 'tarball', 'from', 'the', 'given', 'packager', '.']
->Reconstructed Target:
Create an in - memory tarball from the given packager.
->Reconstructed Predication:
package_name. to_s.package_name. to_s.
->Raw Input:
summarize:def tarball tarfile = StringIO. new ( "" ) Gem :: Package :: TarWriter. new ( tarfile ) do | tar | path = "#{staging_dir}/#{packager.package_name}" name = packager. package_name mode = File. stat ( path ). mode tar. add_file ( name, mode ) do | tf | File. open ( path, "rb" ) do | file | tf. write ( file. read ) end end end tarfile. rewind tarfile end
->Raw Target:
Create an in - memory tarball from the given packager.
--

52=========
->Original Input:
['def', 'clean', 'needs_cleaning', '=', 'File', '.', 'exist?', '(', 'project_dir', ')', 'if', 'needs_cleaning', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Cleaning project directory `#{project_dir}\'"', '}', 'FileUtils', '.', 'rm_rf', '(', 'project_dir', ')', 'end', 'create_required_directories', 'deploy', 'needs_cleaning', 'end']
->Original Target:
['Clean', 'the', 'project', 'directory', 'if', 'it', 'exists', 'and', 'actually', 'extract', 'the', 'downloaded', 'file', '.']
->Reconstructed Target:
Clean the project directory if it exists and actually extract the downloaded file.
->Reconstructed Predication:
clean the project directory ifthe project directory
->Raw Input:
summarize:def clean needs_cleaning = File. exist? ( project_dir ) if needs_cleaning log. info ( log_key ) { "Cleaning project directory `#{project_dir}'" } FileUtils. rm_rf ( project_dir ) end create_required_directories deploy needs_cleaning end
->Raw Target:
Clean the project directory if it exists and actually extract the downloaded file.
--

53=========
->Original Input:
['def', 'deploy', 'if', 'downloaded_file', '.', 'end_with?', '(', '*', 'ALL_EXTENSIONS', ')', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Extracting `#{safe_downloaded_file}\' to `#{safe_project_dir}\'"', '}', 'extract', 'else', 'log', '.', 'info', '(', 'log_key', ')', '{', '"`#{safe_downloaded_file}\' is not an archive - copying to `#{safe_project_dir}\'"', '}', 'if', 'File', '.', 'directory?', '(', 'downloaded_file', ')', 'FileUtils', '.', 'cp_r', '(', '"#{downloaded_file}/."', ',', 'project_dir', ')', 'else', 'FileUtils', '.', 'cp', '(', 'downloaded_file', ',', 'project_dir', ')', 'end', 'end', 'end']
->Original Target:
['Extract', 'the', 'downloaded', 'file', 'using', 'the', 'magical', 'logic', 'based', 'off', 'of', 'the', 'ending', 'file', 'extension', '.', 'In', 'the', 'rare', 'event', 'the', 'file', 'cannot', 'be', 'extracted', 'it', 'is', 'copied', 'over', 'as', 'a', 'raw', 'file', '.']
->Reconstructed Target:
Extract the downloaded file using the magical logic based off of the ending file extension. In the rare event the file cannot be extracted it is copied over as a raw file.
->Reconstructed Predication:
the file to be deployedthe file to be deployed.
->Raw Input:
summarize:def deploy if downloaded_file. end_with? ( * ALL_EXTENSIONS ) log. info ( log_key ) { "Extracting `#{safe_downloaded_file}' to `#{safe_project_dir}'" } extract else log. info ( log_key ) { "`#{safe_downloaded_file}' is not an archive - copying to `#{safe_project_dir}'" } if File. directory? ( downloaded_file ) FileUtils. cp_r ( "#{downloaded_file}/.", project_dir ) else FileUtils. cp ( downloaded_file, project_dir ) end end end
->Raw Target:
Extract the downloaded file using the magical logic based off of the ending file extension. In the rare event the file cannot be extracted it is copied over as a raw file.
--

54=========
->Original Input:
['def', 'extract', 'compression_switch', '=', '""', 'compression_switch', '=', '"z"', 'if', 'downloaded_file', '.', 'end_with?', '(', '"gz"', ')', 'compression_switch', '=', '"--lzma -"', 'if', 'downloaded_file', '.', 'end_with?', '(', '"lzma"', ')', 'compression_switch', '=', '"j"', 'if', 'downloaded_file', '.', 'end_with?', '(', '"bz2"', ')', 'compression_switch', '=', '"J"', 'if', 'downloaded_file', '.', 'end_with?', '(', '"xz"', ')', 'if', 'Ohai', '[', '"platform"', ']', '==', '"windows"', 'if', 'downloaded_file', '.', 'end_with?', '(', '*', 'TAR_EXTENSIONS', ')', '&&', 'source', '[', ':extract', ']', '!=', ':seven_zip', 'returns', '=', '[', '0', ']', 'returns', '<<', '1', 'if', 'source', '[', ':extract', ']', '==', ':lax_tar', 'shellout!', '(', '"tar #{compression_switch}xf #{safe_downloaded_file} -C#{safe_project_dir}"', ',', 'returns', ':', 'returns', ')', 'elsif', 'downloaded_file', '.', 'end_with?', '(', '*', 'COMPRESSED_TAR_EXTENSIONS', ')', 'Dir', '.', 'mktmpdir', 'do', '|', 'temp_dir', '|', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Temporarily extracting `#{safe_downloaded_file}\' to `#{temp_dir}\'"', '}', 'shellout!', '(', '"7z.exe x #{safe_downloaded_file} -o#{windows_safe_path(temp_dir)} -r -y"', ')', 'fname', '=', 'File', '.', 'basename', '(', 'downloaded_file', ',', 'File', '.', 'extname', '(', 'downloaded_file', ')', ')', 'fname', '<<', '".tar"', 'if', 'downloaded_file', '.', 'end_with?', '(', '"tgz"', ',', '"txz"', ')', 'next_file', '=', 'windows_safe_path', '(', 'File', '.', 'join', '(', 'temp_dir', ',', 'fname', ')', ')', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Temporarily extracting `#{next_file}\' to `#{safe_project_dir}\'"', '}', 'shellout!', '(', '"7z.exe x #{next_file} -o#{safe_project_dir} -r -y"', ')', 'end', 'else', 'shellout!', '(', '"7z.exe x #{safe_downloaded_file} -o#{safe_project_dir} -r -y"', ')', 'end', 'elsif', 'downloaded_file', '.', 'end_with?', '(', '".7z"', ')', 'shellout!', '(', '"7z x #{safe_downloaded_file} -o#{safe_project_dir} -r -y"', ')', 'elsif', 'downloaded_file', '.', 'end_with?', '(', '".zip"', ')', 'shellout!', '(', '"unzip #{safe_downloaded_file} -d #{safe_project_dir}"', ')', 'else', 'shellout!', '(', '"#{tar} #{compression_switch}xf #{safe_downloaded_file} -C#{safe_project_dir}"', ')', 'end', 'end']
->Original Target:
['Extracts', 'the', 'downloaded', 'archive', 'file', 'into', 'project_dir', '.']
->Reconstructed Target:
Extracts the downloaded archive file into project_dir.
->Reconstructed Predication:
. end_with? ( ".7z" )( "7z.exe x #{safe_downloaded_file} -o#{safe_project_dir} -r-y" ) elsif downloaded_file.. end_with? ( ".7z.exe" )( "7z.exe x #{safe_downloaded_file} -o#{safe_project_dir} -r-y" ) elsif downloaded_
->Raw Input:
summarize:def extract compression_switch = "" compression_switch = "z" if downloaded_file. end_with? ( "gz" ) compression_switch = "--lzma -" if downloaded_file. end_with? ( "lzma" ) compression_switch = "j" if downloaded_file. end_with? ( "bz2" ) compression_switch = "J" if downloaded_file. end_with? ( "xz" ) if Ohai [ "platform" ] == "windows" if downloaded_file. end_with? ( * TAR_EXTENSIONS ) && source [ :extract ]!= :seven_zip returns = [ 0 ] returns << 1 if source [ :extract ] == :lax_tar shellout! ( "tar #{compression_switch}xf #{safe_downloaded_file} -C#{safe_project_dir}", returns : returns ) elsif downloaded_file. end_with? ( * COMPRESSED_TAR_EXTENSIONS ) Dir. mktmpdir do | temp_dir | log. debug ( log_key ) { "Temporarily extracting `#{safe_downloaded_file}' to `#{temp_dir}'" } shellout! ( "7z.exe x #{safe_downloaded_file} -o#{windows_safe_path(temp_dir)} -r -y" ) fname = File. basename ( downloaded_file, File. extname ( downloaded_file ) ) fname << ".tar" if downloaded_file. end_with? ( "tgz", "txz" ) next_file = windows_safe_path ( File. join ( temp_dir, fname ) ) log. debug ( log_key ) { "Temporarily extracting `#{next_file}' to `#{safe_project_dir}'" } shellout! ( "7z.exe x #{next_file} -o#{safe_project_dir} -r -y" ) end else shellout! ( "7z.exe x #{safe_downloaded_file} -o#{safe_project_dir} -r -y" ) end elsif downloaded_file. end_with? ( ".7z" ) shellout! ( "7z x #{safe_downloaded_file} -o#{safe_project_dir} -r -y" ) elsif downloaded
->Raw Target:
Extracts the downloaded archive file into project_dir.
--

55=========
->Original Input:
['def', 'digest_type', 'DIGESTS', '.', 'each', 'do', '|', 'digest', '|', 'return', 'digest', 'if', 'source', '.', 'key?', 'digest', 'end', 'raise', 'ChecksumMissing', '.', 'new', '(', 'self', ')', 'end']
->Original Target:
['The', 'digest', 'type', 'defined', 'in', 'the', 'software', 'definition']
->Reconstructed Target:
The digest type defined in the software definition
->Reconstructed Predication:
the digest to the checksum
->Raw Input:
summarize:def digest_type DIGESTS. each do | digest | return digest if source. key? digest end raise ChecksumMissing. new ( self ) end
->Raw Target:
The digest type defined in the software definition
--

56=========
->Original Input:
['def', 'verify_checksum!', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Verifying checksum"', '}', 'expected', '=', 'checksum', 'actual', '=', 'digest', '(', 'downloaded_file', ',', 'digest_type', ')', 'if', 'expected', '!=', 'actual', 'raise', 'ChecksumMismatch', '.', 'new', '(', 'self', ',', 'expected', ',', 'actual', ')', 'end', 'end']
->Original Target:
['Verify', 'the', 'downloaded', 'file', 'has', 'the', 'correct', 'checksum', '.']
->Reconstructed Target:
Verify the downloaded file has the correct checksum.
->Reconstructed Predication:
the downloaded file and the checksum
->Raw Input:
summarize:def verify_checksum! log. info ( log_key ) { "Verifying checksum" } expected = checksum actual = digest ( downloaded_file, digest_type ) if expected!= actual raise ChecksumMismatch. new ( self, expected, actual ) end end
->Raw Target:
Verify the downloaded file has the correct checksum.
--

57=========
->Original Input:
['def', 'signing_identity', '(', 'thumbprint', '=', 'NULL', ',', 'params', '=', 'NULL', ')', 'unless', 'null?', '(', 'thumbprint', ')', '@signing_identity', '=', '{', '}', 'unless', 'thumbprint', '.', 'is_a?', '(', 'String', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':signing_identity', ',', '"be a String"', ')', 'end', '@signing_identity', '[', ':thumbprint', ']', '=', 'thumbprint', 'if', '!', 'null?', '(', 'params', ')', 'unless', 'params', '.', 'is_a?', '(', 'Hash', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':params', ',', '"be a Hash"', ')', 'end', 'valid_keys', '=', '[', ':store', ',', ':timestamp_servers', ',', ':machine_store', ',', ':algorithm', ']', 'invalid_keys', '=', 'params', '.', 'keys', '-', 'valid_keys', 'unless', 'invalid_keys', '.', 'empty?', 'raise', 'InvalidValue', '.', 'new', '(', ':params', ',', '"contain keys from [#{valid_keys.join(\', \')}]. "', '"Found invalid keys [#{invalid_keys.join(\', \')}]"', ')', 'end', 'if', '!', 'params', '[', ':machine_store', ']', '.', 'nil?', '&&', '!', '(', 'params', '[', ':machine_store', ']', '.', 'is_a?', '(', 'TrueClass', ')', '||', 'params', '[', ':machine_store', ']', '.', 'is_a?', '(', 'FalseClass', ')', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':params', ',', '"contain key :machine_store of type TrueClass or FalseClass"', ')', 'end', 'else', 'params', '=', '{', '}', 'end', '@signing_identity', '[', ':store', ']', '=', 'params', '[', ':store', ']', '||', '"My"', '@signing_identity', '[', ':algorithm', ']', '=', 'params', '[', ':algorithm', ']', '||', '"SHA256"', 'servers', '=', 'params', '[', ':timestamp_servers', ']', '||', 'DEFAULT_TIMESTAMP_SERVERS', '@signing_identity', '[', ':timestamp_servers', ']', '=', '[', 'servers', ']', '.', 'flatten', '@signing_identity', '[', ':machine_store', ']', '=', 'params', '[', ':machine_store', ']', '||', 'false', 'end', '@signing_identity', 'end']
->Original Target:
['Set', 'the', 'signing', 'certificate', 'name']
->Reconstructed Target:
Set the signing certificate name
->Reconstructed Predication:
[ :algorithm ] =[ :timestamp_servers ] = [[ :algorithm ] =[ :timestamp_servers ][ :algorithm ] =[ :algorithm ][ :timestamp_servers ][ :algorithm ] =[ :algorithm ] =[ :algorithm ] =[ :algorithm ] =[ :timestamp_servers ][ :machine_store ] =[ :algorithm ] =[ :algorithm ] =
->Raw Input:
summarize:def signing_identity ( thumbprint = NULL, params = NULL ) unless null? ( thumbprint ) @signing_identity = { } unless thumbprint. is_a? ( String ) raise InvalidValue. new ( :signing_identity, "be a String" ) end @signing_identity [ :thumbprint ] = thumbprint if! null? ( params ) unless params. is_a? ( Hash ) raise InvalidValue. new ( :params, "be a Hash" ) end valid_keys = [ :store, :timestamp_servers, :machine_store, :algorithm ] invalid_keys = params. keys - valid_keys unless invalid_keys. empty? raise InvalidValue. new ( :params, "contain keys from [#{valid_keys.join(', ')}]. " "Found invalid keys [#{invalid_keys.join(', ')}]" ) end if! params [ :machine_store ]. nil? &&! ( params [ :machine_store ]. is_a? ( TrueClass ) || params [ :machine_store ]. is_a? ( FalseClass ) ) raise InvalidValue. new ( :params, "contain key :machine_store of type TrueClass or FalseClass" ) end else params = { } end @signing_identity [ :store ] = params [ :store ] || "My" @signing_identity [ :algorithm ] = params [ :algorithm ] || "SHA256" servers = params [ :timestamp_servers ] || DEFAULT_TIMESTAMP_SERVERS @signing_identity [ :timestamp_servers ] = [ servers ]. flatten @signing_identity [ :machine_store ] = params [ :machine_store ] || false end @signing_identity end
->Raw Target:
Set the signing certificate name
--

58=========
->Original Input:
['def', 'sign_package', '(', 'package_file', ')', 'success', '=', 'false', 'timestamp_servers', '.', 'each', 'do', '|', 'ts', '|', 'success', '=', 'try_sign', '(', 'package_file', ',', 'ts', ')', 'break', 'if', 'success', 'end', 'raise', 'FailedToSignWindowsPackage', '.', 'new', 'if', '!', 'success', 'end']
->Original Target:
['Iterates', 'through', 'available', 'timestamp', 'servers', 'and', 'tries', 'to', 'sign', 'the', 'file', 'with', 'with', 'each', 'server', 'stopping', 'after', 'the', 'first', 'to', 'succeed', '.', 'If', 'none', 'succeed', 'an', 'exception', 'is', 'raised', '.']
->Reconstructed Target:
Iterates through available timestamp servers and tries to sign the file with with each server stopping after the first to succeed. If none succeed an exception is raised.
->Reconstructed Predication:
package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_file sign_package_
->Raw Input:
summarize:def sign_package ( package_file ) success = false timestamp_servers. each do | ts | success = try_sign ( package_file, ts ) break if success end raise FailedToSignWindowsPackage. new if! success end
->Raw Target:
Iterates through available timestamp servers and tries to sign the file with with each server stopping after the first to succeed. If none succeed an exception is raised.
--

59=========
->Original Input:
['def', 'certificate_subject', 'return', '"CN=#{project.package_name}"', 'unless', 'signing_identity', 'store', '=', 'machine_store?', '?', '"LocalMachine"', ':', '"CurrentUser"', 'cmd', '=', 'Array', '.', 'new', '.', 'tap', 'do', '|', 'arr', '|', 'arr', '<<', '"powershell.exe"', 'arr', '<<', '"-ExecutionPolicy Bypass"', 'arr', '<<', '"-NoProfile"', 'arr', '<<', '"-Command (Get-Item Cert:/#{store}/#{cert_store_name}/#{thumbprint}).Subject"', 'end', '.', 'join', '(', '" "', ')', 'shellout!', '(', 'cmd', ')', '.', 'stdout', '.', 'strip', 'end']
->Original Target:
['Get', 'the', 'certificate', 'subject', 'of', 'the', 'signing', 'identity']
->Reconstructed Target:
Get the certificate subject of the signing identity
->Reconstructed Predication:
the certificate subject for the
->Raw Input:
summarize:def certificate_subject return "CN=#{project.package_name}" unless signing_identity store = machine_store?? "LocalMachine" : "CurrentUser" cmd = Array. new. tap do | arr | arr << "powershell.exe" arr << "-ExecutionPolicy Bypass" arr << "-NoProfile" arr << "-Command (Get-Item Cert:/#{store}/#{cert_store_name}/#{thumbprint}).Subject" end. join ( " " ) shellout! ( cmd ). stdout. strip end
->Raw Target:
Get the certificate subject of the signing identity
--

60=========
->Original Input:
['def', 'manifest_entry', '@manifest_entry', '||=', 'if', 'manifest', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Using user-supplied manifest entry for #{name}"', '}', 'manifest', '.', 'entry_for', '(', 'name', ')', 'else', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Resolving manifest entry for #{name}"', '}', 'to_manifest_entry', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'software', 'object', '.']
->Reconstructed Target:
Create a new software object.
->Reconstructed Predication:
the manifest entry for the
->Raw Input:
summarize:def manifest_entry @manifest_entry ||= if manifest log. info ( log_key ) { "Using user-supplied manifest entry for #{name}" } manifest. entry_for ( name ) else log. info ( log_key ) { "Resolving manifest entry for #{name}" } to_manifest_entry end end
->Raw Target:
Create a new software object.
--

61=========
->Original Input:
['def', 'source', '(', 'val', '=', 'NULL', ')', 'unless', 'null?', '(', 'val', ')', 'unless', 'val', '.', 'is_a?', '(', 'Hash', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':source', ',', '"be a kind of `Hash\', but was `#{val.class.inspect}\'"', ')', 'end', 'val', '=', 'canonicalize_source', '(', 'val', ')', 'extra_keys', '=', 'val', '.', 'keys', '-', '[', ':git', ',', ':file', ',', ':path', ',', ':url', ',', ':md5', ',', ':sha1', ',', ':sha256', ',', ':sha512', ',', ':cookie', ',', ':warning', ',', ':unsafe', ',', ':extract', ',', ':cached_name', ',', ':authorization', ',', ':options', ',', ':submodules', ']', 'unless', 'extra_keys', '.', 'empty?', 'raise', 'InvalidValue', '.', 'new', '(', ':source', ',', '"only include valid keys. Invalid keys: #{extra_keys.inspect}"', ')', 'end', 'duplicate_keys', '=', 'val', '.', 'keys', '&', '[', ':git', ',', ':file', ',', ':path', ',', ':url', ']', 'unless', 'duplicate_keys', '.', 'size', '<', '2', 'raise', 'InvalidValue', '.', 'new', '(', ':source', ',', '"not include duplicate keys. Duplicate keys: #{duplicate_keys.inspect}"', ')', 'end', '@source', '||=', '{', '}', '@source', '.', 'merge!', '(', 'val', ')', 'end', 'override', '=', 'canonicalize_source', '(', 'overrides', '[', ':source', ']', ')', 'apply_overrides', '(', ':source', ',', 'override', ')', 'end']
->Original Target:
['Set', 'or', 'retrieve', 'the', 'source', 'for', 'the', 'software', '.']
->Reconstructed Target:
Set or retrieve the source for the software.
->Reconstructed Predication:
:source,:source,:source, :git, :file:file, :path, :url:cache, :submodules, :cache_name:cache_url, :cache_type, :cache_type:cache_type, :cache_type, :cache_type:cache_type, :cache_type, :cache_type:cache_type, :cache_type, :cache_type
->Raw Input:
summarize:def source ( val = NULL ) unless null? ( val ) unless val. is_a? ( Hash ) raise InvalidValue. new ( :source, "be a kind of `Hash', but was `#{val.class.inspect}'" ) end val = canonicalize_source ( val ) extra_keys = val. keys - [ :git, :file, :path, :url, :md5, :sha1, :sha256, :sha512, :cookie, :warning, :unsafe, :extract, :cached_name, :authorization, :options, :submodules ] unless extra_keys. empty? raise InvalidValue. new ( :source, "only include valid keys. Invalid keys: #{extra_keys.inspect}" ) end duplicate_keys = val. keys & [ :git, :file, :path, :url ] unless duplicate_keys. size < 2 raise InvalidValue. new ( :source, "not include duplicate keys. Duplicate keys: #{duplicate_keys.inspect}" ) end @source ||= { } @source. merge! ( val ) end override = canonicalize_source ( overrides [ :source ] ) apply_overrides ( :source, override ) end
->Raw Target:
Set or retrieve the source for the software.
--

62=========
->Original Input:
['def', 'version', '(', 'val', '=', 'NULL', ',', '&', 'block', ')', 'final_version', '=', 'apply_overrides', '(', ':version', ')', 'if', 'block_given?', 'if', 'val', '.', 'equal?', '(', 'NULL', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':version', ',', '"pass a block when given a version argument"', ')', 'else', 'if', 'val', '==', 'final_version', 'current_license_files', '=', '@license_files', '@license_files', '=', '[', ']', 'yield', 'new_license_files', '=', '@license_files', 'if', 'new_license_files', '.', 'empty?', '@license_files', '=', 'current_license_files', 'end', 'end', 'end', 'end', 'return', 'if', 'final_version', '.', 'nil?', 'begin', 'Chef', '::', 'Sugar', '::', 'Constraints', '::', 'Version', '.', 'new', '(', 'final_version', ')', 'rescue', 'ArgumentError', 'log', '.', 'warn', '(', 'log_key', ')', 'do', '"Version #{final_version} for software #{name} was not parseable. "', '"Comparison methods such as #satisfies? will not be available for this version."', 'end', 'final_version', 'end', 'end']
->Original Target:
['Evaluate', 'a', 'block', 'only', 'if', 'the', 'version', 'matches', '.']
->Reconstructed Target:
Evaluate a block only if the version matches.
->Reconstructed Predication:
the version of the softwarethe version of the software.
->Raw Input:
summarize:def version ( val = NULL, & block ) final_version = apply_overrides ( :version ) if block_given? if val. equal? ( NULL ) raise InvalidValue. new ( :version, "pass a block when given a version argument" ) else if val == final_version current_license_files = @license_files @license_files = [ ] yield new_license_files = @license_files if new_license_files. empty? @license_files = current_license_files end end end end return if final_version. nil? begin Chef :: Sugar :: Constraints :: Version. new ( final_version ) rescue ArgumentError log. warn ( log_key ) do "Version #{final_version} for software #{name} was not parseable. " "Comparison methods such as #satisfies? will not be available for this version." end final_version end end
->Raw Target:
Evaluate a block only if the version matches.
--

63=========
->Original Input:
['def', 'whitelist_file', '(', 'file', ')', 'file', '=', 'Regexp', '.', 'new', '(', 'file', ')', 'unless', 'file', '.', 'kind_of?', '(', 'Regexp', ')', 'whitelist_files', '<<', 'file', 'whitelist_files', '.', 'dup', 'end']
->Original Target:
['Add', 'a', 'file', 'to', 'the', 'healthcheck', 'whitelist', '.']
->Reconstructed Target:
Add a file to the healthcheck whitelist.
->Reconstructed Predication:
file to whitelist.
->Raw Input:
summarize:def whitelist_file ( file ) file = Regexp. new ( file ) unless file. kind_of? ( Regexp ) whitelist_files << file whitelist_files. dup end
->Raw Target:
Add a file to the healthcheck whitelist.
--

64=========
->Original Input:
['def', 'project_file', 'if', 'fetcher', '&&', 'fetcher', '.', 'is_a?', '(', 'NetFetcher', ')', 'log', '.', 'deprecated', '(', 'log_key', ')', 'do', '"project_file (DSL). This is a property of the NetFetcher and will "', '"not be publically exposed in the next major release. In general, "', '"you should not be using this method in your software definitions "', '"as it is an internal implementation detail of the NetFetcher. If "', '"you disagree with this statement, you should open an issue on the "', '"Omnibus repository on GitHub an explain your use case. For now, "', '"I will return the path to the downloaded file on disk, but please "', '"rethink the problem you are trying to solve :)."', 'end', 'fetcher', '.', 'downloaded_file', 'else', 'log', '.', 'warn', '(', 'log_key', ')', 'do', '"Cannot retrieve a `project_file\' for software `#{name}\'. This "', '"attribute is actually an internal representation that is unique "', '"to the NetFetcher class and requires the use of a `source\' "', '"attribute that is declared using a `:url\' key. For backwards-"', '"compatability, I will return `nil\', but this is most likely not "', '"your desired behavior."', 'end', 'nil', 'end', 'end']
->Original Target:
['The', 'path', 'to', 'the', 'downloaded', 'file', 'from', 'a', 'NetFetcher', '.']
->Reconstructed Target:
The path to the downloaded file from a NetFetcher.
->Reconstructed Predication:
thethe project file for the software
->Raw Input:
summarize:def project_file if fetcher && fetcher. is_a? ( NetFetcher ) log. deprecated ( log_key ) do "project_file (DSL). This is a property of the NetFetcher and will " "not be publically exposed in the next major release. In general, " "you should not be using this method in your software definitions " "as it is an internal implementation detail of the NetFetcher. If " "you disagree with this statement, you should open an issue on the " "Omnibus repository on GitHub an explain your use case. For now, " "I will return the path to the downloaded file on disk, but please " "rethink the problem you are trying to solve :)." end fetcher. downloaded_file else log. warn ( log_key ) do "Cannot retrieve a `project_file' for software `#{name}'. This " "attribute is actually an internal representation that is unique " "to the NetFetcher class and requires the use of a `source' " "attribute that is declared using a `:url' key. For backwards-" "compatability, I will return `nil', but this is most likely not " "your desired behavior." end nil end end
->Raw Target:
The path to the downloaded file from a NetFetcher.
--

65=========
->Original Input:
['def', 'prepend_path', '(', '*', 'paths', ')', 'path_values', '=', 'Array', '(', 'paths', ')', 'path_values', '<<', 'ENV', '[', 'path_key', ']', 'separator', '=', 'File', '::', 'PATH_SEPARATOR', '||', '":"', 'path_values', '.', 'join', '(', 'separator', ')', 'end']
->Original Target:
['A', 'PATH', 'variable', 'format', 'string', 'representing', 'the', 'current', 'PATH', 'with', 'the', 'given', 'path', 'prepended', '.', 'The', 'correct', 'path', 'separator', 'for', 'the', 'platform', 'is', 'used', 'to', 'join', 'the', 'paths', '.']
->Reconstructed Target:
A PATH variable format string representing the current PATH with the given path prepended. The correct path separator for the platform is used to join the paths.
->Reconstructed Predication:
the path to the file
->Raw Input:
summarize:def prepend_path ( * paths ) path_values = Array ( paths ) path_values << ENV [ path_key ] separator = File :: PATH_SEPARATOR || ":" path_values. join ( separator ) end
->Raw Target:
A PATH variable format string representing the current PATH with the given path prepended. The correct path separator for the platform is used to join the paths.
--

66=========
->Original Input:
['def', 'overrides', 'if', 'null?', '(', '@overrides', ')', '@overrides', '=', '{', '}', '@overrides', '=', 'project', '.', 'overrides', '[', 'name', '.', 'to_sym', ']', '.', 'dup', 'if', 'project', '.', 'overrides', '[', 'name', '.', 'to_sym', ']', 'end', '@overrides', 'end']
->Original Target:
['The', 'repo', '-', 'level', 'and', 'project', '-', 'level', 'overrides', 'for', 'the', 'software', '.']
->Reconstructed Target:
The repo - level and project - level overrides for the software.
->Reconstructed Predication:
@overrides  def overrides
->Raw Input:
summarize:def overrides if null? ( @overrides ) @overrides = { } @overrides = project. overrides [ name. to_sym ]. dup if project. overrides [ name. to_sym ] end @overrides end
->Raw Target:
The repo - level and project - level overrides for the software.
--

67=========
->Original Input:
['def', 'version_for_cache', '@version_for_cache', '||=', 'if', 'fetcher', '.', 'version_for_cache', 'fetcher', '.', 'version_for_cache', 'elsif', 'version', 'version', 'else', 'log', '.', 'warn', '(', 'log_key', ')', 'do', '"No version given! This is probably a bad thing. I am going to "', '"assume the version `0.0.0\', but that is most certainly not your "', '"desired behavior. If git caching seems off, this is probably why."', 'end', '"0.0.0"', 'end', 'end']
->Original Target:
['Returns', 'the', 'version', 'to', 'be', 'used', 'in', 'cache', '.']
->Reconstructed Target:
Returns the version to be used in cache.
->Reconstructed Predication:
the version for the cache
->Raw Input:
summarize:def version_for_cache @version_for_cache ||= if fetcher. version_for_cache fetcher. version_for_cache elsif version version else log. warn ( log_key ) do "No version given! This is probably a bad thing. I am going to " "assume the version `0.0.0', but that is most certainly not your " "desired behavior. If git caching seems off, this is probably why." end "0.0.0" end end
->Raw Target:
Returns the version to be used in cache.
--

68=========
->Original Input:
['def', 'fetcher', '@fetcher', '||=', 'if', 'source_type', '==', ':url', '&&', 'File', '.', 'basename', '(', 'source', '[', ':url', ']', ',', '"?*"', ')', '.', 'end_with?', '(', '*', 'NetFetcher', '::', 'ALL_EXTENSIONS', ')', 'Fetcher', '.', 'fetcher_class_for_source', '(', 'source', ')', '.', 'new', '(', 'manifest_entry', ',', 'fetch_dir', ',', 'build_dir', ')', 'else', 'Fetcher', '.', 'fetcher_class_for_source', '(', 'source', ')', '.', 'new', '(', 'manifest_entry', ',', 'project_dir', ',', 'build_dir', ')', 'end', 'end']
->Original Target:
['The', 'fetcher', 'for', 'this', 'software']
->Reconstructed Target:
The fetcher for this software
->Reconstructed Predication:
fetcher for a given source
->Raw Input:
summarize:def fetcher @fetcher ||= if source_type == :url && File. basename ( source [ :url ], "?*" ). end_with? ( * NetFetcher :: ALL_EXTENSIONS ) Fetcher. fetcher_class_for_source ( source ). new ( manifest_entry, fetch_dir, build_dir ) else Fetcher. fetcher_class_for_source ( source ). new ( manifest_entry, project_dir, build_dir ) end end
->Raw Target:
The fetcher for this software
--

69=========
->Original Input:
['def', 'shasum', '@shasum', '||=', 'begin', 'digest', '=', 'Digest', '::', 'SHA256', '.', 'new', 'update_with_string', '(', 'digest', ',', 'project', '.', 'shasum', ')', 'update_with_string', '(', 'digest', ',', 'builder', '.', 'shasum', ')', 'update_with_string', '(', 'digest', ',', 'name', ')', 'update_with_string', '(', 'digest', ',', 'version_for_cache', ')', 'update_with_string', '(', 'digest', ',', 'FFI_Yajl', '::', 'Encoder', '.', 'encode', '(', 'overrides', ')', ')', 'if', 'filepath', '&&', 'File', '.', 'exist?', '(', 'filepath', ')', 'update_with_file_contents', '(', 'digest', ',', 'filepath', ')', 'else', 'update_with_string', '(', 'digest', ',', '"<DYNAMIC>"', ')', 'end', 'digest', '.', 'hexdigest', 'end', 'end']
->Original Target:
['The', 'unique', 'SHA256', 'for', 'this', 'sofware', 'definition', '.']
->Reconstructed Target:
The unique SHA256 for this sofware definition.
->Reconstructed Predication:
the project and the builderthe builder and the overridesthe project and the builder
->Raw Input:
summarize:def shasum @shasum ||= begin digest = Digest :: SHA256. new update_with_string ( digest, project. shasum ) update_with_string ( digest, builder. shasum ) update_with_string ( digest, name ) update_with_string ( digest, version_for_cache ) update_with_string ( digest, FFI_Yajl :: Encoder. encode ( overrides ) ) if filepath && File. exist? ( filepath ) update_with_file_contents ( digest, filepath ) else update_with_string ( digest, "<DYNAMIC>" ) end digest. hexdigest end end
->Raw Target:
The unique SHA256 for this sofware definition.
--

70=========
->Original Input:
['def', 'canonicalize_source', '(', 'source', ')', 'if', 'source', '.', 'is_a?', '(', 'Hash', ')', '&&', 'source', '[', ':github', ']', 'source', '=', 'source', '.', 'dup', 'source', '[', ':git', ']', '=', '"https://github.com/#{source[:github]}.git"', 'source', '.', 'delete', '(', ':github', ')', 'end', 'source', 'end']
->Original Target:
['Transform', 'github', '-', '>', 'git', 'in', 'source']
->Reconstructed Target:
Transform github - > git in source
->Reconstructed Predication:
source = source. dup
->Raw Input:
summarize:def canonicalize_source ( source ) if source. is_a? ( Hash ) && source [ :github ] source = source. dup source [ :git ] = "https://github.com/#{source[:github]}.git" source. delete ( :github ) end source end
->Raw Target:
Transform github - > git in source
--

71=========
->Original Input:
['def', 'write_makeselfinst', 'makeselfinst_staging_path', '=', 'File', '.', 'join', '(', 'staging_dir', ',', '"makeselfinst"', ')', 'render_template', '(', 'resource_path', '(', '"makeselfinst.erb"', ')', ',', 'destination', ':', 'makeselfinst_staging_path', ',', 'variables', ':', '{', 'install_dir', ':', 'project', '.', 'install_dir', ',', '}', ')', 'FileUtils', '.', 'chmod', '(', '0755', ',', 'makeselfinst_staging_path', ')', 'end']
->Original Target:
['Render', 'a', 'makeselfinst', 'in', 'the', 'staging', 'directory', 'using', 'the', 'supplied', 'ERB', 'template', '.', 'This', 'file', 'will', 'be', 'used', 'to', 'move', 'the', 'contents', 'of', 'the', 'self', '-', 'extracting', 'archive', 'into', 'place', 'following', 'extraction', '.']
->Reconstructed Target:
Render a makeselfinst in the staging directory using the supplied ERB template. This file will be used to move the contents of the self - extracting archive into place following extraction.
->Reconstructed Predication:
the project to be written
->Raw Input:
summarize:def write_makeselfinst makeselfinst_staging_path = File. join ( staging_dir, "makeselfinst" ) render_template ( resource_path ( "makeselfinst.erb" ), destination : makeselfinst_staging_path, variables : { install_dir : project. install_dir, } ) FileUtils. chmod ( 0755, makeselfinst_staging_path ) end
->Raw Target:
Render a makeselfinst in the staging directory using the supplied ERB template. This file will be used to move the contents of the self - extracting archive into place following extraction.
--

72=========
->Original Input:
['def', 'create_cache_path', 'if', 'File', '.', 'directory?', '(', 'cache_path', ')', 'false', 'else', 'create_directory', '(', 'File', '.', 'dirname', '(', 'cache_path', ')', ')', 'git_cmd', '(', '"init -q"', ')', 'git_cmd', '(', '"config --local user.name \\"Omnibus Git Cache\\""', ')', 'git_cmd', '(', '"config --local user.email \\"omnibus@localhost\\""', ')', 'true', 'end', 'end']
->Original Target:
['Creates', 'the', 'full', 'path', 'if', 'it', 'does', 'not', 'exist', 'already', '.']
->Reconstructed Target:
Creates the full path if it does not exist already.
->Reconstructed Predication:
the cache directory for thethe cache directory for the
->Raw Input:
summarize:def create_cache_path if File. directory? ( cache_path ) false else create_directory ( File. dirname ( cache_path ) ) git_cmd ( "init -q" ) git_cmd ( "config --local user.name \"Omnibus Git Cache\"" ) git_cmd ( "config --local user.email \"omnibus@localhost\"" ) true end end
->Raw Target:
Creates the full path if it does not exist already.
--

73=========
->Original Input:
['def', 'tag', 'return', '@tag', 'if', '@tag', 'log', '.', 'internal', '(', 'log_key', ')', '{', '"Calculating tag"', '}', 'dep_list', '=', 'software', '.', 'project', '.', 'library', '.', 'build_order', '.', 'take_while', 'do', '|', 'dep', '|', 'if', 'dep', '.', 'name', '==', 'software', '.', 'name', '&&', 'dep', '.', 'version', '==', 'software', '.', 'version', 'false', 'else', 'true', 'end', 'end', 'log', '.', 'internal', '(', 'log_key', ')', '{', '"dep_list: #{dep_list.map(&:name).inspect}"', '}', 'shasums', '=', '[', 'dep_list', '.', 'map', '(', '&', ':shasum', ')', ',', 'software', '.', 'shasum', ']', '.', 'flatten', 'suffix', '=', 'Digest', '::', 'SHA256', '.', 'hexdigest', '(', 'shasums', '.', 'join', '(', '"|"', ')', ')', '@tag', '=', '"#{software.name}-#{suffix}-#{SERIAL_NUMBER}"', 'log', '.', 'internal', '(', 'log_key', ')', '{', '"tag: #{@tag}"', '}', '@tag', 'end']
->Original Target:
['Computes', 'the', 'tag', 'for', 'this', 'cache', 'entry', '.']
->Reconstructed Target:
Computes the tag for this cache entry.
->Reconstructed Predication:
@tag =@tag = "latest"@tag = "latest"@tag = "latest"@tag = "latest" @tag =@tag = "latest" @tag =@tag = "latest" @tag ="latest" @tag = "latest"@tag = "latest" @tag =@tag = "latest" @tag ="latest" @tag = "latest" @tag
->Raw Input:
summarize:def tag return @tag if @tag log. internal ( log_key ) { "Calculating tag" } dep_list = software. project. library. build_order. take_while do | dep | if dep. name == software. name && dep. version == software. version false else true end end log. internal ( log_key ) { "dep_list: #{dep_list.map(&:name).inspect}" } shasums = [ dep_list. map ( & :shasum ), software. shasum ]. flatten suffix = Digest :: SHA256. hexdigest ( shasums. join ( "|" ) ) @tag = "#{software.name}-#{suffix}-#{SERIAL_NUMBER}" log. internal ( log_key ) { "tag: #{@tag}" } @tag end
->Raw Target:
Computes the tag for this cache entry.
--

74=========
->Original Input:
['def', 'incremental', 'log', '.', 'internal', '(', 'log_key', ')', '{', '"Performing incremental cache"', '}', 'create_cache_path', 'remove_git_dirs', 'git_cmd', '(', '"add -A -f"', ')', 'begin', 'git_cmd', '(', '%Q{commit -q -m "Backup of #{tag}"}', ')', 'rescue', 'CommandFailed', '=>', 'e', 'raise', 'unless', 'e', '.', 'message', '.', 'include?', '(', '"nothing to commit"', ')', 'end', 'git_cmd', '(', '%Q{tag -f "#{tag}"}', ')', 'end']
->Original Target:
['Create', 'an', 'incremental', 'install', 'path', 'cache', 'for', 'the', 'software', 'step']
->Reconstructed Target:
Create an incremental install path cache for the software step
->Reconstructed Predication:
the incremental logthe incremental log
->Raw Input:
summarize:def incremental log. internal ( log_key ) { "Performing incremental cache" } create_cache_path remove_git_dirs git_cmd ( "add -A -f" ) begin git_cmd ( %Q{commit -q -m "Backup of #{tag}"} ) rescue CommandFailed => e raise unless e. message. include? ( "nothing to commit" ) end git_cmd ( %Q{tag -f "#{tag}"} ) end
->Raw Target:
Create an incremental install path cache for the software step
--

75=========
->Original Input:
['def', 'remove_git_dirs', 'log', '.', 'internal', '(', 'log_key', ')', '{', '"Removing git directories"', '}', 'Dir', '.', 'glob', '(', '"#{install_dir}/**/{,.*}/config"', ')', '.', 'reject', 'do', '|', 'path', '|', 'REQUIRED_GIT_FILES', '.', 'any?', 'do', '|', 'required_file', '|', '!', 'File', '.', 'exist?', '(', 'File', '.', 'join', '(', 'File', '.', 'dirname', '(', 'path', ')', ',', 'required_file', ')', ')', 'end', 'end', '.', 'each', 'do', '|', 'path', '|', 'log', '.', 'internal', '(', 'log_key', ')', '{', '"Removing git dir `#{path}\'"', '}', 'FileUtils', '.', 'rm_rf', '(', 'File', '.', 'dirname', '(', 'path', ')', ')', 'end', 'true', 'end']
->Original Target:
['Git', 'caching', 'will', 'attempt', 'to', 'version', 'embedded', 'git', 'directories', 'partially', 'versioning', 'them', '.', 'This', 'causes', 'failures', 'on', 'subsequent', 'runs', '.', 'This', 'method', 'will', 'find', 'git', 'directories', 'and', 'remove', 'them', 'to', 'prevent', 'those', 'errors', '.']
->Reconstructed Target:
Git caching will attempt to version embedded git directories partially versioning them. This causes failures on subsequent runs. This method will find git directories and remove them to prevent those errors.
->Reconstructed Predication:
the git directory `#{install_dir}/**/config` will removethe git directory `#{install_dir}/**/config` will remove
->Raw Input:
summarize:def remove_git_dirs log. internal ( log_key ) { "Removing git directories" } Dir. glob ( "#{install_dir}/**/{,.*}/config" ). reject do | path | REQUIRED_GIT_FILES. any? do | required_file |! File. exist? ( File. join ( File. dirname ( path ), required_file ) ) end end. each do | path | log. internal ( log_key ) { "Removing git dir `#{path}'" } FileUtils. rm_rf ( File. dirname ( path ) ) end true end
->Raw Target:
Git caching will attempt to version embedded git directories partially versioning them. This causes failures on subsequent runs. This method will find git directories and remove them to prevent those errors.
--

76=========
->Original Input:
['def', 'write_manifest_file', 'render_template', '(', 'resource_path', '(', '"AppxManifest.xml.erb"', ')', ',', 'destination', ':', '"#{windows_safe_path(project.install_dir)}/AppxManifest.xml"', ',', 'variables', ':', '{', 'name', ':', 'project', '.', 'package_name', ',', 'friendly_name', ':', 'project', '.', 'friendly_name', ',', 'version', ':', 'windows_package_version', ',', 'maintainer', ':', 'project', '.', 'maintainer', ',', 'certificate_subject', ':', 'certificate_subject', '.', 'gsub', '(', '\'"\'', ',', '"&quot;"', ')', ',', '}', ')', 'end']
->Original Target:
['Write', 'the', 'manifest', 'file', 'into', 'the', 'staging', 'directory', '.']
->Reconstructed Target:
Write the manifest file into the staging directory.
->Reconstructed Predication:
the manifest file to thethe manifest file to the
->Raw Input:
summarize:def write_manifest_file render_template ( resource_path ( "AppxManifest.xml.erb" ), destination : "#{windows_safe_path(project.install_dir)}/AppxManifest.xml", variables : { name : project. package_name, friendly_name : project. friendly_name, version : windows_package_version, maintainer : project. maintainer, certificate_subject : certificate_subject. gsub ( '"', "&quot;" ), } ) end
->Raw Target:
Write the manifest file into the staging directory.
--

77=========
->Original Input:
['def', 'shellout', '(', '*', 'args', ')', 'options', '=', 'args', '.', 'last', '.', 'kind_of?', '(', 'Hash', ')', '?', 'args', '.', 'pop', ':', '{', '}', 'options', '=', 'SHELLOUT_OPTIONS', '.', 'merge', '(', 'options', ')', 'command_string', '=', 'args', '.', 'join', '(', '" "', ')', 'in_msys', '=', 'options', '.', 'delete', '(', ':in_msys_bash', ')', '&&', 'ENV', '[', '"MSYSTEM"', ']', 'command_string', '=', '"bash -c \\\'#{command_string}\\\'"', 'if', 'in_msys', 'log_level', '=', 'options', '.', 'delete', '(', ':log_level', ')', 'options', '[', ':live_stream', ']', '||=', 'log', '.', 'live_stream', '(', ':internal', ')', 'if', 'options', '[', ':env', ']', 'options', '[', ':environment', ']', '=', 'options', '.', 'fetch', '(', ':environment', ',', '{', '}', ')', '.', 'merge', '(', 'options', '[', ':env', ']', ')', 'end', 'unless', 'options', '[', ':environment', ']', '.', 'empty?', 'log', '.', 'public_send', '(', 'log_level', ',', 'log_key', ')', '{', '"Environment:"', '}', 'options', '[', ':environment', ']', '.', 'sort', '.', 'each', 'do', '|', 'key', ',', 'value', '|', 'log', '.', 'public_send', '(', 'log_level', ',', 'log_key', ')', '{', '"  #{key}=#{value.inspect}"', '}', 'end', 'end', 'log', '.', 'public_send', '(', 'log_level', ',', 'log_key', ')', '{', '"$ #{command_string}"', '}', 'cmd', '=', 'Mixlib', '::', 'ShellOut', '.', 'new', '(', 'command_string', ',', 'options', ')', 'cmd', '.', 'environment', '[', '"HOME"', ']', '=', '"/tmp"', 'unless', 'ENV', '[', '"HOME"', ']', 'cmd', '.', 'run_command', 'cmd', 'end']
->Original Target:
['Shells', 'out', 'and', 'runs', '+', 'command', '+', '.']
->Reconstructed Target:
Shells out and runs + command +.
->Reconstructed Predication:
() { |. public_send ( log_level,) { "Command:"$ #{command_string}" }"$ #{options[:live_stream]}" }"$ #{options[:live_stream]}""$ #{options[:live_stream]}" }"$ #{options[:live_stream]}""$ #{options[:live_stream]}" }"$ #{options[:live_stream]}" } end
->Raw Input:
summarize:def shellout ( * args ) options = args. last. kind_of? ( Hash )? args. pop : { } options = SHELLOUT_OPTIONS. merge ( options ) command_string = args. join ( " " ) in_msys = options. delete ( :in_msys_bash ) && ENV [ "MSYSTEM" ] command_string = "bash -c \'#{command_string}\'" if in_msys log_level = options. delete ( :log_level ) options [ :live_stream ] ||= log. live_stream ( :internal ) if options [ :env ] options [ :environment ] = options. fetch ( :environment, { } ). merge ( options [ :env ] ) end unless options [ :environment ]. empty? log. public_send ( log_level, log_key ) { "Environment:" } options [ :environment ]. sort. each do | key, value | log. public_send ( log_level, log_key ) { "  #{key}=#{value.inspect}" } end end log. public_send ( log_level, log_key ) { "$ #{command_string}" } cmd = Mixlib :: ShellOut. new ( command_string, options ) cmd. environment [ "HOME" ] = "/tmp" unless ENV [ "HOME" ] cmd. run_command cmd end
->Raw Target:
Shells out and runs + command +.
--

78=========
->Original Input:
['def', 'shellout!', '(', '*', 'args', ')', 'cmd', '=', 'shellout', '(', '*', 'args', ')', 'cmd', '.', 'error!', 'cmd', 'rescue', 'Mixlib', '::', 'ShellOut', '::', 'ShellCommandFailed', 'raise', 'CommandFailed', '.', 'new', '(', 'cmd', ')', 'rescue', 'Mixlib', '::', 'ShellOut', '::', 'CommandTimeout', 'raise', 'CommandTimeout', '.', 'new', '(', 'cmd', ')', 'end']
->Original Target:
['Similar', 'to', '+', 'shellout', '+', 'method', 'except', 'it', 'raises', 'an', 'exception', 'if', 'the', 'command', 'fails', '.']
->Reconstructed Target:
Similar to + shellout + method except it raises an exception if the command fails.
->Reconstructed Predication:
ShellOut :: ShellCommand.
->Raw Input:
summarize:def shellout! ( * args ) cmd = shellout ( * args ) cmd. error! cmd rescue Mixlib :: ShellOut :: ShellCommandFailed raise CommandFailed. new ( cmd ) rescue Mixlib :: ShellOut :: CommandTimeout raise CommandTimeout. new ( cmd ) end
->Raw Target:
Similar to + shellout + method except it raises an exception if the command fails.
--

79=========
->Original Input:
['def', 'retry_block', '(', 'logstr', ',', 'retried_exceptions', '=', '[', ']', ',', 'retries', '=', 'Omnibus', '::', 'Config', '.', 'fetcher_retries', ',', '&', 'block', ')', 'yield', 'rescue', 'Exception', '=>', 'e', 'raise', 'e', 'unless', 'retried_exceptions', '.', 'any?', '{', '|', 'eclass', '|', 'e', '.', 'is_a?', '(', 'eclass', ')', '}', 'if', 'retries', '!=', '0', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Retrying failed #{logstr} due to #{e} (#{retries} retries left)..."', '}', 'retries', '-=', '1', 'retry', 'else', 'log', '.', 'error', '(', 'log_key', ')', '{', '"#{logstr} failed - #{e.class}!"', '}', 'raise', 'end', 'end']
->Original Target:
['Retry', 'the', 'given', 'block', 'if', 'a', 'retriable', 'exception', 'is', 'raised', '.', 'Returns', 'the', 'value', 'of', 'the', 'block', 'call', 'if', 'successful', '.']
->Reconstructed Target:
Retry the given block if a retriable exception is raised. Returns the value of the block call if successful.
->Reconstructed Predication:
retry the block with theretrying the block with the
->Raw Input:
summarize:def retry_block ( logstr, retried_exceptions = [ ], retries = Omnibus :: Config. fetcher_retries, & block ) yield rescue Exception => e raise e unless retried_exceptions. any? { | eclass | e. is_a? ( eclass ) } if retries!= 0 log. info ( log_key ) { "Retrying failed #{logstr} due to #{e} (#{retries} retries left)..." } retries -= 1 retry else log. error ( log_key ) { "#{logstr} failed - #{e.class}!" } raise end end
->Raw Target:
Retry the given block if a retriable exception is raised. Returns the value of the block call if successful.
--

80=========
->Original Input:
['def', 'windows_safe_path', '(', '*', 'pieces', ')', 'path', '=', 'File', '.', 'join', '(', '*', 'pieces', ')', 'if', 'File', '::', 'ALT_SEPARATOR', 'path', '.', 'gsub', '(', 'File', '::', 'SEPARATOR', ',', 'File', '::', 'ALT_SEPARATOR', ')', 'else', 'path', 'end', 'end']
->Original Target:
['Convert', 'the', 'given', 'path', 'to', 'be', 'appropiate', 'for', 'shelling', 'out', 'on', 'Windows', '.']
->Reconstructed Target:
Convert the given path to be appropiate for shelling out on Windows.
->Reconstructed Predication:
the path to the file
->Raw Input:
summarize:def windows_safe_path ( * pieces ) path = File. join ( * pieces ) if File :: ALT_SEPARATOR path. gsub ( File :: SEPARATOR, File :: ALT_SEPARATOR ) else path end end
->Raw Target:
Convert the given path to be appropiate for shelling out on Windows.
--

81=========
->Original Input:
['def', 'compiler_safe_path', '(', '*', 'pieces', ')', 'path', '=', 'File', '.', 'join', '(', '*', 'pieces', ')', 'path', '=', 'path', '.', 'sub', '(', '/', '\\/', '/', ',', '"/\\\\1/"', ')', 'if', 'ENV', '[', '"MSYSTEM"', ']', 'path', 'end']
->Original Target:
['Convert', 'the', 'given', 'path', 'to', 'be', 'appropriate', 'for', 'usage', 'with', 'the', 'given', 'compiler']
->Reconstructed Target:
Convert the given path to be appropriate for usage with the given compiler
->Reconstructed Predication:
path
->Raw Input:
summarize:def compiler_safe_path ( * pieces ) path = File. join ( * pieces ) path = path. sub ( / \/ /, "/\\1/" ) if ENV [ "MSYSTEM" ] path end
->Raw Target:
Convert the given path to be appropriate for usage with the given compiler
--

82=========
->Original Input:
['def', 'create_directory', '(', '*', 'paths', ')', 'path', '=', 'File', '.', 'join', '(', '*', 'paths', ')', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Creating directory `#{path}\'"', '}', 'FileUtils', '.', 'mkdir_p', '(', 'path', ')', 'path', 'end']
->Original Target:
['Create', 'a', 'directory', 'at', 'the', 'given', '+', 'path', '+', '.']
->Reconstructed Target:
Create a directory at the given + path +.
->Reconstructed Predication:
Create a directory for the
->Raw Input:
summarize:def create_directory ( * paths ) path = File. join ( * paths ) log. debug ( log_key ) { "Creating directory `#{path}'" } FileUtils. mkdir_p ( path ) path end
->Raw Target:
Create a directory at the given + path +.
--

83=========
->Original Input:
['def', 'remove_directory', '(', '*', 'paths', ')', 'path', '=', 'File', '.', 'join', '(', '*', 'paths', ')', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Remove directory `#{path}\'"', '}', 'FileUtils', '.', 'rm_rf', '(', 'path', ')', 'path', 'end']
->Original Target:
['Remove', 'the', 'directory', 'at', 'the', 'given', '+', 'path', '+', '.']
->Reconstructed Target:
Remove the directory at the given + path +.
->Reconstructed Predication:
Remove a directory
->Raw Input:
summarize:def remove_directory ( * paths ) path = File. join ( * paths ) log. debug ( log_key ) { "Remove directory `#{path}'" } FileUtils. rm_rf ( path ) path end
->Raw Target:
Remove the directory at the given + path +.
--

84=========
->Original Input:
['def', 'copy_file', '(', 'source', ',', 'destination', ')', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Copying `#{source}\' to `#{destination}\'"', '}', 'FileUtils', '.', 'cp', '(', 'source', ',', 'destination', ')', 'destination', 'end']
->Original Target:
['Copy', 'the', '+', 'source', '+', 'file', 'to', 'the', '+', 'destination', '+', '.']
->Reconstructed Target:
Copy the + source + file to the + destination +.
->Reconstructed Predication:
copy a file to a
->Raw Input:
summarize:def copy_file ( source, destination ) log. debug ( log_key ) { "Copying `#{source}' to `#{destination}'" } FileUtils. cp ( source, destination ) destination end
->Raw Target:
Copy the + source + file to the + destination +.
--

85=========
->Original Input:
['def', 'remove_file', '(', '*', 'paths', ')', 'path', '=', 'File', '.', 'join', '(', '*', 'paths', ')', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Removing file `#{path}\'"', '}', 'FileUtils', '.', 'rm_f', '(', 'path', ')', 'path', 'end']
->Original Target:
['Remove', 'the', 'file', 'at', 'the', 'given', 'path', '.']
->Reconstructed Target:
Remove the file at the given path.
->Reconstructed Predication:
Remove a file from the
->Raw Input:
summarize:def remove_file ( * paths ) path = File. join ( * paths ) log. debug ( log_key ) { "Removing file `#{path}'" } FileUtils. rm_f ( path ) path end
->Raw Target:
Remove the file at the given path.
--

86=========
->Original Input:
['def', 'create_file', '(', '*', 'paths', ',', '&', 'block', ')', 'path', '=', 'File', '.', 'join', '(', '*', 'paths', ')', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Creating file `#{path}\'"', '}', 'FileUtils', '.', 'mkdir_p', '(', 'File', '.', 'dirname', '(', 'path', ')', ')', 'if', 'block', 'File', '.', 'open', '(', 'path', ',', '"wb"', ')', '{', '|', 'f', '|', 'f', '.', 'write', '(', 'yield', ')', '}', 'else', 'FileUtils', '.', 'touch', '(', 'path', ')', 'end', 'path', 'end']
->Original Target:
['Create', 'a', 'file', 'at', 'the', 'given', 'path', '.', 'If', 'a', 'block', 'is', 'given', 'the', 'contents', 'of', 'the', 'block', 'are', 'written', 'to', 'the', 'file', '.', 'If', 'the', 'block', 'is', 'not', 'given', 'the', 'file', 'is', 'simply', 'touched', '.']
->Reconstructed Target:
Create a file at the given path. If a block is given the contents of the block are written to the file. If the block is not given the file is simply touched.
->Reconstructed Predication:
a file to be created
->Raw Input:
summarize:def create_file ( * paths, & block ) path = File. join ( * paths ) log. debug ( log_key ) { "Creating file `#{path}'" } FileUtils. mkdir_p ( File. dirname ( path ) ) if block File. open ( path, "wb" ) { | f | f. write ( yield ) } else FileUtils. touch ( path ) end path end
->Raw Target:
Create a file at the given path. If a block is given the contents of the block are written to the file. If the block is not given the file is simply touched.
--

87=========
->Original Input:
['def', 'create_link', '(', 'a', ',', 'b', ')', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"Linking `#{a}\' to `#{b}\'"', '}', 'FileUtils', '.', 'ln_s', '(', 'a', ',', 'b', ')', 'end']
->Original Target:
['Create', 'a', 'symlink', 'from', 'a', 'to', 'b']
->Reconstructed Target:
Create a symlink from a to b
->Reconstructed Predication:
a file to a filea file to a file
->Raw Input:
summarize:def create_link ( a, b ) log. debug ( log_key ) { "Linking `#{a}' to `#{b}'" } FileUtils. ln_s ( a, b ) end
->Raw Target:
Create a symlink from a to b
--

88=========
->Original Input:
['def', 'validate_license_info', 'if', 'project', '.', 'license', '==', '"Unspecified"', 'licensing_warning', '(', '"Project \'#{project.name}\' does not contain licensing information."', ')', 'end', 'if', 'project', '.', 'license', '!=', '"Unspecified"', '&&', 'project', '.', 'license_file', '.', 'nil?', 'licensing_warning', '(', '"Project \'#{project.name}\' does not point to a license file."', ')', 'end', 'if', 'project', '.', 'license', '!=', '"Unspecified"', '&&', '!', 'STANDARD_LICENSES', '.', 'include?', '(', 'project', '.', 'license', ')', 'licensing_info', '(', '"Project \'#{project.name}\' is using \'#{project.license}\' which is not one of the standard licenses identified in https://opensource.org/licenses/alphabetical. Consider using one of the standard licenses."', ')', 'end', 'license_map', '.', 'each', 'do', '|', 'software_name', ',', 'license_info', '|', 'if', 'license_info', '[', ':license', ']', '==', '"Unspecified"', 'licensing_warning', '(', '"Software \'#{software_name}\' does not contain licensing information."', ')', 'end', 'if', 'license_info', '[', ':license', ']', '!=', '"Unspecified"', '&&', 'license_info', '[', ':license_files', ']', '.', 'empty?', 'licensing_warning', '(', '"Software \'#{software_name}\' does not point to any license files."', ')', 'end', 'if', 'license_info', '[', ':license', ']', '!=', '"Unspecified"', '&&', '!', 'STANDARD_LICENSES', '.', 'include?', '(', 'license_info', '[', ':license', ']', ')', 'licensing_info', '(', '"Software \'#{software_name}\' uses license \'#{license_info[:license]}\' which is not one of the standard licenses identified in https://opensource.org/licenses/alphabetical. Consider using one of the standard licenses."', ')', 'end', 'end', 'end']
->Original Target:
['Inspects', 'the', 'licensing', 'information', 'for', 'the', 'project', 'and', 'the', 'included', 'software', 'components', '.', 'Logs', 'the', 'found', 'issues', 'to', 'the', 'log', 'as', 'warning', '.']
->Reconstructed Target:
Inspects the licensing information for the project and the included software components. Logs the found issues to the log as warning.
->Reconstructed Predication:
the license fileslicense_files.license_file. nil? licensing_warning ( "Project'#{project.name}' uses license '#{project.license}' which isthe license '#{project.license_file}''#{project.license_file}' is using license '#{project.license_file}' whichthe license '#{project.license_file}''#{project.license_file}' is using license '#{project.license_
->Raw Input:
summarize:def validate_license_info if project. license == "Unspecified" licensing_warning ( "Project '#{project.name}' does not contain licensing information." ) end if project. license!= "Unspecified" && project. license_file. nil? licensing_warning ( "Project '#{project.name}' does not point to a license file." ) end if project. license!= "Unspecified" &&! STANDARD_LICENSES. include? ( project. license ) licensing_info ( "Project '#{project.name}' is using '#{project.license}' which is not one of the standard licenses identified in https://opensource.org/licenses/alphabetical. Consider using one of the standard licenses." ) end license_map. each do | software_name, license_info | if license_info [ :license ] == "Unspecified" licensing_warning ( "Software '#{software_name}' does not contain licensing information." ) end if license_info [ :license ]!= "Unspecified" && license_info [ :license_files ]. empty? licensing_warning ( "Software '#{software_name}' does not point to any license files." ) end if license_info [ :license ]!= "Unspecified" &&! STANDARD_LICENSES. include? ( license_info [ :license ] ) licensing_info ( "Software '#{software_name}' uses license '#{license_info[:license]}' which is not one of the standard licenses identified in https://opensource.org/licenses/alphabetical. Consider using one of the standard licenses." ) end end end
->Raw Target:
Inspects the licensing information for the project and the included software components. Logs the found issues to the log as warning.
--

89=========
->Original Input:
['def', 'project_license_content', 'project', '.', 'license_file', '.', 'nil?', '?', '""', ':', 'IO', '.', 'read', '(', 'File', '.', 'join', '(', 'Config', '.', 'project_root', ',', 'project', '.', 'license_file', ')', ')', 'end']
->Original Target:
['Contents', 'of', 'the', 'project', 's', 'license']
->Reconstructed Target:
Contents of the project s license
->Reconstructed Predication:
project license content
->Raw Input:
summarize:def project_license_content project. license_file. nil?? "" : IO. read ( File. join ( Config. project_root, project. license_file ) ) end
->Raw Target:
Contents of the project s license
--

90=========
->Original Input:
['def', 'license_map', '@license_map', '||=', 'begin', 'map', '=', '{', '}', 'project', '.', 'library', '.', 'each', 'do', '|', 'component', '|', 'next', 'if', 'component', '.', 'license', '==', ':project_license', 'map', '[', 'component', '.', 'name', ']', '=', '{', 'license', ':', 'component', '.', 'license', ',', 'license_files', ':', 'component', '.', 'license_files', ',', 'version', ':', 'component', '.', 'version', ',', 'project_dir', ':', 'component', '.', 'project_dir', ',', '}', 'end', 'map', 'end', 'end']
->Original Target:
['Map', 'that', 'collects', 'information', 'about', 'the', 'licenses', 'of', 'the', 'softwares', 'included', 'in', 'the', 'project', '.']
->Reconstructed Target:
Map that collects information about the licenses of the softwares included in the project.
->Reconstructed Predication:
the license map for the project
->Raw Input:
summarize:def license_map @license_map ||= begin map = { } project. library. each do | component | next if component. license == :project_license map [ component. name ] = { license : component. license, license_files : component. license_files, version : component. version, project_dir : component. project_dir, } end map end end
->Raw Target:
Map that collects information about the licenses of the softwares included in the project.
--

91=========
->Original Input:
['def', 'process_transitive_dependency_licensing_info', 'Dir', '.', 'glob', '(', '"#{cache_dir}/*/*-dependency-licenses.json"', ')', '.', 'each', 'do', '|', 'license_manifest_path', '|', 'license_manifest_data', '=', 'FFI_Yajl', '::', 'Parser', '.', 'parse', '(', 'File', '.', 'read', '(', 'license_manifest_path', ')', ')', 'project_name', '=', 'license_manifest_data', '[', '"project_name"', ']', 'dependency_license_dir', '=', 'File', '.', 'dirname', '(', 'license_manifest_path', ')', 'license_manifest_data', '[', '"dependency_managers"', ']', '.', 'each', 'do', '|', 'dep_mgr_name', ',', 'dependencies', '|', 'dep_license_map', '[', 'dep_mgr_name', ']', '||=', '{', '}', 'dependencies', '.', 'each', 'do', '|', 'dependency', '|', 'dependency', '[', '"license_files"', ']', '.', 'each', 'do', '|', 'f', '|', 'license_path', '=', 'File', '.', 'join', '(', 'dependency_license_dir', ',', 'f', ')', 'output_path', '=', 'File', '.', 'join', '(', 'output_dir', ',', 'f', ')', 'FileUtils', '.', 'cp', '(', 'license_path', ',', 'output_path', ')', 'end', 'dep_name', '=', 'dependency', '[', '"name"', ']', 'dep_version', '=', 'dependency', '[', '"version"', ']', 'if', 'dep_license_map', '[', 'dep_mgr_name', ']', '[', 'dep_name', ']', '&&', 'dep_license_map', '[', 'dep_mgr_name', ']', '[', 'dep_name', ']', '[', 'dep_version', ']', 'dep_license_map', '[', 'dep_mgr_name', ']', '[', 'dep_name', ']', '[', 'dep_version', ']', '[', '"dependency_of"', ']', '<<', 'project_name', 'else', 'dep_license_map', '[', 'dep_mgr_name', ']', '[', 'dep_name', ']', '||=', '{', '}', 'dep_license_map', '[', 'dep_mgr_name', ']', '[', 'dep_name', ']', '[', 'dep_version', ']', '=', '{', '"license"', '=>', 'dependency', '[', '"license"', ']', ',', '"license_files"', '=>', 'dependency', '[', '"license_files"', ']', ',', '"dependency_of"', '=>', '[', 'project_name', ']', ',', '}', 'end', 'end', 'end', 'end', 'FileUtils', '.', 'rm_rf', '(', 'cache_dir', ')', 'end']
->Original Target:
['0', '.', 'Translate', 'all', 'transitive', 'dependency', 'licensing', 'issues', 'into', 'omnibus', 'warnings', '1', '.', 'Parse', 'all', 'the', 'licensing', 'information', 'for', 'all', 'software', 'from', 'cache_dir', '2', '.', 'Merge', 'and', 'drop', 'the', 'duplicates', '3', '.', 'Add', 'these', 'licenses', 'to', 'the', 'main', 'manifest', 'to', 'be', 'merged', 'with', 'the', 'main', 'licensing', 'information', 'from', 'software', 'definitions', '.']
->Reconstructed Target:
0. Translate all transitive dependency licensing issues into omnibus warnings 1. Parse all the licensing information for all software from cache_dir 2. Merge and drop the duplicates 3. Add these licenses to the main manifest to be merged with the main licensing information from software definitions.
->Reconstructed Predication:
( cache_dir ))( cache_dir )) end end
->Raw Input:
summarize:def process_transitive_dependency_licensing_info Dir. glob ( "#{cache_dir}/*/*-dependency-licenses.json" ). each do | license_manifest_path | license_manifest_data = FFI_Yajl :: Parser. parse ( File. read ( license_manifest_path ) ) project_name = license_manifest_data [ "project_name" ] dependency_license_dir = File. dirname ( license_manifest_path ) license_manifest_data [ "dependency_managers" ]. each do | dep_mgr_name, dependencies | dep_license_map [ dep_mgr_name ] ||= { } dependencies. each do | dependency | dependency [ "license_files" ]. each do | f | license_path = File. join ( dependency_license_dir, f ) output_path = File. join ( output_dir, f ) FileUtils. cp ( license_path, output_path ) end dep_name = dependency [ "name" ] dep_version = dependency [ "version" ] if dep_license_map [ dep_mgr_name ] [ dep_name ] && dep_license_map [ dep_mgr_name ] [ dep_name ] [ dep_version ] dep_license_map [ dep_mgr_name ] [ dep_name ] [ dep_version ] [ "dependency_of" ] << project_name else dep_license_map [ dep_mgr_name ] [ dep_name ] ||= { } dep_license_map [ dep_mgr_name ] [ dep_name ] [ dep_version ] = { "license" => dependency [ "license" ], "license_files" => dependency [ "license_files" ], "dependency_of" => [ project_name ], } end end end end FileUtils. rm_rf ( cache_dir ) end
->Raw Target:
0. Translate all transitive dependency licensing issues into omnibus warnings 1. Parse all the licensing information for all software from cache_dir 2. Merge and drop the duplicates 3. Add these licenses to the main manifest to be merged with the main licensing information from software definitions.
--

92=========
->Original Input:
['def', 'collect_licenses_for', '(', 'software', ')', 'return', 'nil', 'if', 'software', '.', 'license', '==', ':project_license', 'software_name', '=', 'software', '.', 'name', 'license_data', '=', 'license_map', '[', 'software_name', ']', 'license_files', '=', 'license_data', '[', ':license_files', ']', 'license_files', '.', 'each', 'do', '|', 'license_file', '|', 'if', 'license_file', 'output_file', '=', 'license_package_location', '(', 'software_name', ',', 'license_file', ')', 'if', 'local?', '(', 'license_file', ')', 'input_file', '=', 'File', '.', 'expand_path', '(', 'license_file', ',', 'license_data', '[', ':project_dir', ']', ')', 'if', 'File', '.', 'exist?', '(', 'input_file', ')', 'FileUtils', '.', 'cp', '(', 'input_file', ',', 'output_file', ')', 'File', '.', 'chmod', '0644', ',', 'output_file', 'unless', 'windows?', 'else', 'licensing_warning', '(', '"License file \'#{input_file}\' does not exist for software \'#{software_name}\'."', ')', 'raise_if_warnings_fatal!', 'end', 'else', 'begin', 'download_file!', '(', 'license_file', ',', 'output_file', ',', 'enable_progress_bar', ':', 'false', ')', 'File', '.', 'chmod', '0644', ',', 'output_file', 'unless', 'windows?', 'rescue', 'SocketError', ',', 'Errno', '::', 'ECONNREFUSED', ',', 'Errno', '::', 'ECONNRESET', ',', 'Errno', '::', 'ENETUNREACH', ',', 'Timeout', '::', 'Error', ',', 'OpenURI', '::', 'HTTPError', ',', 'OpenSSL', '::', 'SSL', '::', 'SSLError', 'licensing_warning', '(', '"Can not download license file \'#{license_file}\' for software \'#{software_name}\'."', ')', 'raise_if_warnings_fatal!', 'end', 'end', 'end', 'end', 'end']
->Original Target:
['Collect', 'the', 'license', 'files', 'for', 'the', 'software', '.']
->Reconstructed Target:
Collect the license files for the software.
->Reconstructed Predication:
the license files for thelicense_files = license_data [ :license_fileslicense_files = license_data [ :license_fileslicense_files.license_files.license_files.license_files.license_files.license_files.license_files.license_files.license_files.license_files. length > 0license_files. length >license_files. length
->Raw Input:
summarize:def collect_licenses_for ( software ) return nil if software. license == :project_license software_name = software. name license_data = license_map [ software_name ] license_files = license_data [ :license_files ] license_files. each do | license_file | if license_file output_file = license_package_location ( software_name, license_file ) if local? ( license_file ) input_file = File. expand_path ( license_file, license_data [ :project_dir ] ) if File. exist? ( input_file ) FileUtils. cp ( input_file, output_file ) File. chmod 0644, output_file unless windows? else licensing_warning ( "License file '#{input_file}' does not exist for software '#{software_name}'." ) raise_if_warnings_fatal! end else begin download_file! ( license_file, output_file, enable_progress_bar : false ) File. chmod 0644, output_file unless windows? rescue SocketError, Errno :: ECONNREFUSED, Errno :: ECONNRESET, Errno :: ENETUNREACH, Timeout :: Error, OpenURI :: HTTPError, OpenSSL :: SSL :: SSLError licensing_warning ( "Can not download license file '#{license_file}' for software '#{software_name}'." ) raise_if_warnings_fatal! end end end end end
->Raw Target:
Collect the license files for the software.
--

93=========
->Original Input:
['def', 'write_prototype_file', 'shellout!', '"cd #{install_dirname} && find #{install_basename} -print > #{staging_dir_path(\'files\')}"', 'File', '.', 'open', 'staging_dir_path', '(', '"files.clean"', ')', ',', '"w+"', 'do', '|', 'fout', '|', 'File', '.', 'open', 'staging_dir_path', '(', '"files"', ')', 'do', '|', 'fin', '|', 'fin', '.', 'each_line', 'do', '|', 'line', '|', 'if', 'line', '.', 'chomp', '=~', '/', '\\s', '/', 'log', '.', 'warn', '(', 'log_key', ')', '{', '"Skipping packaging \'#{line}\' file due to whitespace in filename"', '}', 'else', 'fout', '.', 'write', '(', 'line', ')', 'end', 'end', 'end', 'end', 'File', '.', 'open', 'staging_dir_path', '(', '"Prototype"', ')', ',', '"w+"', 'do', '|', 'f', '|', 'f', '.', 'write', '<<-EOF', '.', 'gsub', '(', '/', '/', ',', '""', ')', 'EOF', 'end', 'shellout!', '"cd #{install_dirname} && pkgproto < #{staging_dir_path(\'files.clean\')} > #{staging_dir_path(\'Prototype.files\')}"', 'shellout!', '"awk \'{ $5 = \\"root\\"; $6 = \\"root\\"; print }\' < #{staging_dir_path(\'Prototype.files\')} >> #{staging_dir_path(\'Prototype\')}"', 'end']
->Original Target:
['Generate', 'a', 'Prototype', 'file', 'for', 'solaris', 'build']
->Reconstructed Target:
Generate a Prototype file for solaris build
->Reconstructed Predication:
filefile withfile withfile withfile withfile withfile withfile withfile withfile withfile withfile withfile with file name '#{file}'
->Raw Input:
summarize:def write_prototype_file shellout! "cd #{install_dirname} && find #{install_basename} -print > #{staging_dir_path('files')}" File. open staging_dir_path ( "files.clean" ), "w+" do | fout | File. open staging_dir_path ( "files" ) do | fin | fin. each_line do | line | if line. chomp =~ / \s / log. warn ( log_key ) { "Skipping packaging '#{line}' file due to whitespace in filename" } else fout. write ( line ) end end end end File. open staging_dir_path ( "Prototype" ), "w+" do | f | f. write <<-EOF. gsub ( / /, "" ) EOF end shellout! "cd #{install_dirname} && pkgproto < #{staging_dir_path('files.clean')} > #{staging_dir_path('Prototype.files')}" shellout! "awk '{ $5 = \"root\"; $6 = \"root\"; print }' < #{staging_dir_path('Prototype.files')} >> #{staging_dir_path('Prototype')}" end
->Raw Target:
Generate a Prototype file for solaris build
--

94=========
->Original Input:
['def', 'content', '@content', '||=', 'IO', '.', 'read', '(', 'path', ')', 'rescue', 'Errno', '::', 'ENOENT', 'raise', 'NoPackageFile', '.', 'new', '(', 'path', ')', 'end']
->Original Target:
['The', 'actual', 'contents', 'of', 'the', 'package', '.']
->Reconstructed Target:
The actual contents of the package.
->Reconstructed Predication:
content = IO. read
->Raw Input:
summarize:def content @content ||= IO. read ( path ) rescue Errno :: ENOENT raise NoPackageFile. new ( path ) end
->Raw Target:
The actual contents of the package.
--

95=========
->Original Input:
['def', 'validate!', 'unless', 'File', '.', 'exist?', '(', 'path', ')', 'raise', 'NoPackageFile', '.', 'new', '(', 'path', ')', 'end', 'unless', 'File', '.', 'exist?', '(', 'metadata', '.', 'path', ')', 'raise', 'NoPackageMetadataFile', '.', 'new', '(', 'metadata', '.', 'path', ')', 'end', 'true', 'end']
->Original Target:
['Validate', 'the', 'presence', 'of', 'the', 'required', 'components', 'for', 'the', 'package', '.']
->Reconstructed Target:
Validate the presence of the required components for the package.
->Reconstructed Predication:
metadata. path must bemetadata. path must be
->Raw Input:
summarize:def validate! unless File. exist? ( path ) raise NoPackageFile. new ( path ) end unless File. exist? ( metadata. path ) raise NoPackageMetadataFile. new ( metadata. path ) end true end
->Raw Target:
Validate the presence of the required components for the package.
--

96=========
->Original Input:
['def', 'key_for', '(', 'package', ',', '*', 'stuff', ')', 'File', '.', 'join', '(', 'Config', '.', 's3_publish_pattern', '%', 'package', '.', 'metadata', ',', '*', 'stuff', ')', 'end']
->Original Target:
['The', 'unique', 'upload', 'key', 'for', 'this', 'package', '.', 'The', 'additional', 'stuff', 'is', 'postfixed', 'to', 'the', 'end', 'of', 'the', 'path', '.']
->Reconstructed Target:
The unique upload key for this package. The additional stuff is postfixed to the end of the path.
->Reconstructed Predication:
key for a package
->Raw Input:
summarize:def key_for ( package, * stuff ) File. join ( Config. s3_publish_pattern % package. metadata, * stuff ) end
->Raw Target:
The unique upload key for this package. The additional stuff is postfixed to the end of the path.
--

97=========
->Original Input:
['def', 'semver', 'build_tag', '=', 'version_tag', 'if', 'prerelease_version?', 'prerelease', '=', 'prerelease_tag', '.', 'tr', '(', '"-"', ',', '"."', ')', 'build_tag', '<<', '"-"', '<<', 'prerelease', 'end', 'build_version_items', '=', '[', ']', 'if', 'Config', '.', 'append_timestamp', 'build_version_items', '<<', 'build_start_time', 'end', 'unless', 'commits_since_tag', '==', '0', 'build_version_items', '<<', '[', '"git"', ',', 'commits_since_tag', ',', 'git_sha_tag', ']', '.', 'join', '(', '"."', ')', 'end', 'unless', 'build_version_items', '.', 'empty?', 'build_tag', '<<', '"+"', '<<', 'build_version_items', '.', 'join', '(', '"."', ')', 'end', 'build_tag', 'end']
->Original Target:
['Create', 'a', 'new', 'BuildVersion']
->Reconstructed Target:
Create a new BuildVersion
->Reconstructed Predication:
the version of the currentthe current version of the current
->Raw Input:
summarize:def semver build_tag = version_tag if prerelease_version? prerelease = prerelease_tag. tr ( "-", "." ) build_tag << "-" << prerelease end build_version_items = [ ] if Config. append_timestamp build_version_items << build_start_time end unless commits_since_tag == 0 build_version_items << [ "git", commits_since_tag, git_sha_tag ]. join ( "." ) end unless build_version_items. empty? build_tag << "+" << build_version_items. join ( "." ) end build_tag end
->Raw Target:
Create a new BuildVersion
--

98=========
->Original Input:
['def', 'build_start_time', '@build_start_time', '||=', 'begin', 'if', 'ENV', '[', '"BUILD_TIMESTAMP"', ']', 'begin', 'Time', '.', 'strptime', '(', 'ENV', '[', '"BUILD_TIMESTAMP"', ']', ',', '"%Y-%m-%d_%H-%M-%S"', ')', 'rescue', 'ArgumentError', 'error_message', '=', '"BUILD_TIMESTAMP environment variable "', 'error_message', '<<', '"should be in YYYY-MM-DD_hh-mm-ss "', 'error_message', '<<', '"format."', 'raise', 'ArgumentError', ',', 'error_message', 'end', 'elsif', 'ENV', '[', '"BUILD_ID"', ']', 'begin', 'Time', '.', 'strptime', '(', 'ENV', '[', '"BUILD_ID"', ']', ',', '"%Y-%m-%d_%H-%M-%S"', ')', 'rescue', 'ArgumentError', 'error_message', '=', '"BUILD_ID environment variable "', 'error_message', '<<', '"should be in YYYY-MM-DD_hh-mm-ss "', 'error_message', '<<', '"format."', 'raise', 'ArgumentError', ',', 'error_message', 'end', 'else', 'Time', '.', 'now', '.', 'utc', 'end', 'end', '.', 'strftime', '(', 'TIMESTAMP_FORMAT', ')', 'end']
->Original Target:
['We', 'll', 'attempt', 'to', 'retrieve', 'the', 'timestamp', 'from', 'the', 'Jenkin', 's', 'set', 'BUILD_TIMESTAMP', 'or', 'fall', 'back', 'to', 'BUILD_ID', 'environment', 'variable', '.', 'This', 'will', 'ensure', 'platform', 'specfic', 'packages', 'for', 'the', 'same', 'build', 'will', 'share', 'the', 'same', 'timestamp', '.']
->Reconstructed Target:
We ll attempt to retrieve the timestamp from the Jenkin s set BUILD_TIMESTAMP or fall back to BUILD_ID environment variable. This will ensure platform specfic packages for the same build will share the same timestamp.
->Reconstructed Predication:
== "Build start time: #{Time.now.utc}
->Raw Input:
summarize:def build_start_time @build_start_time ||= begin if ENV [ "BUILD_TIMESTAMP" ] begin Time. strptime ( ENV [ "BUILD_TIMESTAMP" ], "%Y-%m-%d_%H-%M-%S" ) rescue ArgumentError error_message = "BUILD_TIMESTAMP environment variable " error_message << "should be in YYYY-MM-DD_hh-mm-ss " error_message << "format." raise ArgumentError, error_message end elsif ENV [ "BUILD_ID" ] begin Time. strptime ( ENV [ "BUILD_ID" ], "%Y-%m-%d_%H-%M-%S" ) rescue ArgumentError error_message = "BUILD_ID environment variable " error_message << "should be in YYYY-MM-DD_hh-mm-ss " error_message << "format." raise ArgumentError, error_message end else Time. now. utc end end. strftime ( TIMESTAMP_FORMAT ) end
->Raw Target:
We ll attempt to retrieve the timestamp from the Jenkin s set BUILD_TIMESTAMP or fall back to BUILD_ID environment variable. This will ensure platform specfic packages for the same build will share the same timestamp.
--

99=========
->Original Input:
['def', 'save', 'File', '.', 'open', '(', 'path', ',', '"w+"', ')', 'do', '|', 'f', '|', 'f', '.', 'write', '(', 'FFI_Yajl', '::', 'Encoder', '.', 'encode', '(', 'to_hash', ',', 'pretty', ':', 'true', ')', ')', 'end', 'true', 'end']
->Original Target:
['Save', 'the', 'file', 'to', 'disk', '.']
->Reconstructed Target:
Save the file to disk.
->Reconstructed Predication:
the hash to the file
->Raw Input:
summarize:def save File. open ( path, "w+" ) do | f | f. write ( FFI_Yajl :: Encoder. encode ( to_hash, pretty : true ) ) end true end
->Raw Target:
Save the file to disk.
--

100=========
->Original Input:
['def', 'vendor', '(', 'val', '=', 'NULL', ')', 'if', 'null?', '(', 'val', ')', '@vendor', '||', '"Omnibus <omnibus@getchef.com>"', 'else', 'unless', 'val', '.', 'is_a?', '(', 'String', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':vendor', ',', '"be a String"', ')', 'end', '@vendor', '=', 'val', 'end', 'end']
->Original Target:
['Set', 'or', 'return', 'the', 'vendor', 'who', 'made', 'this', 'package', '.']
->Reconstructed Target:
Set or return the vendor who made this package.
->Reconstructed Predication:
the vendor of the chef
->Raw Input:
summarize:def vendor ( val = NULL ) if null? ( val ) @vendor || "Omnibus <omnibus@getchef.com>" else unless val. is_a? ( String ) raise InvalidValue. new ( :vendor, "be a String" ) end @vendor = val end end
->Raw Target:
Set or return the vendor who made this package.
--

101=========
->Original Input:
['def', 'license', '(', 'val', '=', 'NULL', ')', 'if', 'null?', '(', 'val', ')', '@license', '||', 'project', '.', 'license', 'else', 'unless', 'val', '.', 'is_a?', '(', 'String', ')', 'raise', 'InvalidValue', '.', 'new', '(', ':license', ',', '"be a String"', ')', 'end', '@license', '=', 'val', 'end', 'end']
->Original Target:
['Set', 'or', 'return', 'the', 'license', 'for', 'this', 'package', '.']
->Reconstructed Target:
Set or return the license for this package.
->Reconstructed Predication:
The license to use for the
->Raw Input:
summarize:def license ( val = NULL ) if null? ( val ) @license || project. license else unless val. is_a? ( String ) raise InvalidValue. new ( :license, "be a String" ) end @license = val end end
->Raw Target:
Set or return the license for this package.
--

102=========
->Original Input:
['def', 'build_filepath', '(', 'path', ')', 'filepath', '=', 'rpm_safe', '(', '"/"', '+', 'path', '.', 'gsub', '(', '"#{build_dir}/"', ',', '""', ')', ')', 'return', 'if', 'config_files', '.', 'include?', '(', 'filepath', ')', 'full_path', '=', 'build_dir', '+', 'filepath', '.', 'gsub', '(', '"[%]"', ',', '"%"', ')', 'full_path', '.', 'delete!', '(', '\'"\'', ')', 'return', 'mark_filesystem_directories', '(', 'filepath', ')', 'if', '!', 'File', '.', 'symlink?', '(', 'full_path', ')', '&&', 'File', '.', 'directory?', '(', 'full_path', ')', 'filepath', 'end']
->Original Target:
['Convert', 'the', 'path', 'of', 'a', 'file', 'in', 'the', 'staging', 'directory', 'to', 'an', 'entry', 'for', 'use', 'in', 'the', 'spec', 'file', '.']
->Reconstructed Target:
Convert the path of a file in the staging directory to an entry for use in the spec file.
->Reconstructed Predication:
path )  def build_filepath
->Raw Input:
summarize:def build_filepath ( path ) filepath = rpm_safe ( "/" + path. gsub ( "#{build_dir}/", "" ) ) return if config_files. include? ( filepath ) full_path = build_dir + filepath. gsub ( "[%]", "%" ) full_path. delete! ( '"' ) return mark_filesystem_directories ( filepath ) if! File. symlink? ( full_path ) && File. directory? ( full_path ) filepath end
->Raw Target:
Convert the path of a file in the staging directory to an entry for use in the spec file.
--

103=========
->Original Input:
['def', 'with_rpm_signing', '(', '&', 'block', ')', 'directory', '=', 'Dir', '.', 'mktmpdir', 'destination', '=', '"#{directory}/sign-rpm"', 'render_template', '(', 'resource_path', '(', '"signing.erb"', ')', ',', 'destination', ':', 'destination', ',', 'mode', ':', '0700', ',', 'variables', ':', '{', 'passphrase', ':', 'signing_passphrase', ',', '}', ')', 'yield', '(', 'destination', ')', 'ensure', 'remove_file', '(', 'destination', ')', 'remove_directory', '(', 'directory', ')', 'end']
->Original Target:
['Render', 'the', 'rpm', 'signing', 'script', 'with', 'secure', 'permissions', 'call', 'the', 'given', 'block', 'with', 'the', 'path', 'to', 'the', 'script', 'and', 'ensure', 'deletion', 'of', 'the', 'script', 'from', 'disk', 'since', 'it', 'contains', 'sensitive', 'information', '.']
->Reconstructed Target:
Render the rpm signing script with secure permissions call the given block with the path to the script and ensure deletion of the script from disk since it contains sensitive information.
->Reconstructed Predication:
signing_passphrase = signing_passphrase. to_s
->Raw Input:
summarize:def with_rpm_signing ( & block ) directory = Dir. mktmpdir destination = "#{directory}/sign-rpm" render_template ( resource_path ( "signing.erb" ), destination : destination, mode : 0700, variables : { passphrase : signing_passphrase, } ) yield ( destination ) ensure remove_file ( destination ) remove_directory ( directory ) end
->Raw Target:
Render the rpm signing script with secure permissions call the given block with the path to the script and ensure deletion of the script from disk since it contains sensitive information.
--

104=========
->Original Input:
['def', 'publish', '(', 'klass', ',', 'pattern', ',', 'options', ')', 'if', 'options', '[', ':platform_mappings', ']', 'options', '[', ':platform_mappings', ']', '=', 'FFI_Yajl', '::', 'Parser', '.', 'parse', '(', 'File', '.', 'read', '(', 'File', '.', 'expand_path', '(', 'options', '[', ':platform_mappings', ']', ')', ')', ')', 'end', 'klass', '.', 'publish', '(', 'pattern', ',', 'options', ')', 'do', '|', 'package', '|', 'say', '(', '"Published \'#{package.name}\' for #{package.metadata[:platform]}-#{package.metadata[:platform_version]}"', ',', ':green', ')', 'end', 'end']
->Original Target:
['Shortcut', 'method', 'for', 'executing', 'a', 'publisher', '.']
->Reconstructed Target:
Shortcut method for executing a publisher.
->Reconstructed Predication:
packagepackage_metadata = { }
->Raw Input:
summarize:def publish ( klass, pattern, options ) if options [ :platform_mappings ] options [ :platform_mappings ] = FFI_Yajl :: Parser. parse ( File. read ( File. expand_path ( options [ :platform_mappings ] ) ) ) end klass. publish ( pattern, options ) do | package | say ( "Published '#{package.name}' for #{package.metadata[:platform]}-#{package.metadata[:platform_version]}", :green ) end end
->Raw Target:
Shortcut method for executing a publisher.
--

105=========
->Original Input:
['def', 'build_version', '(', 'val', '=', 'NULL', ',', '&', 'block', ')', 'if', 'block', '&&', '!', 'null?', '(', 'val', ')', 'raise', 'Error', ',', '"You cannot specify additional parameters to "', '"#build_version when a block is given!"', 'end', 'if', 'block', '@build_version_dsl', '=', 'BuildVersionDSL', '.', 'new', '(', '&', 'block', ')', 'else', 'if', 'null?', '(', 'val', ')', '@build_version_dsl', '.', 'build_version', 'else', '@build_version_dsl', '=', 'BuildVersionDSL', '.', 'new', '(', 'val', ')', 'end', 'end', 'end']
->Original Target:
['Set', 'or', 'retrieve', 'the', 'version', 'of', 'the', 'project', '.']
->Reconstructed Target:
Set or retrieve the version of the project.
->Reconstructed Predication:
the build version to
->Raw Input:
summarize:def build_version ( val = NULL, & block ) if block &&! null? ( val ) raise Error, "You cannot specify additional parameters to " "#build_version when a block is given!" end if block @build_version_dsl = BuildVersionDSL. new ( & block ) else if null? ( val ) @build_version_dsl. build_version else @build_version_dsl = BuildVersionDSL. new ( val ) end end end
->Raw Target:
Set or retrieve the version of the project.
--

106=========
->Original Input:
['def', 'package', '(', 'id', ',', '&', 'block', ')', 'unless', 'block', 'raise', 'InvalidValue', '.', 'new', '(', ':package', ',', '"have a block"', ')', 'end', 'packagers', '[', 'id', ']', '<<', 'block', 'end']
->Original Target:
['Add', 'or', 'override', 'a', 'customization', 'for', 'the', 'packager', 'with', 'the', 'given', '+', 'id', '+', '.', 'When', 'given', 'multiple', 'blocks', 'with', 'the', 'same', '+', 'id', '+', 'they', 'are', 'evaluated', '_in', 'order_', 'so', 'the', 'last', 'block', 'evaluated', 'will', 'take', 'precedence', 'over', 'the', 'previous', 'ones', '.']
->Reconstructed Target:
Add or override a customization for the packager with the given + id +. When given multiple blocks with the same + id + they are evaluated _in order_ so the last block evaluated will take precedence over the previous ones.
->Reconstructed Predication:
the package to be used in
->Raw Input:
summarize:def package ( id, & block ) unless block raise InvalidValue. new ( :package, "have a block" ) end packagers [ id ] << block end
->Raw Target:
Add or override a customization for the packager with the given + id +. When given multiple blocks with the same + id + they are evaluated _in order_ so the last block evaluated will take precedence over the previous ones.
--

107=========
->Original Input:
['def', 'compress', '(', 'id', ',', '&', 'block', ')', 'if', 'block', 'compressors', '[', 'id', ']', '<<', 'block', 'else', 'compressors', '[', 'id', ']', '<<', 'Proc', '.', 'new', '{', '}', 'end', 'end']
->Original Target:
['Add', 'or', 'override', 'a', 'customization', 'for', 'the', 'compressor', 'with', 'the', 'given', '+', 'id', '+', '.', 'When', 'given', 'multiple', 'blocks', 'with', 'the', 'same', '+', 'id', '+', 'they', 'are', 'evaluated', '_in', 'order_', 'so', 'the', 'last', 'block', 'evaluated', 'will', 'take', 'precedence', 'over', 'the', 'previous', 'ones', '.']
->Reconstructed Target:
Add or override a customization for the compressor with the given + id +. When given multiple blocks with the same + id + they are evaluated _in order_ so the last block evaluated will take precedence over the previous ones.
->Reconstructed Predication:
def compress_block ( id )
->Raw Input:
summarize:def compress ( id, & block ) if block compressors [ id ] << block else compressors [ id ] << Proc. new { } end end
->Raw Target:
Add or override a customization for the compressor with the given + id +. When given multiple blocks with the same + id + they are evaluated _in order_ so the last block evaluated will take precedence over the previous ones.
--

108=========
->Original Input:
['def', 'override', '(', 'name', ',', 'val', '=', 'NULL', ')', 'if', 'null?', '(', 'val', ')', 'overrides', '[', 'name', '.', 'to_sym', ']', 'else', 'overrides', '[', 'name', '.', 'to_sym', ']', '=', 'val', 'end', 'end']
->Original Target:
['Set', 'or', 'retrieve', 'the', 'overrides', 'hash', 'for', 'one', 'piece', 'of', 'software', 'being', 'overridden', '.', 'Calling', 'it', 'as', 'a', 'setter', 'does', 'not', 'merge', 'hash', 'entries', 'and', 'it', 'will', 'set', 'all', 'the', 'overrides', 'for', 'a', 'given', 'software', 'definition', '.']
->Reconstructed Target:
Set or retrieve the overrides hash for one piece of software being overridden. Calling it as a setter does not merge hash entries and it will set all the overrides for a given software definition.
->Reconstructed Predication:
override the value of the
->Raw Input:
summarize:def override ( name, val = NULL ) if null? ( val ) overrides [ name. to_sym ] else overrides [ name. to_sym ] = val end end
->Raw Target:
Set or retrieve the overrides hash for one piece of software being overridden. Calling it as a setter does not merge hash entries and it will set all the overrides for a given software definition.
--

109=========
->Original Input:
['def', 'license_file_path', '(', 'path', '=', 'NULL', ')', 'if', 'null?', '(', 'path', ')', '@license_file_path', '||', 'File', '.', 'join', '(', 'install_dir', ',', '"LICENSE"', ')', 'else', '@license_file_path', '=', 'File', '.', 'join', '(', 'install_dir', ',', 'path', ')', 'end', 'end']
->Original Target:
['Location', 'of', 'license', 'file', 'that', 'omnibus', 'will', 'create', 'and', 'that', 'will', 'contain', 'the', 'information', 'about', 'the', 'license', 'of', 'the', 'project', 'plus', 'the', 'details', 'about', 'the', 'licenses', 'of', 'the', 'software', 'components', 'included', 'in', 'the', 'project', '.']
->Reconstructed Target:
Location of license file that omnibus will create and that will contain the information about the license of the project plus the details about the licenses of the software components included in the project.
->Reconstructed Predication:
The license file path to
->Raw Input:
summarize:def license_file_path ( path = NULL ) if null? ( path ) @license_file_path || File. join ( install_dir, "LICENSE" ) else @license_file_path = File. join ( install_dir, path ) end end
->Raw Target:
Location of license file that omnibus will create and that will contain the information about the license of the project plus the details about the licenses of the software components included in the project.
--

110=========
->Original Input:
['def', 'dependency?', '(', 'software', ')', 'name', '=', 'software', '.', 'is_a?', '(', 'Software', ')', '?', 'software', '.', 'name', ':', 'software', 'dependencies', '.', 'include?', '(', 'name', ')', 'end']
->Original Target:
['Indicates', 'whether', 'the', 'given', '+', 'software', '+', 'is', 'defined', 'as', 'a', 'software', 'component', 'of', 'this', 'project', '.']
->Reconstructed Target:
Indicates whether the given + software + is defined as a software component of this project.
->Reconstructed Predication:
if the dependency is athe dependency to the software.
->Raw Input:
summarize:def dependency? ( software ) name = software. is_a? ( Software )? software. name : software dependencies. include? ( name ) end
->Raw Target:
Indicates whether the given + software + is defined as a software component of this project.
--

111=========
->Original Input:
['def', 'built_manifest', 'log', '.', 'info', '(', 'log_key', ')', '{', '"Building version manifest"', '}', 'm', '=', 'Omnibus', '::', 'Manifest', '.', 'new', '(', 'build_version', ',', 'build_git_revision', ',', 'license', ')', 'softwares', '.', 'each', 'do', '|', 'software', '|', 'm', '.', 'add', '(', 'software', '.', 'name', ',', 'software', '.', 'manifest_entry', ')', 'end', 'm', 'end']
->Original Target:
['Generate', 'a', 'version', 'manifest', 'of', 'the', 'loaded', 'software', 'sources', '.']
->Reconstructed Target:
Generate a version manifest of the loaded software sources.
->Reconstructed Predication:
the manifest for the current
->Raw Input:
summarize:def built_manifest log. info ( log_key ) { "Building version manifest" } m = Omnibus :: Manifest. new ( build_version, build_git_revision, license ) softwares. each do | software | m. add ( software. name, software. manifest_entry ) end m end
->Raw Target:
Generate a version manifest of the loaded software sources.
--

112=========
->Original Input:
['def', 'write_text_manifest', 'File', '.', 'open', '(', 'text_manifest_path', ',', '"w"', ')', 'do', '|', 'f', '|', 'f', '.', 'puts', '"#{name} #{build_version}"', 'f', '.', 'puts', '""', 'f', '.', 'puts', 'Omnibus', '::', 'Reports', '.', 'pretty_version_map', '(', 'self', ')', 'end', 'end']
->Original Target:
['Writes', 'a', 'text', 'manifest', 'to', 'the', 'text_manifest_path', '.', 'This', 'uses', 'the', 'same', 'method', 'as', 'the', 'version', '-', 'manifest', 'software', 'definition', 'in', 'omnibus', '-', 'software', '.']
->Reconstructed Target:
Writes a text manifest to the text_manifest_path. This uses the same method as the version - manifest software definition in omnibus - software.
->Reconstructed Predication:
the manifest to the file
->Raw Input:
summarize:def write_text_manifest File. open ( text_manifest_path, "w" ) do | f | f. puts "#{name} #{build_version}" f. puts "" f. puts Omnibus :: Reports. pretty_version_map ( self ) end end
->Raw Target:
Writes a text manifest to the text_manifest_path. This uses the same method as the version - manifest software definition in omnibus - software.
--

113=========
->Original Input:
['def', 'write_conffiles_file', 'return', 'if', 'project', '.', 'config_files', '.', 'empty?', 'render_template', '(', 'resource_path', '(', '"conffiles.erb"', ')', ',', 'destination', ':', 'File', '.', 'join', '(', 'debian_dir', ',', '"conffiles"', ')', ',', 'variables', ':', '{', 'config_files', ':', 'project', '.', 'config_files', ',', '}', ')', 'end']
->Original Target:
['Render', 'the', 'list', 'of', 'config', 'files', 'into', 'the', 'conffile', '.']
->Reconstructed Target:
Render the list of config files into the conffile.
->Reconstructed Predication:
.
->Raw Input:
summarize:def write_conffiles_file return if project. config_files. empty? render_template ( resource_path ( "conffiles.erb" ), destination : File. join ( debian_dir, "conffiles" ), variables : { config_files : project. config_files, } ) end
->Raw Target:
Render the list of config files into the conffile.
--

114=========
->Original Input:
['def', 'package_size', '@package_size', '||=', 'begin', 'path', '=', '"#{project.install_dir}/**/*"', 'total', '=', 'FileSyncer', '.', 'glob', '(', 'path', ')', '.', 'inject', '(', '0', ')', 'do', '|', 'size', ',', 'path', '|', 'unless', 'File', '.', 'directory?', '(', 'path', ')', '||', 'File', '.', 'symlink?', '(', 'path', ')', 'size', '+=', 'File', '.', 'size', '(', 'path', ')', 'end', 'size', 'end', 'total', '/', '1024', 'end', 'end']
->Original Target:
['The', 'size', 'of', 'this', 'Debian', 'package', '.', 'This', 'is', 'dynamically', 'calculated', '.']
->Reconstructed Target:
The size of this Debian package. This is dynamically calculated.
->Reconstructed Predication:
the package size of the
->Raw Input:
summarize:def package_size @package_size ||= begin path = "#{project.install_dir}/**/*" total = FileSyncer. glob ( path ). inject ( 0 ) do | size, path | unless File. directory? ( path ) || File. symlink? ( path ) size += File. size ( path ) end size end total / 1024 end end
->Raw Target:
The size of this Debian package. This is dynamically calculated.
--

115=========
->Original Input:
['def', 'dir_empty?', '(', 'dir', ')', 'Dir', '.', 'entries', '(', 'dir', ')', '.', 'reject', '{', '|', 'd', '|', '[', '"."', ',', '".."', ']', '.', 'include?', '(', 'd', ')', '}', '.', 'empty?', 'end']
->Original Target:
['Determine', 'if', 'a', 'directory', 'is', 'empty']
->Reconstructed Target:
Determine if a directory is empty
->Reconstructed Predication:
return true if the directory
->Raw Input:
summarize:def dir_empty? ( dir ) Dir. entries ( dir ). reject { | d | [ ".", ".." ]. include? ( d ) }. empty? end
->Raw Target:
Determine if a directory is empty
--

116=========
->Original Input:
['def', 'force_recreate_project_dir!', 'log', '.', 'warn', '(', 'log_key', ')', '{', '"Removing existing directory #{project_dir} before cloning"', '}', 'FileUtils', '.', 'rm_rf', '(', 'project_dir', ')', 'Dir', '.', 'mkdir', '(', 'project_dir', ')', 'end']
->Original Target:
['Forcibly', 'remove', 'and', 'recreate', 'the', 'project', 'directory']
->Reconstructed Target:
Forcibly remove and recreate the project directory
->Reconstructed Predication:
The project directory must be
->Raw Input:
summarize:def force_recreate_project_dir! log. warn ( log_key ) { "Removing existing directory #{project_dir} before cloning" } FileUtils. rm_rf ( project_dir ) Dir. mkdir ( project_dir ) end
->Raw Target:
Forcibly remove and recreate the project directory
--

117=========
->Original Input:
['def', 'current_revision', 'cmd', '=', 'git', '(', '"rev-parse HEAD"', ')', 'cmd', '.', 'stdout', '.', 'strip', 'rescue', 'CommandFailed', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"unable to determine current revision"', '}', 'nil', 'end']
->Original Target:
['The', 'current', 'revision', 'for', 'the', 'cloned', 'checkout', '.']
->Reconstructed Target:
The current revision for the cloned checkout.
->Reconstructed Predication:
the current revision of the
->Raw Input:
summarize:def current_revision cmd = git ( "rev-parse HEAD" ) cmd. stdout. strip rescue CommandFailed log. debug ( log_key ) { "unable to determine current revision" } nil end
->Raw Target:
The current revision for the cloned checkout.
--

118=========
->Original Input:
['def', 'contains_revision?', '(', 'rev', ')', 'cmd', '=', 'git', '(', '"cat-file -t #{rev}"', ')', 'cmd', '.', 'stdout', '.', 'strip', '==', '"commit"', 'rescue', 'CommandFailed', 'log', '.', 'debug', '(', 'log_key', ')', '{', '"unable to determine presence of commit #{rev}"', '}', 'false', 'end']
->Original Target:
['Check', 'if', 'the', 'current', 'clone', 'has', 'the', 'requested', 'commit', 'id', '.']
->Reconstructed Target:
Check if the current clone has the requested commit id.
->Reconstructed Predication:
the revision of the commit
->Raw Input:
summarize:def contains_revision? ( rev ) cmd = git ( "cat-file -t #{rev}" ) cmd. stdout. strip == "commit" rescue CommandFailed log. debug ( log_key ) { "unable to determine presence of commit #{rev}" } false end
->Raw Target:
Check if the current clone has the requested commit id.
--

119=========
->Original Input:
['def', 'to_ssh', 'if', 'zero?', 'return', '[', '0', ']', '.', 'pack', '(', '"N"', ')', 'else', 'buf', '=', 'to_s', '(', '2', ')', 'if', 'buf', '.', 'getbyte', '(', '0', ')', '[', '7', ']', '==', '1', 'return', '[', 'buf', '.', 'length', '+', '1', ',', '0', ',', 'buf', ']', '.', 'pack', '(', '"NCA*"', ')', 'else', 'return', '[', 'buf', '.', 'length', ',', 'buf', ']', '.', 'pack', '(', '"NA*"', ')', 'end', 'end', 'end']
->Original Target:
['Converts', 'a', 'BN', 'object', 'to', 'a', 'string', '.', 'The', 'format', 'used', 'is', 'that', 'which', 'is', 'required', 'by', 'the', 'SSH2', 'protocol', '.']
->Reconstructed Target:
Converts a BN object to a string. The format used is that which is required by the SSH2 protocol.
->Reconstructed Predication:
return the ssh key
->Raw Input:
summarize:def to_ssh if zero? return [ 0 ]. pack ( "N" ) else buf = to_s ( 2 ) if buf. getbyte ( 0 ) [ 7 ] == 1 return [ buf. length + 1, 0, buf ]. pack ( "NCA*" ) else return [ buf. length, buf ]. pack ( "NA*" ) end end end
->Raw Target:
Converts a BN object to a string. The format used is that which is required by the SSH2 protocol.
--

120=========
->Original Input:
['def', 'compute_need_bits', 'need_bits', '=', 'data', '[', ':need_bytes', ']', '*', '8', '*', '2', '+', '1', 'data', '[', ':minimum_dh_bits', ']', '||=', 'MINIMUM_BITS', 'if', 'need_bits', '<', 'data', '[', ':minimum_dh_bits', ']', 'need_bits', '=', 'data', '[', ':minimum_dh_bits', ']', 'elsif', 'need_bits', '>', 'MAXIMUM_BITS', 'need_bits', '=', 'MAXIMUM_BITS', 'end', 'data', '[', ':need_bits', ']', '=', 'need_bits', 'data', '[', ':need_bytes', ']', '=', 'need_bits', '/', '8', 'end']
->Original Target:
['Compute', 'the', 'number', 'of', 'bits', 'needed', 'for', 'the', 'given', 'number', 'of', 'bytes', '.']
->Reconstructed Target:
Compute the number of bits needed for the given number of bytes.
->Reconstructed Predication:
the need_bits of the
->Raw Input:
summarize:def compute_need_bits need_bits = data [ :need_bytes ] * 8 * 2 + 1 data [ :minimum_dh_bits ] ||= MINIMUM_BITS if need_bits < data [ :minimum_dh_bits ] need_bits = data [ :minimum_dh_bits ] elsif need_bits > MAXIMUM_BITS need_bits = MAXIMUM_BITS end data [ :need_bits ] = need_bits data [ :need_bytes ] = need_bits / 8 end
->Raw Target:
Compute the number of bits needed for the given number of bytes.
--

121=========
->Original Input:
['def', 'get_parameters', 'compute_need_bits', 'buffer', '=', 'Net', '::', 'SSH', '::', 'Buffer', '.', 'from', '(', ':byte', ',', 'KEXDH_GEX_REQUEST', ',', ':long', ',', 'data', '[', ':minimum_dh_bits', ']', ',', ':long', ',', 'data', '[', ':need_bits', ']', ',', ':long', ',', 'MAXIMUM_BITS', ')', 'connection', '.', 'send_message', '(', 'buffer', ')', 'buffer', '=', 'connection', '.', 'next_message', 'raise', 'Net', '::', 'SSH', '::', 'Exception', ',', '"expected KEXDH_GEX_GROUP, got #{buffer.type}"', 'unless', 'buffer', '.', 'type', '==', 'KEXDH_GEX_GROUP', 'p', '=', 'buffer', '.', 'read_bignum', 'g', '=', 'buffer', '.', 'read_bignum', '[', 'p', ',', 'g', ']', 'end']
->Original Target:
['Returns', 'the', 'DH', 'key', 'parameters', 'for', 'the', 'given', 'session', '.']
->Reconstructed Target:
Returns the DH key parameters for the given session.
->Reconstructed Predication:
data [ :minimum_dh_bits ]data [ :need_bits ]
->Raw Input:
summarize:def get_parameters compute_need_bits buffer = Net :: SSH :: Buffer. from ( :byte, KEXDH_GEX_REQUEST, :long, data [ :minimum_dh_bits ], :long, data [ :need_bits ], :long, MAXIMUM_BITS ) connection. send_message ( buffer ) buffer = connection. next_message raise Net :: SSH :: Exception, "expected KEXDH_GEX_GROUP, got #{buffer.type}" unless buffer. type == KEXDH_GEX_GROUP p = buffer. read_bignum g = buffer. read_bignum [ p, g ] end
->Raw Target:
Returns the DH key parameters for the given session.
--

122=========
->Original Input:
['def', 'build_signature_buffer', '(', 'result', ')', 'response', '=', 'Net', '::', 'SSH', '::', 'Buffer', '.', 'new', 'response', '.', 'write_string', 'data', '[', ':client_version_string', ']', ',', 'data', '[', ':server_version_string', ']', ',', 'data', '[', ':client_algorithm_packet', ']', ',', 'data', '[', ':server_algorithm_packet', ']', ',', 'result', '[', ':key_blob', ']', 'response', '.', 'write_long', 'MINIMUM_BITS', ',', 'data', '[', ':need_bits', ']', ',', 'MAXIMUM_BITS', 'response', '.', 'write_bignum', 'dh', '.', 'p', ',', 'dh', '.', 'g', ',', 'dh', '.', 'pub_key', ',', 'result', '[', ':server_dh_pubkey', ']', ',', 'result', '[', ':shared_secret', ']', 'response', 'end']
->Original Target:
['Build', 'the', 'signature', 'buffer', 'to', 'use', 'when', 'verifying', 'a', 'signature', 'from', 'the', 'server', '.']
->Reconstructed Target:
Build the signature buffer to use when verifying a signature from the server.
->Reconstructed Predication:
the signature buffer. 
->Raw Input:
summarize:def build_signature_buffer ( result ) response = Net :: SSH :: Buffer. new response. write_string data [ :client_version_string ], data [ :server_version_string ], data [ :client_algorithm_packet ], data [ :server_algorithm_packet ], result [ :key_blob ] response. write_long MINIMUM_BITS, data [ :need_bits ], MAXIMUM_BITS response. write_bignum dh. p, dh. g, dh. pub_key, result [ :server_dh_pubkey ], result [ :shared_secret ] response end
->Raw Target:
Build the signature buffer to use when verifying a signature from the server.
--

123=========
->Original Input:
['def', 'when_loaded', 'previously_loaded', '=', 'loaded', 'self', '.', 'loaded', '=', 'loaded?', 'raise', 'SitePrism', '::', 'FailedLoadValidationError', ',', 'load_error', 'unless', 'loaded', 'yield', 'self', 'if', 'block_given?', 'ensure', 'self', '.', 'loaded', '=', 'previously_loaded', 'end']
->Original Target:
['Executes', 'the', 'given', 'block', 'after', 'the', 'page', 'is', 'loaded', '.']
->Reconstructed Target:
Executes the given block after the page is loaded.
->Reconstructed Predication:
load the site.
->Raw Input:
summarize:def when_loaded previously_loaded = loaded self. loaded = loaded? raise SitePrism :: FailedLoadValidationError, load_error unless loaded yield self if block_given? ensure self. loaded = previously_loaded end
->Raw Target:
Executes the given block after the page is loaded.
--

124=========
->Original Input:
['def', 'load_validations_pass?', 'self', '.', 'class', '.', 'load_validations', '.', 'all?', 'do', '|', 'validation', '|', 'passed', ',', 'message', '=', 'instance_eval', '(', '&', 'validation', ')', 'self', '.', 'load_error', '=', 'message', 'if', 'message', '&&', '!', 'passed', 'passed', 'end', 'end']
->Original Target:
['If', 'any', 'load', 'validations', 'from', 'page', 'subclasses', 'returns', 'false', 'immediately', 'return', 'false', '.']
->Reconstructed Target:
If any load validations from page subclasses returns false immediately return false.
->Reconstructed Predication:
the validation
->Raw Input:
summarize:def load_validations_pass? self. class. load_validations. all? do | validation | passed, message = instance_eval ( & validation ) self. load_error = message if message &&! passed passed end end
->Raw Target:
If any load validations from page subclasses returns false immediately return false.
--

125=========
->Original Input:
['def', 'raise_if_block', '(', 'obj', ',', 'name', ',', 'has_block', ',', 'type', ')', 'return', 'unless', 'has_block', 'SitePrism', '.', 'logger', '.', 'debug', '(', '"Type passed in: #{type}"', ')', 'SitePrism', '.', 'logger', '.', 'warn', '(', "'section / iFrame can only accept blocks.'", ')', 'SitePrism', '.', 'logger', '.', 'error', '(', '"#{obj.class}##{name} does not accept blocks"', ')', 'raise', 'SitePrism', '::', 'UnsupportedBlockError', 'end']
->Original Target:
['Prevent', 'users', 'from', 'calling', 'methods', 'with', 'blocks', 'when', 'they', 'shouldn', 't', 'be', '.']
->Reconstructed Target:
Prevent users from calling methods with blocks when they shouldn t be.
->Reconstructed Predication:
block is not a blockblock is not a block of
->Raw Input:
summarize:def raise_if_block ( obj, name, has_block, type ) return unless has_block SitePrism. logger. debug ( "Type passed in: #{type}" ) SitePrism. logger. warn ('section / iFrame can only accept blocks.' ) SitePrism. logger. error ( "#{obj.class}##{name} does not accept blocks" ) raise SitePrism :: UnsupportedBlockError end
->Raw Target:
Prevent users from calling methods with blocks when they shouldn t be.
--

126=========
->Original Input:
['def', 'merge_args', '(', 'find_args', ',', 'runtime_args', ',', 'visibility_args', '=', '{', '}', ')', 'find_args', '=', 'find_args', '.', 'dup', 'runtime_args', '=', 'runtime_args', '.', 'dup', 'options', '=', 'visibility_args', '.', 'dup', 'SitePrism', '.', 'logger', '.', 'debug', '(', '"Initial args: #{find_args}, #{runtime_args}."', ')', 'recombine_args', '(', 'find_args', ',', 'runtime_args', ',', 'options', ')', 'return', '[', '*', 'find_args', ',', '*', 'runtime_args', ']', 'if', 'options', '.', 'empty?', '[', '*', 'find_args', ',', '*', 'runtime_args', ',', 'options', ']', 'end']
->Original Target:
['Sanitize', 'method', 'called', 'before', 'calling', 'any', 'SitePrism', 'DSL', 'method', 'or', 'meta', '-', 'programmed', 'method', '.', 'This', 'ensures', 'that', 'the', 'Capybara', 'query', 'is', 'correct', '.']
->Reconstructed Target:
Sanitize method called before calling any SitePrism DSL method or meta - programmed method. This ensures that the Capybara query is correct.
->Reconstructed Predication:
:  def merge_args (:
->Raw Input:
summarize:def merge_args ( find_args, runtime_args, visibility_args = { } ) find_args = find_args. dup runtime_args = runtime_args. dup options = visibility_args. dup SitePrism. logger. debug ( "Initial args: #{find_args}, #{runtime_args}." ) recombine_args ( find_args, runtime_args, options ) return [ * find_args, * runtime_args ] if options. empty? [ * find_args, * runtime_args, options ] end
->Raw Target:
Sanitize method called before calling any SitePrism DSL method or meta - programmed method. This ensures that the Capybara query is correct.
--

127=========
->Original Input:
['def', 'recombine_args', '(', 'find_args', ',', 'runtime_args', ',', 'options', ')', 'options', '.', 'merge!', '(', 'find_args', '.', 'pop', ')', 'if', 'find_args', '.', 'last', '.', 'is_a?', 'Hash', 'options', '.', 'merge!', '(', 'runtime_args', '.', 'pop', ')', 'if', 'runtime_args', '.', 'last', '.', 'is_a?', 'Hash', 'options', '[', ':wait', ']', '=', 'wait_time', 'unless', 'wait_key_present?', '(', 'options', ')', 'end']
->Original Target:
['Options', 're', '-', 'combiner', '.', 'This', 'takes', 'the', 'original', 'inputs', 'and', 'combines', 'them', 'such', 'that', 'there', 'is', 'only', 'one', 'hash', 'passed', 'as', 'a', 'final', 'argument', 'to', 'Capybara', '.']
->Reconstructed Target:
Options re - combiner. This takes the original inputs and combines them such that there is only one hash passed as a final argument to Capybara.
->Reconstructed Predication:
the arguments to thethe arguments to the
->Raw Input:
summarize:def recombine_args ( find_args, runtime_args, options ) options. merge! ( find_args. pop ) if find_args. last. is_a? Hash options. merge! ( runtime_args. pop ) if runtime_args. last. is_a? Hash options [ :wait ] = wait_time unless wait_key_present? ( options ) end
->Raw Target:
Options re - combiner. This takes the original inputs and combines them such that there is only one hash passed as a final argument to Capybara.
--

128=========
->Original Input:
['def', 'elements_to_check', 'if', '_expected_items', 'SitePrism', '.', 'logger', '.', 'debug', '(', "'Expected Items has been set.'", ')', '_mapped_items', '.', 'select', '{', '|', 'item_name', '|', '_expected_items', '.', 'include?', '(', 'item_name', ')', '}', 'else', '_mapped_items', 'end', 'end']
->Original Target:
['If', 'the', 'page', 'or', 'section', 'has', 'expected_items', 'set', 'return', 'expected_items', 'that', 'are', 'mapped', ';', 'otherwise', 'just', 'return', 'the', 'list', 'of', 'all', 'mapped_items']
->Reconstructed Target:
If the page or section has expected_items set return expected_items that are mapped ; otherwise just return the list of all mapped_items
->Reconstructed Predication:
the list of elements to
->Raw Input:
summarize:def elements_to_check if _expected_items SitePrism. logger. debug ( 'Expected Items has been set.' ) _mapped_items. select { | item_name | _expected_items. include? ( item_name ) } else _mapped_items end end
->Raw Target:
If the page or section has expected_items set return expected_items that are mapped ; otherwise just return the list of all mapped_items
--

129=========
->Original Input:
['def', 'matches?', '(', 'url', ',', 'expected_mappings', '=', '{', '}', ')', 'actual_mappings', '=', 'mappings', '(', 'url', ')', 'return', 'false', 'unless', 'actual_mappings', 'expected_mappings', '.', 'empty?', '||', 'all_expected_mappings_match?', '(', 'expected_mappings', ',', 'actual_mappings', ')', 'end']
->Original Target:
['Determine', 'whether', 'URL', 'matches', 'our', 'pattern', 'and', 'optionally', 'whether', 'the', 'extracted', 'mappings', 'match', 'a', 'hash', 'of', 'expected', 'values', '.', 'You', 'can', 'specify', 'values', 'as', 'strings', 'numbers', 'or', 'regular', 'expressions', '.']
->Reconstructed Target:
Determine whether URL matches our pattern and optionally whether the extracted mappings match a hash of expected values. You can specify values as strings numbers or regular expressions.
->Reconstructed Predication:
the url matches the expected mappings
->Raw Input:
summarize:def matches? ( url, expected_mappings = { } ) actual_mappings = mappings ( url ) return false unless actual_mappings expected_mappings. empty? || all_expected_mappings_match? ( expected_mappings, actual_mappings ) end
->Raw Target:
Determine whether URL matches our pattern and optionally whether the extracted mappings match a hash of expected values. You can specify values as strings numbers or regular expressions.
--

130=========
->Original Input:
['def', 'component_matches', '(', 'component', ',', 'uri', ')', 'component_template', '=', 'component_templates', '[', 'component', ']', 'return', '{', '}', 'unless', 'component_template', 'component_url', '=', 'uri', '.', 'public_send', '(', 'component', ')', '.', 'to_s', 'mappings', '=', 'component_template', '.', 'extract', '(', 'component_url', ')', 'return', 'mappings', 'if', 'mappings', 'prefix', '=', 'component_prefixes', '[', 'component', ']', 'return', 'nil', 'unless', 'prefix', 'component_template', '.', 'extract', '(', 'prefix', '+', 'component_url', ')', 'end']
->Original Target:
['Returns', 'empty', 'hash', 'if', 'the', 'template', 'omits', 'the', 'component', 'or', 'a', 'set', 'of', 'substitutions', 'if', 'the', 'provided', 'URI', 'component', 'matches', 'the', 'template', 'component', 'or', 'nil', 'if', 'the', 'match', 'fails', '.']
->Reconstructed Target:
Returns empty hash if the template omits the component or a set of substitutions if the provided URI component matches the template component or nil if the match fails.
->Reconstructed Predication:
the component matches the given
->Raw Input:
summarize:def component_matches ( component, uri ) component_template = component_templates [ component ] return { } unless component_template component_url = uri. public_send ( component ). to_s mappings = component_template. extract ( component_url ) return mappings if mappings prefix = component_prefixes [ component ] return nil unless prefix component_template. extract ( prefix + component_url ) end
->Raw Target:
Returns empty hash if the template omits the component or a set of substitutions if the provided URI component matches the template component or nil if the match fails.
--

131=========
->Original Input:
['def', 'to_substituted_uri', 'url', '=', 'pattern', 'substitutions', '.', 'each_pair', '{', '|', 'slug', ',', 'value', '|', 'url', '=', 'url', '.', 'sub', '(', 'slug', ',', 'value', ')', '}', 'begin', 'Addressable', '::', 'URI', '.', 'parse', '(', 'url', ')', 'rescue', 'Addressable', '::', 'URI', '::', 'InvalidURIError', 'SitePrism', '.', 'logger', '.', 'warn', '(', '"Ensure you don\'t use templated port numbers."', ')', 'raise', 'SitePrism', '::', 'InvalidUrlMatcherError', 'end', 'end']
->Original Target:
['Convert', 'the', 'pattern', 'into', 'an', 'Addressable', 'URI', 'by', 'substituting', 'the', 'template', 'slugs', 'with', 'nonsense', 'strings', '.']
->Reconstructed Target:
Convert the pattern into an Addressable URI by substituting the template slugs with nonsense strings.
->Reconstructed Predication:
url = pattern substitutions =substitutes
->Raw Input:
summarize:def to_substituted_uri url = pattern substitutions. each_pair { | slug, value | url = url. sub ( slug, value ) } begin Addressable :: URI. parse ( url ) rescue Addressable :: URI :: InvalidURIError SitePrism. logger. warn ( "Ensure you don't use templated port numbers." ) raise SitePrism :: InvalidUrlMatcherError end end
->Raw Target:
Convert the pattern into an Addressable URI by substituting the template slugs with nonsense strings.
--

132=========
->Original Input:
['def', 'substitution_value', '(', 'index', ')', 'sha', '=', 'Digest', '::', 'SHA1', '.', 'digest', '(', 'index', '.', 'to_s', ')', 'Base64', '.', 'urlsafe_encode64', '(', 'sha', ')', '.', 'gsub', '(', '/', '/', ',', "''", ')', '[', '0', '..', '5', ']', 'end']
->Original Target:
['Generate', 'a', 'repeatable', '5', 'character', 'uniform', 'alphabetical', 'nonsense', 'string', 'to', 'allow', 'parsing', 'as', 'a', 'URI']
->Reconstructed Target:
Generate a repeatable 5 character uniform alphabetical nonsense string to allow parsing as a URI
->Reconstructed Predication:
the substitution value for the given
->Raw Input:
summarize:def substitution_value ( index ) sha = Digest :: SHA1. digest ( index. to_s ) Base64. urlsafe_encode64 ( sha ). gsub ( / /, '' ) [ 0.. 5 ] end
->Raw Target:
Generate a repeatable 5 character uniform alphabetical nonsense string to allow parsing as a URI
--

133=========
->Original Input:
['def', 'build_times_enumerator', '(', 'number', ',', 'cursor', ':', ')', 'raise', 'ArgumentError', ',', '"First argument must be an Integer"', 'unless', 'number', '.', 'is_a?', '(', 'Integer', ')', 'wrap', '(', 'self', ',', 'build_array_enumerator', '(', 'number', '.', 'times', '.', 'to_a', ',', 'cursor', ':', 'cursor', ')', ')', 'end']
->Original Target:
['Builds', 'Enumerator', 'objects', 'that', 'iterates', 'N', 'times', 'and', 'yields', 'number', 'starting', 'from', 'zero', '.']
->Reconstructed Target:
Builds Enumerator objects that iterates N times and yields number starting from zero.
->Reconstructed Predication:
the number of times to
->Raw Input:
summarize:def build_times_enumerator ( number, cursor : ) raise ArgumentError, "First argument must be an Integer" unless number. is_a? ( Integer ) wrap ( self, build_array_enumerator ( number. times. to_a, cursor : cursor ) ) end
->Raw Target:
Builds Enumerator objects that iterates N times and yields number starting from zero.
--

134=========
->Original Input:
['def', 'build_array_enumerator', '(', 'enumerable', ',', 'cursor', ':', ')', 'unless', 'enumerable', '.', 'is_a?', '(', 'Array', ')', 'raise', 'ArgumentError', ',', '"enumerable must be an Array"', 'end', 'if', 'enumerable', '.', 'any?', '{', '|', 'i', '|', 'defined?', '(', 'ActiveRecord', ')', '&&', 'i', '.', 'is_a?', '(', 'ActiveRecord', '::', 'Base', ')', '}', 'raise', 'ArgumentError', ',', '"array cannot contain ActiveRecord objects"', 'end', 'drop', '=', 'if', 'cursor', '.', 'nil?', '0', 'else', 'cursor', '+', '1', 'end', 'wrap', '(', 'self', ',', 'enumerable', '.', 'each_with_index', '.', 'drop', '(', 'drop', ')', '.', 'to_enum', '{', 'enumerable', '.', 'size', '}', ')', 'end']
->Original Target:
['Builds', 'Enumerator', 'object', 'from', 'a', 'given', 'array', 'using', '+', 'cursor', '+', 'as', 'an', 'offset', '.']
->Reconstructed Target:
Builds Enumerator object from a given array using + cursor + as an offset.
->Reconstructed Predication:
the array of objects to
->Raw Input:
summarize:def build_array_enumerator ( enumerable, cursor : ) unless enumerable. is_a? ( Array ) raise ArgumentError, "enumerable must be an Array" end if enumerable. any? { | i | defined? ( ActiveRecord ) && i. is_a? ( ActiveRecord :: Base ) } raise ArgumentError, "array cannot contain ActiveRecord objects" end drop = if cursor. nil? 0 else cursor + 1 end wrap ( self, enumerable. each_with_index. drop ( drop ). to_enum { enumerable. size } ) end
->Raw Target:
Builds Enumerator object from a given array using + cursor + as an offset.
--

135=========
->Original Input:
['def', 'build_lock_queue_enumerator', '(', 'lock_queue', ',', 'at_most_once', ':', ')', 'unless', 'lock_queue', '.', 'is_a?', '(', 'BackgroundQueue', '::', 'LockQueue', '::', 'RedisQueue', ')', '||', 'lock_queue', '.', 'is_a?', '(', 'BackgroundQueue', '::', 'LockQueue', '::', 'RolloutRedisQueue', ')', 'raise', 'ArgumentError', ',', '"an argument to #build_lock_queue_enumerator must be a LockQueue"', 'end', 'wrap', '(', 'self', ',', 'BackgroundQueue', '::', 'LockQueueEnumerator', '.', 'new', '(', 'lock_queue', ',', 'at_most_once', ':', 'at_most_once', ')', '.', 'to_enum', ')', 'end']
->Original Target:
['Builds', 'Enumerator', 'from', 'a', 'lock', 'queue', 'instance', 'that', 'belongs', 'to', 'a', 'job', '.', 'The', 'helper', 'is', 'only', 'to', 'be', 'used', 'from', 'jobs', 'that', 'use', 'LockQueue', 'module', '.']
->Reconstructed Target:
Builds Enumerator from a lock queue instance that belongs to a job. The helper is only to be used from jobs that use LockQueue module.
->Reconstructed Predication:
LockQueue Enumerator for a given RedisQueue
->Raw Input:
summarize:def build_lock_queue_enumerator ( lock_queue, at_most_once : ) unless lock_queue. is_a? ( BackgroundQueue :: LockQueue :: RedisQueue ) || lock_queue. is_a? ( BackgroundQueue :: LockQueue :: RolloutRedisQueue ) raise ArgumentError, "an argument to #build_lock_queue_enumerator must be a LockQueue" end wrap ( self, BackgroundQueue :: LockQueueEnumerator. new ( lock_queue, at_most_once : at_most_once ). to_enum ) end
->Raw Target:
Builds Enumerator from a lock queue instance that belongs to a job. The helper is only to be used from jobs that use LockQueue module.
--

136=========
->Original Input:
['def', 'build_active_record_enumerator_on_records', '(', 'scope', ',', 'cursor', ':', ',', '**', 'args', ')', 'enum', '=', 'build_active_record_enumerator', '(', 'scope', ',', 'cursor', ':', 'cursor', ',', '**', 'args', ')', '.', 'records', 'wrap', '(', 'self', ',', 'enum', ')', 'end']
->Original Target:
['Builds', 'Enumerator', 'from', 'Active', 'Record', 'Relation', '.', 'Each', 'Enumerator', 'tick', 'moves', 'the', 'cursor', 'one', 'row', 'forward', '.']
->Reconstructed Target:
Builds Enumerator from Active Record Relation. Each Enumerator tick moves the cursor one row forward.
->Reconstructed Predication:
the active record enumeration
->Raw Input:
summarize:def build_active_record_enumerator_on_records ( scope, cursor :, ** args ) enum = build_active_record_enumerator ( scope, cursor : cursor, ** args ). records wrap ( self, enum ) end
->Raw Target:
Builds Enumerator from Active Record Relation. Each Enumerator tick moves the cursor one row forward.
--

137=========
->Original Input:
['def', 'build_active_record_enumerator_on_batches', '(', 'scope', ',', 'cursor', ':', ',', '**', 'args', ')', 'enum', '=', 'build_active_record_enumerator', '(', 'scope', ',', 'cursor', ':', 'cursor', ',', '**', 'args', ')', '.', 'batches', 'wrap', '(', 'self', ',', 'enum', ')', 'end']
->Original Target:
['Builds', 'Enumerator', 'from', 'Active', 'Record', 'Relation', 'and', 'enumerates', 'on', 'batches', '.', 'Each', 'Enumerator', 'tick', 'moves', 'the', 'cursor', '+', 'batch_size', '+', 'rows', 'forward', '.']
->Reconstructed Target:
Builds Enumerator from Active Record Relation and enumerates on batches. Each Enumerator tick moves the cursor + batch_size + rows forward.
->Reconstructed Predication:
the active record
->Raw Input:
summarize:def build_active_record_enumerator_on_batches ( scope, cursor :, ** args ) enum = build_active_record_enumerator ( scope, cursor : cursor, ** args ). batches wrap ( self, enum ) end
->Raw Target:
Builds Enumerator from Active Record Relation and enumerates on batches. Each Enumerator tick moves the cursor + batch_size + rows forward.
--

138=========
->Original Input:
['def', 'batches', '(', 'batch_size', ':', ',', 'cursor', ':', ')', '@csv', '.', 'lazy', '.', 'each_slice', '(', 'batch_size', ')', '.', 'each_with_index', '.', 'drop', '(', 'cursor', '.', 'to_i', ')', '.', 'to_enum', '{', '(', 'count_rows_in_file', '.', 'to_f', '/', 'batch_size', ')', '.', 'ceil', '}', 'end']
->Original Target:
['Constructs', 'a', 'enumerator', 'on', 'batches', 'of', 'CSV', 'rows']
->Reconstructed Target:
Constructs a enumerator on batches of CSV rows
->Reconstructed Predication:
the batch of rows in the
->Raw Input:
summarize:def batches ( batch_size :, cursor : ) @csv. lazy. each_slice ( batch_size ). each_with_index. drop ( cursor. to_i ). to_enum { ( count_rows_in_file. to_f / batch_size ). ceil } end
->Raw Target:
Constructs a enumerator on batches of CSV rows
--

139=========
->Original Input:
['def', 'reify', '(', 'options', '=', '{', '}', ')', 'unless', 'self', '.', 'class', '.', 'column_names', '.', 'include?', '"object"', 'raise', '"reify can\'t be called without an object column"', 'end', 'return', 'nil', 'if', 'object', '.', 'nil?', '::', 'PaperTrail', '::', 'Reifier', '.', 'reify', '(', 'self', ',', 'options', ')', 'end']
->Original Target:
['Restore', 'the', 'item', 'from', 'this', 'version', '.']
->Reconstructed Target:
Restore the item from this version.
->Reconstructed Predication:
the object to be reified.
->Raw Input:
summarize:def reify ( options = { } ) unless self. class. column_names. include? "object" raise "reify can't be called without an object column" end return nil if object. nil? :: PaperTrail :: Reifier. reify ( self, options ) end
->Raw Target:
Restore the item from this version.
--

140=========
->Original Input:
['def', 'version_limit', 'if', 'self', '.', 'class', '.', 'item_subtype_column_present?', 'klass', '=', '(', 'item_subtype', '||', 'item_type', ')', '.', 'constantize', 'if', 'klass', '&.', 'paper_trail_options', '&.', 'key?', '(', ':limit', ')', 'return', 'klass', '.', 'paper_trail_options', '[', ':limit', ']', 'end', 'end', 'PaperTrail', '.', 'config', '.', 'version_limit', 'end']
->Original Target:
['See', 'docs', 'section', '2', '.', 'e', '.', 'Limiting', 'the', 'Number', 'of', 'Versions', 'Created', '.', 'The', 'version', 'limit', 'can', 'be', 'global', 'or', 'per', '-', 'model', '.']
->Reconstructed Target:
See docs section 2. e. Limiting the Number of Versions Created. The version limit can be global or per - model.
->Reconstructed Predication:
the version limit for the item
->Raw Input:
summarize:def version_limit if self. class. item_subtype_column_present? klass = ( item_subtype || item_type ). constantize if klass &. paper_trail_options &. key? ( :limit ) return klass. paper_trail_options [ :limit ] end end PaperTrail. config. version_limit end
->Raw Target:
See docs section 2. e. Limiting the Number of Versions Created. The version limit can be global or per - model.
--

141=========
->Original Input:
['def', 'on_create', '@model_class', '.', 'after_create', '{', '|', 'r', '|', 'r', '.', 'paper_trail', '.', 'record_create', 'if', 'r', '.', 'paper_trail', '.', 'save_version?', '}', 'return', 'if', '@model_class', '.', 'paper_trail_options', '[', ':on', ']', '.', 'include?', '(', ':create', ')', '@model_class', '.', 'paper_trail_options', '[', ':on', ']', '<<', ':create', 'end']
->Original Target:
['Adds', 'a', 'callback', 'that', 'records', 'a', 'version', 'after', 'a', 'create', 'event', '.']
->Reconstructed Target:
Adds a callback that records a version after a create event.
->Reconstructed Predication:
@model_class @model_class @model_class @model_class
->Raw Input:
summarize:def on_create @model_class. after_create { | r | r. paper_trail. record_create if r. paper_trail. save_version? } return if @model_class. paper_trail_options [ :on ]. include? ( :create ) @model_class. paper_trail_options [ :on ] << :create end
->Raw Target:
Adds a callback that records a version after a create event.
--

142=========
->Original Input:
['def', 'on_destroy', '(', 'recording_order', '=', '"before"', ')', 'unless', '%w[', 'after', 'before', ']', '.', 'include?', '(', 'recording_order', '.', 'to_s', ')', 'raise', 'ArgumentError', ',', '\'recording order can only be "after" or "before"\'', 'end', 'if', 'recording_order', '.', 'to_s', '==', '"after"', '&&', 'cannot_record_after_destroy?', 'raise', 'E_CANNOT_RECORD_AFTER_DESTROY', 'end', '@model_class', '.', 'send', '(', '"#{recording_order}_destroy"', ',', 'lambda', 'do', '|', 'r', '|', 'return', 'unless', 'r', '.', 'paper_trail', '.', 'save_version?', 'r', '.', 'paper_trail', '.', 'record_destroy', '(', 'recording_order', ')', 'end', ')', 'return', 'if', '@model_class', '.', 'paper_trail_options', '[', ':on', ']', '.', 'include?', '(', ':destroy', ')', '@model_class', '.', 'paper_trail_options', '[', ':on', ']', '<<', ':destroy', 'end']
->Original Target:
['Adds', 'a', 'callback', 'that', 'records', 'a', 'version', 'before', 'or', 'after', 'a', 'destroy', 'event', '.']
->Reconstructed Target:
Adds a callback that records a version before or after a destroy event.
->Reconstructed Predication:
the model to be deleted
->Raw Input:
summarize:def on_destroy ( recording_order = "before" ) unless %w[ after before ]. include? ( recording_order. to_s ) raise ArgumentError,'recording order can only be "after" or "before"' end if recording_order. to_s == "after" && cannot_record_after_destroy? raise E_CANNOT_RECORD_AFTER_DESTROY end @model_class. send ( "#{recording_order}_destroy", lambda do | r | return unless r. paper_trail. save_version? r. paper_trail. record_destroy ( recording_order ) end ) return if @model_class. paper_trail_options [ :on ]. include? ( :destroy ) @model_class. paper_trail_options [ :on ] << :destroy end
->Raw Target:
Adds a callback that records a version before or after a destroy event.
--

143=========
->Original Input:
['def', 'on_update', '@model_class', '.', 'before_save', '{', '|', 'r', '|', 'r', '.', 'paper_trail', '.', 'reset_timestamp_attrs_for_update_if_needed', '}', '@model_class', '.', 'after_update', '{', '|', 'r', '|', 'if', 'r', '.', 'paper_trail', '.', 'save_version?', 'r', '.', 'paper_trail', '.', 'record_update', '(', 'force', ':', 'false', ',', 'in_after_callback', ':', 'true', ',', 'is_touch', ':', 'false', ')', 'end', '}', '@model_class', '.', 'after_update', '{', '|', 'r', '|', 'r', '.', 'paper_trail', '.', 'clear_version_instance', '}', 'return', 'if', '@model_class', '.', 'paper_trail_options', '[', ':on', ']', '.', 'include?', '(', ':update', ')', '@model_class', '.', 'paper_trail_options', '[', ':on', ']', '<<', ':update', 'end']
->Original Target:
['Adds', 'a', 'callback', 'that', 'records', 'a', 'version', 'after', 'an', 'update', 'event', '.']
->Reconstructed Target:
Adds a callback that records a version after an update event.
->Reconstructed Predication:
: update:update
->Raw Input:
summarize:def on_update @model_class. before_save { | r | r. paper_trail. reset_timestamp_attrs_for_update_if_needed } @model_class. after_update { | r | if r. paper_trail. save_version? r. paper_trail. record_update ( force : false, in_after_callback : true, is_touch : false ) end } @model_class. after_update { | r | r. paper_trail. clear_version_instance } return if @model_class. paper_trail_options [ :on ]. include? ( :update ) @model_class. paper_trail_options [ :on ] << :update end
->Raw Target:
Adds a callback that records a version after an update event.
--

144=========
->Original Input:
['def', 'on_touch', '@model_class', '.', 'after_touch', '{', '|', 'r', '|', 'r', '.', 'paper_trail', '.', 'record_update', '(', 'force', ':', 'true', ',', 'in_after_callback', ':', 'true', ',', 'is_touch', ':', 'true', ')', '}', 'end']
->Original Target:
['Adds', 'a', 'callback', 'that', 'records', 'a', 'version', 'after', 'a', 'touch', 'event', '.']
->Reconstructed Target:
Adds a callback that records a version after a touch event.
->Reconstructed Predication:
 def update_model_after_touch ( model_class
->Raw Input:
summarize:def on_touch @model_class. after_touch { | r | r. paper_trail. record_update ( force : true, in_after_callback : true, is_touch : true ) } end
->Raw Target:
Adds a callback that records a version after a touch event.
--

145=========
->Original Input:
['def', 'check_presence_of_item_subtype_column', '(', 'options', ')', 'return', 'unless', 'options', '.', 'key?', '(', ':limit', ')', 'return', 'if', 'version_class', '.', 'item_subtype_column_present?', 'raise', 'format', '(', 'E_MODEL_LIMIT_REQUIRES_ITEM_SUBTYPE', ',', '@model_class', '.', 'name', ')', 'end']
->Original Target:
['Some', 'options', 'require', 'the', 'presence', 'of', 'the', 'item_subtype', 'column', '.', 'Currently', 'only', 'limit', 'but', 'in', 'the', 'future', 'there', 'may', 'be', 'others', '.']
->Reconstructed Target:
Some options require the presence of the item_subtype column. Currently only limit but in the future there may be others.
->Reconstructed Predication:
the presence of the item
->Raw Input:
summarize:def check_presence_of_item_subtype_column ( options ) return unless options. key? ( :limit ) return if version_class. item_subtype_column_present? raise format ( E_MODEL_LIMIT_REQUIRES_ITEM_SUBTYPE, @model_class. name ) end
->Raw Target:
Some options require the presence of the item_subtype column. Currently only limit but in the future there may be others.
--

146=========
->Original Input:
['def', 'save_version?', 'if_condition', '=', '@record', '.', 'paper_trail_options', '[', ':if', ']', 'unless_condition', '=', '@record', '.', 'paper_trail_options', '[', ':unless', ']', '(', 'if_condition', '.', 'blank?', '||', 'if_condition', '.', 'call', '(', '@record', ')', ')', '&&', '!', 'unless_condition', '.', 'try', '(', ':call', ',', '@record', ')', 'end']
->Original Target:
['AR', 'callback', '.']
->Reconstructed Target:
AR callback.
->Reconstructed Predication:
the paper_trail_options to the paper_trail_options
->Raw Input:
summarize:def save_version? if_condition = @record. paper_trail_options [ :if ] unless_condition = @record. paper_trail_options [ :unless ] ( if_condition. blank? || if_condition. call ( @record ) ) &&! unless_condition. try ( :call, @record ) end
->Raw Target:
AR callback.
--

147=========
->Original Input:
['def', '_squash_changes', '(', 'changes', ')', 'changes', '=', 'changes', '.', 'map', '{', '|', 'change', ',', 'dir', ',', 'path', '|', '[', 'change', ',', 'dir', '+', 'path', ']', '}', 'actions', '=', 'changes', '.', 'group_by', '(', '&', ':last', ')', '.', 'map', 'do', '|', 'path', ',', 'action_list', '|', '[', '_logical_action_for', '(', 'path', ',', 'action_list', '.', 'map', '(', '&', ':first', ')', ')', ',', 'path', '.', 'to_s', ']', 'end', 'config', '.', 'debug', '(', '"listen: raw changes: #{actions.inspect}"', ')', '{', 'modified', ':', '[', ']', ',', 'added', ':', '[', ']', ',', 'removed', ':', '[', ']', '}', '.', 'tap', 'do', '|', 'squashed', '|', 'actions', '.', 'each', 'do', '|', 'type', ',', 'path', '|', 'squashed', '[', 'type', ']', '<<', 'path', 'unless', 'type', '.', 'nil?', 'end', 'config', '.', 'debug', '(', '"listen: final changes: #{squashed.inspect}"', ')', 'end', 'end']
->Original Target:
['groups', 'changes', 'into', 'the', 'expected', 'structure', 'expected', 'by', 'clients']
->Reconstructed Target:
groups changes into the expected structure expected by clients
->Reconstructed Predication:
changes: modified : added,
->Raw Input:
summarize:def _squash_changes ( changes ) changes = changes. map { | change, dir, path | [ change, dir + path ] } actions = changes. group_by ( & :last ). map do | path, action_list | [ _logical_action_for ( path, action_list. map ( & :first ) ), path. to_s ] end config. debug ( "listen: raw changes: #{actions.inspect}" ) { modified : [ ], added : [ ], removed : [ ] }. tap do | squashed | actions. each do | type, path | squashed [ type ] << path unless type. nil? end config. debug ( "listen: final changes: #{squashed.inspect}" ) end end
->Raw Target:
groups changes into the expected structure expected by clients
--

148=========
->Original Input:
['def', 'to_node', 'object', 'if', 'object', '.', 'is_a?', '(', 'self', '.', 'ancestry_base_class', ')', 'then', 'object', 'else', 'unscoped_where', '{', '|', 'scope', '|', 'scope', '.', 'find', 'object', '}', 'end', 'end']
->Original Target:
['Fetch', 'tree', 'node', 'if', 'necessary']
->Reconstructed Target:
Fetch tree node if necessary
->Reconstructed Predication:
the node to be returned
->Raw Input:
summarize:def to_node object if object. is_a? ( self. ancestry_base_class ) then object else unscoped_where { | scope | scope. find object } end end
->Raw Target:
Fetch tree node if necessary
--

149=========
->Original Input:
['def', 'scope_depth', 'depth_options', ',', 'depth', 'depth_options', '.', 'inject', '(', 'self', '.', 'ancestry_base_class', ')', 'do', '|', 'scope', ',', 'option', '|', 'scope_name', ',', 'relative_depth', '=', 'option', 'if', '[', ':before_depth', ',', ':to_depth', ',', ':at_depth', ',', ':from_depth', ',', ':after_depth', ']', '.', 'include?', 'scope_name', 'scope', '.', 'send', 'scope_name', ',', 'depth', '+', 'relative_depth', 'else', 'raise', 'Ancestry', '::', 'AncestryException', '.', 'new', '(', '"Unknown depth option: #{scope_name}."', ')', 'end', 'end', 'end']
->Original Target:
['Scope', 'on', 'relative', 'depth', 'options']
->Reconstructed Target:
Scope on relative depth options
->Reconstructed Predication:
the depth of the current
->Raw Input:
summarize:def scope_depth depth_options, depth depth_options. inject ( self. ancestry_base_class ) do | scope, option | scope_name, relative_depth = option if [ :before_depth, :to_depth, :at_depth, :from_depth, :after_depth ]. include? scope_name scope. send scope_name, depth + relative_depth else raise Ancestry :: AncestryException. new ( "Unknown depth option: #{scope_name}." ) end end end
->Raw Target:
Scope on relative depth options
--

150=========
->Original Input:
['def', 'orphan_strategy', '=', 'orphan_strategy', 'if', '[', ':rootify', ',', ':adopt', ',', ':restrict', ',', ':destroy', ']', '.', 'include?', 'orphan_strategy', 'class_variable_set', ':@@orphan_strategy', ',', 'orphan_strategy', 'else', 'raise', 'Ancestry', '::', 'AncestryException', '.', 'new', '(', '"Invalid orphan strategy, valid ones are :rootify,:adopt, :restrict and :destroy."', ')', 'end', 'end']
->Original Target:
['Orphan', 'strategy', 'writer']
->Reconstructed Target:
Orphan strategy writer
->Reconstructed Predication:
 def orphan_strategy = orphan_strategy
->Raw Input:
summarize:def orphan_strategy = orphan_strategy if [ :rootify, :adopt, :restrict, :destroy ]. include? orphan_strategy class_variable_set :@@orphan_strategy, orphan_strategy else raise Ancestry :: AncestryException. new ( "Invalid orphan strategy, valid ones are :rootify,:adopt, :restrict and :destroy." ) end end
->Raw Target:
Orphan strategy writer
--

151=========
->Original Input:
['def', 'arrange', 'options', '=', '{', '}', 'if', '(', 'order', '=', 'options', '.', 'delete', '(', ':order', ')', ')', 'arrange_nodes', 'self', '.', 'ancestry_base_class', '.', 'order', '(', 'order', ')', '.', 'where', '(', 'options', ')', 'else', 'arrange_nodes', 'self', '.', 'ancestry_base_class', '.', 'where', '(', 'options', ')', 'end', 'end']
->Original Target:
['Get', 'all', 'nodes', 'and', 'sorting', 'them', 'into', 'an', 'empty', 'hash']
->Reconstructed Target:
Get all nodes and sorting them into an empty hash
->Reconstructed Predication:
the nodes to arrange.
->Raw Input:
summarize:def arrange options = { } if ( order = options. delete ( :order ) ) arrange_nodes self. ancestry_base_class. order ( order ). where ( options ) else arrange_nodes self. ancestry_base_class. where ( options ) end end
->Raw Target:
Get all nodes and sorting them into an empty hash
--

152=========
->Original Input:
['def', 'arrange_serializable', 'options', '=', '{', '}', ',', 'nodes', '=', 'nil', ',', '&', 'block', 'nodes', '=', 'arrange', '(', 'options', ')', 'if', 'nodes', '.', 'nil?', 'nodes', '.', 'map', 'do', '|', 'parent', ',', 'children', '|', 'if', 'block_given?', 'yield', 'parent', ',', 'arrange_serializable', '(', 'options', ',', 'children', ',', '&', 'block', ')', 'else', 'parent', '.', 'serializable_hash', '.', 'merge', "'children'", '=>', 'arrange_serializable', '(', 'options', ',', 'children', ')', 'end', 'end', 'end']
->Original Target:
['Arrangement', 'to', 'nested', 'array']
->Reconstructed Target:
Arrangement to nested array
->Reconstructed Predication:
the nodes to serialize.
->Raw Input:
summarize:def arrange_serializable options = { }, nodes = nil, & block nodes = arrange ( options ) if nodes. nil? nodes. map do | parent, children | if block_given? yield parent, arrange_serializable ( options, children, & block ) else parent. serializable_hash. merge 'children' => arrange_serializable ( options, children ) end end end
->Raw Target:
Arrangement to nested array
--

153=========
->Original Input:
['def', 'build_ancestry_from_parent_ids!', 'parent_id', '=', 'nil', ',', 'ancestry', '=', 'nil', 'unscoped_where', 'do', '|', 'scope', '|', 'scope', '.', 'where', '(', ':parent_id', '=>', 'parent_id', ')', '.', 'find_each', 'do', '|', 'node', '|', 'node', '.', 'without_ancestry_callbacks', 'do', 'node', '.', 'update_attribute', 'ancestry_column', ',', 'ancestry', 'end', 'build_ancestry_from_parent_ids!', 'node', '.', 'id', ',', 'if', 'ancestry', '.', 'nil?', 'then', '"#{node.id}"', 'else', '"#{ancestry}/#{node.id}"', 'end', 'end', 'end', 'end']
->Original Target:
['Build', 'ancestry', 'from', 'parent', 'id', 's', 'for', 'migration', 'purposes']
->Reconstructed Target:
Build ancestry from parent id s for migration purposes
->Reconstructed Predication:
the parent id of the
->Raw Input:
summarize:def build_ancestry_from_parent_ids! parent_id = nil, ancestry = nil unscoped_where do | scope | scope. where ( :parent_id => parent_id ). find_each do | node | node. without_ancestry_callbacks do node. update_attribute ancestry_column, ancestry end build_ancestry_from_parent_ids! node. id, if ancestry. nil? then "#{node.id}" else "#{ancestry}/#{node.id}" end end end end
->Raw Target:
Build ancestry from parent id s for migration purposes
--

154=========
->Original Input:
['def', 'rebuild_depth_cache!', 'raise', 'Ancestry', '::', 'AncestryException', '.', 'new', '(', '"Cannot rebuild depth cache for model without depth caching."', ')', 'unless', 'respond_to?', ':depth_cache_column', 'self', '.', 'ancestry_base_class', '.', 'transaction', 'do', 'unscoped_where', 'do', '|', 'scope', '|', 'scope', '.', 'find_each', 'do', '|', 'node', '|', 'node', '.', 'update_attribute', 'depth_cache_column', ',', 'node', '.', 'depth', 'end', 'end', 'end', 'end']
->Original Target:
['Rebuild', 'depth', 'cache', 'if', 'it', 'got', 'corrupted', 'or', 'if', 'depth', 'caching', 'was', 'just', 'turned', 'on']
->Reconstructed Target:
Rebuild depth cache if it got corrupted or if depth caching was just turned on
->Reconstructed Predication:
the depth cache for the
->Raw Input:
summarize:def rebuild_depth_cache! raise Ancestry :: AncestryException. new ( "Cannot rebuild depth cache for model without depth caching." ) unless respond_to? :depth_cache_column self. ancestry_base_class. transaction do unscoped_where do | scope | scope. find_each do | node | node. update_attribute depth_cache_column, node. depth end end end end
->Raw Target:
Rebuild depth cache if it got corrupted or if depth caching was just turned on
--

155=========
->Original Input:
['def', 'indirect_conditions', '(', 'object', ')', 't', '=', 'arel_table', 'node', '=', 'to_node', '(', 'object', ')', 'if', 'ActiveRecord', '::', 'VERSION', '::', 'MAJOR', '>=', '5', 't', '[', 'ancestry_column', ']', '.', 'matches', '(', '"#{node.child_ancestry}/%"', ',', 'nil', ',', 'true', ')', 'else', 't', '[', 'ancestry_column', ']', '.', 'matches', '(', '"#{node.child_ancestry}/%"', ')', 'end', 'end']
->Original Target:
['indirect', '=', 'anyone', 'who', 'is', 'a', 'descendant', 'but', 'not', 'a', 'child']
->Reconstructed Target:
indirect = anyone who is a descendant but not a child
->Reconstructed Predication:
the given object. 
->Raw Input:
summarize:def indirect_conditions ( object ) t = arel_table node = to_node ( object ) if ActiveRecord :: VERSION :: MAJOR >= 5 t [ ancestry_column ]. matches ( "#{node.child_ancestry}/%", nil, true ) else t [ ancestry_column ]. matches ( "#{node.child_ancestry}/%" ) end end
->Raw Target:
indirect = anyone who is a descendant but not a child
--

156=========
->Original Input:
['def', 'request_defaults', '(', 'sudo', '=', 'nil', ')', 'self', '.', 'class', '.', 'default_params', 'sudo', ':', 'sudo', 'raise', 'Error', '::', 'MissingCredentials', ',', "'Please set an endpoint to API'", 'unless', '@endpoint', 'self', '.', 'class', '.', 'default_params', '.', 'delete', '(', ':sudo', ')', 'if', 'sudo', '.', 'nil?', 'end']
->Original Target:
['Sets', 'a', 'base_uri', 'and', 'default_params', 'for', 'requests', '.']
->Reconstructed Target:
Sets a base_uri and default_params for requests.
->Reconstructed Predication:
the endpoint to API. 
->Raw Input:
summarize:def request_defaults ( sudo = nil ) self. class. default_params sudo : sudo raise Error :: MissingCredentials, 'Please set an endpoint to API' unless @endpoint self. class. default_params. delete ( :sudo ) if sudo. nil? end
->Raw Target:
Sets a base_uri and default_params for requests.
--

157=========
->Original Input:
['def', 'options', 'VALID_OPTIONS_KEYS', '.', 'inject', '(', '{', '}', ')', 'do', '|', 'option', ',', 'key', '|', 'option', '.', 'merge!', '(', 'key', '=>', 'send', '(', 'key', ')', ')', 'end', 'end']
->Original Target:
['Creates', 'a', 'hash', 'of', 'options', 'and', 'their', 'values', '.']
->Reconstructed Target:
Creates a hash of options and their values.
->Reconstructed Predication:
options
->Raw Input:
summarize:def options VALID_OPTIONS_KEYS. inject ( { } ) do | option, key | option. merge! ( key => send ( key ) ) end end
->Raw Target:
Creates a hash of options and their values.
--

158=========
->Original Input:
['def', 'reset', 'self', '.', 'endpoint', '=', 'ENV', '[', "'GITLAB_API_ENDPOINT'", ']', 'self', '.', 'private_token', '=', 'ENV', '[', "'GITLAB_API_PRIVATE_TOKEN'", ']', '||', 'ENV', '[', "'GITLAB_API_AUTH_TOKEN'", ']', 'self', '.', 'httparty', '=', 'get_httparty_config', '(', 'ENV', '[', "'GITLAB_API_HTTPARTY_OPTIONS'", ']', ')', 'self', '.', 'sudo', '=', 'nil', 'self', '.', 'user_agent', '=', 'DEFAULT_USER_AGENT', 'end']
->Original Target:
['Resets', 'all', 'configuration', 'options', 'to', 'the', 'defaults', '.']
->Reconstructed Target:
Resets all configuration options to the defaults.
->Reconstructed Predication:
..
->Raw Input:
summarize:def reset self. endpoint = ENV [ 'GITLAB_API_ENDPOINT' ] self. private_token = ENV [ 'GITLAB_API_PRIVATE_TOKEN' ] || ENV [ 'GITLAB_API_AUTH_TOKEN' ] self. httparty = get_httparty_config ( ENV [ 'GITLAB_API_HTTPARTY_OPTIONS' ] ) self. sudo = nil self. user_agent = DEFAULT_USER_AGENT end
->Raw Target:
Resets all configuration options to the defaults.
--

159=========
->Original Input:
['def', 'get_httparty_config', '(', 'options', ')', 'return', 'if', 'options', '.', 'nil?', 'httparty', '=', 'Gitlab', '::', 'CLI', '::', 'Helpers', '.', 'yaml_load', '(', 'options', ')', 'raise', 'ArgumentError', ',', "'HTTParty config should be a Hash.'", 'unless', 'httparty', '.', 'is_a?', 'Hash', 'Gitlab', '::', 'CLI', '::', 'Helpers', '.', 'symbolize_keys', 'httparty', 'end']
->Original Target:
['Allows', 'HTTParty', 'config', 'to', 'be', 'specified', 'in', 'ENV', 'using', 'YAML', 'hash', '.']
->Reconstructed Target:
Allows HTTParty config to be specified in ENV using YAML hash.
->Reconstructed Predication:
the HTTParty config. 
->Raw Input:
summarize:def get_httparty_config ( options ) return if options. nil? httparty = Gitlab :: CLI :: Helpers. yaml_load ( options ) raise ArgumentError, 'HTTParty config should be a Hash.' unless httparty. is_a? Hash Gitlab :: CLI :: Helpers. symbolize_keys httparty end
->Raw Target:
Allows HTTParty config to be specified in ENV using YAML hash.
--

160=========
->Original Input:
['def', 'start_timer', '(', 'timer', '=', 'DEFAULT_TIMER', '.', 'new', ')', 'raise', 'Socketry', '::', 'InternalError', ',', '"timer already started"', 'if', 'defined?', '(', '@timer', ')', 'raise', 'Socketry', '::', 'InternalError', ',', '"deadline already set"', 'if', 'defined?', '(', '@deadline', ')', '@deadline', '=', 'nil', '@timer', '=', 'timer', '@timer', '.', 'start', 'true', 'end']
->Original Target:
['Start', 'a', 'timer', 'in', 'the', 'included', 'object']
->Reconstructed Target:
Start a timer in the included object
->Reconstructed Predication:
 def start_timer
->Raw Input:
summarize:def start_timer ( timer = DEFAULT_TIMER. new ) raise Socketry :: InternalError, "timer already started" if defined? ( @timer ) raise Socketry :: InternalError, "deadline already set" if defined? ( @deadline ) @deadline = nil @timer = timer @timer. start true end
->Raw Target:
Start a timer in the included object
--

161=========
->Original Input:
['def', 'set_timeout', '(', 'timeout', ')', 'raise', 'Socketry', '::', 'InternalError', ',', '"deadline already set"', 'if', '@deadline', 'return', 'unless', 'timeout', 'raise', 'Socketry', '::', 'TimeoutError', ',', '"time expired"', 'if', 'timeout', '<', '0', '@deadline', '=', 'lifetime', '+', 'timeout', 'end']
->Original Target:
['Set', 'a', 'timeout', '.', 'Only', 'one', 'timeout', 'may', 'be', 'active', 'at', 'a', 'given', 'time', 'for', 'a', 'given', 'object', '.']
->Reconstructed Target:
Set a timeout. Only one timeout may be active at a given time for a given object.
->Reconstructed Predication:
 def set_timeout ( lifetime
->Raw Input:
summarize:def set_timeout ( timeout ) raise Socketry :: InternalError, "deadline already set" if @deadline return unless timeout raise Socketry :: TimeoutError, "time expired" if timeout < 0 @deadline = lifetime + timeout end
->Raw Target:
Set a timeout. Only one timeout may be active at a given time for a given object.
--

162=========
->Original Input:
['def', 'time_remaining', '(', 'timeout', ')', 'return', 'unless', 'timeout', 'raise', 'Socketry', '::', 'InternalError', ',', '"no deadline set"', 'unless', '@deadline', 'remaining', '=', '@deadline', '-', 'lifetime', 'raise', 'Socketry', '::', 'TimeoutError', ',', '"time expired"', 'if', 'remaining', '<=', '0', 'remaining', 'end']
->Original Target:
['Calculate', 'number', 'of', 'seconds', 'remaining', 'until', 'we', 'hit', 'the', 'timeout']
->Reconstructed Target:
Calculate number of seconds remaining until we hit the timeout
->Reconstructed Predication:
 def time_remaining
->Raw Input:
summarize:def time_remaining ( timeout ) return unless timeout raise Socketry :: InternalError, "no deadline set" unless @deadline remaining = @deadline - lifetime raise Socketry :: TimeoutError, "time expired" if remaining <= 0 remaining end
->Raw Target:
Calculate number of seconds remaining until we hit the timeout
--

163=========
->Original Input:
['def', 'build_schemas', '(', 'parent_schema', ')', 'schema', '=', 'parent_schema', '.', 'schema', 'if', 'schema', '[', '"$ref"', ']', 'load_ref_schema', '(', 'parent_schema', ',', 'schema', '[', '"$ref"', ']', ')', 'end', 'case', 'schema', '[', '"extends"', ']', 'when', 'String', 'load_ref_schema', '(', 'parent_schema', ',', 'schema', '[', '"extends"', ']', ')', 'when', 'Array', 'schema', '[', "'extends'", ']', '.', 'each', 'do', '|', 'type', '|', 'handle_schema', '(', 'parent_schema', ',', 'type', ')', 'end', 'end', '[', '"type"', ',', '"disallow"', ']', '.', 'each', 'do', '|', 'key', '|', 'if', 'schema', '[', 'key', ']', '.', 'is_a?', '(', 'Array', ')', 'schema', '[', 'key', ']', '.', 'each', 'do', '|', 'type', '|', 'if', 'type', '.', 'is_a?', '(', 'Hash', ')', 'handle_schema', '(', 'parent_schema', ',', 'type', ')', 'end', 'end', 'end', 'end', '%w[', 'definitions', 'properties', 'patternProperties', ']', '.', 'each', 'do', '|', 'key', '|', 'next', 'unless', 'value', '=', 'schema', '[', 'key', ']', 'value', '.', 'each', 'do', '|', 'k', ',', 'inner_schema', '|', 'handle_schema', '(', 'parent_schema', ',', 'inner_schema', ')', 'end', 'end', '%w[', 'additionalProperties', 'additionalItems', 'dependencies', 'extends', ']', '.', 'each', 'do', '|', 'key', '|', 'next', 'unless', 'schema', '[', 'key', ']', '.', 'is_a?', '(', 'Hash', ')', 'handle_schema', '(', 'parent_schema', ',', 'schema', '[', 'key', ']', ')', 'end', '%w[', 'allOf', 'anyOf', 'oneOf', 'not', ']', '.', 'each', 'do', '|', 'key', '|', 'next', 'unless', 'value', '=', 'schema', '[', 'key', ']', 'Array', '(', 'value', ')', '.', 'each', 'do', '|', 'inner_schema', '|', 'handle_schema', '(', 'parent_schema', ',', 'inner_schema', ')', 'end', 'end', 'if', 'schema', '[', '"items"', ']', 'items', '=', 'schema', '[', '"items"', ']', '.', 'clone', 'items', '=', '[', 'items', ']', 'unless', 'items', '.', 'is_a?', '(', 'Array', ')', 'items', '.', 'each', 'do', '|', 'item', '|', 'handle_schema', '(', 'parent_schema', ',', 'item', ')', 'end', 'end', 'if', 'schema', '[', '"enum"', ']', '.', 'is_a?', '(', 'Array', ')', 'schema', '[', '"enum"', ']', '=', 'ArraySet', '.', 'new', '(', 'schema', '[', '"enum"', ']', ')', 'end', 'end']
->Original Target:
['Build', 'all', 'schemas', 'with', 'IDs', 'mapping', 'out', 'the', 'namespace']
->Reconstructed Target:
Build all schemas with IDs mapping out the namespace
->Reconstructed Predication:
( parent_schema, schema)( parent_schema, schema) end( parent_schema, schema) end( parent_schema, schema) end end( parent_schema, schema )( parent_schema, schema )( parent_schema, schema )( parent_schema, schema )( parent_schema, schema )( parent_schema, schema )( parent_schema, schema )(
->Raw Input:
summarize:def build_schemas ( parent_schema ) schema = parent_schema. schema if schema [ "$ref" ] load_ref_schema ( parent_schema, schema [ "$ref" ] ) end case schema [ "extends" ] when String load_ref_schema ( parent_schema, schema [ "extends" ] ) when Array schema [ 'extends' ]. each do | type | handle_schema ( parent_schema, type ) end end [ "type", "disallow" ]. each do | key | if schema [ key ]. is_a? ( Array ) schema [ key ]. each do | type | if type. is_a? ( Hash ) handle_schema ( parent_schema, type ) end end end end %w[ definitions properties patternProperties ]. each do | key | next unless value = schema [ key ] value. each do | k, inner_schema | handle_schema ( parent_schema, inner_schema ) end end %w[ additionalProperties additionalItems dependencies extends ]. each do | key | next unless schema [ key ]. is_a? ( Hash ) handle_schema ( parent_schema, schema [ key ] ) end %w[ allOf anyOf oneOf not ]. each do | key | next unless value = schema [ key ] Array ( value ). each do | inner_schema | handle_schema ( parent_schema, inner_schema ) end end if schema [ "items" ] items = schema [ "items" ]. clone items = [ items ] unless items. is_a? ( Array ) items. each do | item | handle_schema ( parent_schema, item ) end end if schema [ "enum" ]. is_a? ( Array ) schema [ "enum" ] = ArraySet. new ( schema [ "enum" ] ) end end
->Raw Target:
Build all schemas with IDs mapping out the namespace
--

164=========
->Original Input:
['def', 'handle_schema', '(', 'parent_schema', ',', 'obj', ')', 'if', 'obj', '.', 'is_a?', '(', 'Hash', ')', 'schema_uri', '=', 'parent_schema', '.', 'uri', '.', 'dup', 'schema', '=', 'JSON', '::', 'Schema', '.', 'new', '(', 'obj', ',', 'schema_uri', ',', 'parent_schema', '.', 'validator', ')', 'if', 'obj', '[', "'id'", ']', 'self', '.', 'class', '.', 'add_schema', '(', 'schema', ')', 'end', 'build_schemas', '(', 'schema', ')', 'end', 'end']
->Original Target:
['Either', 'load', 'a', 'reference', 'schema', 'or', 'create', 'a', 'new', 'schema']
->Reconstructed Target:
Either load a reference schema or create a new schema
->Reconstructed Predication:
the schema for the giventhe schema for the given object
->Raw Input:
summarize:def handle_schema ( parent_schema, obj ) if obj. is_a? ( Hash ) schema_uri = parent_schema. uri. dup schema = JSON :: Schema. new ( obj, schema_uri, parent_schema. validator ) if obj [ 'id' ] self. class. add_schema ( schema ) end build_schemas ( schema ) end end
->Raw Target:
Either load a reference schema or create a new schema
--

165=========
->Original Input:
['def', 'matches_conditions?', '(', 'action', ',', 'subject', ',', 'extra_args', ')', 'if', '@match_all', 'call_block_with_all', '(', 'action', ',', 'subject', ',', 'extra_args', ')', 'elsif', '@block', '&&', '!', 'subject_class?', '(', 'subject', ')', '@block', '.', 'call', '(', 'subject', ',', '*', 'extra_args', ')', 'elsif', '@conditions', '.', 'kind_of?', '(', 'Hash', ')', '&&', 'subject', '.', 'class', '==', 'Hash', 'nested_subject_matches_conditions?', '(', 'subject', ')', 'elsif', '@conditions', '.', 'kind_of?', '(', 'Hash', ')', '&&', '!', 'subject_class?', '(', 'subject', ')', 'matches_conditions_hash?', '(', 'subject', ')', 'else', '@conditions', '.', 'empty?', '?', 'true', ':', '@base_behavior', 'end', 'end']
->Original Target:
['Matches', 'the', 'block', 'or', 'conditions', 'hash']
->Reconstructed Target:
Matches the block or conditions hash
->Reconstructed Predication:
the condition to the condition
->Raw Input:
summarize:def matches_conditions? ( action, subject, extra_args ) if @match_all call_block_with_all ( action, subject, extra_args ) elsif @block &&! subject_class? ( subject ) @block. call ( subject, * extra_args ) elsif @conditions. kind_of? ( Hash ) && subject. class == Hash nested_subject_matches_conditions? ( subject ) elsif @conditions. kind_of? ( Hash ) &&! subject_class? ( subject ) matches_conditions_hash? ( subject ) else @conditions. empty?? true : @base_behavior end end
->Raw Target:
Matches the block or conditions hash
--

166=========
->Original Input:
['def', 'alias_action', '(', '*', 'args', ')', 'target', '=', 'args', '.', 'pop', '[', ':to', ']', 'validate_target', '(', 'target', ')', 'aliased_actions', '[', 'target', ']', '||=', '[', ']', 'aliased_actions', '[', 'target', ']', '+=', 'args', 'end']
->Original Target:
['Alias', 'one', 'or', 'more', 'actions', 'into', 'another', 'one', '.']
->Reconstructed Target:
Alias one or more actions into another one.
->Reconstructed Predication:
the action to be used for
->Raw Input:
summarize:def alias_action ( * args ) target = args. pop [ :to ] validate_target ( target ) aliased_actions [ target ] ||= [ ] aliased_actions [ target ] += args end
->Raw Target:
Alias one or more actions into another one.
--

167=========
->Original Input:
['def', 'expand_actions', '(', 'actions', ')', 'actions', '.', 'map', 'do', '|', 'action', '|', 'aliased_actions', '[', 'action', ']', '?', '[', 'action', ',', '*', 'expand_actions', '(', 'aliased_actions', '[', 'action', ']', ')', ']', ':', 'action', 'end', '.', 'flatten', 'end']
->Original Target:
['Accepts', 'an', 'array', 'of', 'actions', 'and', 'returns', 'an', 'array', 'of', 'actions', 'which', 'match', '.', 'This', 'should', 'be', 'called', 'before', 'matches?', 'and', 'other', 'checking', 'methods', 'since', 'they', 'rely', 'on', 'the', 'actions', 'to', 'be', 'expanded', '.']
->Reconstructed Target:
Accepts an array of actions and returns an array of actions which match. This should be called before matches? and other checking methods since they rely on the actions to be expanded.
->Reconstructed Predication:
actions to be expanded.
->Raw Input:
summarize:def expand_actions ( actions ) actions. map do | action | aliased_actions [ action ]? [ action, * expand_actions ( aliased_actions [ action ] ) ] : action end. flatten end
->Raw Target:
Accepts an array of actions and returns an array of actions which match. This should be called before matches? and other checking methods since they rely on the actions to be expanded.
--

168=========
->Original Input:
['def', 'aliases_for_action', '(', 'action', ')', 'results', '=', '[', 'action', ']', 'aliased_actions', '.', 'each', 'do', '|', 'aliased_action', ',', 'actions', '|', 'results', '+=', 'aliases_for_action', '(', 'aliased_action', ')', 'if', 'actions', '.', 'include?', 'action', 'end', 'results', 'end']
->Original Target:
['Given', 'an', 'action', 'it', 'will', 'try', 'to', 'find', 'all', 'of', 'the', 'actions', 'which', 'are', 'aliased', 'to', 'it', '.', 'This', 'does', 'the', 'opposite', 'kind', 'of', 'lookup', 'as', 'expand_actions', '.']
->Reconstructed Target:
Given an action it will try to find all of the actions which are aliased to it. This does the opposite kind of lookup as expand_actions.
->Reconstructed Predication:
aliases for an action.
->Raw Input:
summarize:def aliases_for_action ( action ) results = [ action ] aliased_actions. each do | aliased_action, actions | results += aliases_for_action ( aliased_action ) if actions. include? action end results end
->Raw Target:
Given an action it will try to find all of the actions which are aliased to it. This does the opposite kind of lookup as expand_actions.
--

169=========
->Original Input:
['def', 'relevant_rules', '(', 'action', ',', 'subject', ')', 'rules', '.', 'reverse', '.', 'select', 'do', '|', 'rule', '|', 'rule', '.', 'expanded_actions', '=', 'expand_actions', '(', 'rule', '.', 'actions', ')', 'rule', '.', 'relevant?', 'action', ',', 'subject', 'end', 'end']
->Original Target:
['Returns', 'an', 'array', 'of', 'Rule', 'instances', 'which', 'match', 'the', 'action', 'and', 'subject', 'This', 'does', 'not', 'take', 'into', 'consideration', 'any', 'hash', 'conditions', 'or', 'block', 'statements']
->Reconstructed Target:
Returns an array of Rule instances which match the action and subject This does not take into consideration any hash conditions or block statements
->Reconstructed Predication:
the rules that match the given
->Raw Input:
summarize:def relevant_rules ( action, subject ) rules. reverse. select do | rule | rule. expanded_actions = expand_actions ( rule. actions ) rule. relevant? action, subject end end
->Raw Target:
Returns an array of Rule instances which match the action and subject This does not take into consideration any hash conditions or block statements
--

170=========
->Original Input:
['def', 'create_missing_file', 'raise', 'Errno', '::', 'EISDIR', ',', 'path', '.', 'to_s', 'if', 'File', '.', 'directory?', '(', '@path', ')', 'return', 'if', 'File', '.', 'exist?', '(', '@path', ')', 'dirname', '=', 'RealFile', '.', 'dirname', '@path', 'unless', 'dirname', '==', "'.'", 'dir', '=', 'FileSystem', '.', 'find', 'dirname', 'raise', 'Errno', '::', 'ENOENT', ',', 'path', '.', 'to_s', 'unless', 'dir', '.', 'is_a?', 'FakeDir', 'end', '@file', '=', 'FileSystem', '.', 'add', '(', 'path', ',', 'FakeFile', '.', 'new', ')', 'end']
->Original Target:
['Create', 'a', 'missing', 'file', 'if', 'the', 'path', 'is', 'valid', '.']
->Reconstructed Target:
Create a missing file if the path is valid.
->Reconstructed Predication:
@file = File. new@file = File. new
->Raw Input:
summarize:def create_missing_file raise Errno :: EISDIR, path. to_s if File. directory? ( @path ) return if File. exist? ( @path ) dirname = RealFile. dirname @path unless dirname == '.' dir = FileSystem. find dirname raise Errno :: ENOENT, path. to_s unless dir. is_a? FakeDir end @file = FileSystem. add ( path, FakeFile. new ) end
->Raw Target:
Create a missing file if the path is valid.
--

171=========
->Original Input:
['def', 'each_filename', 'return', 'to_enum', '(', '__method__', ')', 'unless', 'block_given?', '_prefix', ',', 'names', '=', 'split_names', '(', '@path', ')', 'names', '.', 'each', '{', '|', 'filename', '|', 'yield', 'filename', '}', 'nil', 'end']
->Original Target:
['Iterates', 'over', 'each', 'component', 'of', 'the', 'path', '.']
->Reconstructed Target:
Iterates over each component of the path.
->Reconstructed Predication:
the file to be summarizeed.
->Raw Input:
summarize:def each_filename return to_enum ( __method__ ) unless block_given? _prefix, names = split_names ( @path ) names. each { | filename | yield filename } nil end
->Raw Target:
Iterates over each component of the path.
--

172=========
->Original Input:
['def', 'descend', 'vs', '=', '[', ']', 'ascend', '{', '|', 'v', '|', 'vs', '<<', 'v', '}', 'vs', '.', 'reverse_each', '{', '|', 'v', '|', 'yield', 'v', '}', 'nil', 'end']
->Original Target:
['Iterates', 'over', 'and', 'yields', 'a', 'new', 'Pathname', 'object', 'for', 'each', 'element', 'in', 'the', 'given', 'path', 'in', 'descending', 'order', '.']
->Reconstructed Target:
Iterates over and yields a new Pathname object for each element in the given path in descending order.
->Reconstructed Predication:
the descending of the nested
->Raw Input:
summarize:def descend vs = [ ] ascend { | v | vs << v } vs. reverse_each { | v | yield v } nil end
->Raw Target:
Iterates over and yields a new Pathname object for each element in the given path in descending order.
--

173=========
->Original Input:
['def', 'ascend', 'path', '=', '@path', 'yield', 'self', 'while', '(', 'r', '=', 'chop_basename', '(', 'path', ')', ')', 'path', ',', '_name', '=', 'r', 'break', 'if', 'path', '.', 'empty?', 'yield', 'self', '.', 'class', '.', 'new', '(', 'del_trailing_separator', '(', 'path', ')', ')', 'end', 'end']
->Original Target:
['Iterates', 'over', 'and', 'yields', 'a', 'new', 'Pathname', 'object', 'for', 'each', 'element', 'in', 'the', 'given', 'path', 'in', 'ascending', 'order', '.']
->Reconstructed Target:
Iterates over and yields a new Pathname object for each element in the given path in ascending order.
->Reconstructed Predication:
the file name and the file
->Raw Input:
summarize:def ascend path = @path yield self while ( r = chop_basename ( path ) ) path, _name = r break if path. empty? yield self. class. new ( del_trailing_separator ( path ) ) end end
->Raw Target:
Iterates over and yields a new Pathname object for each element in the given path in ascending order.
--

174=========
->Original Input:
['def', 'c_checksum', 'sum', '=', '0', 'checksum_values', '.', 'each_with_index', 'do', '|', 'value', ',', 'index', '|', 'sum', '+=', '(', '(', 'index', '%', '20', ')', '+', '1', ')', '*', 'value', 'end', 'sum', '%', '47', 'end']
->Original Target:
['Calculates', 'the', 'C', 'checksum', 'based', 'on', 'checksum_values']
->Reconstructed Target:
Calculates the C checksum based on checksum_values
->Reconstructed Predication:
the checksum of the checksum_value
->Raw Input:
summarize:def c_checksum sum = 0 checksum_values. each_with_index do | value, index | sum += ( ( index % 20 ) + 1 ) * value end sum % 47 end
->Raw Target:
Calculates the C checksum based on checksum_values
--

175=========
->Original Input:
['def', 'k_checksum', 'sum', '=', '0', 'checksum_values_with_c_checksum', '.', 'each_with_index', 'do', '|', 'value', ',', 'index', '|', 'sum', '+=', '(', '(', 'index', '%', '15', ')', '+', '1', ')', '*', 'value', 'end', 'sum', '%', '47', 'end']
->Original Target:
['Calculates', 'the', 'K', 'checksum', 'based', 'on', 'checksum_values_with_c_checksum']
->Reconstructed Target:
Calculates the K checksum based on checksum_values_with_c_checksum
->Reconstructed Predication:
the checksum of the checksum
->Raw Input:
summarize:def k_checksum sum = 0 checksum_values_with_c_checksum. each_with_index do | value, index | sum += ( ( index % 15 ) + 1 ) * value end sum % 47 end
->Raw Target:
Calculates the K checksum based on checksum_values_with_c_checksum
--

176=========
->Original Input:
['def', 'annotate_pdf', '(', 'pdf', ',', 'options', '=', '{', '}', ')', 'with_options', 'options', 'do', 'xpos', ',', 'ypos', '=', 'x', ',', 'y', 'orig_xpos', '=', 'xpos', 'if', 'barcode', '.', 'two_dimensional?', 'boolean_groups', '.', 'reverse_each', 'do', '|', 'groups', '|', 'groups', '.', 'each', 'do', '|', 'bar', ',', 'amount', '|', 'if', 'bar', 'pdf', '.', 'move_to', '(', 'xpos', ',', 'ypos', ')', '.', 'line_to', '(', 'xpos', ',', 'ypos', '+', 'xdim', ')', '.', 'line_to', '(', 'xpos', '+', '(', 'xdim', '*', 'amount', ')', ',', 'ypos', '+', 'xdim', ')', '.', 'line_to', '(', 'xpos', '+', '(', 'xdim', '*', 'amount', ')', ',', 'ypos', ')', '.', 'line_to', '(', 'xpos', ',', 'ypos', ')', '.', 'fill', 'end', 'xpos', '+=', '(', 'xdim', '*', 'amount', ')', 'end', 'xpos', '=', 'orig_xpos', 'ypos', '+=', 'xdim', 'end', 'else', 'boolean_groups', '.', 'each', 'do', '|', 'bar', ',', 'amount', '|', 'if', 'bar', 'pdf', '.', 'move_to', '(', 'xpos', ',', 'ypos', ')', '.', 'line_to', '(', 'xpos', ',', 'ypos', '+', 'height', ')', '.', 'line_to', '(', 'xpos', '+', '(', 'xdim', '*', 'amount', ')', ',', 'ypos', '+', 'height', ')', '.', 'line_to', '(', 'xpos', '+', '(', 'xdim', '*', 'amount', ')', ',', 'ypos', ')', '.', 'line_to', '(', 'xpos', ',', 'ypos', ')', '.', 'fill', 'end', 'xpos', '+=', '(', 'xdim', '*', 'amount', ')', 'end', 'end', 'end', 'pdf', 'end']
->Original Target:
['Annotate', 'a', 'PDFWriter', 'document', 'with', 'the', 'barcode']
->Reconstructed Target:
Annotate a PDFWriter document with the barcode
->Reconstructed Predication:
pdf.y, x, yy, y )y, y )y, y )y, y ) end
->Raw Input:
summarize:def annotate_pdf ( pdf, options = { } ) with_options options do xpos, ypos = x, y orig_xpos = xpos if barcode. two_dimensional? boolean_groups. reverse_each do | groups | groups. each do | bar, amount | if bar pdf. move_to ( xpos, ypos ). line_to ( xpos, ypos + xdim ). line_to ( xpos + ( xdim * amount ), ypos + xdim ). line_to ( xpos + ( xdim * amount ), ypos ). line_to ( xpos, ypos ). fill end xpos += ( xdim * amount ) end xpos = orig_xpos ypos += xdim end else boolean_groups. each do | bar, amount | if bar pdf. move_to ( xpos, ypos ). line_to ( xpos, ypos + height ). line_to ( xpos + ( xdim * amount ), ypos + height ). line_to ( xpos + ( xdim * amount ), ypos ). line_to ( xpos, ypos ). fill end xpos += ( xdim * amount ) end end end pdf end
->Raw Target:
Annotate a PDFWriter document with the barcode
--

177=========
->Original Input:
['def', 'characters', 'chars', '=', 'raw_characters', 'extended', '?', 'chars', '.', 'map', '{', '|', 'c', '|', 'EXTENDED_ENCODINGS', '[', 'c', ']', '.', 'split', '(', '/', '/', ')', '}', '.', 'flatten', ':', 'chars', 'end']
->Original Target:
['Returns', 'the', 'encodable', 'characters', '.', 'If', 'extended', 'mode', 'is', 'enabled', 'each', 'character', 'will', 'first', 'be', 'replaced', 'by', 'two', 'characters', 'from', 'the', 'encodable', 'charset']
->Reconstructed Target:
Returns the encodable characters. If extended mode is enabled each character will first be replaced by two characters from the encodable charset
->Reconstructed Predication:
characters to be encoded
->Raw Input:
summarize:def characters chars = raw_characters extended? chars. map { | c | EXTENDED_ENCODINGS [ c ]. split ( / / ) }. flatten : chars end
->Raw Target:
Returns the encodable characters. If extended mode is enabled each character will first be replaced by two characters from the encodable charset
--

178=========
->Original Input:
['def', 'characters', 'chars', '=', 'data', '.', 'split', '(', '/', '/n', ')', 'if', 'type', '==', "'C'", 'result', '=', '[', ']', 'count', '=', '0', 'while', 'count', '<', 'chars', '.', 'size', 'if', 'chars', '[', 'count', ']', '=~', '/', '\\d', '/', 'result', '<<', '"#{chars[count]}#{chars[count+1]}"', 'count', '+=', '2', 'else', 'result', '<<', 'chars', '[', 'count', ']', 'count', '+=', '1', 'end', 'end', 'result', 'else', 'chars', 'end', 'end']
->Original Target:
['Get', 'an', 'array', 'of', 'the', 'individual', 'characters', 'for', 'this', 'barcode', '.', 'Special', 'characters', 'like', 'FNC1', 'will', 'be', 'present', '.', 'Characters', 'from', 'extras', 'are', 'not', 'present', '.']
->Reconstructed Target:
Get an array of the individual characters for this barcode. Special characters like FNC1 will be present. Characters from extras are not present.
->Reconstructed Predication:
the characters to be summarizeed
->Raw Input:
summarize:def characters chars = data. split ( / /n ) if type == 'C' result = [ ] count = 0 while count < chars. size if chars [ count ] =~ / \d / result << "#{chars[count]}#{chars[count+1]}" count += 2 else result << chars [ count ] count += 1 end end result else chars end end
->Raw Target:
Get an array of the individual characters for this barcode. Special characters like FNC1 will be present. Characters from extras are not present.
--

179=========
->Original Input:
['def', 'checksum', 'pos', '=', '0', '(', 'numbers', '+', 'extra_numbers', ')', '.', 'inject', '(', 'start_num', ')', 'do', '|', 'sum', ',', 'number', '|', 'pos', '+=', '1', 'sum', '+', '(', 'number', '*', 'pos', ')', 'end', '%', '103', 'end']
->Original Target:
['Calculate', 'the', 'checksum', 'for', 'the', 'data', 'in', 'this', 'barcode', '.', 'The', 'data', 'includes', 'data', 'from', 'extras', '.']
->Reconstructed Target:
Calculate the checksum for the data in this barcode. The data includes data from extras.
->Reconstructed Predication:
summarize number of number of number
->Raw Input:
summarize:def checksum pos = 0 ( numbers + extra_numbers ). inject ( start_num ) do | sum, number | pos += 1 sum + ( number * pos ) end % 103 end
->Raw Target:
Calculate the checksum for the data in this barcode. The data includes data from extras.
--

180=========
->Original Input:
['def', 'encoding_for_bars', '(', '*', 'bars', ')', 'wide', ',', 'narrow', ',', 'space', '=', 'wide_encoding', ',', 'narrow_encoding', ',', 'space_encoding', 'bars', '.', 'flatten', '.', 'inject', "''", 'do', '|', 'enc', ',', 'bar', '|', 'enc', '+', '(', 'bar', '==', 'WIDE', '?', 'wide', ':', 'narrow', ')', '+', 'space', 'end', 'end']
->Original Target:
['Generate', 'encoding', 'for', 'an', 'array', 'of', 'W', 'N']
->Reconstructed Target:
Generate encoding for an array of W N
->Reconstructed Predication:
the bar
->Raw Input:
summarize:def encoding_for_bars ( * bars ) wide, narrow, space = wide_encoding, narrow_encoding, space_encoding bars. flatten. inject '' do | enc, bar | enc + ( bar == WIDE? wide : narrow ) + space end end
->Raw Target:
Generate encoding for an array of W N
--

181=========
->Original Input:
['def', 'render_to_cairo_context', '(', 'context', ',', 'options', '=', '{', '}', ')', 'if', 'context', '.', 'respond_to?', '(', ':have_current_point?', ')', 'and', 'context', '.', 'have_current_point?', 'current_x', ',', 'current_y', '=', 'context', '.', 'current_point', 'else', 'current_x', '=', 'x', '(', 'options', ')', '||', 'margin', '(', 'options', ')', 'current_y', '=', 'y', '(', 'options', ')', '||', 'margin', '(', 'options', ')', 'end', '_xdim', '=', 'xdim', '(', 'options', ')', '_height', '=', 'height', '(', 'options', ')', 'original_current_x', '=', 'current_x', 'context', '.', 'save', 'do', 'context', '.', 'set_source_color', '(', ':black', ')', 'context', '.', 'fill', 'do', 'if', 'barcode', '.', 'two_dimensional?', 'boolean_groups', '.', 'each', 'do', '|', 'groups', '|', 'groups', '.', 'each', 'do', '|', 'bar', ',', 'amount', '|', 'current_width', '=', '_xdim', '*', 'amount', 'if', 'bar', 'context', '.', 'rectangle', '(', 'current_x', ',', 'current_y', ',', 'current_width', ',', '_xdim', ')', 'end', 'current_x', '+=', 'current_width', 'end', 'current_x', '=', 'original_current_x', 'current_y', '+=', '_xdim', 'end', 'else', 'boolean_groups', '.', 'each', 'do', '|', 'bar', ',', 'amount', '|', 'current_width', '=', '_xdim', '*', 'amount', 'if', 'bar', 'context', '.', 'rectangle', '(', 'current_x', ',', 'current_y', ',', 'current_width', ',', '_height', ')', 'end', 'current_x', '+=', 'current_width', 'end', 'end', 'end', 'end', 'context', 'end']
->Original Target:
['Render', 'the', 'barcode', 'onto', 'a', 'Cairo', 'context']
->Reconstructed Target:
Render the barcode onto a Cairo context
->Reconstructed Predication:
the currentcurrent_x, current_y =current_x, current_ycurrent_y, current_x, current_ycurrent_y, current_x, current_ycurrent_y, current_x, current_ycurrent_y, current_x, current_ycurrent_y, current_y, current_xcurrent_y, current_y, current_ycurrent_x, current
->Raw Input:
summarize:def render_to_cairo_context ( context, options = { } ) if context. respond_to? ( :have_current_point? ) and context. have_current_point? current_x, current_y = context. current_point else current_x = x ( options ) || margin ( options ) current_y = y ( options ) || margin ( options ) end _xdim = xdim ( options ) _height = height ( options ) original_current_x = current_x context. save do context. set_source_color ( :black ) context. fill do if barcode. two_dimensional? boolean_groups. each do | groups | groups. each do | bar, amount | current_width = _xdim * amount if bar context. rectangle ( current_x, current_y, current_width, _xdim ) end current_x += current_width end current_x = original_current_x current_y += _xdim end else boolean_groups. each do | bar, amount | current_width = _xdim * amount if bar context. rectangle ( current_x, current_y, current_width, _height ) end current_x += current_width end end end end context end
->Raw Target:
Render the barcode onto a Cairo context
--

182=========
->Original Input:
['def', 'to_png', '(', 'options', '=', '{', '}', ')', 'output_to_string_io', 'do', '|', 'io', '|', 'Cairo', '::', 'ImageSurface', '.', 'new', '(', 'options', '[', ':format', ']', ',', 'full_width', '(', 'options', ')', ',', 'full_height', '(', 'options', ')', ')', 'do', '|', 'surface', '|', 'render', '(', 'surface', ',', 'options', ')', 'surface', '.', 'write_to_png', '(', 'io', ')', 'end', 'end', 'end']
->Original Target:
['Render', 'the', 'barcode', 'to', 'a', 'PNG', 'image']
->Reconstructed Target:
Render the barcode to a PNG image
->Reconstructed Predication:
the image to be rendered
->Raw Input:
summarize:def to_png ( options = { } ) output_to_string_io do | io | Cairo :: ImageSurface. new ( options [ :format ], full_width ( options ), full_height ( options ) ) do | surface | render ( surface, options ) surface. write_to_png ( io ) end end end
->Raw Target:
Render the barcode to a PNG image
--

183=========
->Original Input:
['def', 'to_ps', '(', 'options', '=', '{', '}', ')', 'output_to_string_io', 'do', '|', 'io', '|', 'Cairo', '::', 'PSSurface', '.', 'new', '(', 'io', ',', 'full_width', '(', 'options', ')', ',', 'full_height', '(', 'options', ')', ')', 'do', '|', 'surface', '|', 'surface', '.', 'eps', '=', 'options', '[', ':eps', ']', 'if', 'surface', '.', 'respond_to?', '(', ':eps=', ')', 'render', '(', 'surface', ',', 'options', ')', 'end', 'end', 'end']
->Original Target:
['Render', 'the', 'barcode', 'to', 'a', 'PS', 'document']
->Reconstructed Target:
Render the barcode to a PS document
->Reconstructed Predication:
the output of the surface
->Raw Input:
summarize:def to_ps ( options = { } ) output_to_string_io do | io | Cairo :: PSSurface. new ( io, full_width ( options ), full_height ( options ) ) do | surface | surface. eps = options [ :eps ] if surface. respond_to? ( :eps= ) render ( surface, options ) end end end
->Raw Target:
Render the barcode to a PS document
--

184=========
->Original Input:
['def', 'to_pdf', '(', 'options', '=', '{', '}', ')', 'output_to_string_io', 'do', '|', 'io', '|', 'Cairo', '::', 'PDFSurface', '.', 'new', '(', 'io', ',', 'full_width', '(', 'options', ')', ',', 'full_height', '(', 'options', ')', ')', 'do', '|', 'surface', '|', 'render', '(', 'surface', ',', 'options', ')', 'end', 'end', 'end']
->Original Target:
['Render', 'the', 'barcode', 'to', 'a', 'PDF', 'document']
->Reconstructed Target:
Render the barcode to a PDF document
->Reconstructed Predication:
the PDF surface to the specified
->Raw Input:
summarize:def to_pdf ( options = { } ) output_to_string_io do | io | Cairo :: PDFSurface. new ( io, full_width ( options ), full_height ( options ) ) do | surface | render ( surface, options ) end end end
->Raw Target:
Render the barcode to a PDF document
--

185=========
->Original Input:
['def', 'to_svg', '(', 'options', '=', '{', '}', ')', 'output_to_string_io', 'do', '|', 'io', '|', 'Cairo', '::', 'SVGSurface', '.', 'new', '(', 'io', ',', 'full_width', '(', 'options', ')', ',', 'full_height', '(', 'options', ')', ')', 'do', '|', 'surface', '|', 'render', '(', 'surface', ',', 'options', ')', 'end', 'end', 'end']
->Original Target:
['Render', 'the', 'barcode', 'to', 'an', 'SVG', 'document']
->Reconstructed Target:
Render the barcode to an SVG document
->Reconstructed Predication:
the SVG surface to the specified
->Raw Input:
summarize:def to_svg ( options = { } ) output_to_string_io do | io | Cairo :: SVGSurface. new ( io, full_width ( options ), full_height ( options ) ) do | surface | render ( surface, options ) end end end
->Raw Target:
Render the barcode to an SVG document
--

186=========
->Original Input:
['def', 'max_threads', '=', '(', 'number', ')', '@max_threads', '=', 'number', '.', 'to_i', '.', 'positive?', '&&', 'throttle', '.', 'zero?', '?', 'number', '.', 'to_i', ':', '1', 'hydra', '.', 'max_concurrency', '=', '@max_threads', 'end']
->Original Target:
['Set', 'the', 'threads', 'attribute', 'and', 'update', 'hydra', 'accordinly', 'If', 'the', 'throttle', 'attribute', 'is', '>', '0', 'max_threads', 'will', 'be', 'forced', 'to', '1']
->Reconstructed Target:
Set the threads attribute and update hydra accordinly If the throttle attribute is > 0 max_threads will be forced to 1
->Reconstructed Predication:
 def set_max_threads ( throttle
->Raw Input:
summarize:def max_threads = ( number ) @max_threads = number. to_i. positive? && throttle. zero?? number. to_i : 1 hydra. max_concurrency = @max_threads end
->Raw Target:
Set the threads attribute and update hydra accordinly If the throttle attribute is > 0 max_threads will be forced to 1
--

187=========
->Original Input:
['def', 'online?', '(', 'path', '=', 'nil', ')', 'NS', '::', 'Browser', '.', 'get', '(', 'url', '(', 'path', ')', ')', '.', 'code', '.', 'nonzero?', '?', 'true', ':', 'false', 'end']
->Original Target:
['Checks', 'if', 'the', 'remote', 'website', 'is', 'up', '.']
->Reconstructed Target:
Checks if the remote website is up.
->Reconstructed Predication:
return true if the browser is
->Raw Input:
summarize:def online? ( path = nil ) NS :: Browser. get ( url ( path ) ). code. nonzero?? true : false end
->Raw Target:
Checks if the remote website is up.
--

188=========
->Original Input:
['def', 'head_and_get', '(', 'path', ',', 'codes', '=', '[', '200', ']', ',', 'params', '=', '{', '}', ')', 'url_to_get', '=', 'url', '(', 'path', ')', 'head_params', '=', '(', 'params', '[', ':head', ']', '||', '{', '}', ')', '.', 'merge', '(', 'head_or_get_params', ')', 'head_res', '=', 'NS', '::', 'Browser', '.', 'forge_request', '(', 'url_to_get', ',', 'head_params', ')', '.', 'run', 'codes', '.', 'include?', '(', 'head_res', '.', 'code', ')', '?', 'NS', '::', 'Browser', '.', 'get', '(', 'url_to_get', ',', 'params', '[', ':get', ']', '||', '{', '}', ')', ':', 'head_res', 'end']
->Original Target:
['Perform', 'a', 'HEAD', 'request', 'to', 'the', 'path', 'provided', 'then', 'if', 'its', 'response', 'code', 'is', 'in', 'the', 'array', 'of', 'codes', 'given', 'a', 'GET', 'is', 'done', 'and', 'the', 'response', 'returned', '.', 'Otherwise', 'the', 'HEAD', 'response', 'is', 'returned', '.']
->Reconstructed Target:
Perform a HEAD request to the path provided then if its response code is in the array of codes given a GET is done and the response returned. Otherwise the HEAD response is returned.
->Reconstructed Predication:
the head and get thethe head and get the
->Raw Input:
summarize:def head_and_get ( path, codes = [ 200 ], params = { } ) url_to_get = url ( path ) head_params = ( params [ :head ] || { } ). merge ( head_or_get_params ) head_res = NS :: Browser. forge_request ( url_to_get, head_params ). run codes. include? ( head_res. code )? NS :: Browser. get ( url_to_get, params [ :get ] || { } ) : head_res end
->Raw Target:
Perform a HEAD request to the path provided then if its response code is in the array of codes given a GET is done and the response returned. Otherwise the HEAD response is returned.
--

189=========
->Original Input:
['def', 'db', 'return', '@db', 'unless', '@db', '.', 'nil?', 'Sequel', '.', 'single_threaded', '=', 'true', '@db', '=', 'Sequel', '.', 'connect', '(', 'config', '(', ':sql_url', ')', ',', ':encoding', '=>', "'utf8'", ')', 'if', '@db', '.', 'tables', '.', 'empty?', 'dir', '=', 'File', '.', 'join', '(', 'File', '.', 'dirname', '(', '__FILE__', ')', ',', "'migrations'", ')', 'puts', '"Database empty, running migrations from #{dir}"', 'Sequel', '.', 'extension', ':migration', 'Sequel', '::', 'Migrator', '.', 'apply', '(', '@db', ',', 'dir', ')', 'end', '@db', 'end']
->Original Target:
['Get', 'a', 'connection', 'to', 'the', 'database']
->Reconstructed Target:
Get a connection to the database
->Reconstructed Predication:
@db = nil end  def@db.
->Raw Input:
summarize:def db return @db unless @db. nil? Sequel. single_threaded = true @db = Sequel. connect ( config ( :sql_url ), :encoding => 'utf8' ) if @db. tables. empty? dir = File. join ( File. dirname ( __FILE__ ),'migrations' ) puts "Database empty, running migrations from #{dir}" Sequel. extension :migration Sequel :: Migrator. apply ( @db, dir ) end @db end
->Raw Target:
Get a connection to the database
--

190=========
->Original Input:
['def', 'ensure_commit', '(', 'repo', ',', 'sha', ',', 'user', ',', 'comments', '=', 'true', ')', 'ensure_repo', '(', 'user', ',', 'repo', ')', 'c', '=', 'retrieve_commit', '(', 'repo', ',', 'sha', ',', 'user', ')', 'if', 'c', '.', 'nil?', 'warn', '"Commit #{user}/#{repo} -> #{sha} does not exist"', 'return', 'end', 'stored', '=', 'store_commit', '(', 'c', ',', 'repo', ',', 'user', ')', 'ensure_parents', '(', 'c', ')', 'if', 'not', 'c', '[', "'commit'", ']', '[', "'comment_count'", ']', '.', 'nil?', 'and', 'c', '[', "'commit'", ']', '[', "'comment_count'", ']', '>', '0', 'ensure_commit_comments', '(', 'user', ',', 'repo', ',', 'sha', ')', 'if', 'comments', 'end', 'ensure_repo_commit', '(', 'user', ',', 'repo', ',', 'sha', ')', 'stored', 'end']
->Original Target:
['Make', 'sure', 'a', 'commit', 'exists']
->Reconstructed Target:
Make sure a commit exists
->Reconstructed Predication:
the committhe commit to the repository
->Raw Input:
summarize:def ensure_commit ( repo, sha, user, comments = true ) ensure_repo ( user, repo ) c = retrieve_commit ( repo, sha, user ) if c. nil? warn "Commit #{user}/#{repo} -> #{sha} does not exist" return end stored = store_commit ( c, repo, user ) ensure_parents ( c ) if not c [ 'commit' ] [ 'comment_count' ]. nil? and c [ 'commit' ] [ 'comment_count' ] > 0 ensure_commit_comments ( user, repo, sha ) if comments end ensure_repo_commit ( user, repo, sha ) stored end
->Raw Target:
Make sure a commit exists
--

191=========
->Original Input:
['def', 'ensure_parents', '(', 'commit', ')', 'commits', '=', 'db', '[', ':commits', ']', 'parents', '=', 'db', '[', ':commit_parents', ']', 'commit', '[', "'parents'", ']', '.', 'map', 'do', '|', 'p', '|', 'save', 'do', 'url', '=', 'p', '[', "'url'", ']', '.', 'split', '(', '/', '\\/', '/', ')', 'this', '=', 'commits', '.', 'first', '(', ':sha', '=>', 'commit', '[', "'sha'", ']', ')', 'parent', '=', 'commits', '.', 'first', '(', ':sha', '=>', 'url', '[', '7', ']', ')', 'if', 'parent', '.', 'nil?', 'c', '=', 'retrieve_commit', '(', 'url', '[', '5', ']', ',', 'url', '[', '7', ']', ',', 'url', '[', '4', ']', ')', 'if', 'c', '.', 'nil?', 'warn', '"Could not retrieve commit_parent #{url[4]}/#{url[5]} -> #{url[7]} to #{this[:sha]}"', 'next', 'end', 'parent', '=', 'store_commit', '(', 'c', ',', 'url', '[', '5', ']', ',', 'url', '[', '4', ']', ')', 'end', 'if', 'parent', '.', 'nil?', 'warn', '"Could not find #{url[4]}/#{url[5]} -> #{url[7]}, parent to commit #{this[:sha]}"', 'next', 'end', 'if', 'parents', '.', 'first', '(', ':commit_id', '=>', 'this', '[', ':id', ']', ',', ':parent_id', '=>', 'parent', '[', ':id', ']', ')', '.', 'nil?', 'parents', '.', 'insert', '(', ':commit_id', '=>', 'this', '[', ':id', ']', ',', ':parent_id', '=>', 'parent', '[', ':id', ']', ')', 'info', '"Added commit_parent #{parent[:sha]} to commit #{this[:sha]}"', 'else', 'debug', '"Parent #{parent[:sha]} for commit #{this[:sha]} exists"', 'end', 'parents', '.', 'first', '(', ':commit_id', '=>', 'this', '[', ':id', ']', ',', ':parent_id', '=>', 'parent', '[', ':id', ']', ')', 'end', 'end', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Get', 'the', 'parents', 'for', 'a', 'specific', 'commit', '.', 'The', 'commit', 'must', 'be', 'first', 'stored', 'in', 'the', 'database', '.']
->Reconstructed Target:
Get the parents for a specific commit. The commit must be first stored in the database.
->Reconstructed Predication:
commit_parentscommit_parent #{parent[:id]} for commit #{this[:sha]}"commit_parent #{parent[:id]} for commit #{this[:sha]}"commit_parent #{parent[:id]} for commit #{this[:sha]}"commit_parent #{parent[:id]} for commit #{this[:sha]}"commit_parent #{parent[:id]} for commit #{this[:sha]}"commit_parent #{parent[:id]} for commit #{this[:
->Raw Input:
summarize:def ensure_parents ( commit ) commits = db [ :commits ] parents = db [ :commit_parents ] commit [ 'parents' ]. map do | p | save do url = p [ 'url' ]. split ( / \/ / ) this = commits. first ( :sha => commit ['sha' ] ) parent = commits. first ( :sha => url [ 7 ] ) if parent. nil? c = retrieve_commit ( url [ 5 ], url [ 7 ], url [ 4 ] ) if c. nil? warn "Could not retrieve commit_parent #{url[4]}/#{url[5]} -> #{url[7]} to #{this[:sha]}" next end parent = store_commit ( c, url [ 5 ], url [ 4 ] ) end if parent. nil? warn "Could not find #{url[4]}/#{url[5]} -> #{url[7]}, parent to commit #{this[:sha]}" next end if parents. first ( :commit_id => this [ :id ], :parent_id => parent [ :id ] ). nil? parents. insert ( :commit_id => this [ :id ], :parent_id => parent [ :id ] ) info "Added commit_parent #{parent[:sha]} to commit #{this[:sha]}" else debug "Parent #{parent[:sha]} for commit #{this[:sha]} exists" end parents. first ( :commit_id => this [ :id ], :parent_id => parent [ :id ] ) end end. select { | x |! x. nil? } end
->Raw Target:
Get the parents for a specific commit. The commit must be first stored in the database.
--

192=========
->Original Input:
['def', 'ensure_user_followers', '(', 'followed', ')', 'curuser', '=', 'ensure_user', '(', 'followed', ',', 'false', ',', 'false', ')', 'followers', '=', 'db', '.', 'from', '(', ':followers', ',', ':users', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'followers'", ',', "'follower_id'", ')', '=>', 'Sequel', '.', 'qualify', '(', "'users'", ',', "'id'", ')', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'followers'", ',', "'user_id'", ')', '=>', 'curuser', '[', ':id', ']', ')', '.', 'select', '(', ':login', ')', '.', 'all', 'retrieve_user_followers', '(', 'followed', ')', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'followers', '.', 'find', '{', '|', 'y', '|', 'y', '[', ':login', ']', '==', 'x', '[', "'login'", ']', '}', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_user_follower', '(', 'followed', ',', 'x', '[', "'login'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Get', 'all', 'followers', 'for', 'a', 'user', '.', 'Since', 'we', 'do', 'not', 'know', 'when', 'the', 'actual', 'follow', 'event', 'took', 'place', 'we', 'set', 'the', 'created_at', 'field', 'to', 'the', 'timestamp', 'of', 'the', 'method', 'call', '.']
->Reconstructed Target:
Get all followers for a user. Since we do not know when the actual follow event took place we set the created_at field to the timestamp of the method call.
->Reconstructed Predication:
the userthe user the user isfollowed ). select (). select (). select (). select (). select (). select (). select (). select (
->Raw Input:
summarize:def ensure_user_followers ( followed ) curuser = ensure_user ( followed, false, false ) followers = db. from ( :followers, :users ). where ( Sequel. qualify ( 'followers', 'follower_id' ) => Sequel. qualify ( 'users', 'id' ) ). where ( Sequel. qualify ( 'followers', 'user_id' ) => curuser [ :id ] ). select ( :login ). all retrieve_user_followers ( followed ). reduce ( [ ] ) do | acc, x | if followers. find { | y | y [ :login ] == x [ 'login' ] }. nil? acc << x else acc end end. map { | x | save { ensure_user_follower ( followed, x [ 'login' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Get all followers for a user. Since we do not know when the actual follow event took place we set the created_at field to the timestamp of the method call.
--

193=========
->Original Input:
['def', 'ensure_user_follower', '(', 'followed', ',', 'follower', ',', 'date_added', '=', 'nil', ')', 'follower_user', '=', 'ensure_user', '(', 'follower', ',', 'false', ',', 'false', ')', 'followed_user', '=', 'ensure_user', '(', 'followed', ',', 'false', ',', 'false', ')', 'if', 'followed_user', '.', 'nil?', 'or', 'follower_user', '.', 'nil?', 'warn', '"Could not find follower #{follower} or user #{followed}"', 'return', 'end', 'followers', '=', 'db', '[', ':followers', ']', 'follower_id', '=', 'follower_user', '[', ':id', ']', 'followed_id', '=', 'followed_user', '[', ':id', ']', 'follower_exists', '=', 'followers', '.', 'first', '(', ':user_id', '=>', 'followed_id', ',', ':follower_id', '=>', 'follower_id', ')', 'if', 'follower_exists', '.', 'nil?', 'added', '=', 'if', 'date_added', '.', 'nil?', 'max', '(', 'follower_user', '[', ':created_at', ']', ',', 'followed_user', '[', ':created_at', ']', ')', 'else', 'date_added', 'end', 'retrieved', '=', 'retrieve_user_follower', '(', 'followed', ',', 'follower', ')', 'if', 'retrieved', '.', 'nil?', 'warn', '"Could not retrieve follower #{follower} for #{followed}"', 'return', 'end', 'followers', '.', 'insert', '(', ':user_id', '=>', 'followed_id', ',', ':follower_id', '=>', 'follower_id', ',', ':created_at', '=>', 'added', ')', 'info', '"Added follower #{follower} to #{followed}"', 'else', 'debug', '"Follower #{follower} for user #{followed} exists"', 'end', 'unless', 'date_added', '.', 'nil?', 'followers', '.', 'filter', '(', ':user_id', '=>', 'followed_id', ',', ':follower_id', '=>', 'follower_id', ')', '.', 'update', '(', ':created_at', '=>', 'date', '(', 'date_added', ')', ')', 'info', '"Updated follower #{followed} -> #{follower}, created_at -> #{date(date_added)}"', 'end', 'followers', '.', 'first', '(', ':user_id', '=>', 'followed_id', ',', ':follower_id', '=>', 'follower_id', ')', 'end']
->Original Target:
['Make', 'sure', 'that', 'a', 'user', 'follows', 'another', 'one']
->Reconstructed Target:
Make sure that a user follows another one
->Reconstructed Predication:
follower #{follower}follower #{follower}follower #{follower}follower #{follower}follower #{follower} for user #{followed}"
->Raw Input:
summarize:def ensure_user_follower ( followed, follower, date_added = nil ) follower_user = ensure_user ( follower, false, false ) followed_user = ensure_user ( followed, false, false ) if followed_user. nil? or follower_user. nil? warn "Could not find follower #{follower} or user #{followed}" return end followers = db [ :followers ] follower_id = follower_user [ :id ] followed_id = followed_user [ :id ] follower_exists = followers. first ( :user_id => followed_id, :follower_id => follower_id ) if follower_exists. nil? added = if date_added. nil? max ( follower_user [ :created_at ], followed_user [ :created_at ] ) else date_added end retrieved = retrieve_user_follower ( followed, follower ) if retrieved. nil? warn "Could not retrieve follower #{follower} for #{followed}" return end followers. insert ( :user_id => followed_id, :follower_id => follower_id, :created_at => added ) info "Added follower #{follower} to #{followed}" else debug "Follower #{follower} for user #{followed} exists" end unless date_added. nil? followers. filter ( :user_id => followed_id, :follower_id => follower_id ). update ( :created_at => date ( date_added ) ) info "Updated follower #{followed} -> #{follower}, created_at -> #{date(date_added)}" end followers. first ( :user_id => followed_id, :follower_id => follower_id ) end
->Raw Target:
Make sure that a user follows another one
--

194=========
->Original Input:
['def', 'ensure_user_byemail', '(', 'email', ',', 'name', ')', 'users', '=', 'db', '[', ':users', ']', 'usr', '=', 'users', '.', 'first', '(', ':email', '=>', 'email', ')', 'if', 'usr', '.', 'nil?', 'u', '=', 'retrieve_user_byemail', '(', 'email', ',', 'name', ')', 'if', 'u', '.', 'nil?', 'or', 'u', '[', "'login'", ']', '.', 'nil?', 'warn', '"Could not retrieve user #{email} through search API query"', 'login', '=', '(', '0', '...', '8', ')', '.', 'map', '{', '65', '.', '+', '(', 'rand', '(', '25', ')', ')', '.', 'chr', '}', '.', 'join', 'users', '.', 'insert', '(', ':email', '=>', 'email', ',', ':name', '=>', 'name', ',', ':login', '=>', 'login', ',', ':fake', '=>', 'true', ',', ':deleted', '=>', 'false', ',', ':created_at', '=>', 'Time', '.', 'now', ')', 'info', '"Added user fake #{login} -> #{email}"', 'users', '.', 'first', '(', ':login', '=>', 'login', ')', 'else', 'in_db', '=', 'users', '.', 'first', '(', ':login', '=>', 'u', '[', "'login'", ']', ')', 'geo', '=', 'geolocate', '(', 'location', ':', 'u', '[', "'location'", ']', ')', 'if', 'in_db', '.', 'nil?', 'users', '.', 'insert', '(', ':login', '=>', 'u', '[', "'login'", ']', ',', ':name', '=>', 'u', '[', "'name'", ']', ',', ':company', '=>', 'u', '[', "'company'", ']', ',', ':email', '=>', 'u', '[', "'email'", ']', ',', ':long', '=>', 'geo', '[', ':long', ']', ',', ':lat', '=>', 'geo', '[', ':lat', ']', ',', ':country_code', '=>', 'geo', '[', ':country_code', ']', ',', ':state', '=>', 'geo', '[', ':state', ']', ',', ':city', '=>', 'geo', '[', ':city', ']', ',', ':fake', '=>', 'false', ',', ':deleted', '=>', 'false', ',', ':created_at', '=>', 'date', '(', 'u', '[', "'created_at'", ']', ')', ')', 'info', '"Added user #{u[\'login\']} (#{email}) through search API query"', 'else', 'in_db', '.', 'update', '(', ':name', '=>', 'u', '[', "'name'", ']', ',', ':company', '=>', 'u', '[', "'company'", ']', ',', ':email', '=>', 'u', '[', "'email'", ']', ',', ':long', '=>', 'geo', '[', ':long', ']', ',', ':lat', '=>', 'geo', '[', ':lat', ']', ',', ':country_code', '=>', 'geo', '[', ':country_code', ']', ',', ':state', '=>', 'geo', '[', ':state', ']', ',', ':city', '=>', 'geo', '[', ':city', ']', ',', ':fake', '=>', 'false', ',', ':deleted', '=>', 'false', ',', ':created_at', '=>', 'date', '(', 'u', '[', "'created_at'", ']', ')', ')', 'debug', '"User #{u[\'login\']} with email #{email} exists"', 'end', 'users', '.', 'first', '(', ':login', '=>', 'u', '[', "'login'", ']', ')', 'end', 'else', 'debug', '"User with email #{email} exists"', 'usr', 'end', 'end']
->Original Target:
['Try', 'to', 'retrieve', 'a', 'user', 'by', 'email', '.', 'Search', 'the', 'DB', 'first', 'fall', 'back', 'to', 'Github', 'search', 'API', 'if', 'unsuccessful', '.']
->Reconstructed Target:
Try to retrieve a user by email. Search the DB first fall back to Github search API if unsuccessful.
->Reconstructed Predication:
:login => email, :name=> name, :location =>=> u [ 'location' ]:country_code => geo [:state => geo [:lat => geo [:country_code ], :state =>:country_code ], :state =>:state ], :country_code =>:country_code ], :state =>:state ], :country_code =>:country_code
->Raw Input:
summarize:def ensure_user_byemail ( email, name ) users = db [ :users ] usr = users. first ( :email => email ) if usr. nil? u = retrieve_user_byemail ( email, name ) if u. nil? or u [ 'login' ]. nil? warn "Could not retrieve user #{email} through search API query" login = ( 0... 8 ). map { 65. + ( rand ( 25 ) ). chr }. join users. insert ( :email => email, :name => name, :login => login, :fake => true, :deleted => false, :created_at => Time. now ) info "Added user fake #{login} -> #{email}" users. first ( :login => login ) else in_db = users. first ( :login => u [ 'login' ] ) geo = geolocate ( location : u [ 'location' ] ) if in_db. nil? users. insert ( :login => u [ 'login' ], :name => u [ 'name' ], :company => u [ 'company' ], :email => u [ 'email' ], :long => geo [ :long ], :lat => geo [ :lat ], :country_code => geo [ :country_code ], :state => geo [ :state ], :city => geo [ :city ], :fake => false, :deleted => false, :created_at => date ( u [ 'created_at' ] ) ) info "Added user #{u['login']} (#{email}) through search API query" else in_db. update ( :name => u [ 'name' ], :company => u [ 'company' ], :email => u [ 'email' ], :long => geo [ :long ], :lat => geo [ :lat ], :country_code => geo [ :country_code ], :state => geo [ :state ], :city => geo [ :city ], :fake => false, :deleted => false, :created_at => date ( u [ 'created_at' ] ) ) debug "User #{u['login']} with email #{email} exists" end users. first ( :login => u [ 'login' ] ) end else debug "User with email #{email} exists" usr end end
->Raw Target:
Try to retrieve a user by email. Search the DB first fall back to Github search API if unsuccessful.
--

195=========
->Original Input:
['def', 'ensure_repo', '(', 'user', ',', 'repo', ',', 'recursive', '=', 'false', ')', 'repos', '=', 'db', '[', ':projects', ']', 'curuser', '=', 'ensure_user', '(', 'user', ',', 'false', ',', 'false', ')', 'if', 'curuser', '.', 'nil?', 'warn', '"Could not find user #{user}"', 'return', 'end', 'currepo', '=', 'repos', '.', 'first', '(', ':owner_id', '=>', 'curuser', '[', ':id', ']', ',', ':name', '=>', 'repo', ')', 'unless', 'currepo', '.', 'nil?', 'debug', '"Repo #{user}/#{repo} exists"', 'return', 'refresh_repo', '(', 'user', ',', 'repo', ',', 'currepo', ')', 'end', 'r', '=', 'retrieve_repo', '(', 'user', ',', 'repo', ',', 'true', ')', 'if', 'r', '.', 'nil?', 'warn', '"Could not retrieve repo #{user}/#{repo}"', 'return', 'end', 'if', 'r', '[', "'owner'", ']', '[', "'login'", ']', '!=', 'curuser', '[', ':login', ']', 'info', '"Repo changed owner from #{curuser[:login]} to #{r[\'owner\'][\'login\']}"', 'curuser', '=', 'ensure_user', '(', 'r', '[', "'owner'", ']', '[', "'login'", ']', ',', 'false', ',', 'false', ')', 'end', 'repos', '.', 'insert', '(', ':url', '=>', 'r', '[', "'url'", ']', ',', ':owner_id', '=>', 'curuser', '[', ':id', ']', ',', ':name', '=>', 'r', '[', "'name'", ']', ',', ':description', '=>', 'unless', 'r', '[', "'description'", ']', '.', 'nil?', 'then', 'r', '[', "'description'", ']', '[', '0', '..', '254', ']', 'else', 'nil', 'end', ',', ':language', '=>', 'r', '[', "'language'", ']', ',', ':created_at', '=>', 'date', '(', 'r', '[', "'created_at'", ']', ')', ',', ':updated_at', '=>', 'date', '(', 'Time', '.', 'now', ')', ',', ':etag', '=>', 'unless', 'r', '[', "'etag'", ']', '.', 'nil?', 'then', 'r', '[', "'etag'", ']', 'end', ')', 'unless', 'r', '[', "'parent'", ']', '.', 'nil?', 'parent_owner', '=', 'r', '[', "'parent'", ']', '[', "'owner'", ']', '[', "'login'", ']', 'parent_repo', '=', 'r', '[', "'parent'", ']', '[', "'name'", ']', 'parent', '=', 'ensure_repo', '(', 'parent_owner', ',', 'parent_repo', ')', 'if', 'parent', '.', 'nil?', 'warn', '"Could not find repo #{parent_owner}/#{parent_repo}, parent of: #{user}/#{repo}"', 'repos', '.', 'filter', '(', ':owner_id', '=>', 'curuser', '[', ':id', ']', ',', ':name', '=>', 'repo', ')', '.', 'update', '(', ':forked_from', '=>', '-', '1', ')', 'else', 'repos', '.', 'filter', '(', ':owner_id', '=>', 'curuser', '[', ':id', ']', ',', ':name', '=>', 'repo', ')', '.', 'update', '(', ':forked_from', '=>', 'parent', '[', ':id', ']', ')', 'info', '"Repo #{user}/#{repo} is a fork of #{parent_owner}/#{parent_repo}"', 'unless', 'ensure_fork_point', '(', 'user', ',', 'repo', ')', '.', 'nil?', 'warn', '"Could not find fork point for #{user}/#{repo}, fork of #{parent_owner}/#{parent_repo}"', 'end', 'end', 'end', 'if', 'recursive', 'and', 'not', 'ensure_repo_recursive', '(', 'user', ',', 'repo', ')', 'warn', '"Could retrieve #{user}/#{repo} recursively"', 'return', 'nil', 'end', 'info', '"Added repo #{user}/#{repo}"', 'return', 'repos', '.', 'first', '(', ':owner_id', '=>', 'curuser', '[', ':id', ']', ',', ':name', '=>', 'repo', ')', 'end']
->Original Target:
['Ensure', 'that', 'a', 'repo', 'exists', 'or', 'fetch', 'its', 'latest', 'state', 'from', 'Github']
->Reconstructed Target:
Ensure that a repo exists or fetch its latest state from Github
->Reconstructed Predication:
repo )repo ).( :forked_from => - 1)repo ). update (:forked_from => parent [:forked_from => - 1 )( :owner_id => curuser [:id ], :name =>=> repo ). update:forked_from => parent [:forked_from => parent [:forked_from ] ):forked
->Raw Input:
summarize:def ensure_repo ( user, repo, recursive = false ) repos = db [ :projects ] curuser = ensure_user ( user, false, false ) if curuser. nil? warn "Could not find user #{user}" return end currepo = repos. first ( :owner_id => curuser [ :id ], :name => repo ) unless currepo. nil? debug "Repo #{user}/#{repo} exists" return refresh_repo ( user, repo, currepo ) end r = retrieve_repo ( user, repo, true ) if r. nil? warn "Could not retrieve repo #{user}/#{repo}" return end if r [ 'owner' ] [ 'login' ]!= curuser [ :login ] info "Repo changed owner from #{curuser[:login]} to #{r['owner']['login']}" curuser = ensure_user ( r [ 'owner' ] [ 'login' ], false, false ) end repos. insert ( :url => r [ 'url' ], :owner_id => curuser [ :id ], :name => r [ 'name' ], :description => unless r [ 'description' ]. nil? then r [ 'description' ] [ 0.. 254 ] else nil end, :language => r [ 'language' ], :created_at => date ( r [ 'created_at' ] ), :updated_at => date ( Time. now ), :etag => unless r [ 'etag' ]. nil? then r [ 'etag' ] end ) unless r [ 'parent' ]. nil? parent_owner = r [ 'parent' ] [ 'owner' ] [ 'login' ] parent_repo = r [ 'parent' ] [ 'name' ] parent = ensure_repo ( parent_owner, parent_repo ) if parent. nil? warn "Could not find repo #{parent_owner}/#{parent_repo}, parent of: #{user}/#{repo}" repos. filter ( :owner_id => curuser [ :id ], :name => repo ). update ( :forked_from => - 1 ) else repos. filter ( :owner_id => curuser [ :id ], :name => repo ). update ( :forked_from => parent [ :id ] ) info "Repo #{user}/#{repo} is a fork of #{parent_owner}/#{parent_repo}" unless ensure_fork_point (
->Raw Target:
Ensure that a repo exists or fetch its latest state from Github
--

196=========
->Original Input:
['def', 'ensure_languages', '(', 'owner', ',', 'repo', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'langs', '=', 'retrieve_languages', '(', 'owner', ',', 'repo', ')', 'if', 'langs', '.', 'nil?', 'or', 'langs', '.', 'empty?', 'warn', '"Could not find languages for repo #{owner}/#{repo}"', 'return', 'end', 'ts', '=', 'Time', '.', 'now', 'langs', '.', 'keys', '.', 'each', 'do', '|', 'lang', '|', 'db', '[', ':project_languages', ']', '.', 'insert', '(', ':project_id', '=>', 'currepo', '[', ':id', ']', ',', ':language', '=>', 'lang', '.', 'downcase', ',', ':bytes', '=>', 'langs', '[', 'lang', ']', ',', ':created_at', '=>', 'ts', ')', 'info', '"Added project_language #{owner}/#{repo} -> #{lang} (#{langs[lang]} bytes)"', 'end', 'db', '[', ':project_languages', ']', '.', 'where', '(', ':project_id', '=>', 'currepo', '[', ':id', ']', ')', '.', 'where', '(', ':created_at', '=>', 'ts', ')', '.', 'all', 'end']
->Original Target:
['Get', 'details', 'about', 'the', 'languages', 'used', 'in', 'the', 'repository']
->Reconstructed Target:
Get details about the languages used in the repository
->Reconstructed Predication:
the project languages for thethe project languages for thethe project languages for thethe project languages for thethe project languages for thethe project languages for thethe project languages for thethe project languages for thethe project languages for thethe project languages for thethe project languages for thethe project languages for the
->Raw Input:
summarize:def ensure_languages ( owner, repo ) currepo = ensure_repo ( owner, repo ) langs = retrieve_languages ( owner, repo ) if langs. nil? or langs. empty? warn "Could not find languages for repo #{owner}/#{repo}" return end ts = Time. now langs. keys. each do | lang | db [ :project_languages ]. insert ( :project_id => currepo [ :id ], :language => lang. downcase, :bytes => langs [ lang ], :created_at => ts ) info "Added project_language #{owner}/#{repo} -> #{lang} (#{langs[lang]} bytes)" end db [ :project_languages ]. where ( :project_id => currepo [ :id ] ). where ( :created_at => ts ). all end
->Raw Target:
Get details about the languages used in the repository
--

197=========
->Original Input:
['def', 'ensure_fork_commits', '(', 'owner', ',', 'repo', ',', 'parent_owner', ',', 'parent_repo', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'currepo', '.', 'nil?', 'warn', '"Could not find repo #{owner}/#{repo}"', 'return', 'end', 'parent', '=', 'ensure_repo', '(', 'parent_owner', ',', 'parent_repo', ')', 'if', 'parent', '.', 'nil?', 'warn', '"Could not find repo #{parent_owner}/#{parent_repo}, parent of #{owner}/#{repo}"', 'return', 'end', 'strategy', '=', 'case', 'when', 'config', '(', ':fork_commits', ')', '.', 'match', '(', '/', '/i', ')', ':all', 'when', 'config', '(', ':fork_commits', ')', '.', 'match', '(', '/', '/i', ')', ':fork_point', 'when', 'config', '(', ':fork_commits', ')', '.', 'match', '(', '/', '/i', ')', ':none', 'else', ':fork_point', 'end', 'fork_commit', '=', 'ensure_fork_point', '(', 'owner', ',', 'repo', ')', 'if', 'fork_commit', '.', 'nil?', 'or', 'fork_commit', '.', 'empty?', 'warn', '"Could not find fork commit for repo #{owner}/#{repo}. Retrieving all commits."', 'return', 'ensure_commits', '(', 'owner', ',', 'repo', ',', 'fork_all', ':', 'true', ')', 'end', 'debug', '"Retrieving commits for fork #{owner}/#{repo}: strategy is #{strategy}"', 'return', 'if', 'strategy', '==', ':none', 'if', 'strategy', '==', ':fork_point', 'info', '"Retrieving commits for #{owner}/#{repo} until fork commit #{fork_commit[:sha]}"', 'master_branch', '=', 'retrieve_default_branch', '(', 'parent_owner', ',', 'parent_repo', ')', 'return', 'if', 'master_branch', '.', 'nil?', 'sha', '=', 'master_branch', 'found', '=', 'false', 'while', 'not', 'found', 'commits', '=', 'retrieve_commits', '(', 'repo', ',', 'sha', ',', 'owner', ',', '1', ')', 'if', 'commits', '.', 'size', '==', '0', 'break', 'end', 'if', 'commits', '.', 'size', '==', '1', 'and', 'commits', '[', '0', ']', '[', "'sha'", ']', '==', 'sha', 'break', 'end', 'for', 'c', 'in', 'commits', 'ensure_commit', '(', 'repo', ',', 'c', '[', "'sha'", ']', ',', 'owner', ')', 'sha', '=', 'c', '[', "'sha'", ']', 'if', 'c', '[', "'sha'", ']', '==', 'fork_commit', '[', ':sha', ']', 'found', '=', 'true', 'break', 'end', 'end', 'end', 'end', 'if', 'strategy', '==', ':all', 'shared_commit', '=', 'db', '[', ':commits', ']', '.', 'first', '(', ':sha', '=>', 'fork_commit', ')', 'copied', '=', '0', 'to_copy', '=', 'db', '.', 'from', '(', ':project_commits', ',', ':commits', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'project_commits'", ',', "'commit_id'", ')', '=>', 'Sequel', '.', 'qualify', '(', "'commits'", ',', "'id'", ')', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'project_commits'", ',', "'project_id'", ')', '=>', 'parent', '[', ':id', ']', ')', '.', 'where', '(', "'commits.created_at < ?'", ',', 'shared_commit', '[', ':created_at', ']', ')', '.', 'select', '(', 'Sequel', '.', 'qualify', '(', "'commits'", ',', "'id'", ')', ')', 'to_copy', '.', 'each', 'do', '|', 'c', '|', 'copied', '+=', '1', 'begin', 'db', '[', ':project_commits', ']', '.', 'insert', '(', ':project_id', '=>', 'currepo', '[', ':id', ']', ',', ':commit_id', '=>', 'c', '[', ':id', ']', ')', 'debug', '"Copied commit #{c[:sha]} #{parent_owner}/#{parent_repo} -> #{owner}/#{repo} (#{copied} total)"', 'rescue', 'StandardError', '=>', 'e', 'warn', '"Could not copy commit #{c[:sha]} #{parent_owner}/#{parent_repo} -> #{owner}/#{repo} : #{e.message}"', 'end', 'end', 'info', '"Finished copying commits from #{parent_owner}/#{parent_repo} -> #{owner}/#{repo}: #{copied} total"', 'end', 'end']
->Original Target:
['Fast', 'path', 'to', 'project', 'forking', '.', 'Retrieve', 'all', 'commits', 'page', 'by', 'page', 'until', 'we', 'reach', 'a', 'commit', 'that', 'has', 'been', 'registered', 'with', 'the', 'parent', 'repository', '.', 'Then', 'copy', 'all', 'remaining', 'parent', 'commits', 'to', 'this', 'repo', '.']
->Reconstructed Target:
Fast path to project forking. Retrieve all commits page by page until we reach a commit that has been registered with the parent repository. Then copy all remaining parent commits to this repo.
->Reconstructed Predication:
( :fork_commits ). match).( :fork_commits ). match).( :fork_commits ). match).( :fork_commits ). match).( :fork_commits ). match)..( :fork_commits ). match)..( :fork_commits )......
->Raw Input:
summarize:def ensure_fork_commits ( owner, repo, parent_owner, parent_repo ) currepo = ensure_repo ( owner, repo ) if currepo. nil? warn "Could not find repo #{owner}/#{repo}" return end parent = ensure_repo ( parent_owner, parent_repo ) if parent. nil? warn "Could not find repo #{parent_owner}/#{parent_repo}, parent of #{owner}/#{repo}" return end strategy = case when config ( :fork_commits ). match ( / /i ) :all when config ( :fork_commits ). match ( / /i ) :fork_point when config ( :fork_commits ). match ( / /i ) :none else :fork_point end fork_commit = ensure_fork_point ( owner, repo ) if fork_commit. nil? or fork_commit. empty? warn "Could not find fork commit for repo #{owner}/#{repo}. Retrieving all commits." return ensure_commits ( owner, repo, fork_all : true ) end debug "Retrieving commits for fork #{owner}/#{repo}: strategy is #{strategy}" return if strategy == :none if strategy == :fork_point info "Retrieving commits for #{owner}/#{repo} until fork commit #{fork_commit[:sha]}" master_branch = retrieve_default_branch ( parent_owner, parent_repo ) return if master_branch. nil? sha = master_branch found = false while not found commits = retrieve_commits ( repo, sha, owner, 1 ) if commits. size == 0 break end if commits. size == 1 and commits [ 0 ] ['sha' ] == sha break end for c in commits ensure_commit ( repo, c ['sha' ], owner ) sha = c ['sha' ] if c ['sha' ] == fork_commit [ :sha ] found = true break end end end end if strategy == :all shared_commit = db [ :commits ]. first ( :sha => fork_commit ) copied = 0 to_copy = db. from ( :project_commits, :commits ). where ( Sequel. qualify ( 'project_commits', 'commit_id' ) => Sequel. qualify ( 'commits', 'id' ) ). where ( Sequel. qualify ( 'project_commits', 'project_id' ) => parent [ :id ]
->Raw Target:
Fast path to project forking. Retrieve all commits page by page until we reach a commit that has been registered with the parent repository. Then copy all remaining parent commits to this repo.
--

198=========
->Original Input:
['def', 'ensure_fork_point', '(', 'owner', ',', 'repo', ')', 'fork', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ',', 'false', ')', 'if', 'fork', '[', ':forked_from', ']', '.', 'nil?', 'warn', '"Repo #{owner}/#{repo} is not a fork"', 'return', 'nil', 'end', 'unless', 'fork', '[', ':forked_commit_id', ']', '.', 'nil?', 'commit', '=', 'db', '[', ':commits', ']', '.', 'where', '(', ':id', '=>', 'fork', '[', ':forked_commit_id', ']', ')', '.', 'first', 'return', 'commit', 'unless', 'commit', '.', 'nil?', 'end', 'parent', '=', 'db', '.', 'from', '(', ':projects', ',', ':users', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'projects'", ',', "'owner_id'", ')', '=>', 'Sequel', '.', 'qualify', '(', "'users'", ',', "'id'", ')', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'projects'", ',', "'id'", ')', '=>', 'fork', '[', ':forked_from', ']', ')', '.', 'select', '(', 'Sequel', '.', 'qualify', '(', "'users'", ',', "'login'", ')', ',', 'Sequel', '.', 'qualify', '(', "'projects'", ',', "'name'", ')', ')', '.', 'first', 'if', 'parent', '.', 'nil?', 'warn', '"Unknown parent for repo #{owner}/#{repo}"', 'return', 'nil', 'end', 'default_branch', '=', 'retrieve_default_branch', '(', 'parent', '[', ':login', ']', ',', 'parent', '[', ':name', ']', ')', 'diff', '=', 'retrieve_master_branch_diff', '(', 'owner', ',', 'repo', ',', 'default_branch', ',', 'parent', '[', ':login', ']', ',', 'parent', '[', ':name', ']', ',', 'default_branch', ')', 'if', 'diff', '.', 'nil?', 'or', 'diff', '.', 'empty?', 'default_branch', '=', 'retrieve_default_branch', '(', 'parent', '[', ':login', ']', ',', 'parent', '[', ':name', ']', ',', 'true', ')', 'diff', '=', 'retrieve_master_branch_diff', '(', 'owner', ',', 'repo', ',', 'default_branch', ',', 'parent', '[', ':login', ']', ',', 'parent', '[', ':name', ']', ',', 'default_branch', ')', 'end', 'if', 'diff', '.', 'nil?', 'or', 'diff', '.', 'empty?', 'warn', '"No common ancestor between #{parent[:login]}/#{parent[:name]} and #{owner}/#{repo}"', 'return', 'nil', 'else', 'debug', '"Fork #{owner}/#{repo} is #{diff[\'ahead_by\']} commits ahead and #{diff[\'behind_by\']} commits behind #{parent[:login]}/#{parent[:name]}"', 'end', 'if', 'diff', '[', "'ahead_by'", ']', '.', 'to_i', '>', '0', 'earliest_diverging', '=', 'diff', '[', "'commits'", ']', '.', 'sort_by', '{', '|', 'x', '|', 'x', '[', "'commit'", ']', '[', "'author'", ']', '[', "'date'", ']', '}', '.', 'first', 'if', 'earliest_diverging', '[', "'parents'", ']', '.', 'nil?', 'likely_fork_point', '=', 'ensure_commit', '(', 'parent', '[', ':name', ']', ',', 'earliest_diverging', '[', "'sha'", ']', ',', 'parent', '[', "'login'", ']', ')', 'else', 'likely_fork_point', '=', 'earliest_diverging', '[', "'parents'", ']', '.', 'map', '{', '|', 'x', '|', 'ensure_commit', '(', 'parent', '[', ':name', ']', ',', 'x', '[', "'sha'", ']', ',', 'parent', '[', ':login', ']', ')', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', '.', 'sort_by', '{', '|', 'x', '|', 'x', '[', ':created_at', ']', '}', '.', 'last', 'end', 'forked_sha', '=', 'likely_fork_point', '[', ':sha', ']', 'else', 'forked_sha', '=', 'diff', '[', "'merge_base_commit'", ']', '[', "'sha'", ']', 'end', 'forked_commit', '=', 'ensure_commit', '(', 'repo', ',', 'forked_sha', ',', 'owner', ')', ';', 'debug', '"Fork commit for #{owner}/#{repo} is #{forked_sha}"', 'unless', 'forked_commit', '.', 'nil?', 'db', '[', ':projects', ']', '.', 'filter', '(', ':id', '=>', 'fork', '[', ':id', ']', ')', '.', 'update', '(', ':forked_commit_id', '=>', 'forked_commit', '[', ':id', ']', ')', 'info', '"Repo #{owner}/#{repo} was forked at #{parent[:login]}/#{parent[:name]}:#{forked_sha}"', 'end', 'db', '[', ':commits', ']', '.', 'where', '(', ':sha', '=>', 'forked_sha', ')', '.', 'first', 'end']
->Original Target:
['Retrieve', 'and', 'return', 'the', 'commit', 'at', 'which', 'the', 'provided', 'fork', 'was', 'forked', 'at']
->Reconstructed Target:
Retrieve and return the commit at which the provided fork was forked at
->Reconstructed Predication:
( owner, repo). first[ :forked_from ][ :forked_from ]].[ 'parents' ]..[ 'forked_from' ]..[ 'forked_from' ].[ 'forked_from' ].[ 'forked_from' ]. nil?[ 'forked_from' ]. nil?[ 'forked
->Raw Input:
summarize:def ensure_fork_point ( owner, repo ) fork = ensure_repo ( owner, repo, false ) if fork [ :forked_from ]. nil? warn "Repo #{owner}/#{repo} is not a fork" return nil end unless fork [ :forked_commit_id ]. nil? commit = db [ :commits ]. where ( :id => fork [ :forked_commit_id ] ). first return commit unless commit. nil? end parent = db. from ( :projects, :users ). where ( Sequel. qualify ( 'projects', 'owner_id' ) => Sequel. qualify ( 'users', 'id' ) ). where ( Sequel. qualify ( 'projects', 'id' ) => fork [ :forked_from ] ). select ( Sequel. qualify ( 'users', 'login' ), Sequel. qualify ( 'projects', 'name' ) ). first if parent. nil? warn "Unknown parent for repo #{owner}/#{repo}" return nil end default_branch = retrieve_default_branch ( parent [ :login ], parent [ :name ] ) diff = retrieve_master_branch_diff ( owner, repo, default_branch, parent [ :login ], parent [ :name ], default_branch ) if diff. nil? or diff. empty? default_branch = retrieve_default_branch ( parent [ :login ], parent [ :name ], true ) diff = retrieve_master_branch_diff ( owner, repo, default_branch, parent [ :login ], parent [ :name ], default_branch ) end if diff. nil? or diff. empty? warn "No common ancestor between #{parent[:login]}/#{parent[:name]} and #{owner}/#{repo}" return nil else debug "Fork #{owner}/#{repo} is #{diff['ahead_by']} commits ahead and #{diff['behind_by']} commits behind #{parent[:login]}/#{parent[:name]}" end if diff [ 'ahead_by' ]. to_i > 0 earliest_diverging = diff [ 'commits' ]. sort_by { | x | x [ 'commit' ] [ 'author' ] [ 'date' ] }. first if earliest_diverging [ 'parents' ]. nil? likely_fork_point = ensure
->Raw Target:
Retrieve and return the commit at which the provided fork was forked at
--

199=========
->Original Input:
['def', 'ensure_orgs', '(', 'user', ')', 'retrieve_orgs', '(', 'user', ')', '.', 'map', '{', '|', 'o', '|', 'save', '{', 'ensure_participation', '(', 'user', ',', 'o', '[', "'login'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Make', 'sure', 'that', 'the', 'organizations', 'the', 'user', 'participates', 'into', 'exist']
->Reconstructed Target:
Make sure that the organizations the user participates into exist
->Reconstructed Predication:
the user s organization and thethe user s organization
->Raw Input:
summarize:def ensure_orgs ( user ) retrieve_orgs ( user ). map { | o | save { ensure_participation ( user, o [ 'login' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Make sure that the organizations the user participates into exist
--

200=========
->Original Input:
['def', 'ensure_participation', '(', 'user', ',', 'organization', ',', 'members', '=', 'true', ')', 'org', '=', 'ensure_org', '(', 'organization', ',', 'members', ')', 'if', 'org', '.', 'nil?', 'warn', '"Could not find organization #{organization}"', 'return', 'end', 'usr', '=', 'ensure_user', '(', 'user', ',', 'false', ',', 'false', ')', 'org_members', '=', 'db', '[', ':organization_members', ']', 'participates', '=', 'org_members', '.', 'first', '(', ':user_id', '=>', 'usr', '[', ':id', ']', ',', ':org_id', '=>', 'org', '[', ':id', ']', ')', 'if', 'participates', '.', 'nil?', 'org_members', '.', 'insert', '(', ':user_id', '=>', 'usr', '[', ':id', ']', ',', ':org_id', '=>', 'org', '[', ':id', ']', ')', 'info', '"Added participation #{organization} -> #{user}"', 'org_members', '.', 'first', '(', ':user_id', '=>', 'usr', '[', ':id', ']', ',', ':org_id', '=>', 'org', '[', ':id', ']', ')', 'else', 'debug', '"Participation #{organization} -> #{user} exists"', 'participates', 'end', 'end']
->Original Target:
['Make', 'sure', 'that', 'a', 'user', 'participates', 'to', 'the', 'provided', 'organization']
->Reconstructed Target:
Make sure that a user participates to the provided organization
->Reconstructed Predication:
the userthe user is participating in
->Raw Input:
summarize:def ensure_participation ( user, organization, members = true ) org = ensure_org ( organization, members ) if org. nil? warn "Could not find organization #{organization}" return end usr = ensure_user ( user, false, false ) org_members = db [ :organization_members ] participates = org_members. first ( :user_id => usr [ :id ], :org_id => org [ :id ] ) if participates. nil? org_members. insert ( :user_id => usr [ :id ], :org_id => org [ :id ] ) info "Added participation #{organization} -> #{user}" org_members. first ( :user_id => usr [ :id ], :org_id => org [ :id ] ) else debug "Participation #{organization} -> #{user} exists" participates end end
->Raw Target:
Make sure that a user participates to the provided organization
--

201=========
->Original Input:
['def', 'ensure_org', '(', 'organization', ',', 'members', '=', 'true', ')', 'org', '=', 'db', '[', ':users', ']', '.', 'first', '(', ':login', '=>', 'organization', ',', ':type', '=>', "'org'", ')', 'if', 'org', '.', 'nil?', 'org', '=', 'ensure_user', '(', 'organization', ',', 'false', ',', 'false', ')', 'if', 'org', '[', ':type', ']', '!=', "'ORG'", 'warn', '"User #{organization} is not an organization"', 'return', 'nil', 'end', 'end', 'if', 'members', 'retrieve_org_members', '(', 'organization', ')', '.', 'map', 'do', '|', 'x', '|', 'ensure_participation', '(', 'ensure_user', '(', 'x', '[', "'login'", ']', ',', 'false', ',', 'false', ')', '[', ':login', ']', ',', 'organization', ',', 'false', ')', 'end', 'end', 'org', 'end']
->Original Target:
['Make', 'sure', 'that', 'an', 'organization', 'exists']
->Reconstructed Target:
Make sure that an organization exists
->Reconstructed Predication:
the user for the giventhe user for the given
->Raw Input:
summarize:def ensure_org ( organization, members = true ) org = db [ :users ]. first ( :login => organization, :type => 'org' ) if org. nil? org = ensure_user ( organization, false, false ) if org [ :type ]!= 'ORG' warn "User #{organization} is not an organization" return nil end end if members retrieve_org_members ( organization ). map do | x | ensure_participation ( ensure_user ( x [ 'login' ], false, false ) [ :login ], organization, false ) end end org end
->Raw Target:
Make sure that an organization exists
--

202=========
->Original Input:
['def', 'ensure_commit_comments', '(', 'user', ',', 'repo', ',', 'sha', ')', 'commit_id', '=', 'db', '[', ':commits', ']', '.', 'first', '(', ':sha', '=>', 'sha', ')', '[', ':id', ']', 'stored_comments', '=', 'db', '[', ':commit_comments', ']', '.', 'filter', '(', ':commit_id', '=>', 'commit_id', ')', 'commit_comments', '=', 'retrieve_commit_comments', '(', 'user', ',', 'repo', ',', 'sha', ')', 'not_saved', '=', 'commit_comments', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'stored_comments', '.', 'find', '{', '|', 'y', '|', 'y', '[', ':comment_id', ']', '==', 'x', '[', "'id'", ']', '}', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', 'not_saved', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_commit_comment', '(', 'user', ',', 'repo', ',', 'sha', ',', 'x', '[', "'id'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Get', 'all', 'comments', 'for', 'a', 'commit']
->Reconstructed Target:
Get all comments for a commit
->Reconstructed Predication:
commit comments for a commitcommit comments for a commitcommit comments for a commitcommit comments for a commitcommit comments for a commit
->Raw Input:
summarize:def ensure_commit_comments ( user, repo, sha ) commit_id = db [ :commits ]. first ( :sha => sha ) [ :id ] stored_comments = db [ :commit_comments ]. filter ( :commit_id => commit_id ) commit_comments = retrieve_commit_comments ( user, repo, sha ) not_saved = commit_comments. reduce ( [ ] ) do | acc, x | if stored_comments. find { | y | y [ :comment_id ] == x [ 'id' ] }. nil? acc << x else acc end end not_saved. map { | x | save { ensure_commit_comment ( user, repo, sha, x [ 'id' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Get all comments for a commit
--

203=========
->Original Input:
['def', 'ensure_watchers', '(', 'owner', ',', 'repo', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'currepo', '.', 'nil?', 'warn', '"Could not find repo #{owner}/#{repo} for retrieving watchers"', 'return', 'end', 'watchers', '=', 'db', '.', 'from', '(', ':watchers', ',', ':users', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'watchers'", ',', "'user_id'", ')', '=>', 'Sequel', '.', 'qualify', '(', "'users'", ',', "'id'", ')', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'watchers'", ',', "'repo_id'", ')', '=>', 'currepo', '[', ':id', ']', ')', '.', 'select', '(', ':login', ')', '.', 'all', 'retrieve_watchers', '(', 'owner', ',', 'repo', ')', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'watchers', '.', 'find', '{', '|', 'y', '|', 'y', '[', ':login', ']', '==', 'x', '[', "'login'", ']', '}', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_watcher', '(', 'owner', ',', 'repo', ',', 'x', '[', "'login'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Make', 'sure', 'that', 'all', 'watchers', 'exist', 'for', 'a', 'repository']
->Reconstructed Target:
Make sure that all watchers exist for a repository
->Reconstructed Predication:
thethe watchers for the currentcurrent repo"
->Raw Input:
summarize:def ensure_watchers ( owner, repo ) currepo = ensure_repo ( owner, repo ) if currepo. nil? warn "Could not find repo #{owner}/#{repo} for retrieving watchers" return end watchers = db. from ( :watchers, :users ). where ( Sequel. qualify ( 'watchers', 'user_id' ) => Sequel. qualify ( 'users', 'id' ) ). where ( Sequel. qualify ( 'watchers','repo_id' ) => currepo [ :id ] ). select ( :login ). all retrieve_watchers ( owner, repo ). reduce ( [ ] ) do | acc, x | if watchers. find { | y | y [ :login ] == x [ 'login' ] }. nil? acc << x else acc end end. map { | x | save { ensure_watcher ( owner, repo, x [ 'login' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Make sure that all watchers exist for a repository
--

204=========
->Original Input:
['def', 'ensure_pull_requests', '(', 'owner', ',', 'repo', ',', 'refresh', '=', 'false', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'currepo', '.', 'nil?', 'warn', '"Could not find repo #{owner}/#{repo} for retrieving pull requests"', 'return', 'end', 'raw_pull_reqs', '=', 'if', 'refresh', 'retrieve_pull_requests', '(', 'owner', ',', 'repo', ',', 'refresh', '=', 'true', ')', 'else', 'pull_reqs', '=', 'db', '[', ':pull_requests', ']', '.', 'filter', '(', ':base_repo_id', '=>', 'currepo', '[', ':id', ']', ')', '.', 'all', 'retrieve_pull_requests', '(', 'owner', ',', 'repo', ')', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'pull_reqs', '.', 'find', '{', '|', 'y', '|', 'y', '[', ':pullreq_id', ']', '==', 'x', '[', "'number'", ']', '}', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', 'end', 'raw_pull_reqs', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_pull_request', '(', 'owner', ',', 'repo', ',', 'x', '[', "'number'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Process', 'all', 'pull', 'requests']
->Reconstructed Target:
Process all pull requests
->Reconstructed Predication:
pull requests for the givenrepopull_requests for the given repopull_requests for the given repo.pull_requests for the given repo
->Raw Input:
summarize:def ensure_pull_requests ( owner, repo, refresh = false ) currepo = ensure_repo ( owner, repo ) if currepo. nil? warn "Could not find repo #{owner}/#{repo} for retrieving pull requests" return end raw_pull_reqs = if refresh retrieve_pull_requests ( owner, repo, refresh = true ) else pull_reqs = db [ :pull_requests ]. filter ( :base_repo_id => currepo [ :id ] ). all retrieve_pull_requests ( owner, repo ). reduce ( [ ] ) do | acc, x | if pull_reqs. find { | y | y [ :pullreq_id ] == x [ 'number' ] }. nil? acc << x else acc end end end raw_pull_reqs. map { | x | save { ensure_pull_request ( owner, repo, x [ 'number' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Process all pull requests
--

205=========
->Original Input:
['def', 'ensure_pull_request_history', '(', 'id', ',', 'ts', ',', 'act', ',', 'actor', ')', 'user', '=', 'unless', 'actor', '.', 'nil?', 'ensure_user', '(', 'actor', ',', 'false', ',', 'false', ')', 'end', 'pull_req_history', '=', 'db', '[', ':pull_request_history', ']', 'entry', '=', 'if', '[', "'opened'", ',', "'merged'", ']', '.', 'include?', 'act', 'pull_req_history', '.', 'first', '(', ':pull_request_id', '=>', 'id', ',', ':action', '=>', 'act', ')', 'else', 'pull_req_history', '.', 'first', '(', ':pull_request_id', '=>', 'id', ',', ':created_at', '=>', '(', 'ts', '-', '3', ')', '..', '(', 'ts', '+', '3', ')', ',', ':action', '=>', 'act', ')', 'end', 'if', 'entry', '.', 'nil?', 'pull_req_history', '.', 'insert', '(', ':pull_request_id', '=>', 'id', ',', ':created_at', '=>', 'ts', ',', ':action', '=>', 'act', ',', ':actor_id', '=>', 'unless', 'user', '.', 'nil?', 'then', 'user', '[', ':id', ']', 'end', ')', 'info', '"Added pullreq_event (#{id}) -> (#{act}) by (#{actor}) timestamp #{ts}"', 'else', 'debug', '"Pull request (#{id}) event (#{act}) by (#{actor}) timestamp #{ts} exists"', 'if', 'entry', '[', ':actor_id', ']', '.', 'nil?', 'and', 'not', 'user', '.', 'nil?', 'pull_req_history', '.', 'where', '(', ':pull_request_id', '=>', 'id', ',', ':created_at', '=>', '(', 'ts', '-', '3', ')', '..', '(', 'ts', '+', '3', ')', ',', ':action', '=>', 'act', ')', '.', 'update', '(', ':actor_id', '=>', 'user', '[', ':id', ']', ')', 'info', '"Updated pull request (#{id}) event (#{act}) timestamp #{ts}, actor -> #{user[:login]}"', 'end', 'end', 'end']
->Original Target:
['Adds', 'a', 'pull', 'request', 'history', 'event']
->Reconstructed Target:
Adds a pull request history event
->Reconstructed Predication:
( id )( ts ).. ().. ( ts +), :actor_id => user), :created_at => ().. ( ts +), :action => act), :actor_id => user), :created_at => ().. ( ts +), :created_at => (), :created_at => (), :created_at => (
->Raw Input:
summarize:def ensure_pull_request_history ( id, ts, act, actor ) user = unless actor. nil? ensure_user ( actor, false, false ) end pull_req_history = db [ :pull_request_history ] entry = if [ 'opened','merged' ]. include? act pull_req_history. first ( :pull_request_id => id, :action => act ) else pull_req_history. first ( :pull_request_id => id, :created_at => ( ts - 3 ).. ( ts + 3 ), :action => act ) end if entry. nil? pull_req_history. insert ( :pull_request_id => id, :created_at => ts, :action => act, :actor_id => unless user. nil? then user [ :id ] end ) info "Added pullreq_event (#{id}) -> (#{act}) by (#{actor}) timestamp #{ts}" else debug "Pull request (#{id}) event (#{act}) by (#{actor}) timestamp #{ts} exists" if entry [ :actor_id ]. nil? and not user. nil? pull_req_history. where ( :pull_request_id => id, :created_at => ( ts - 3 ).. ( ts + 3 ), :action => act ). update ( :actor_id => user [ :id ] ) info "Updated pull request (#{id}) event (#{act}) timestamp #{ts}, actor -> #{user[:login]}" end end end
->Raw Target:
Adds a pull request history event
--

206=========
->Original Input:
['def', 'pr_is_intra_branch', '(', 'req', ')', 'return', 'false', 'unless', 'pr_has_head_repo', '(', 'req', ')', 'if', 'req', '[', "'head'", ']', '[', "'repo'", ']', '[', "'owner'", ']', '[', "'login'", ']', '==', 'req', '[', "'base'", ']', '[', "'repo'", ']', '[', "'owner'", ']', '[', "'login'", ']', 'and', 'req', '[', "'head'", ']', '[', "'repo'", ']', '[', "'full_name'", ']', '==', 'req', '[', "'base'", ']', '[', "'repo'", ']', '[', "'full_name'", ']', 'true', 'else', 'false', 'end', 'end']
->Original Target:
['Checks', 'whether', 'a', 'pull', 'request', 'concerns', 'two', 'branches', 'of', 'the', 'same', 'repository']
->Reconstructed Target:
Checks whether a pull request concerns two branches of the same repository
->Reconstructed Predication:
the branch is intra branch
->Raw Input:
summarize:def pr_is_intra_branch ( req ) return false unless pr_has_head_repo ( req ) if req [ 'head' ] ['repo' ] [ 'owner' ] [ 'login' ] == req [ 'base' ] ['repo' ] [ 'owner' ] [ 'login' ] and req [ 'head' ] ['repo' ] [ 'full_name' ] == req [ 'base' ] ['repo' ] [ 'full_name' ] true else false end end
->Raw Target:
Checks whether a pull request concerns two branches of the same repository
--

207=========
->Original Input:
['def', 'ensure_forks', '(', 'owner', ',', 'repo', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'currepo', '.', 'nil?', 'warn', '"Could not find repo #{owner}/#{repo} for retrieving forks"', 'return', 'end', 'existing_forks', '=', 'db', '.', 'from', '(', ':projects', ',', ':users', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'users'", ',', "'id'", ')', '=>', 'Sequel', '.', 'qualify', '(', "'projects'", ',', "'owner_id'", ')', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'projects'", ',', "'forked_from'", ')', '=>', 'currepo', '[', ':id', ']', ')', '.', 'select', '(', 'Sequel', '.', 'qualify', '(', "'projects'", ',', "'name'", ')', ',', ':login', ')', '.', 'all', 'retrieve_forks', '(', 'owner', ',', 'repo', ')', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'existing_forks', '.', 'find', 'do', '|', 'y', '|', 'forked_repo_owner', '=', 'x', '[', "'url'", ']', '.', 'split', '(', '/', '\\/', '/', ')', '[', '4', ']', 'forked_repo_name', '=', 'x', '[', "'url'", ']', '.', 'split', '(', '/', '\\/', '/', ')', '[', '5', ']', 'y', '[', ':login', ']', '==', 'forked_repo_owner', '&&', 'y', '[', ':name', ']', '==', 'forked_repo_name', 'end', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_fork', '(', 'owner', ',', 'repo', ',', 'x', '[', "'id'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Get', 'all', 'forks', 'for', 'a', 'project', '.']
->Reconstructed Target:
Get all forks for a project.
->Reconstructed Predication:
( owner, repo)) { ||) { |||||| || | || | | || | | || | || | || | || | || | || | || | | || | | || | || | | || | | | || | | ||
->Raw Input:
summarize:def ensure_forks ( owner, repo ) currepo = ensure_repo ( owner, repo ) if currepo. nil? warn "Could not find repo #{owner}/#{repo} for retrieving forks" return end existing_forks = db. from ( :projects, :users ). where ( Sequel. qualify ( 'users', 'id' ) => Sequel. qualify ( 'projects', 'owner_id' ) ). where ( Sequel. qualify ( 'projects', 'forked_from' ) => currepo [ :id ] ). select ( Sequel. qualify ( 'projects', 'name' ), :login ). all retrieve_forks ( owner, repo ). reduce ( [ ] ) do | acc, x | if existing_forks. find do | y | forked_repo_owner = x [ 'url' ]. split ( / \/ / ) [ 4 ] forked_repo_name = x [ 'url' ]. split ( / \/ / ) [ 5 ] y [ :login ] == forked_repo_owner && y [ :name ] == forked_repo_name end. nil? acc << x else acc end end. map { | x | save { ensure_fork ( owner, repo, x [ 'id' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Get all forks for a project.
--

208=========
->Original Input:
['def', 'ensure_fork', '(', 'owner', ',', 'repo', ',', 'fork_id', ')', 'fork', '=', 'retrieve_fork', '(', 'owner', ',', 'repo', ',', 'fork_id', ')', 'if', 'fork', '.', 'nil?', 'warn', '"Could not retrieve fork #{owner}/#{repo} -> #{fork_id}"', 'return', 'end', 'fork_name', '=', 'if', 'fork', '[', "'full_name'", ']', '.', 'nil?', 'then', 'fork', '[', "'url'", ']', '.', 'split', '(', '/', '\\/', '/', ')', '[', '4', '..', '5', ']', '.', 'join', '(', "'/'", ')', 'else', 'fork', '[', "'full_name'", ']', 'end', 'fork_owner', '=', 'fork_name', '.', 'split', '(', '/', '\\/', '/', ')', '[', '0', ']', 'fork_name', '=', 'fork_name', '.', 'split', '(', '/', '\\/', '/', ')', '[', '1', ']', 'r', '=', 'ensure_repo', '(', 'fork_owner', ',', 'fork_name', ',', 'true', ')', 'if', 'r', '.', 'nil?', 'warn', '"Could not add #{fork_owner}/#{fork_name} as fork of #{owner}/#{repo}"', 'else', 'info', '"Added fork #{fork_owner}/#{fork_name} of #{owner}/#{repo}"', 'end', 'r', 'end']
->Original Target:
['Make', 'sure', 'that', 'a', 'fork', 'is', 'retrieved', 'for', 'a', 'project']
->Reconstructed Target:
Make sure that a fork is retrieved for a project
->Reconstructed Predication:
the fork ofthe fork of #{owner}/#{repo}" end
->Raw Input:
summarize:def ensure_fork ( owner, repo, fork_id ) fork = retrieve_fork ( owner, repo, fork_id ) if fork. nil? warn "Could not retrieve fork #{owner}/#{repo} -> #{fork_id}" return end fork_name = if fork [ 'full_name' ]. nil? then fork [ 'url' ]. split ( / \/ / ) [ 4.. 5 ]. join ( '/' ) else fork [ 'full_name' ] end fork_owner = fork_name. split ( / \/ / ) [ 0 ] fork_name = fork_name. split ( / \/ / ) [ 1 ] r = ensure_repo ( fork_owner, fork_name, true ) if r. nil? warn "Could not add #{fork_owner}/#{fork_name} as fork of #{owner}/#{repo}" else info "Added fork #{fork_owner}/#{fork_name} of #{owner}/#{repo}" end r end
->Raw Target:
Make sure that a fork is retrieved for a project
--

209=========
->Original Input:
['def', 'ensure_issues', '(', 'owner', ',', 'repo', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'currepo', '.', 'nil?', 'warn', '"Could not find repo #{owner}/#{repo} for retrieving issues"', 'return', 'end', 'issues', '=', 'db', '[', ':issues', ']', '.', 'filter', '(', ':repo_id', '=>', 'currepo', '[', ':id', ']', ')', '.', 'all', 'raw_issues', '=', 'retrieve_issues', '(', 'owner', ',', 'repo', ')', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'issues', '.', 'find', '{', '|', 'y', '|', 'y', '[', ':issue_id', ']', '==', 'x', '[', "'number'", ']', '}', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', 'raw_issues', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_issue', '(', 'owner', ',', 'repo', ',', 'x', '[', "'number'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Make', 'sure', 'all', 'issues', 'exist', 'for', 'a', 'project']
->Reconstructed Target:
Make sure all issues exist for a project
->Reconstructed Predication:
reporepo )) { | x |) { | x |) { |) { return
->Raw Input:
summarize:def ensure_issues ( owner, repo ) currepo = ensure_repo ( owner, repo ) if currepo. nil? warn "Could not find repo #{owner}/#{repo} for retrieving issues" return end issues = db [ :issues ]. filter ( :repo_id => currepo [ :id ] ). all raw_issues = retrieve_issues ( owner, repo ). reduce ( [ ] ) do | acc, x | if issues. find { | y | y [ :issue_id ] == x [ 'number' ] }. nil? acc << x else acc end end raw_issues. map { | x | save { ensure_issue ( owner, repo, x [ 'number' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Make sure all issues exist for a project
--

210=========
->Original Input:
['def', 'ensure_issue', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'events', '=', 'true', ',', 'comments', '=', 'true', ',', 'labels', '=', 'true', ')', 'issues', '=', 'db', '[', ':issues', ']', 'repository', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'repository', '.', 'nil?', 'warn', '"Could not find repo #{owner}/#{repo} for retrieving issue #{issue_id}"', 'return', 'end', 'cur_issue', '=', 'issues', '.', 'first', '(', ':issue_id', '=>', 'issue_id', ',', ':repo_id', '=>', 'repository', '[', ':id', ']', ')', 'retrieved', '=', 'retrieve_issue', '(', 'owner', ',', 'repo', ',', 'issue_id', ')', 'if', 'retrieved', '.', 'nil?', 'warn', '"Could not retrieve issue #{owner}/#{repo} -> #{issue_id}"', 'return', 'end', 'pull_req', '=', 'unless', 'retrieved', '[', "'pull_request'", ']', '.', 'nil?', 'or', 'retrieved', '[', "'pull_request'", ']', '[', "'patch_url'", ']', '.', 'nil?', 'debug', '"Issue #{owner}/#{repo}->#{issue_id} is a pull request"', 'ensure_pull_request', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'false', ',', 'false', ',', 'false', ')', 'end', 'if', 'cur_issue', '.', 'nil?', 'reporter', '=', 'ensure_user', '(', 'retrieved', '[', "'user'", ']', '[', "'login'", ']', ',', 'false', ',', 'false', ')', 'assignee', '=', 'unless', 'retrieved', '[', "'assignee'", ']', '.', 'nil?', 'ensure_user', '(', 'retrieved', '[', "'assignee'", ']', '[', "'login'", ']', ',', 'false', ',', 'false', ')', 'end', 'issues', '.', 'insert', '(', ':repo_id', '=>', 'repository', '[', ':id', ']', ',', ':assignee_id', '=>', 'unless', 'assignee', '.', 'nil?', 'then', 'assignee', '[', ':id', ']', 'end', ',', ':reporter_id', '=>', 'reporter', '[', ':id', ']', ',', ':issue_id', '=>', 'issue_id', ',', ':pull_request', '=>', 'if', 'pull_req', '.', 'nil?', 'then', 'false', 'else', 'true', 'end', ',', ':pull_request_id', '=>', 'unless', 'pull_req', '.', 'nil?', 'then', 'pull_req', '[', ':id', ']', 'end', ',', ':created_at', '=>', 'date', '(', 'retrieved', '[', "'created_at'", ']', ')', ')', 'info', '"Added issue #{owner}/#{repo} -> #{issue_id}"', 'else', 'debug', '"Issue #{owner}/#{repo}->#{issue_id} exists"', 'if', 'cur_issue', '[', ':pull_request', ']', '==', 'false', 'and', 'not', 'pull_req', '.', 'nil?', 'info', '"Updated issue #{owner}/#{repo}->#{issue_id} as pull request"', 'issues', '.', 'filter', '(', ':issue_id', '=>', 'issue_id', ',', ':repo_id', '=>', 'repository', '[', ':id', ']', ')', '.', 'update', '(', ':pull_request', '=>', 'true', ',', ':pull_request_id', '=>', 'pull_req', '[', ':id', ']', ')', 'end', 'end', 'ensure_issue_events', '(', 'owner', ',', 'repo', ',', 'issue_id', ')', 'if', 'events', 'ensure_issue_comments', '(', 'owner', ',', 'repo', ',', 'issue_id', ')', 'if', 'comments', 'ensure_issue_labels', '(', 'owner', ',', 'repo', ',', 'issue_id', ')', 'if', 'labels', 'issues', '.', 'first', '(', ':issue_id', '=>', 'issue_id', ',', ':repo_id', '=>', 'repository', '[', ':id', ']', ')', 'end']
->Original Target:
['Make', 'sure', 'that', 'the', 'issue', 'exists']
->Reconstructed Target:
Make sure that the issue exists
->Reconstructed Predication:
: issue_id ],:issue_id ], :reporter_id =>:issue_id ], :reporter_id =>:issue_id ], :reporter_id =>:issue_id ], :reporter_id =>:issue_id ], :reporter_id =>:issue_id ], :reporter_id =>:issue_id ], :reporter_id =>
->Raw Input:
summarize:def ensure_issue ( owner, repo, issue_id, events = true, comments = true, labels = true ) issues = db [ :issues ] repository = ensure_repo ( owner, repo ) if repository. nil? warn "Could not find repo #{owner}/#{repo} for retrieving issue #{issue_id}" return end cur_issue = issues. first ( :issue_id => issue_id, :repo_id => repository [ :id ] ) retrieved = retrieve_issue ( owner, repo, issue_id ) if retrieved. nil? warn "Could not retrieve issue #{owner}/#{repo} -> #{issue_id}" return end pull_req = unless retrieved [ 'pull_request' ]. nil? or retrieved [ 'pull_request' ] [ 'patch_url' ]. nil? debug "Issue #{owner}/#{repo}->#{issue_id} is a pull request" ensure_pull_request ( owner, repo, issue_id, false, false, false ) end if cur_issue. nil? reporter = ensure_user ( retrieved [ 'user' ] [ 'login' ], false, false ) assignee = unless retrieved [ 'assignee' ]. nil? ensure_user ( retrieved [ 'assignee' ] [ 'login' ], false, false ) end issues. insert ( :repo_id => repository [ :id ], :assignee_id => unless assignee. nil? then assignee [ :id ] end, :reporter_id => reporter [ :id ], :issue_id => issue_id, :pull_request => if pull_req. nil? then false else true end, :pull_request_id => unless pull_req. nil? then pull_req [ :id ] end, :created_at => date ( retrieved [ 'created_at' ] ) ) info "Added issue #{owner}/#{repo} -> #{issue_id}" else debug "Issue #{owner}/#{repo}->#{issue_id} exists" if cur_issue [ :pull_request ] == false and not pull_req. nil? info "Updated issue #{owner}/#{repo}->#{issue_id} as pull request" issues. filter ( :issue_id => issue_id, :repo_id => repository [ :id ] ). update ( :pull_request => true, :pull_request_id => pull_req [ :
->Raw Target:
Make sure that the issue exists
--

211=========
->Original Input:
['def', 'ensure_issue_events', '(', 'owner', ',', 'repo', ',', 'issue_id', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'currepo', '.', 'nil?', 'warn', '"Could not find repository #{owner}/#{repo} for retrieving events for issue #{issue_id}"', 'return', 'end', 'issue', '=', 'ensure_issue', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'false', ',', 'false', ',', 'false', ')', 'if', 'issue', '.', 'nil?', 'warn', '"Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving events"', 'return', 'end', 'retrieve_issue_events', '(', 'owner', ',', 'repo', ',', 'issue_id', ')', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'db', '[', ':issue_events', ']', '.', 'first', '(', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ':event_id', '=>', 'x', '[', "'id'", ']', ')', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_issue_event', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'x', '[', "'id'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Retrieve', 'and', 'process', 'all', 'events', 'for', 'an', 'issue']
->Reconstructed Target:
Retrieve and process all events for an issue
->Reconstructed Predication:
issue_id, event_id )issue_id, event_id )issue_id, event_id )issue_id, event_id )issue_id, event_id )issue_id, event_id ) end
->Raw Input:
summarize:def ensure_issue_events ( owner, repo, issue_id ) currepo = ensure_repo ( owner, repo ) if currepo. nil? warn "Could not find repository #{owner}/#{repo} for retrieving events for issue #{issue_id}" return end issue = ensure_issue ( owner, repo, issue_id, false, false, false ) if issue. nil? warn "Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving events" return end retrieve_issue_events ( owner, repo, issue_id ). reduce ( [ ] ) do | acc, x | if db [ :issue_events ]. first ( :issue_id => issue [ :id ], :event_id => x [ 'id' ] ). nil? acc << x else acc end end. map { | x | save { ensure_issue_event ( owner, repo, issue_id, x [ 'id' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Retrieve and process all events for an issue
--

212=========
->Original Input:
['def', 'ensure_issue_event', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'event_id', ')', 'issue', '=', 'ensure_issue', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'false', ',', 'false', ',', 'false', ')', 'if', 'issue', '.', 'nil?', 'warn', '"Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving event #{event_id}"', 'return', 'end', 'issue_event_str', '=', '"#{owner}/#{repo} -> #{issue_id}/#{event_id}"', 'curevent', '=', 'db', '[', ':issue_events', ']', '.', 'first', '(', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ':event_id', '=>', 'event_id', ')', 'if', 'curevent', '.', 'nil?', 'retrieved', '=', 'retrieve_issue_event', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'event_id', ')', 'if', 'retrieved', '.', 'nil?', 'warn', '"Could not retrieve issue_event #{owner}/#{repo} -> #{issue_id}/#{issue_event_str}"', 'return', 'elsif', 'retrieved', '[', "'actor'", ']', '.', 'nil?', 'warn', '"Could not find issue_event_actor #{owner}/#{repo} -> #{issue_id}/#{issue_event_str}"', 'return', 'end', 'actor', '=', 'ensure_user', '(', 'retrieved', '[', "'actor'", ']', '[', "'login'", ']', ',', 'false', ',', 'false', ')', 'action_specific', '=', 'case', 'retrieved', '[', "'event'", ']', 'when', '"referenced"', 'then', 'retrieved', '[', "'commit_id'", ']', 'when', '"merged"', 'then', 'retrieved', '[', "'commit_id'", ']', 'when', '"closed"', 'then', 'retrieved', '[', "'commit_id'", ']', 'else', 'nil', 'end', 'if', 'retrieved', '[', "'event'", ']', '==', "'assigned'", 'def', 'update_assignee', '(', 'owner', ',', 'repo', ',', 'issue', ',', 'actor', ')', 'db', '[', ':issues', ']', '.', 'first', '(', ':id', '=>', 'issue', '[', ':id', ']', ')', '.', 'update', '(', ':assignee_id', '=>', 'actor', '[', ':id', ']', ')', 'info', '"Updated #{owner}/#{repo} -> #{issue[:id]}, assignee -> #{actor[:id]}"', 'end', 'if', 'issue', '[', ':assignee_id', ']', '.', 'nil?', 'then', 'update_assignee', '(', 'owner', ',', 'repo', ',', 'issue', ',', 'actor', ')', 'else', 'existing', '=', 'db', '[', ':issue_events', ']', '.', 'filter', '(', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ':action', '=>', "'assigned'", ')', '.', 'order', '(', 'Sequel', '.', 'desc', '(', ':created_at', ')', ')', '.', 'first', 'if', 'existing', '.', 'nil?', 'update_assignee', '(', 'owner', ',', 'repo', ',', 'issue', ',', 'actor', ')', 'elsif', 'date', '(', 'existing', '[', ':created_at', ']', ')', '<', 'date', '(', 'retrieved', '[', "'created_at'", ']', ')', 'update_assignee', '(', 'owner', ',', 'repo', ',', 'issue', ',', 'actor', ')', 'end', 'end', 'end', 'db', '[', ':issue_events', ']', '.', 'insert', '(', ':event_id', '=>', 'event_id', ',', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ':actor_id', '=>', 'unless', 'actor', '.', 'nil?', 'then', 'actor', '[', ':id', ']', 'end', ',', ':action', '=>', 'retrieved', '[', "'event'", ']', ',', ':action_specific', '=>', 'action_specific', ',', ':created_at', '=>', 'date', '(', 'retrieved', '[', "'created_at'", ']', ')', ')', 'info', '"Added issue_event #{owner}/#{repo} -> #{issue_id}/#{issue_event_str}"', 'db', '[', ':issue_events', ']', '.', 'first', '(', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ':event_id', '=>', 'event_id', ')', 'else', 'debug', '"Issue event #{owner}/#{repo} -> #{issue_id}/#{issue_event_str} exists"', 'curevent', 'end', 'end']
->Original Target:
['Retrieve', 'and', 'process', '+', 'event_id', '+', 'for', 'an', '+', 'issue_id', '+']
->Reconstructed Target:
Retrieve and process + event_id + for an + issue_id +
->Reconstructed Predication:
issue [ :assignee_id ]:id ] ). update:assignee_id ]. nil?:assignee_id ]. nil?:assignee_id ]. nil?:assignee_id ]. nil?:assignee_id ]. nil?:assignee_id ]. nil?:assignee_id ]. nil?:assignee_id ]. nil?:
->Raw Input:
summarize:def ensure_issue_event ( owner, repo, issue_id, event_id ) issue = ensure_issue ( owner, repo, issue_id, false, false, false ) if issue. nil? warn "Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving event #{event_id}" return end issue_event_str = "#{owner}/#{repo} -> #{issue_id}/#{event_id}" curevent = db [ :issue_events ]. first ( :issue_id => issue [ :id ], :event_id => event_id ) if curevent. nil? retrieved = retrieve_issue_event ( owner, repo, issue_id, event_id ) if retrieved. nil? warn "Could not retrieve issue_event #{owner}/#{repo} -> #{issue_id}/#{issue_event_str}" return elsif retrieved [ 'actor' ]. nil? warn "Could not find issue_event_actor #{owner}/#{repo} -> #{issue_id}/#{issue_event_str}" return end actor = ensure_user ( retrieved [ 'actor' ] [ 'login' ], false, false ) action_specific = case retrieved [ 'event' ] when "referenced" then retrieved [ 'commit_id' ] when "merged" then retrieved [ 'commit_id' ] when "closed" then retrieved [ 'commit_id' ] else nil end if retrieved [ 'event' ] == 'assigned' def update_assignee ( owner, repo, issue, actor ) db [ :issues ]. first ( :id => issue [ :id ] ). update ( :assignee_id => actor [ :id ] ) info "Updated #{owner}/#{repo} -> #{issue[:id]}, assignee -> #{actor[:id]}" end if issue [ :assignee_id ]. nil? then update_assignee ( owner, repo, issue, actor ) else existing = db [ :issue_events ]. filter ( :issue_id => issue [ :id ], :action => 'assigned' ). order ( Sequel. desc ( :created_at ) ). first if existing. nil? update_assignee ( owner, repo, issue, actor ) elsif date ( existing [ :created_at ] ) < date ( retrieved [ 'created_at' ] ) update_assignee ( owner, repo, issue, actor )
->Raw Target:
Retrieve and process + event_id + for an + issue_id +
--

213=========
->Original Input:
['def', 'ensure_issue_comments', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'pull_req_id', '=', 'nil', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'currepo', '.', 'nil?', 'warn', '"Could not find repository #{owner}/#{repo} for retrieving issue comments for issue #{issue_id}"', 'return', 'end', 'issue', '=', 'if', 'pull_req_id', '.', 'nil?', 'ensure_issue', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'false', ',', 'false', ',', 'false', ')', 'else', 'db', '[', ':issues', ']', '.', 'first', '(', ':pull_request_id', '=>', 'pull_req_id', ')', 'end', 'if', 'issue', '.', 'nil?', 'warn', '"Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving issue comments"', 'return', 'end', 'retrieve_issue_comments', '(', 'owner', ',', 'repo', ',', 'issue_id', ')', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'db', '[', ':issue_comments', ']', '.', 'first', '(', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ':comment_id', '=>', 'x', '[', "'id'", ']', ')', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_issue_comment', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'x', '[', "'id'", ']', ',', 'pull_req_id', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Retrieve', 'and', 'process', 'all', 'comments', 'for', 'an', 'issue', '.', 'If', 'pull_req_id', 'is', 'not', 'nil', 'this', 'means', 'that', 'we', 'are', 'only', 'retrieving', 'comments', 'for', 'the', 'pull', 'request', 'discussion', 'for', 'projects', 'that', 'don', 't', 'have', 'issues', 'enabled']
->Reconstructed Target:
Retrieve and process all comments for an issue. If pull_req_id is not nil this means that we are only retrieving comments for the pull request discussion for projects that don t have issues enabled
->Reconstructed Predication:
issue comments for the givenissue_id, pull_req_id )issue comments for the givenissue comments for the givenpull request" return end
->Raw Input:
summarize:def ensure_issue_comments ( owner, repo, issue_id, pull_req_id = nil ) currepo = ensure_repo ( owner, repo ) if currepo. nil? warn "Could not find repository #{owner}/#{repo} for retrieving issue comments for issue #{issue_id}" return end issue = if pull_req_id. nil? ensure_issue ( owner, repo, issue_id, false, false, false ) else db [ :issues ]. first ( :pull_request_id => pull_req_id ) end if issue. nil? warn "Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving issue comments" return end retrieve_issue_comments ( owner, repo, issue_id ). reduce ( [ ] ) do | acc, x | if db [ :issue_comments ]. first ( :issue_id => issue [ :id ], :comment_id => x [ 'id' ] ). nil? acc << x else acc end end. map { | x | save { ensure_issue_comment ( owner, repo, issue_id, x [ 'id' ], pull_req_id ) } }. select { | x |! x. nil? } end
->Raw Target:
Retrieve and process all comments for an issue. If pull_req_id is not nil this means that we are only retrieving comments for the pull request discussion for projects that don t have issues enabled
--

214=========
->Original Input:
['def', 'ensure_issue_comment', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'comment_id', ',', 'pull_req_id', '=', 'nil', ')', 'issue', '=', 'if', 'pull_req_id', '.', 'nil?', 'ensure_issue', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'false', ',', 'false', ',', 'false', ')', 'else', 'db', '[', ':issues', ']', '.', 'first', '(', ':pull_request_id', '=>', 'pull_req_id', ')', 'end', 'if', 'issue', '.', 'nil?', 'warn', '"Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving comment #{comment_id}"', 'return', 'end', 'issue_comment_str', '=', '"#{owner}/#{repo} -> #{issue_id}/#{comment_id}"', 'curcomment', '=', 'db', '[', ':issue_comments', ']', '.', 'first', '(', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ':comment_id', '=>', 'comment_id', ')', 'if', 'curcomment', '.', 'nil?', 'retrieved', '=', 'retrieve_issue_comment', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'comment_id', ')', 'if', 'retrieved', '.', 'nil?', 'warn', '"Could not retrieve issue_comment #{issue_comment_str}"', 'return', 'end', 'user', '=', 'ensure_user', '(', 'retrieved', '[', "'user'", ']', '[', "'login'", ']', ',', 'false', ',', 'false', ')', 'db', '[', ':issue_comments', ']', '.', 'insert', '(', ':comment_id', '=>', 'comment_id', ',', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ':user_id', '=>', 'unless', 'user', '.', 'nil?', 'then', 'user', '[', ':id', ']', 'end', ',', ':created_at', '=>', 'date', '(', 'retrieved', '[', "'created_at'", ']', ')', ')', 'info', '"Added issue_comment #{issue_comment_str}"', 'db', '[', ':issue_comments', ']', '.', 'first', '(', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ':comment_id', '=>', 'comment_id', ')', 'else', 'debug', '"Issue comment #{issue_comment_str} exists"', 'curcomment', 'end', 'end']
->Original Target:
['Retrieve', 'and', 'process', '+', 'comment_id', '+', 'for', 'an', '+', 'issue_id', '+']
->Reconstructed Target:
Retrieve and process + comment_id + for an + issue_id +
->Reconstructed Predication:
issue_comment_strcomment_id )comment_id )comment_id )comment_id )comment_id ) end
->Raw Input:
summarize:def ensure_issue_comment ( owner, repo, issue_id, comment_id, pull_req_id = nil ) issue = if pull_req_id. nil? ensure_issue ( owner, repo, issue_id, false, false, false ) else db [ :issues ]. first ( :pull_request_id => pull_req_id ) end if issue. nil? warn "Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving comment #{comment_id}" return end issue_comment_str = "#{owner}/#{repo} -> #{issue_id}/#{comment_id}" curcomment = db [ :issue_comments ]. first ( :issue_id => issue [ :id ], :comment_id => comment_id ) if curcomment. nil? retrieved = retrieve_issue_comment ( owner, repo, issue_id, comment_id ) if retrieved. nil? warn "Could not retrieve issue_comment #{issue_comment_str}" return end user = ensure_user ( retrieved [ 'user' ] [ 'login' ], false, false ) db [ :issue_comments ]. insert ( :comment_id => comment_id, :issue_id => issue [ :id ], :user_id => unless user. nil? then user [ :id ] end, :created_at => date ( retrieved [ 'created_at' ] ) ) info "Added issue_comment #{issue_comment_str}" db [ :issue_comments ]. first ( :issue_id => issue [ :id ], :comment_id => comment_id ) else debug "Issue comment #{issue_comment_str} exists" curcomment end end
->Raw Target:
Retrieve and process + comment_id + for an + issue_id +
--

215=========
->Original Input:
['def', 'ensure_labels', '(', 'owner', ',', 'repo', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'currepo', '.', 'nil?', 'warn', '"Could not find #{owner}/#{repo} for retrieving issue labels"', 'return', 'end', 'repo_labels', '=', 'db', '[', ':repo_labels', ']', '.', 'filter', '(', ':repo_id', '=>', 'currepo', '[', ':id', ']', ')', '.', 'all', 'retrieve_repo_labels', '(', 'owner', ',', 'repo', ')', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'repo_labels', '.', 'find', '{', '|', 'y', '|', 'y', '[', ':name', ']', '==', 'x', '[', "'name'", ']', '}', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_repo_label', '(', 'owner', ',', 'repo', ',', 'x', '[', "'name'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Retrieve', 'repository', 'issue', 'labels']
->Reconstructed Target:
Retrieve repository issue labels
->Reconstructed Predication:
repo_labelsrepo_labels = repo_labels.repo_labels.repo_labels.repo_labels.repo_labels.
->Raw Input:
summarize:def ensure_labels ( owner, repo ) currepo = ensure_repo ( owner, repo ) if currepo. nil? warn "Could not find #{owner}/#{repo} for retrieving issue labels" return end repo_labels = db [ :repo_labels ]. filter ( :repo_id => currepo [ :id ] ). all retrieve_repo_labels ( owner, repo ). reduce ( [ ] ) do | acc, x | if repo_labels. find { | y | y [ :name ] == x [ 'name' ] }. nil? acc << x else acc end end. map { | x | save { ensure_repo_label ( owner, repo, x [ 'name' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Retrieve repository issue labels
--

216=========
->Original Input:
['def', 'ensure_repo_label', '(', 'owner', ',', 'repo', ',', 'name', ')', 'currepo', '=', 'ensure_repo', '(', 'owner', ',', 'repo', ')', 'if', 'currepo', '.', 'nil?', 'warn', '"Could not find #{owner}/#{repo} for retrieving label #{name}"', 'return', 'end', 'label', '=', 'db', '[', ':repo_labels', ']', '.', 'first', '(', ':repo_id', '=>', 'currepo', '[', ':id', ']', ',', ':name', '=>', 'name', ')', 'if', 'label', '.', 'nil?', 'retrieved', '=', 'retrieve_repo_label', '(', 'owner', ',', 'repo', ',', 'name', ')', 'if', 'retrieved', '.', 'nil?', 'warn', '"Could not retrieve repo_label #{owner}/#{repo} -> #{name}"', 'return', 'end', 'db', '[', ':repo_labels', ']', '.', 'insert', '(', ':repo_id', '=>', 'currepo', '[', ':id', ']', ',', ':name', '=>', 'name', ')', 'info', '"Added repo_label #{owner}/#{repo} -> #{name}"', 'db', '[', ':repo_labels', ']', '.', 'first', '(', ':repo_id', '=>', 'currepo', '[', ':id', ']', ',', ':name', '=>', 'name', ')', 'else', 'label', 'end', 'end']
->Original Target:
['Retrieve', 'a', 'single', 'repository', 'issue', 'label', 'by', 'name']
->Reconstructed Target:
Retrieve a single repository issue label by name
->Reconstructed Predication:
repo_label #{owner}/#{repo} -> #{name}" return
->Raw Input:
summarize:def ensure_repo_label ( owner, repo, name ) currepo = ensure_repo ( owner, repo ) if currepo. nil? warn "Could not find #{owner}/#{repo} for retrieving label #{name}" return end label = db [ :repo_labels ]. first ( :repo_id => currepo [ :id ], :name => name ) if label. nil? retrieved = retrieve_repo_label ( owner, repo, name ) if retrieved. nil? warn "Could not retrieve repo_label #{owner}/#{repo} -> #{name}" return end db [ :repo_labels ]. insert ( :repo_id => currepo [ :id ], :name => name ) info "Added repo_label #{owner}/#{repo} -> #{name}" db [ :repo_labels ]. first ( :repo_id => currepo [ :id ], :name => name ) else label end end
->Raw Target:
Retrieve a single repository issue label by name
--

217=========
->Original Input:
['def', 'ensure_issue_labels', '(', 'owner', ',', 'repo', ',', 'issue_id', ')', 'issue', '=', 'ensure_issue', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'false', ',', 'false', ',', 'false', ')', 'if', 'issue', '.', 'nil?', 'warn', '"Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving labels"', 'return', 'end', 'issue_labels', '=', 'db', '.', 'from', '(', ':issue_labels', ',', ':repo_labels', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'issue_labels'", ',', "'label_id'", ')', '=>', 'Sequel', '.', 'qualify', '(', "'repo_labels'", ',', "'id'", ')', ')', '.', 'where', '(', 'Sequel', '.', 'qualify', '(', "'issue_labels'", ',', "'issue_id'", ')', '=>', 'issue', '[', ':id', ']', ')', '.', 'select', '(', 'Sequel', '.', 'qualify', '(', "'repo_labels'", ',', "'name'", ')', ')', '.', 'all', 'retrieve_issue_labels', '(', 'owner', ',', 'repo', ',', 'issue_id', ')', '.', 'reduce', '(', '[', ']', ')', 'do', '|', 'acc', ',', 'x', '|', 'if', 'issue_labels', '.', 'find', '{', '|', 'y', '|', 'y', '[', ':name', ']', '==', 'x', '[', "'name'", ']', '}', '.', 'nil?', 'acc', '<<', 'x', 'else', 'acc', 'end', 'end', '.', 'map', '{', '|', 'x', '|', 'save', '{', 'ensure_issue_label', '(', 'owner', ',', 'repo', ',', 'issue', '[', ':issue_id', ']', ',', 'x', '[', "'name'", ']', ')', '}', '}', '.', 'select', '{', '|', 'x', '|', '!', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Ensure', 'that', 'all', 'labels', 'have', 'been', 'assigned', 'to', 'the', 'issue']
->Reconstructed Target:
Ensure that all labels have been assigned to the issue
->Reconstructed Predication:
( owner, repo,, issue_id )issue_id ], issue [). select (). select (). select (). select (). select (). select (). select (). select (). select (). select (). select (). select (). select (). select (). select ().
->Raw Input:
summarize:def ensure_issue_labels ( owner, repo, issue_id ) issue = ensure_issue ( owner, repo, issue_id, false, false, false ) if issue. nil? warn "Could not find issue #{owner}/#{repo} -> #{issue_id} for retrieving labels" return end issue_labels = db. from ( :issue_labels, :repo_labels ). where ( Sequel. qualify ( 'issue_labels', 'label_id' ) => Sequel. qualify ('repo_labels', 'id' ) ). where ( Sequel. qualify ( 'issue_labels', 'issue_id' ) => issue [ :id ] ). select ( Sequel. qualify ('repo_labels', 'name' ) ). all retrieve_issue_labels ( owner, repo, issue_id ). reduce ( [ ] ) do | acc, x | if issue_labels. find { | y | y [ :name ] == x [ 'name' ] }. nil? acc << x else acc end end. map { | x | save { ensure_issue_label ( owner, repo, issue [ :issue_id ], x [ 'name' ] ) } }. select { | x |! x. nil? } end
->Raw Target:
Ensure that all labels have been assigned to the issue
--

218=========
->Original Input:
['def', 'ensure_issue_label', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'name', ')', 'issue', '=', 'ensure_issue', '(', 'owner', ',', 'repo', ',', 'issue_id', ',', 'false', ',', 'false', ',', 'false', ')', 'if', 'issue', '.', 'nil?', 'warn', '"Could not find issue #{owner}/#{repo} -> #{issue_id} to assign label #{name}"', 'return', 'end', 'label', '=', 'ensure_repo_label', '(', 'owner', ',', 'repo', ',', 'name', ')', 'if', 'label', '.', 'nil?', 'warn', '"Could not find repo label #{owner}/#{repo} -> #{name}"', 'return', 'end', 'issue_lbl', '=', 'db', '[', ':issue_labels', ']', '.', 'first', '(', ':label_id', '=>', 'label', '[', ':id', ']', ',', ':issue_id', '=>', 'issue', '[', ':id', ']', ')', 'if', 'issue_lbl', '.', 'nil?', 'db', '[', ':issue_labels', ']', '.', 'insert', '(', ':label_id', '=>', 'label', '[', ':id', ']', ',', ':issue_id', '=>', 'issue', '[', ':id', ']', ',', ')', 'info', '"Added issue_label #{name} to issue #{owner}/#{repo} -> #{issue_id}"', 'db', '[', ':issue_labels', ']', '.', 'first', '(', ':label_id', '=>', 'label', '[', ':id', ']', ',', ':issue_id', '=>', 'issue', '[', ':id', ']', ')', 'else', 'debug', '"Issue label #{name} to issue #{owner}/#{repo} -> #{issue_id} exists"', 'issue_lbl', 'end', 'end']
->Original Target:
['Ensure', 'that', 'a', 'specific', 'label', 'has', 'been', 'assigned', 'to', 'the', 'issue']
->Reconstructed Target:
Ensure that a specific label has been assigned to the issue
->Reconstructed Predication:
issue_idissue_id )issue_id )issue_id )issue_label #{name} to issue #{owner}/#{repo}issue_id"
->Raw Input:
summarize:def ensure_issue_label ( owner, repo, issue_id, name ) issue = ensure_issue ( owner, repo, issue_id, false, false, false ) if issue. nil? warn "Could not find issue #{owner}/#{repo} -> #{issue_id} to assign label #{name}" return end label = ensure_repo_label ( owner, repo, name ) if label. nil? warn "Could not find repo label #{owner}/#{repo} -> #{name}" return end issue_lbl = db [ :issue_labels ]. first ( :label_id => label [ :id ], :issue_id => issue [ :id ] ) if issue_lbl. nil? db [ :issue_labels ]. insert ( :label_id => label [ :id ], :issue_id => issue [ :id ], ) info "Added issue_label #{name} to issue #{owner}/#{repo} -> #{issue_id}" db [ :issue_labels ]. first ( :label_id => label [ :id ], :issue_id => issue [ :id ] ) else debug "Issue label #{name} to issue #{owner}/#{repo} -> #{issue_id} exists" issue_lbl end end
->Raw Target:
Ensure that a specific label has been assigned to the issue
--

219=========
->Original Input:
['def', 'transaction', '(', '&', 'block', ')', 'db', 'persister', 'result', '=', 'nil', 'start_time', '=', 'Time', '.', 'now', 'begin', 'db', '.', 'transaction', '(', ':rollback', '=>', ':reraise', ',', ':isolation', '=>', ':repeatable', ',', ':retry_on', '=>', '@retry_on_error', ',', ':num_retries', '=>', '3', ')', 'do', 'result', '=', 'yield', 'block', 'end', 'total', '=', 'Time', '.', 'now', '.', 'to_ms', '-', 'start_time', '.', 'to_ms', 'debug', '"Transaction committed (#{total} ms)"', 'result', 'rescue', 'StandardError', '=>', 'e', 'total', '=', 'Time', '.', 'now', '.', 'to_ms', '-', 'start_time', '.', 'to_ms', 'warn', '"Transaction failed (#{total} ms)"', 'raise', 'e', 'ensure', 'GC', '.', 'start', 'end', 'end']
->Original Target:
['Run', 'a', 'block', 'in', 'a', 'DB', 'transaction', '.', 'Exceptions', 'trigger', 'transaction', 'rollback', 'and', 'are', 'rethrown', '.']
->Reconstructed Target:
Run a block in a DB transaction. Exceptions trigger transaction rollback and are rethrown.
->Reconstructed Predication:
transaction
->Raw Input:
summarize:def transaction ( & block ) db persister result = nil start_time = Time. now begin db. transaction ( :rollback => :reraise, :isolation => :repeatable, :retry_on => @retry_on_error, :num_retries => 3 ) do result = yield block end total = Time. now. to_ms - start_time. to_ms debug "Transaction committed (#{total} ms)" result rescue StandardError => e total = Time. now. to_ms - start_time. to_ms warn "Transaction failed (#{total} ms)" raise e ensure GC. start end end
->Raw Target:
Run a block in a DB transaction. Exceptions trigger transaction rollback and are rethrown.
--

220=========
->Original Input:
['def', 'store_commit', '(', 'c', ',', 'repo', ',', 'user', ')', 'commits', '=', 'db', '[', ':commits', ']', 'commit', '=', 'commits', '.', 'first', '(', ':sha', '=>', 'c', '[', "'sha'", ']', ')', 'if', 'commit', '.', 'nil?', 'author', '=', 'commit_user', '(', 'c', '[', "'author'", ']', ',', 'c', '[', "'commit'", ']', '[', "'author'", ']', ')', 'commiter', '=', 'commit_user', '(', 'c', '[', "'committer'", ']', ',', 'c', '[', "'commit'", ']', '[', "'committer'", ']', ')', 'repository', '=', 'ensure_repo', '(', 'user', ',', 'repo', ')', 'if', 'repository', '.', 'nil?', 'warn', '"Could not find repo #{user}/#{repo} for storing commit #{c[\'sha\']}"', 'end', 'commits', '.', 'insert', '(', ':sha', '=>', 'c', '[', "'sha'", ']', ',', ':author_id', '=>', 'author', '[', ':id', ']', ',', ':committer_id', '=>', 'commiter', '[', ':id', ']', ',', ':project_id', '=>', 'if', 'repository', '.', 'nil?', 'then', 'nil', 'else', 'repository', '[', ':id', ']', 'end', ',', ':created_at', '=>', 'date', '(', 'c', '[', "'commit'", ']', '[', "'author'", ']', '[', "'date'", ']', ')', ')', 'info', '"Added commit #{user}/#{repo} -> #{c[\'sha\']} "', 'commits', '.', 'first', '(', ':sha', '=>', 'c', '[', "'sha'", ']', ')', 'else', 'debug', '"Commit #{user}/#{repo} -> #{c[\'sha\']} exists"', 'commit', 'end', 'end']
->Original Target:
['Store', 'a', 'commit', 'contained', 'in', 'a', 'hash', '.', 'First', 'check', 'whether', 'the', 'commit', 'exists', '.']
->Reconstructed Target:
Store a commit contained in a hash. First check whether the commit exists.
->Reconstructed Predication:
commit #{user}/#{repo} -> #{c['sha']}commit #{c['sha']}commit #{c['sha']}commit #{user}/#{repo} -> #{c['sha']}commit #{c['sha']} is notcommit #{c['sha']} exists" commit = db
->Raw Input:
summarize:def store_commit ( c, repo, user ) commits = db [ :commits ] commit = commits. first ( :sha => c ['sha' ] ) if commit. nil? author = commit_user ( c [ 'author' ], c [ 'commit' ] [ 'author' ] ) commiter = commit_user ( c [ 'committer' ], c [ 'commit' ] [ 'committer' ] ) repository = ensure_repo ( user, repo ) if repository. nil? warn "Could not find repo #{user}/#{repo} for storing commit #{c['sha']}" end commits. insert ( :sha => c ['sha' ], :author_id => author [ :id ], :committer_id => commiter [ :id ], :project_id => if repository. nil? then nil else repository [ :id ] end, :created_at => date ( c [ 'commit' ] [ 'author' ] [ 'date' ] ) ) info "Added commit #{user}/#{repo} -> #{c['sha']} " commits. first ( :sha => c ['sha' ] ) else debug "Commit #{user}/#{repo} -> #{c['sha']} exists" commit end end
->Raw Target:
Store a commit contained in a hash. First check whether the commit exists.
--

221=========
->Original Input:
['def', 'log', '(', 'level', ',', 'msg', ')', 'case', 'level', 'when', ':fatal', 'then', 'loggerr', '.', 'fatal', '(', 'retrieve_caller', '+', 'msg', ')', 'when', ':error', 'then', 'loggerr', '.', 'error', '(', 'retrieve_caller', '+', 'msg', ')', 'when', ':warn', 'then', 'loggerr', '.', 'warn', '(', 'retrieve_caller', '+', 'msg', ')', 'when', ':info', 'then', 'loggerr', '.', 'info', '(', 'retrieve_caller', '+', 'msg', ')', 'when', ':debug', 'then', 'loggerr', '.', 'debug', '(', 'retrieve_caller', '+', 'msg', ')', 'else', 'loggerr', '.', 'debug', '(', 'retrieve_caller', '+', 'msg', ')', 'end', 'end']
->Original Target:
['Log', 'a', 'message', 'at', 'the', 'given', 'level', '.']
->Reconstructed Target:
Log a message at the given level.
->Reconstructed Predication:
the log message
->Raw Input:
summarize:def log ( level, msg ) case level when :fatal then loggerr. fatal ( retrieve_caller + msg ) when :error then loggerr. error ( retrieve_caller + msg ) when :warn then loggerr. warn ( retrieve_caller + msg ) when :info then loggerr. info ( retrieve_caller + msg ) when :debug then loggerr. debug ( retrieve_caller + msg ) else loggerr. debug ( retrieve_caller + msg ) end end
->Raw Target:
Log a message at the given level.
--

222=========
->Original Input:
['def', 'paged_api_request', '(', 'url', ',', 'pages', '=', 'config', '(', ':mirror_history_pages_back', ')', ',', 'last', '=', 'nil', ')', 'url', '=', 'ensure_max_per_page', '(', 'url', ')', 'data', '=', 'api_request_raw', '(', 'url', ')', 'return', '[', ']', 'if', 'data', '.', 'nil?', 'unless', 'data', '.', 'meta', '[', "'link'", ']', '.', 'nil?', 'links', '=', 'parse_links', '(', 'data', '.', 'meta', '[', "'link'", ']', ')', 'last', '=', 'links', '[', "'last'", ']', 'if', 'last', '.', 'nil?', 'if', 'pages', '>', '0', 'pages', '=', 'pages', '-', '1', 'if', 'pages', '==', '0', 'return', 'parse_request_result', '(', 'data', ')', 'end', 'end', 'if', 'links', '[', "'next'", ']', '.', 'nil?', 'parse_request_result', '(', 'data', ')', 'else', 'parse_request_result', '(', 'data', ')', '|', 'paged_api_request', '(', 'links', '[', "'next'", ']', ',', 'pages', ',', 'last', ')', 'end', 'else', 'parse_request_result', '(', 'data', ')', 'end', 'end']
->Original Target:
['A', 'paged', 'request', '.', 'Used', 'when', 'the', 'result', 'can', 'expand', 'to', 'more', 'than', 'one', 'result', 'pages', '.']
->Reconstructed Target:
A paged request. Used when the result can expand to more than one result pages.
->Reconstructed Predication:
pagepage_number = pages. to_ipage_number = pages. to_ipage_number = pages. to_ipage_number = pages. to_ipage_number = pages. to_ipage_number = pages. to_ipage_number = pages. to_ipage_number = pages. to_ipage_number ) page_number = pagespage_number ) page
->Raw Input:
summarize:def paged_api_request ( url, pages = config ( :mirror_history_pages_back ), last = nil ) url = ensure_max_per_page ( url ) data = api_request_raw ( url ) return [ ] if data. nil? unless data. meta [ 'link' ]. nil? links = parse_links ( data. meta [ 'link' ] ) last = links [ 'last' ] if last. nil? if pages > 0 pages = pages - 1 if pages == 0 return parse_request_result ( data ) end end if links [ 'next' ]. nil? parse_request_result ( data ) else parse_request_result ( data ) | paged_api_request ( links [ 'next' ], pages, last ) end else parse_request_result ( data ) end end
->Raw Target:
A paged request. Used when the result can expand to more than one result pages.
--

223=========
->Original Input:
['def', 'last_updated', '(', 'url', ',', 'etag', ')', 'begin', 'ts', '=', 'Time', '.', 'now', 'response', '=', 'do_request', '(', 'url', ',', "''", ',', 'etag', ')', 'info', '"Successful etag request. URL: #{url}, Etag: #{etag}, Remaining: #{@remaining}, Total: #{Time.now.to_ms - ts.to_ms} ms"', 'rescue', 'OpenURI', '::', 'HTTPError', '=>', 'e', 'response', '=', 'e', '.', 'io', 'if', 'response', '.', 'status', '.', 'first', '!=', "'304'", 'etag_request_error_message', '(', 'url', ',', 'e', ',', 'etag', ')', 'raise', 'e', 'end', 'end', 'return', 'Time', '.', 'parse', '(', 'response', '.', 'meta', '[', "'last-modified'", ']', ')', 'unless', 'response', '.', 'meta', '[', "'last-modified'", ']', '.', 'nil?', 'return', 'Time', '.', 'at', '(', '86400', ')', 'end']
->Original Target:
['Check', 'whether', 'the', 'resource', 'identified', 'by', 'the', 'provided', 'url', 'has', 'changed']
->Reconstructed Target:
Check whether the resource identified by the provided url has changed
->Reconstructed Predication:
the last modified time ofthe last modified time of thethe last modified time.the last modified time.the last modified time. The last
->Raw Input:
summarize:def last_updated ( url, etag ) begin ts = Time. now response = do_request ( url, '', etag ) info "Successful etag request. URL: #{url}, Etag: #{etag}, Remaining: #{@remaining}, Total: #{Time.now.to_ms - ts.to_ms} ms" rescue OpenURI :: HTTPError => e response = e. io if response. status. first!= '304' etag_request_error_message ( url, e, etag ) raise e end end return Time. parse ( response. meta [ 'last-modified' ] ) unless response. meta [ 'last-modified' ]. nil? return Time. at ( 86400 ) end
->Raw Target:
Check whether the resource identified by the provided url has changed
--

224=========
->Original Input:
['def', 'num_pages', '(', 'url', ')', 'url', '=', 'ensure_max_per_page', '(', 'url', ')', 'data', '=', 'api_request_raw', '(', 'url', ')', 'if', 'data', '.', 'nil?', 'or', 'data', '.', 'meta', '.', 'nil?', 'or', 'data', '.', 'meta', '[', "'link'", ']', '.', 'nil?', 'return', '1', 'end', 'links', '=', 'parse_links', '(', 'data', '.', 'meta', '[', "'link'", ']', ')', 'if', 'links', '.', 'nil?', 'or', 'links', '[', "'last'", ']', '.', 'nil?', 'return', '1', 'end', 'params', '=', 'CGI', '::', 'parse', '(', 'URI', '::', 'parse', '(', 'links', '[', "'last'", ']', ')', '.', 'query', ')', 'params', '[', "'page'", ']', '[', '0', ']', '.', 'to_i', 'end']
->Original Target:
['Determine', 'the', 'number', 'of', 'pages', 'contained', 'in', 'a', 'multi', '-', 'page', 'API', 'response']
->Reconstructed Target:
Determine the number of pages contained in a multi - page API response
->Reconstructed Predication:
the page number of thethe page number of the page
->Raw Input:
summarize:def num_pages ( url ) url = ensure_max_per_page ( url ) data = api_request_raw ( url ) if data. nil? or data. meta. nil? or data. meta [ 'link' ]. nil? return 1 end links = parse_links ( data. meta [ 'link' ] ) if links. nil? or links [ 'last' ]. nil? return 1 end params = CGI :: parse ( URI :: parse ( links [ 'last' ] ). query ) params [ 'page' ] [ 0 ]. to_i end
->Raw Target:
Determine the number of pages contained in a multi - page API response
--

225=========
->Original Input:
['def', 'parse_links', '(', 'links', ')', 'links', '.', 'split', '(', '/', '/', ')', '.', 'reduce', '(', '{', '}', ')', 'do', '|', 'acc', ',', 'x', '|', 'matches', '=', 'x', '.', 'strip', '.', 'match', '(', '/', '\\"', '\\"', '/', ')', 'acc', '[', 'matches', '[', '2', ']', ']', '=', 'matches', '[', '1', ']', 'acc', 'end', 'end']
->Original Target:
['Parse', 'a', 'Github', 'link', 'header']
->Reconstructed Target:
Parse a Github link header
->Reconstructed Predication:
the links to the link
->Raw Input:
summarize:def parse_links ( links ) links. split ( / / ). reduce ( { } ) do | acc, x | matches = x. strip. match ( / \" \" / ) acc [ matches [ 2 ] ] = matches [ 1 ] acc end end
->Raw Target:
Parse a Github link header
--

226=========
->Original Input:
['def', 'parse_request_result', '(', 'result', ')', 'if', 'result', '.', 'nil?', '[', ']', 'else', 'json', '=', 'result', '.', 'read', 'if', 'json', '.', 'nil?', '[', ']', 'else', 'r', '=', 'JSON', '.', 'parse', '(', 'json', ')', 'if', 'result', '.', 'meta', '[', "'etag'", ']', 'and', 'r', '.', 'class', '!=', 'Array', 'r', '[', "'etag'", ']', '=', 'result', '.', 'meta', '[', "'etag'", ']', 'end', 'r', 'end', 'end', 'end']
->Original Target:
['Parse', 'the', 'JSON', 'result', 'array']
->Reconstructed Target:
Parse the JSON result array
->Reconstructed Predication:
the result of the request
->Raw Input:
summarize:def parse_request_result ( result ) if result. nil? [ ] else json = result. read if json. nil? [ ] else r = JSON. parse ( json ) if result. meta [ 'etag' ] and r. class!= Array r [ 'etag' ] = result. meta [ 'etag' ] end r end end end
->Raw Target:
Parse the JSON result array
--

227=========
->Original Input:
['def', 'api_request_raw', '(', 'url', ',', 'media_type', '=', "''", ')', 'begin', 'start_time', '=', 'Time', '.', 'now', 'contents', '=', 'do_request', '(', 'url', ',', 'media_type', ')', 'total', '=', 'Time', '.', 'now', '.', 'to_ms', '-', 'start_time', '.', 'to_ms', 'info', '"Successful request. URL: #{url}, Remaining: #{@remaining}, Total: #{total} ms"', 'contents', 'rescue', 'OpenURI', '::', 'HTTPError', '=>', 'e', '@remaining', '=', 'e', '.', 'io', '.', 'meta', '[', "'x-ratelimit-remaining'", ']', '.', 'to_i', '@reset', '=', 'e', '.', 'io', '.', 'meta', '[', "'x-ratelimit-reset'", ']', '.', 'to_i', 'case', 'e', '.', 'io', '.', 'status', '[', '0', ']', '.', 'to_i', 'when', '400', ',', '403', ',', '404', ',', '409', ',', '422', 'then', 'warn', 'request_error_msg', '(', 'url', ',', 'e', ')', 'return', 'nil', 'when', '401', 'warn', 'request_error_msg', '(', 'url', ',', 'e', ')', 'warn', '"Unauthorised request with token: #{@token}"', 'raise', 'e', 'when', '451', 'warn', 'request_error_msg', '(', 'url', ',', 'e', ')', 'warn', '"Repo was taken down (DMCA)"', 'return', 'nil', 'else', 'warn', 'request_error_msg', '(', 'url', ',', 'e', ')', 'raise', 'e', 'end', 'rescue', 'StandardError', '=>', 'e', 'warn', 'error_msg', '(', 'url', ',', 'e', ')', 'raise', 'e', 'ensure', 'if', '@remaining', '<', '@req_limit', 'to_sleep', '=', '@reset', '-', 'Time', '.', 'now', '.', 'to_i', '+', '2', 'warn', '"Request limit reached, reset in: #{to_sleep} secs"', 't', '=', 'Thread', '.', 'new', 'do', 'slept', '=', '0', 'while', 'true', 'do', 'debug', '"Sleeping for #{to_sleep - slept} seconds"', 'sleep', '1', 'slept', '+=', '1', 'end', 'end', 'sleep', '(', '[', '0', ',', 'to_sleep', ']', '.', 'max', ')', 't', '.', 'exit', 'end', 'end', 'end']
->Original Target:
['Do', 'the', 'actual', 'request', 'and', 'return', 'the', 'result', 'object']
->Reconstructed Target:
Do the actual request and return the result object
->Reconstructed Predication:
@remaining = @remaining - Time. now. to_i@remaining@reset = @reset - Time. now. to_i@remaining@remaining = @remaining - Timeto_i + 2to_sleep + 2to_sleep + 2 )to_sleep + 2 )to_sleep + 2 )to_sleep + 2 )to_sleep + 2 )to_sleep + 2 )
->Raw Input:
summarize:def api_request_raw ( url, media_type = '' ) begin start_time = Time. now contents = do_request ( url, media_type ) total = Time. now. to_ms - start_time. to_ms info "Successful request. URL: #{url}, Remaining: #{@remaining}, Total: #{total} ms" contents rescue OpenURI :: HTTPError => e @remaining = e. io. meta [ 'x-ratelimit-remaining' ]. to_i @reset = e. io. meta [ 'x-ratelimit-reset' ]. to_i case e. io. status [ 0 ]. to_i when 400, 403, 404, 409, 422 then warn request_error_msg ( url, e ) return nil when 401 warn request_error_msg ( url, e ) warn "Unauthorised request with token: #{@token}" raise e when 451 warn request_error_msg ( url, e ) warn "Repo was taken down (DMCA)" return nil else warn request_error_msg ( url, e ) raise e end rescue StandardError => e warn error_msg ( url, e ) raise e ensure if @remaining < @req_limit to_sleep = @reset - Time. now. to_i + 2 warn "Request limit reached, reset in: #{to_sleep} secs" t = Thread. new do slept = 0 while true do debug "Sleeping for #{to_sleep - slept} seconds" sleep 1 slept += 1 end end sleep ( [ 0, to_sleep ]. max ) t. exit end end end
->Raw Target:
Do the actual request and return the result object
--

228=========
->Original Input:
['def', 'attach_to', '(', 'ip', ')', 'TCPSocket', '.', 'instance_eval', 'do', '(', 'class', '<<', 'self', ';', 'self', ';', 'end', ')', '.', 'instance_eval', 'do', 'alias_method', ':original_open', ',', ':open', 'case', 'RUBY_VERSION', 'when', '/', '/', ',', '/', '/', 'define_method', '(', ':open', ')', 'do', '|', 'conn_address', ',', 'conn_port', '|', 'original_open', '(', 'conn_address', ',', 'conn_port', ',', 'ip', ')', 'end', 'else', 'define_method', '(', ':open', ')', 'do', '|', 'conn_address', ',', 'conn_port', ',', 'local_host', ',', 'local_port', '|', 'original_open', '(', 'conn_address', ',', 'conn_port', ',', 'ip', ',', 'local_port', ')', 'end', 'end', 'end', 'end', 'result', '=', 'begin', 'yield', 'rescue', 'StandardError', '=>', 'e', 'raise', 'e', 'ensure', 'TCPSocket', '.', 'instance_eval', 'do', '(', 'class', '<<', 'self', ';', 'self', ';', 'end', ')', '.', 'instance_eval', 'do', 'alias_method', ':open', ',', ':original_open', 'remove_method', ':original_open', 'end', 'end', 'end', 'result', 'end']
->Original Target:
['Attach', 'to', 'a', 'specific', 'IP', 'address', 'if', 'the', 'machine', 'has', 'multiple']
->Reconstructed Target:
Attach to a specific IP address if the machine has multiple
->Reconstructed Predication:
the socket to the given address
->Raw Input:
summarize:def attach_to ( ip ) TCPSocket. instance_eval do ( class << self ; self ; end ). instance_eval do alias_method :original_open, :open case RUBY_VERSION when / /, / / define_method ( :open ) do | conn_address, conn_port | original_open ( conn_address, conn_port, ip ) end else define_method ( :open ) do | conn_address, conn_port, local_host, local_port | original_open ( conn_address, conn_port, ip, local_port ) end end end end result = begin yield rescue StandardError => e raise e ensure TCPSocket. instance_eval do ( class << self ; self ; end ). instance_eval do alias_method :open, :original_open remove_method :original_open end end end result end
->Raw Target:
Attach to a specific IP address if the machine has multiple
--

229=========
->Original Input:
['def', 'connect', '(', 'adapter', ',', 'settings', ')', 'driver', '=', 'ADAPTERS', '[', 'adapter', '.', 'intern', ']', 'driver', '.', 'new', '(', 'settings', ')', 'end']
->Original Target:
['Factory', 'method', 'for', 'retrieving', 'persistence', 'connections', '.', 'The', '+', 'settings', '+', 'argument', 'is', 'a', 'fully', 'parsed', 'YAML', 'document', 'passed', 'on', 'to', 'adapters', '.', 'The', 'available', '+', 'adapter', '+', 'are', 'mongo', 'and', 'noop']
->Reconstructed Target:
Factory method for retrieving persistence connections. The + settings + argument is a fully parsed YAML document passed on to adapters. The available + adapter + are mongo and noop
->Reconstructed Predication:
 def connect ( adapter)
->Raw Input:
summarize:def connect ( adapter, settings ) driver = ADAPTERS [ adapter. intern ] driver. new ( settings ) end
->Raw Target:
Factory method for retrieving persistence connections. The + settings + argument is a fully parsed YAML document passed on to adapters. The available + adapter + are mongo and noop
--

230=========
->Original Input:
['def', 'retrieve_commit', '(', 'repo', ',', 'sha', ',', 'user', ')', 'commit', '=', 'persister', '.', 'find', '(', ':commits', ',', '{', "'sha'", '=>', '"#{sha}"', '}', ')', 'if', 'commit', '.', 'empty?', 'url', '=', 'ghurl', '"repos/#{user}/#{repo}/commits/#{sha}"', 'c', '=', 'api_request', '(', 'url', ')', 'if', 'c', '.', 'nil?', 'or', 'c', '.', 'empty?', 'return', 'end', 'if', 'config', '(', ':commit_handling', ')', '==', "'trim'", 'c', '[', "'files'", ']', '.', 'each', '{', '|', 'file', '|', 'file', '.', 'delete', '(', "'patch'", ')', '}', 'end', 'persister', '.', 'store', '(', ':commits', ',', 'c', ')', 'info', '"Added commit #{user}/#{repo} -> #{sha}"', 'c', 'else', 'debug', '"Commit #{user}/#{repo} -> #{sha} exists"', 'commit', '.', 'first', 'end', 'end']
->Original Target:
['Retrieve', 'a', 'single', 'commit', 'from', 'a', 'repo']
->Reconstructed Target:
Retrieve a single commit from a repo
->Reconstructed Predication:
commit for a given commitcommit for a given commitcommitcommit. first commit
->Raw Input:
summarize:def retrieve_commit ( repo, sha, user ) commit = persister. find ( :commits, {'sha' => "#{sha}" } ) if commit. empty? url = ghurl "repos/#{user}/#{repo}/commits/#{sha}" c = api_request ( url ) if c. nil? or c. empty? return end if config ( :commit_handling ) == 'trim' c [ 'files' ]. each { | file | file. delete ( 'patch' ) } end persister. store ( :commits, c ) info "Added commit #{user}/#{repo} -> #{sha}" c else debug "Commit #{user}/#{repo} -> #{sha} exists" commit. first end end
->Raw Target:
Retrieve a single commit from a repo
--

231=========
->Original Input:
['def', 'retrieve_commits', '(', 'repo', ',', 'sha', ',', 'user', ',', 'pages', '=', '-', '1', ')', 'url', '=', 'if', 'sha', '.', 'nil?', 'ghurl', '"repos/#{user}/#{repo}/commits"', 'else', 'ghurl', '"repos/#{user}/#{repo}/commits?sha=#{sha}"', 'end', 'commits', '=', 'restricted_page_request', '(', 'url', ',', 'pages', ')', 'commits', '.', 'map', 'do', '|', 'c', '|', 'retrieve_commit', '(', 'repo', ',', 'c', '[', "'sha'", ']', ',', 'user', ')', 'end', '.', 'select', '{', '|', 'x', '|', 'not', 'x', '.', 'nil?', '}', 'end']
->Original Target:
['Retrieve', 'commits', 'starting', 'from', 'the', 'provided', '+', 'sha', '+']
->Reconstructed Target:
Retrieve commits starting from the provided + sha +
->Reconstructed Predication:
the commits for the given
->Raw Input:
summarize:def retrieve_commits ( repo, sha, user, pages = - 1 ) url = if sha. nil? ghurl "repos/#{user}/#{repo}/commits" else ghurl "repos/#{user}/#{repo}/commits?sha=#{sha}" end commits = restricted_page_request ( url, pages ) commits. map do | c | retrieve_commit ( repo, c ['sha' ], user ) end. select { | x | not x. nil? } end
->Raw Target:
Retrieve commits starting from the provided + sha +
--

232=========
->Original Input:
['def', 'retrieve_orgs', '(', 'user', ')', 'url', '=', 'ghurl', '"users/#{user}/orgs"', 'orgs', '=', 'paged_api_request', '(', 'url', ')', 'orgs', '.', 'map', '{', '|', 'o', '|', 'retrieve_org', '(', 'o', '[', "'login'", ']', ')', '}', 'end']
->Original Target:
['Retrieve', 'organizations', 'the', 'provided', 'user', 'participates', 'into']
->Reconstructed Target:
Retrieve organizations the provided user participates into
->Reconstructed Predication:
the organization for the user
->Raw Input:
summarize:def retrieve_orgs ( user ) url = ghurl "users/#{user}/orgs" orgs = paged_api_request ( url ) orgs. map { | o | retrieve_org ( o [ 'login' ] ) } end
->Raw Target:
Retrieve organizations the provided user participates into
--

233=========
->Original Input:
['def', 'retrieve_watchers', '(', 'user', ',', 'repo', ')', 'repo_bound_items', '(', 'user', ',', 'repo', ',', ':watchers', ',', '[', '"repos/#{user}/#{repo}/stargazers"', ']', ',', '{', "'repo'", '=>', 'repo', ',', "'owner'", '=>', 'user', '}', ',', "'login'", ',', 'item', '=', 'nil', ',', 'refresh', '=', 'false', ',', 'order', '=', ':desc', ')', 'end']
->Original Target:
['Retrieve', 'all', 'watchers', 'for', 'a', 'repository']
->Reconstructed Target:
Retrieve all watchers for a repository
->Reconstructed Predication:
the list of stargazers forthe list of stargazers for thethe list of stargazers forthe list of stargazers for thethe list of stargazers for the
->Raw Input:
summarize:def retrieve_watchers ( user, repo ) repo_bound_items ( user, repo, :watchers, [ "repos/#{user}/#{repo}/stargazers" ], {'repo' => repo, 'owner' => user }, 'login', item = nil, refresh = false, order = :desc ) end
->Raw Target:
Retrieve all watchers for a repository
--

234=========
->Original Input:
['def', 'retrieve_watcher', '(', 'user', ',', 'repo', ',', 'watcher', ')', 'repo_bound_item', '(', 'user', ',', 'repo', ',', 'watcher', ',', ':watchers', ',', '[', '"repos/#{user}/#{repo}/stargazers"', ']', ',', '{', "'repo'", '=>', 'repo', ',', "'owner'", '=>', 'user', '}', ',', "'login'", ',', 'order', '=', ':desc', ')', 'end']
->Original Target:
['Retrieve', 'a', 'single', 'watcher', 'for', 'a', 'repository']
->Reconstructed Target:
Retrieve a single watcher for a repository
->Reconstructed Predication:
the watcher to retrieve. 
->Raw Input:
summarize:def retrieve_watcher ( user, repo, watcher ) repo_bound_item ( user, repo, watcher, :watchers, [ "repos/#{user}/#{repo}/stargazers" ], {'repo' => repo, 'owner' => user }, 'login', order = :desc ) end
->Raw Target:
Retrieve a single watcher for a repository
--

235=========
->Original Input:
['def', 'get_repo_events', '(', 'owner', ',', 'repo', ')', 'url', '=', 'ghurl', '(', '"repos/#{owner}/#{repo}/events"', ')', 'r', '=', 'paged_api_request', '(', 'url', ')', 'r', '.', 'each', 'do', '|', 'e', '|', 'unless', 'get_event', '(', 'e', '[', "'id'", ']', ')', '.', 'empty?', 'debug', '"Repository event #{owner}/#{repo} -> #{e[\'type\']}-#{e[\'id\']} already exists"', 'else', 'persister', '.', 'store', '(', ':events', ',', 'e', ')', 'info', '"Added event for repository #{owner}/#{repo} -> #{e[\'type\']}-#{e[\'id\']}"', 'end', 'end', 'persister', '.', 'find', '(', ':events', ',', '{', "'repo.name'", '=>', '"#{owner}/#{repo}"', '}', ')', 'end']
->Original Target:
['Get', 'all', 'events', 'for', 'the', 'specified', 'repo', '.', 'GitHub', 'will', 'only', 'return', '90', 'days', 'of', 'events']
->Reconstructed Target:
Get all events for the specified repo. GitHub will only return 90 days of events
->Reconstructed Predication:
the events for a repositorythe events for a repositorythe events for a repositoryfor a repositoryfor a repositoryfor a repository" end
->Raw Input:
summarize:def get_repo_events ( owner, repo ) url = ghurl ( "repos/#{owner}/#{repo}/events" ) r = paged_api_request ( url ) r. each do | e | unless get_event ( e [ 'id' ] ). empty? debug "Repository event #{owner}/#{repo} -> #{e['type']}-#{e['id']} already exists" else persister. store ( :events, e ) info "Added event for repository #{owner}/#{repo} -> #{e['type']}-#{e['id']}" end end persister. find ( :events, {'repo.name' => "#{owner}/#{repo}" } ) end
->Raw Target:
Get all events for the specified repo. GitHub will only return 90 days of events
--

236=========
->Original Input:
['def', 'retrieve_master_branch_diff', '(', 'owner', ',', 'repo', ',', 'branch', ',', 'parent_owner', ',', 'parent_repo', ',', 'parent_branch', ')', 'branch', '=', 'retrieve_default_branch', '(', 'owner', ',', 'repo', ')', 'if', 'branch', '.', 'nil?', 'parent_branch', '=', 'retrieve_default_branch', '(', 'parent_owner', ',', 'parent_repo', ')', 'if', 'parent_branch', '.', 'nil?', 'return', 'nil', 'if', 'branch', '.', 'nil?', 'or', 'parent_branch', '.', 'nil?', 'cmp_url', '=', '"https://api.github.com/repos/#{parent_owner}/#{parent_repo}/compare/#{parent_branch}...#{owner}:#{branch}"', 'api_request', '(', 'cmp_url', ')', 'end']
->Original Target:
['Retrieve', 'diff', 'between', 'two', 'branches', '.', 'If', 'either', 'branch', 'name', 'is', 'not', 'provided', 'the', 'branch', 'name', 'is', 'resolved', 'to', 'the', 'corresponding', 'default', 'branch']
->Reconstructed Target:
Retrieve diff between two branches. If either branch name is not provided the branch name is resolved to the corresponding default branch
->Reconstructed Predication:
branch = retrieve_default_branch ( ownerbranch = retrieve_default_branch ( parent_ownerbranch = retrieve_default_branch ( ownerbranch = retrieve_default_branch ( parent_ownerbranch = retrieve_default_branch ( owner
->Raw Input:
summarize:def retrieve_master_branch_diff ( owner, repo, branch, parent_owner, parent_repo, parent_branch ) branch = retrieve_default_branch ( owner, repo ) if branch. nil? parent_branch = retrieve_default_branch ( parent_owner, parent_repo ) if parent_branch. nil? return nil if branch. nil? or parent_branch. nil? cmp_url = "https://api.github.com/repos/#{parent_owner}/#{parent_repo}/compare/#{parent_branch}...#{owner}:#{branch}" api_request ( cmp_url ) end
->Raw Target:
Retrieve diff between two branches. If either branch name is not provided the branch name is resolved to the corresponding default branch
--

237=========
->Original Input:
['def', 'retrieve_default_branch', '(', 'owner', ',', 'repo', ',', 'refresh', '=', 'false', ')', 'retrieved', '=', 'retrieve_repo', '(', 'owner', ',', 'repo', ',', 'refresh', ')', 'return', 'nil', 'if', 'retrieved', '.', 'nil?', 'master_branch', '=', "'master'", 'if', 'retrieved', '[', "'default_branch'", ']', '.', 'nil?', 'retrieved', '=', 'retrieve_repo', '(', 'owner', ',', 'repo', ',', 'true', ')', 'return', 'nil', 'if', 'retrieved', '.', 'nil?', 'end', 'master_branch', '=', 'retrieved', '[', "'default_branch'", ']', 'unless', 'retrieved', '.', 'nil?', 'master_branch', 'end']
->Original Target:
['Retrieve', 'the', 'default', 'branch', 'for', 'a', 'repo', '.', 'If', 'nothing', 'is', 'retrieved', 'master', 'is', 'returned']
->Reconstructed Target:
Retrieve the default branch for a repo. If nothing is retrieved master is returned
->Reconstructed Predication:
the default branch for the
->Raw Input:
summarize:def retrieve_default_branch ( owner, repo, refresh = false ) retrieved = retrieve_repo ( owner, repo, refresh ) return nil if retrieved. nil? master_branch ='master' if retrieved [ 'default_branch' ]. nil? retrieved = retrieve_repo ( owner, repo, true ) return nil if retrieved. nil? end master_branch = retrieved [ 'default_branch' ] unless retrieved. nil? master_branch end
->Raw Target:
Retrieve the default branch for a repo. If nothing is retrieved master is returned
--

238=========
->Original Input:
['def', 'process_options', 'command', '=', 'self', '@options', '=', 'Trollop', '::', 'options', '(', 'command', '.', 'args', ')', 'do', 'command', '.', 'prepare_options', '(', 'self', ')', 'banner', '<<-END', 'END', 'opt', ':config', ',', "'config.yaml file location'", ',', ':short', '=>', "'c'", ',', ':default', '=>', "'config.yaml'", 'opt', ':verbose', ',', "'verbose mode'", ',', ':short', '=>', "'v'", 'opt', ':addr', ',', "'IP address to use for performing requests'", ',', ':short', '=>', "'a'", ',', ':type', '=>', 'String', 'opt', ':token', ',', "'GitHub OAuth token'", ',', ':type', '=>', 'String', ',', ':short', '=>', "'t'", 'opt', ':req_limit', ',', "'Number or requests to leave on any provided account (in reqs/hour)'", ',', ':type', '=>', 'Integer', ',', ':short', '=>', "'l'", 'opt', ':uniq', ',', "'Unique name for this command. Will appear in logs.'", ',', ':type', '=>', 'String', ',', ':short', '=>', "'u'", 'end', 'end']
->Original Target:
['Specify', 'and', 'parse', 'top', '-', 'level', 'command', 'line', 'options', '.']
->Reconstructed Target:
Specify and parse top - level command line options.
->Reconstructed Predication:
the command to run.the command to run.the command to run.the command to run. Thethe command to run. Thethe command to run. Thethe command to run. Thethe command to run. Thethe command to run. Thethe command to run. Thethe command to run. Thethe command to run. The commandwill be executed in thethe command to run. Thethe command
->Raw Input:
summarize:def process_options command = self @options = Trollop :: options ( command. args ) do command. prepare_options ( self ) banner <<-END END opt :config, 'config.yaml file location', :short => 'c', :default => 'config.yaml' opt :verbose,'verbose mode', :short => 'v' opt :addr, 'IP address to use for performing requests', :short => 'a', :type => String opt :token, 'GitHub OAuth token', :type => String, :short => 't' opt :req_limit, 'Number or requests to leave on any provided account (in reqs/hour)', :type => Integer, :short => 'l' opt :uniq, 'Unique name for this command. Will appear in logs.', :type => String, :short => 'u' end end
->Raw Target:
Specify and parse top - level command line options.
--

239=========
->Original Input:
['def', 'validate', 'if', 'options', '[', ':config', ']', '.', 'nil?', 'unless', '(', 'File', '.', 'exist?', '(', '"config.yaml"', ')', ')', 'Trollop', '::', 'die', '"No config file in default location (#{Dir.pwd}). You                        need to specify the #{:config} parameter. Read the                        documentation on how to create a config.yaml file."', 'end', 'else', 'Trollop', '::', 'die', '"Cannot find file #{options[:config]}"', 'unless', 'File', '.', 'exist?', '(', 'options', '[', ':config', ']', ')', 'end', 'unless', '@options', '[', ':user', ']', '.', 'nil?', 'if', 'not', 'Process', '.', 'uid', '==', '0', 'Trollop', '::', 'die', '"Option --user (-u) can only be specified by root"', 'end', 'begin', 'Etc', '.', 'getpwnam', '(', '@options', '[', ':user', ']', ')', 'rescue', 'ArgumentError', 'Trollop', '::', 'die', '"No such user: #{@options[:user]}"', 'end', 'end', 'end']
->Original Target:
['Examine', 'the', 'validity', 'of', 'the', 'provided', 'options', 'in', 'the', 'context', 'of', 'the', 'executed', 'command', '.', 'Subclasses', 'can', 'also', 'call', 'super', 'to', 'also', 'invoke', 'the', 'checks', 'provided', 'by', 'this', 'class', '.']
->Reconstructed Target:
Examine the validity of the provided options in the context of the executed command. Subclasses can also call super to also invoke the checks provided by this class.
->Reconstructed Predication:
the config file. The config.yaml fileis a valid config file."the config file. The config.yaml fileis a valid config file." end
->Raw Input:
summarize:def validate if options [ :config ]. nil? unless ( File. exist? ( "config.yaml" ) ) Trollop :: die "No config file in default location (#{Dir.pwd}). You                        need to specify the #{:config} parameter. Read the                        documentation on how to create a config.yaml file." end else Trollop :: die "Cannot find file #{options[:config]}" unless File. exist? ( options [ :config ] ) end unless @options [ :user ]. nil? if not Process. uid == 0 Trollop :: die "Option --user (-u) can only be specified by root" end begin Etc. getpwnam ( @options [ :user ] ) rescue ArgumentError Trollop :: die "No such user: #{@options[:user]}" end end end
->Raw Target:
Examine the validity of the provided options in the context of the executed command. Subclasses can also call super to also invoke the checks provided by this class.
--

240=========
->Original Input:
['def', 'queue_client', '(', 'queue', ',', 'key', '=', 'queue', ',', 'ack', '=', ':after', ',', 'block', ')', 'stopped', '=', 'false', 'while', 'not', 'stopped', 'begin', 'conn', '=', 'Bunny', '.', 'new', '(', ':host', '=>', 'config', '(', ':amqp_host', ')', ',', ':port', '=>', 'config', '(', ':amqp_port', ')', ',', ':username', '=>', 'config', '(', ':amqp_username', ')', ',', ':password', '=>', 'config', '(', ':amqp_password', ')', ')', 'conn', '.', 'start', 'ch', '=', 'conn', '.', 'create_channel', 'debug', '"Queue setting prefetch to #{config(:amqp_prefetch)}"', 'ch', '.', 'prefetch', '(', 'config', '(', ':amqp_prefetch', ')', ')', 'debug', '"Queue connection to #{config(:amqp_host)} succeeded"', 'x', '=', 'ch', '.', 'topic', '(', 'config', '(', ':amqp_exchange', ')', ',', ':durable', '=>', 'true', ',', ':auto_delete', '=>', 'false', ')', 'q', '=', 'ch', '.', 'queue', '(', 'queue', ',', ':durable', '=>', 'true', ')', 'q', '.', 'bind', '(', 'x', ',', ':routing_key', '=>', 'key', ')', 'q', '.', 'subscribe', '(', ':block', '=>', 'true', ',', ':manual_ack', '=>', 'true', ')', 'do', '|', 'delivery_info', ',', 'properties', ',', 'msg', '|', 'if', 'ack', '==', ':before', 'ch', '.', 'acknowledge', '(', 'delivery_info', '.', 'delivery_tag', ')', 'end', 'begin', 'block', '.', 'call', '(', 'msg', ')', 'ensure', 'if', 'ack', '!=', ':before', 'ch', '.', 'acknowledge', '(', 'delivery_info', '.', 'delivery_tag', ')', 'end', 'end', 'end', 'rescue', 'Bunny', '::', 'TCPConnectionFailed', '=>', 'e', 'warn', '"Connection to #{config(:amqp_host)} failed. Retrying in 1 sec"', 'sleep', '(', '1', ')', 'rescue', 'Bunny', '::', 'PossibleAuthenticationFailureError', '=>', 'e', 'warn', '"Could not authenticate as #{conn.username}"', 'rescue', 'Bunny', '::', 'NotFound', ',', 'Bunny', '::', 'AccessRefused', ',', 'Bunny', '::', 'PreconditionFailed', '=>', 'e', 'warn', '"Channel error: #{e}. Retrying in 1 sec"', 'sleep', '(', '1', ')', 'rescue', 'Interrupt', '=>', '_', 'stopped', '=', 'true', 'rescue', 'StandardError', '=>', 'e', 'raise', 'e', 'end', 'end', 'ch', '.', 'close', 'unless', 'ch', '.', 'nil?', 'conn', '.', 'close', 'unless', 'conn', '.', 'nil?', 'end']
->Original Target:
['Specify', 'a', 'handler', 'to', 'incoming', 'messages', 'from', 'a', 'connection', 'to', 'a', 'queue', '.']
->Reconstructed Target:
Specify a handler to incoming messages from a connection to a queue.
->Reconstructed Predication:
queue client isqueuequeue.))) end
->Raw Input:
summarize:def queue_client ( queue, key = queue, ack = :after, block ) stopped = false while not stopped begin conn = Bunny. new ( :host => config ( :amqp_host ), :port => config ( :amqp_port ), :username => config ( :amqp_username ), :password => config ( :amqp_password ) ) conn. start ch = conn. create_channel debug "Queue setting prefetch to #{config(:amqp_prefetch)}" ch. prefetch ( config ( :amqp_prefetch ) ) debug "Queue connection to #{config(:amqp_host)} succeeded" x = ch. topic ( config ( :amqp_exchange ), :durable => true, :auto_delete => false ) q = ch. queue ( queue, :durable => true ) q. bind ( x, :routing_key => key ) q. subscribe ( :block => true, :manual_ack => true ) do | delivery_info, properties, msg | if ack == :before ch. acknowledge ( delivery_info. delivery_tag ) end begin block. call ( msg ) ensure if ack!= :before ch. acknowledge ( delivery_info. delivery_tag ) end end end rescue Bunny :: TCPConnectionFailed => e warn "Connection to #{config(:amqp_host)} failed. Retrying in 1 sec" sleep ( 1 ) rescue Bunny :: PossibleAuthenticationFailureError => e warn "Could not authenticate as #{conn.username}" rescue Bunny :: NotFound, Bunny :: AccessRefused, Bunny :: PreconditionFailed => e warn "Channel error: #{e}. Retrying in 1 sec" sleep ( 1 ) rescue Interrupt => _ stopped = true rescue StandardError => e raise e end end ch. close unless ch. nil? conn. close unless conn. nil? end
->Raw Target:
Specify a handler to incoming messages from a connection to a queue.
--

241=========
->Original Input:
['def', 'read_value', '(', 'from', ',', 'key', ')', 'return', 'from', 'if', 'key', '.', 'nil?', 'or', 'key', '==', '""', 'key', '.', 'split', '(', '/', '\\.', '/', ')', '.', 'reduce', '(', '{', '}', ')', 'do', '|', 'acc', ',', 'x', '|', 'unless', 'acc', '.', 'nil?', 'if', 'acc', '.', 'empty?', 'acc', '=', 'from', '[', 'x', ']', 'else', 'if', 'acc', '.', 'has_key?', '(', 'x', ')', 'acc', '=', 'acc', '[', 'x', ']', 'else', 'return', 'nil', 'end', 'end', 'else', 'return', 'nil', 'end', 'end', 'end']
->Original Target:
['Read', 'the', 'value', 'for', 'a', 'key', 'whose', 'format', 'is', 'foo', '.', 'bar', '.', 'baz', 'from', 'a', 'hierarchical', 'map', 'where', 'a', 'dot', 'represents', 'one', 'level', 'deep', 'in', 'the', 'hierarchy', '.']
->Reconstructed Target:
Read the value for a key whose format is foo. bar. baz from a hierarchical map where a dot represents one level deep in the hierarchy.
->Reconstructed Predication:
the value for the given key
->Raw Input:
summarize:def read_value ( from, key ) return from if key. nil? or key == "" key. split ( / \. / ). reduce ( { } ) do | acc, x | unless acc. nil? if acc. empty? acc = from [ x ] else if acc. has_key? ( x ) acc = acc [ x ] else return nil end end else return nil end end end
->Raw Target:
Read the value for a key whose format is foo. bar. baz from a hierarchical map where a dot represents one level deep in the hierarchy.
--

242=========
->Original Input:
['def', 'location_filter', '(', 'location', ')', 'return', 'nil', 'if', 'location', '.', 'nil?', 'location', '.', 'strip', '.', 'downcase', '.', 'tr', '(', '\'#"<>[]\'', ',', "''", ')', '.', 'gsub', '(', '/', '\\/', '/', ',', "''", ')', '.', 'gsub', '(', '/', '/', ',', "' '", ')', '.', 'gsub', '(', '/', '/', ',', "'\\1'", ')', 'end']
->Original Target:
['Standard', 'filtering', 'on', 'all', 'locations', 'used', 'by', 'GHTorrent']
->Reconstructed Target:
Standard filtering on all locations used by GHTorrent
->Reconstructed Predication:
the location to be filtered
->Raw Input:
summarize:def location_filter ( location ) return nil if location. nil? location. strip. downcase. tr ( '#"<>[]', '' ). gsub ( / \/ /, '' ). gsub ( / /,'' ). gsub ( / /, '\1' ) end
->Raw Target:
Standard filtering on all locations used by GHTorrent
--

243=========
->Original Input:
['def', 'validate_usage!', 'registered_topics', '=', 'self', '.', 'class', '.', 'topics', '.', 'map', 'do', '|', 'name', ',', 'topic', '|', 'topic', '.', 'to_h', '.', 'merge!', '(', 'usage_count', ':', 'messages_buffer', '[', 'name', ']', '&.', 'count', '||', '0', ')', 'end', 'used_topics', '=', 'messages_buffer', '.', 'map', 'do', '|', 'name', ',', 'usage', '|', 'topic', '=', 'self', '.', 'class', '.', 'topics', '[', 'name', ']', '||', 'Responders', '::', 'Topic', '.', 'new', '(', 'name', ',', 'registered', ':', 'false', ')', 'topic', '.', 'to_h', '.', 'merge!', '(', 'usage_count', ':', 'usage', '.', 'count', ')', 'end', 'result', '=', 'Karafka', '::', 'Schemas', '::', 'ResponderUsage', '.', 'call', '(', 'registered_topics', ':', 'registered_topics', ',', 'used_topics', ':', 'used_topics', ')', 'return', 'if', 'result', '.', 'success?', 'raise', 'Karafka', '::', 'Errors', '::', 'InvalidResponderUsageError', ',', 'result', '.', 'errors', 'end']
->Original Target:
['Checks', 'if', 'we', 'met', 'all', 'the', 'topics', 'requirements', '.', 'It', 'will', 'fail', 'if', 'we', 'didn', 't', 'send', 'a', 'message', 'to', 'a', 'registered', 'required', 'topic', 'etc', '.']
->Reconstructed Target:
Checks if we met all the topics requirements. It will fail if we didn t send a message to a registered required topic etc.
->Reconstructed Predication:
the messages that arethethethe messages that are
->Raw Input:
summarize:def validate_usage! registered_topics = self. class. topics. map do | name, topic | topic. to_h. merge! ( usage_count : messages_buffer [ name ] &. count || 0 ) end used_topics = messages_buffer. map do | name, usage | topic = self. class. topics [ name ] || Responders :: Topic. new ( name, registered : false ) topic. to_h. merge! ( usage_count : usage. count ) end result = Karafka :: Schemas :: ResponderUsage. call ( registered_topics : registered_topics, used_topics : used_topics ) return if result. success? raise Karafka :: Errors :: InvalidResponderUsageError, result. errors end
->Raw Target:
Checks if we met all the topics requirements. It will fail if we didn t send a message to a registered required topic etc.
--

244=========
->Original Input:
['def', 'validate_options!', 'return', 'true', 'unless', 'self', '.', 'class', '.', 'options_schema', 'messages_buffer', '.', 'each_value', 'do', '|', 'messages_set', '|', 'messages_set', '.', 'each', 'do', '|', 'message_data', '|', 'result', '=', 'self', '.', 'class', '.', 'options_schema', '.', 'call', '(', 'message_data', '.', 'last', ')', 'next', 'if', 'result', '.', 'success?', 'raise', 'Karafka', '::', 'Errors', '::', 'InvalidResponderMessageOptionsError', ',', 'result', '.', 'errors', 'end', 'end', 'end']
->Original Target:
['Checks', 'if', 'we', 'met', 'all', 'the', 'options', 'requirements', 'before', 'sending', 'them', 'to', 'the', 'producer', '.']
->Reconstructed Target:
Checks if we met all the options requirements before sending them to the producer.
->Reconstructed Predication:
the messages to validate
->Raw Input:
summarize:def validate_options! return true unless self. class. options_schema messages_buffer. each_value do | messages_set | messages_set. each do | message_data | result = self. class. options_schema. call ( message_data. last ) next if result. success? raise Karafka :: Errors :: InvalidResponderMessageOptionsError, result. errors end end end
->Raw Target:
Checks if we met all the options requirements before sending them to the producer.
--

245=========
->Original Input:
['def', 'deliver!', 'messages_buffer', '.', 'each_value', 'do', '|', 'data_elements', '|', 'data_elements', '.', 'each', 'do', '|', 'data', ',', 'options', '|', 'mapped_topic', '=', 'Karafka', '::', 'App', '.', 'config', '.', 'topic_mapper', '.', 'outgoing', '(', 'options', '[', ':topic', ']', ')', 'external_options', '=', 'options', '.', 'merge', '(', 'topic', ':', 'mapped_topic', ')', 'producer', '(', 'options', ')', '.', 'call', '(', 'data', ',', 'external_options', ')', 'end', 'end', 'end']
->Original Target:
['Takes', 'all', 'the', 'messages', 'from', 'the', 'buffer', 'and', 'delivers', 'them', 'one', 'by', 'one']
->Reconstructed Target:
Takes all the messages from the buffer and delivers them one by one
->Reconstructed Predication:
the messages to the producer
->Raw Input:
summarize:def deliver! messages_buffer. each_value do | data_elements | data_elements. each do | data, options | mapped_topic = Karafka :: App. config. topic_mapper. outgoing ( options [ :topic ] ) external_options = options. merge ( topic : mapped_topic ) producer ( options ). call ( data, external_options ) end end end
->Raw Target:
Takes all the messages from the buffer and delivers them one by one
--

246=========
->Original Input:
['def', 'notice_signal', '(', 'signal', ')', 'Thread', '.', 'new', 'do', 'Karafka', '.', 'monitor', '.', 'instrument', '(', "'process.notice_signal'", ',', 'caller', ':', 'self', ',', 'signal', ':', 'signal', ')', 'end', 'end']
->Original Target:
['Informs', 'monitoring', 'about', 'trapped', 'signal']
->Reconstructed Target:
Informs monitoring about trapped signal
->Reconstructed Predication:
the thread to run the notice
->Raw Input:
summarize:def notice_signal ( signal ) Thread. new do Karafka. monitor. instrument ( 'process.notice_signal', caller : self, signal : signal ) end end
->Raw Target:
Informs monitoring about trapped signal
--

247=========
->Original Input:
['def', 'embedding_lookup', '(', 'params', ',', 'ids', ',', 'partition_strategy', ':', '"mod"', ',', 'name', ':', 'nil', ',', 'validate_indices', ':', 'true', ',', 'max_norm', ':', 'nil', ')', '_embedding_lookup_and_transform', '(', 'params', ',', 'ids', ',', 'partition_strategy', ':', 'partition_strategy', ',', 'name', ':', 'name', ',', 'max_norm', ':', 'max_norm', ',', 'transform_fn', ':', 'nil', ')', 'end']
->Original Target:
['Looks', 'up', 'ids', 'in', 'a', 'list', 'of', 'embedding', 'tensors', '.']
->Reconstructed Target:
Looks up ids in a list of embedding tensors.
->Reconstructed Predication:
the embedding lookup for the giventhe embedding lookup for the giventhe embedding lookup for the given
->Raw Input:
summarize:def embedding_lookup ( params, ids, partition_strategy : "mod", name : nil, validate_indices : true, max_norm : nil ) _embedding_lookup_and_transform ( params, ids, partition_strategy : partition_strategy, name : name, max_norm : max_norm, transform_fn : nil ) end
->Raw Target:
Looks up ids in a list of embedding tensors.
--

248=========
->Original Input:
['def', '_embedding_lookup_and_transform', '(', 'params', ',', 'ids', ',', 'partition_strategy', ':', '"mod"', ',', 'name', ':', 'nil', ',', 'max_norm', ':', 'nil', ',', 'transform_fn', ':', 'nil', ')', 'raise', 'TensorStream', '::', 'ValueError', ',', '"Need at least one param"', 'if', 'params', '.', 'nil?', 'params', '=', '[', 'params', ']', 'unless', 'params', '.', 'is_a?', '(', 'Array', ')', 'TensorStream', '.', 'name_scope', '(', 'name', ',', '"embedding_lookup"', ',', 'values', ':', 'params', '+', '[', 'ids', ']', ')', 'do', '|', 'name', '|', 'np', '=', 'params', '.', 'size', 'ids', '=', 'TensorStream', '.', 'convert_to_tensor', '(', 'ids', ',', 'name', ':', '"ids"', ')', 'if', '(', 'np', '==', '1', ')', '&&', '(', 'transform_fn', '.', 'nil?', '||', '(', 'ids', '.', 'shape', '.', 'size', '==', '1', ')', ')', 'result', '=', 'nil', 'TensorStream', '.', 'colocate_with', '(', 'params', '[', '0', ']', ')', 'do', 'result', '=', '_clip', '(', 'TensorStream', '.', 'gather', '(', 'params', '[', '0', ']', ',', 'ids', ',', 'name', ':', 'name', ')', ',', 'ids', ',', 'max_norm', ')', 'result', '=', 'transform_fn', '.', 'call', '(', 'result', ')', 'if', 'transform_fn', 'end', 'return', 'TensorStream', '.', 'identity', '(', 'result', ')', 'else', 'flat_ids', '=', 'TensorStream', '.', 'reshape', '(', 'ids', ',', '[', '-', '1', ']', ')', 'original_indices', '=', 'TensorStream', '.', 'range', '(', 'TensorStream', '.', 'size', '(', 'flat_ids', ')', ')', 'p_assignments', '=', 'nil', 'new_ids', '=', 'nil', 'if', 'partition_strategy', '==', '"mod"', 'p_assignments', '=', 'flat_ids', '%', 'np', 'new_ids', '=', 'floor_div', '(', 'flat_ids', ',', 'np', ')', 'elsif', 'partition_strategy', '==', '"div"', 'raise', '"not yet supported!"', 'else', 'raise', 'TensorStream', '::', 'ValueError', ',', '"Unrecognized partition strategy: "', '+', 'partition_strategy', 'end', 'p_assignments', '=', 'TensorStream', '.', 'cast', '(', 'p_assignments', ',', ':int32', ')', 'gather_ids', '=', 'TensorStream', '.', 'dynamic_partition', '(', 'new_ids', ',', 'p_assignments', ',', 'np', ')', 'pindices', '=', 'TensorStream', '.', 'dynamic_partition', '(', 'original_indices', ',', 'p_assignments', ',', 'np', ')', 'partitioned_result', '=', '[', ']', '(', '0', '...', 'np', ')', '.', 'each', 'do', '|', 'p', '|', 'pids', '=', 'gather_ids', '[', 'p', ']', 'result', '=', 'nil', 'TensorStream', '.', 'colocate_with', '(', 'params', '[', 'p', ']', ')', 'do', 'result', '=', 'TensorStream', '.', 'gather', '(', 'params', '[', 'p', ']', ',', 'pids', ')', 'if', 'transform_fn', 'result', '=', 'transform_fn', '.', 'call', '(', '_clip', '(', 'result', ',', 'pids', ',', 'max_norm', ')', ')', 'end', 'end', 'partitioned_result', '<<', 'result', 'end', 'ret', '=', 'TensorStream', '.', 'dynamic_stitch', '(', 'pindices', ',', 'partitioned_result', ',', 'name', ':', 'name', ')', 'if', 'transform_fn', '.', 'nil?', 'element_shape_s', '=', 'params', '[', '0', ']', '.', 'shape', '[', '1', '..', '-', '1', ']', 'params', '[', '1', '..', '-', '1', ']', '.', 'each', '{', '|', 'p', '|', 'element_shape_s', '=', 'element_shape_s', '.', 'merge_with', '(', 'p', '.', 'shape', '[', '1', '..', '-', '1', ']', ')', '}', 'else', 'element_shape_s', '=', 'ret', '.', 'shape', '[', '1', '..', '-', '1', ']', 'end', 'element_shape_d', '=', 'if', 'element_shape_s', '.', 'fully_defined?', 'element_shape_s', 'elsif', 'transform_fn', '.', 'nil?', 'TensorStream', '.', 'colocate_with', '(', 'params', '[', '0', ']', ')', 'do', 'params_shape', '=', 'TensorStream', '.', 'shape', '(', 'params', '[', '0', ']', ')', 'params_shape', '[', '1', '..', '-', '1', ']', 'end', 'else', 'TensorStream', '.', 'shape', '(', 'ret', ')', '[', '1', '..', '-', '1', ']', 'end', 'ret', '=', 'TensorStream', '.', 'reshape', '(', 'ret', ',', 'TensorStream', '.', 'concat', '(', '[', 'TensorStream', '.', 'shape', '(', 'ids', ')', ',', 'element_shape_d', ']', ',', '0', ')', ')', 'ret', '=', '_clip', '(', 'ret', ',', 'ids', ',', 'max_norm', ')', 'unless', 'transform_fn', 'ret', 'end', 'end', 'end']
->Original Target:
['Helper', 'function', 'for', 'embedding_lookup', 'and', '_compute_sampled_logits', '.']
->Reconstructed Target:
Helper function for embedding_lookup and _compute_sampled_logits.
->Reconstructed Predication:
. shape ). size == 1.. size == 1 ).. size == 1 ). size == 1 ).. size == 1 ).. size == 1 ).. size == 1 ). size ==. size == 1. size == 1. size == 1. size == 1. size == 1. size == 1. size == 1. size ==
->Raw Input:
summarize:def _embedding_lookup_and_transform ( params, ids, partition_strategy : "mod", name : nil, max_norm : nil, transform_fn : nil ) raise TensorStream :: ValueError, "Need at least one param" if params. nil? params = [ params ] unless params. is_a? ( Array ) TensorStream. name_scope ( name, "embedding_lookup", values : params + [ ids ] ) do | name | np = params. size ids = TensorStream. convert_to_tensor ( ids, name : "ids" ) if ( np == 1 ) && ( transform_fn. nil? || ( ids. shape. size == 1 ) ) result = nil TensorStream. colocate_with ( params [ 0 ] ) do result = _clip ( TensorStream. gather ( params [ 0 ], ids, name : name ), ids, max_norm ) result = transform_fn. call ( result ) if transform_fn end return TensorStream. identity ( result ) else flat_ids = TensorStream. reshape ( ids, [ - 1 ] ) original_indices = TensorStream. range ( TensorStream. size ( flat_ids ) ) p_assignments = nil new_ids = nil if partition_strategy == "mod" p_assignments = flat_ids % np new_ids = floor_div ( flat_ids, np ) elsif partition_strategy == "div" raise "not yet supported!" else raise TensorStream :: ValueError, "Unrecognized partition strategy: " + partition_strategy end p_assignments = TensorStream. cast ( p_assignments, :int32 ) gather_ids = TensorStream. dynamic_partition ( new_ids, p_assignments, np ) pindices = TensorStream. dynamic_partition ( original_indices, p_assignments, np ) partitioned_result = [ ] ( 0... np ). each do | p | pids = gather_ids [ p ] result = nil TensorStream. colocate_with ( params [ p ] ) do result = TensorStream. gather ( params [ p ], pids ) if transform_fn result = transform_fn. call ( _clip ( result, pids, max_norm ) ) end end partitioned_result << result end ret = TensorStream. dynamic_stitch ( pindices, partitioned_result, name : name ) if transform_fn. nil? element_shape_
->Raw Target:
Helper function for embedding_lookup and _compute_sampled_logits.
--

249=========
->Original Input:
['def', 'load', '(', 'pbfile', ')', 'f', '=', 'File', '.', 'new', '(', 'pbfile', ',', '"r"', ')', 'lines', '=', '[', ']', 'while', '!', 'f', '.', 'eof?', '&&', '(', 'str', '=', 'f', '.', 'readline', '.', 'strip', ')', 'lines', '<<', 'str', 'end', 'evaluate_lines', '(', 'lines', ')', 'end']
->Original Target:
['parsers', 'a', 'protobuf', 'file', 'and', 'spits', 'out', 'a', 'ruby', 'hash']
->Reconstructed Target:
parsers a protobuf file and spits out a ruby hash
->Reconstructed Predication:
 def load ( pbfile)
->Raw Input:
summarize:def load ( pbfile ) f = File. new ( pbfile, "r" ) lines = [ ] while! f. eof? && ( str = f. readline. strip ) lines << str end evaluate_lines ( lines ) end
->Raw Target:
parsers a protobuf file and spits out a ruby hash
--

250=========
->Original Input:
['def', 'assert_equal', '(', 'x', ',', 'y', ',', 'data', ':', 'nil', ',', 'summarize', ':', 'nil', ',', 'message', ':', 'nil', ',', 'name', ':', 'nil', ')', '_op', '(', ':assert_equal', ',', 'x', ',', 'y', ',', 'data', ':', 'data', ',', 'summarize', ':', 'summarize', ',', 'message', ':', 'message', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Assert', 'the', 'condition', 'x', '==', 'y', 'holds', 'element', '-', 'wise', '.']
->Reconstructed Target:
Assert the condition x == y holds element - wise.
->Reconstructed Predication:
assert that x == yassert that y == data
->Raw Input:
summarize:def assert_equal ( x, y, data : nil, summarize : nil, message : nil, name : nil ) _op ( :assert_equal, x, y, data : data, summarize : summarize, message : message, name : name ) end
->Raw Target:
Assert the condition x == y holds element - wise.
--

251=========
->Original Input:
['def', 'gradients', '(', 'tensor_ys', ',', 'wrt_xs', ',', 'name', ':', '"gradients"', ',', 'stop_gradients', ':', 'nil', ')', 'tensor_ys', '=', 'tensor_ys', '.', 'op', 'gs', '=', 'wrt_xs', '.', 'map', '(', '&', ':op', ')', '.', 'collect', '{', '|', 'x', '|', 'stops', '=', 'stop_gradients', '?', 'stop_gradients', '.', 'map', '(', '&', ':name', ')', '.', 'join', '(', '"_"', ')', ':', '""', 'gradient_program_name', '=', '"grad_#{tensor_ys.name}_#{x.name}_#{stops}"', '.', 'to_sym', 'tensor_graph', '=', 'tensor_ys', '.', 'graph', 'tensor_program', '=', 'if', 'tensor_graph', '.', 'node_added?', '(', 'gradient_program_name', ')', 'tensor_graph', '.', 'get_node', '(', 'gradient_program_name', ')', 'else', 'tensor_graph', '.', 'name_scope', '(', '"gradient_wrt_#{x.name}"', ')', 'do', 'derivative_ops', '=', 'TensorStream', '::', 'MathGradients', '.', 'derivative', '(', 'tensor_ys', ',', 'x', ',', 'graph', ':', 'tensor_graph', ',', 'stop_gradients', ':', 'stop_gradients', ')', 'tensor_graph', '.', 'add_node!', '(', 'gradient_program_name', ',', 'derivative_ops', ')', 'end', 'end', 'tensor_program', '}', 'gs', 'end']
->Original Target:
['Constructs', 'symbolic', 'derivatives', 'of', 'ys', 'of', 'input', 'w', '.', 'r', '.', 't', '.', 'x', 'in', 'wrt_xs', '.']
->Reconstructed Target:
Constructs symbolic derivatives of ys of input w. r. t. x in wrt_xs.
->Reconstructed Predication:
the gradients of the.. map { | x| gradient_ops | gradient_ops...
->Raw Input:
summarize:def gradients ( tensor_ys, wrt_xs, name : "gradients", stop_gradients : nil ) tensor_ys = tensor_ys. op gs = wrt_xs. map ( & :op ). collect { | x | stops = stop_gradients? stop_gradients. map ( & :name ). join ( "_" ) : "" gradient_program_name = "grad_#{tensor_ys.name}_#{x.name}_#{stops}". to_sym tensor_graph = tensor_ys. graph tensor_program = if tensor_graph. node_added? ( gradient_program_name ) tensor_graph. get_node ( gradient_program_name ) else tensor_graph. name_scope ( "gradient_wrt_#{x.name}" ) do derivative_ops = TensorStream :: MathGradients. derivative ( tensor_ys, x, graph : tensor_graph, stop_gradients : stop_gradients ) tensor_graph. add_node! ( gradient_program_name, derivative_ops ) end end tensor_program } gs end
->Raw Target:
Constructs symbolic derivatives of ys of input w. r. t. x in wrt_xs.
--

252=========
->Original Input:
['def', 'random_normal', '(', 'shape', ',', 'dtype', ':', ':float32', ',', 'mean', ':', '0.0', ',', 'stddev', ':', '1.0', ',', 'seed', ':', 'nil', ',', 'name', ':', 'nil', ')', 'options', '=', '{', 'dtype', ':', 'dtype', ',', 'mean', ':', 'mean', ',', 'stddev', ':', 'stddev', ',', 'seed', ':', 'seed', ',', 'name', ':', 'name', '}', '_op', '(', ':random_standard_normal', ',', 'shape', ',', 'options', ')', 'end']
->Original Target:
['Outputs', 'random', 'values', 'from', 'a', 'normal', 'distribution', '.']
->Reconstructed Target:
Outputs random values from a normal distribution.
->Reconstructed Predication:
the random normal of the giventhe given shape and thethe standard normal of the giventhe standard normal of the given
->Raw Input:
summarize:def random_normal ( shape, dtype : :float32, mean : 0.0, stddev : 1.0, seed : nil, name : nil ) options = { dtype : dtype, mean : mean, stddev : stddev, seed : seed, name : name } _op ( :random_standard_normal, shape, options ) end
->Raw Target:
Outputs random values from a normal distribution.
--

253=========
->Original Input:
['def', 'eye', '(', 'num_rows', ',', 'num_columns', ':', 'nil', ',', 'dtype', ':', ':float32', ',', 'name', ':', 'nil', ')', '_op', '(', ':eye', ',', 'num_rows', ',', 'num_columns', '||', 'num_rows', ',', 'data_type', ':', 'dtype', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Construct', 'an', 'identity', 'matrix']
->Reconstructed Target:
Construct an identity matrix
->Reconstructed Predication:
summarize matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix matrix
->Raw Input:
summarize:def eye ( num_rows, num_columns : nil, dtype : :float32, name : nil ) _op ( :eye, num_rows, num_columns || num_rows, data_type : dtype, name : name ) end
->Raw Target:
Construct an identity matrix
--

254=========
->Original Input:
['def', 'glorot_uniform_initializer', '(', 'seed', ':', 'nil', ',', 'dtype', ':', 'nil', ')', 'TensorStream', '::', 'Initializer', '.', 'new', '(', '->', '{', '_op', '(', ':glorot_uniform', ',', 'seed', ':', 'seed', ',', 'data_type', ':', 'dtype', ')', '}', ')', 'end']
->Original Target:
['The', 'Glorot', 'uniform', 'initializer', 'also', 'called', 'Xavier', 'uniform', 'initializer', '.']
->Reconstructed Target:
The Glorot uniform initializer also called Xavier uniform initializer.
->Reconstructed Predication:
initializer.  def
->Raw Input:
summarize:def glorot_uniform_initializer ( seed : nil, dtype : nil ) TensorStream :: Initializer. new ( -> { _op ( :glorot_uniform, seed : seed, data_type : dtype ) } ) end
->Raw Target:
The Glorot uniform initializer also called Xavier uniform initializer.
--

255=========
->Original Input:
['def', 'random_uniform_initializer', '(', 'minval', ':', '0', ',', 'maxval', ':', '1', ',', 'seed', ':', 'nil', ',', 'dtype', ':', 'nil', ')', 'TensorStream', '::', 'Initializer', '.', 'new', '(', '->', '{', '_op', '(', ':random_uniform', ',', 'minval', ':', '0', ',', 'maxval', ':', '1', ',', 'seed', ':', 'seed', ',', 'data_type', ':', 'dtype', ')', '}', ')', 'end']
->Original Target:
['Initializer', 'that', 'generates', 'tensors', 'with', 'a', 'uniform', 'distribution', '.']
->Reconstructed Target:
Initializer that generates tensors with a uniform distribution.
->Reconstructed Predication:
The initial seed for the def random_uniform_initializer ( seed
->Raw Input:
summarize:def random_uniform_initializer ( minval : 0, maxval : 1, seed : nil, dtype : nil ) TensorStream :: Initializer. new ( -> { _op ( :random_uniform, minval : 0, maxval : 1, seed : seed, data_type : dtype ) } ) end
->Raw Target:
Initializer that generates tensors with a uniform distribution.
--

256=========
->Original Input:
['def', 'slice', '(', 'input', ',', 'start', ',', 'size', ',', 'name', ':', 'nil', ')', '_op', '(', ':slice', ',', 'input', ',', 'start', ',', 'size', ':', 'size', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Extracts', 'a', 'slice', 'from', 'a', 'tensor', '.']
->Reconstructed Target:
Extracts a slice from a tensor.
->Reconstructed Predication:
the input array to thethe input array to thethe input array to thethe input array to thethe input array to thethe input array to the
->Raw Input:
summarize:def slice ( input, start, size, name : nil ) _op ( :slice, input, start, size : size, name : name ) end
->Raw Target:
Extracts a slice from a tensor.
--

257=========
->Original Input:
['def', 'ones', '(', 'shape', ',', 'dtype', ':', ':float32', ',', 'name', ':', 'nil', ')', '_op', '(', ':ones', ',', 'shape', ',', 'data_type', ':', 'dtype', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Creates', 'a', 'tensor', 'with', 'all', 'elements', 'set', 'to', '1', '.']
->Reconstructed Target:
Creates a tensor with all elements set to 1.
->Reconstructed Predication:
summarize a shape of areturn a
->Raw Input:
summarize:def ones ( shape, dtype : :float32, name : nil ) _op ( :ones, shape, data_type : dtype, name : name ) end
->Raw Target:
Creates a tensor with all elements set to 1.
--

258=========
->Original Input:
['def', 'logical_and', '(', 'input_a', ',', 'input_b', ',', 'name', ':', 'nil', ')', 'check_data_types', '(', 'input_a', ',', 'input_b', ')', '_op', '(', ':logical_and', ',', 'input_a', ',', 'input_b', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Returns', 'the', 'truth', 'value', 'of', 'x', 'AND', 'y', 'element', '-', 'wise', '.']
->Reconstructed Target:
Returns the truth value of x AND y element - wise.
->Reconstructed Predication:
the logical and of the inputthe output of the logical and
->Raw Input:
summarize:def logical_and ( input_a, input_b, name : nil ) check_data_types ( input_a, input_b ) _op ( :logical_and, input_a, input_b, name : name ) end
->Raw Target:
Returns the truth value of x AND y element - wise.
--

259=========
->Original Input:
['def', 'reduce_mean', '(', 'input_tensor', ',', 'axis', '=', 'nil', ',', 'keepdims', ':', 'false', ',', 'name', ':', 'nil', ')', 'reduce', '(', ':mean', ',', 'input_tensor', ',', 'axis', ',', 'keepdims', ':', 'keepdims', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'the', 'mean', 'of', 'elements', 'across', 'dimensions', 'of', 'a', 'tensor', '.']
->Reconstructed Target:
Computes the mean of elements across dimensions of a tensor.
->Reconstructed Predication:
the input tensor to thethe output tensor to the input
->Raw Input:
summarize:def reduce_mean ( input_tensor, axis = nil, keepdims : false, name : nil ) reduce ( :mean, input_tensor, axis, keepdims : keepdims, name : name ) end
->Raw Target:
Computes the mean of elements across dimensions of a tensor.
--

260=========
->Original Input:
['def', 'concat', '(', 'values', ',', 'axis', ',', 'name', ':', '"concat"', ')', 'if', 'values', '.', 'is_a?', '(', 'Array', ')', '_op', '(', ':concat', ',', 'axis', ',', '*', 'values', ',', 'name', ':', 'name', ')', 'else', '_op', '(', ':concat', ',', 'axis', ',', 'values', ',', 'name', ':', 'name', ')', 'end', 'end']
->Original Target:
['Concatenates', 'tensors', 'along', 'one', 'dimension', '.']
->Reconstructed Target:
Concatenates tensors along one dimension.
->Reconstructed Predication:
concatenate a set of values to
->Raw Input:
summarize:def concat ( values, axis, name : "concat" ) if values. is_a? ( Array ) _op ( :concat, axis, * values, name : name ) else _op ( :concat, axis, values, name : name ) end end
->Raw Target:
Concatenates tensors along one dimension.
--

261=========
->Original Input:
['def', 'dynamic_partition', '(', 'data', ',', 'partitions', ',', 'num_partitions', ',', 'name', ':', 'nil', ')', 'result', '=', '_op', '(', ':dynamic_partition', ',', 'data', ',', 'partitions', ',', 'num_partitions', ':', 'num_partitions', ',', 'name', ':', 'nil', ')', 'num_partitions', '.', 'times', '.', 'map', 'do', '|', 'index', '|', 'result', '[', 'index', ']', 'end', 'end']
->Original Target:
['Partitions', 'data', 'into', 'num_partitions', 'tensors', 'using', 'indices', 'from', 'partitions']
->Reconstructed Target:
Partitions data into num_partitions tensors using indices from partitions
->Reconstructed Predication:
the data to be returnedthe data to be returned
->Raw Input:
summarize:def dynamic_partition ( data, partitions, num_partitions, name : nil ) result = _op ( :dynamic_partition, data, partitions, num_partitions : num_partitions, name : nil ) num_partitions. times. map do | index | result [ index ] end end
->Raw Target:
Partitions data into num_partitions tensors using indices from partitions
--

262=========
->Original Input:
['def', 'where', '(', 'condition', ',', 'true_t', '=', 'nil', ',', 'false_t', '=', 'nil', ',', 'name', ':', 'nil', ')', '_op', '(', ':where', ',', 'condition', ',', 'true_t', ',', 'false_t', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Return', 'the', 'elements', 'either', 'from', 'x', 'or', 'y', 'depending', 'on', 'the', 'condition', '.']
->Reconstructed Target:
Return the elements either from x or y depending on the condition.
->Reconstructed Predication:
where a condition is truereturn the result of the condition
->Raw Input:
summarize:def where ( condition, true_t = nil, false_t = nil, name : nil ) _op ( :where, condition, true_t, false_t, name : name ) end
->Raw Target:
Return the elements either from x or y depending on the condition.
--

263=========
->Original Input:
['def', 'asin', '(', 'input', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input', ',', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':asin', ',', 'input', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'asin', 'of', 'input', 'element', '-', 'wise']
->Reconstructed Target:
Computes asin of input element - wise
->Reconstructed Predication:
a floating point.  defreturn
->Raw Input:
summarize:def asin ( input, name : nil ) check_allowed_types ( input, FLOATING_POINT_TYPES ) _op ( :asin, input, name : name ) end
->Raw Target:
Computes asin of input element - wise
--

264=========
->Original Input:
['def', 'acos', '(', 'input', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input', ',', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':acos', ',', 'input', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'acos', 'of', 'input', 'element', '-', 'wise']
->Reconstructed Target:
Computes acos of input element - wise
->Reconstructed Predication:
a floating point.  defreturn a floating point.
->Raw Input:
summarize:def acos ( input, name : nil ) check_allowed_types ( input, FLOATING_POINT_TYPES ) _op ( :acos, input, name : name ) end
->Raw Target:
Computes acos of input element - wise
--

265=========
->Original Input:
['def', 'atan', '(', 'input', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input', ',', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':atan', ',', 'input', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'atan', 'of', 'input', 'element', '-', 'wise']
->Reconstructed Target:
Computes atan of input element - wise
->Reconstructed Predication:
summarize a number of floatsreturn a number of floats
->Raw Input:
summarize:def atan ( input, name : nil ) check_allowed_types ( input, FLOATING_POINT_TYPES ) _op ( :atan, input, name : name ) end
->Raw Target:
Computes atan of input element - wise
--

266=========
->Original Input:
['def', 'cast', '(', 'input', ',', 'dtype', ',', 'name', ':', 'nil', ')', 'input', '=', 'convert_to_tensor', '(', 'input', ')', 'return', 'input', 'if', 'input', '.', 'data_type', '==', 'dtype', '_op', '(', ':cast', ',', 'input', ',', 'data_type', ':', 'dtype', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Casts', 'a', 'tensor', 'to', 'a', 'new', 'type', 'if', 'needed']
->Reconstructed Target:
Casts a tensor to a new type if needed
->Reconstructed Predication:
the input tensor to a giventhe input tensor to a given
->Raw Input:
summarize:def cast ( input, dtype, name : nil ) input = convert_to_tensor ( input ) return input if input. data_type == dtype _op ( :cast, input, data_type : dtype, name : name ) end
->Raw Target:
Casts a tensor to a new type if needed
--

267=========
->Original Input:
['def', 'print', '(', 'input', ',', 'data', ',', 'message', ':', 'nil', ',', 'name', ':', 'nil', ')', '_op', '(', ':print', ',', 'input', ',', 'data', ',', 'message', ':', 'message', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Prints', 'a', 'list', 'of', 'tensors', '.']
->Reconstructed Target:
Prints a list of tensors.
->Reconstructed Predication:
print input data data name :
->Raw Input:
summarize:def print ( input, data, message : nil, name : nil ) _op ( :print, input, data, message : message, name : name ) end
->Raw Target:
Prints a list of tensors.
--

268=========
->Original Input:
['def', 'sec', '(', 'input', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input', ',', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':sec', ',', 'input', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'sec', 'of', 'input', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes sec of input element - wise.
->Reconstructed Predication:
the input Floating point. 
->Raw Input:
summarize:def sec ( input, name : nil ) check_allowed_types ( input, FLOATING_POINT_TYPES ) _op ( :sec, input, name : name ) end
->Raw Target:
Computes sec of input element - wise.
--

269=========
->Original Input:
['def', 'sqrt', '(', 'input', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input', ',', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':sqrt', ',', 'input', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'sqrt', 'of', 'input', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes sqrt of input element - wise.
->Reconstructed Predication:
summarize a float. Returns thethe sum of the input
->Raw Input:
summarize:def sqrt ( input, name : nil ) check_allowed_types ( input, FLOATING_POINT_TYPES ) _op ( :sqrt, input, name : name ) end
->Raw Target:
Computes sqrt of input element - wise.
--

270=========
->Original Input:
['def', 'log', '(', 'input', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input', ',', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':log', ',', 'input', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'natural', 'logarithm', 'of', 'x', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes natural logarithm of x element - wise.
->Reconstructed Predication:
the log of the inputthe log of the input
->Raw Input:
summarize:def log ( input, name : nil ) check_allowed_types ( input, FLOATING_POINT_TYPES ) _op ( :log, input, name : name ) end
->Raw Target:
Computes natural logarithm of x element - wise.
--

271=========
->Original Input:
['def', 'exp', '(', 'input', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input', ',', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':exp', ',', 'input', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'exponential', 'of', 'x', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes exponential of x element - wise.
->Reconstructed Predication:
summarize a floatreturn summarize ( input )
->Raw Input:
summarize:def exp ( input, name : nil ) check_allowed_types ( input, FLOATING_POINT_TYPES ) _op ( :exp, input, name : name ) end
->Raw Target:
Computes exponential of x element - wise.
--

272=========
->Original Input:
['def', 'pad', '(', 'tensor', ',', 'paddings', ',', 'mode', ':', '"CONSTANT"', ',', 'name', ':', 'nil', ')', '_op', '(', ':pad', ',', 'tensor', ',', 'paddings', ',', 'mode', ':', 'mode', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Pads', 'a', 'tensor', '.', 'This', 'operation', 'pads', 'a', 'tensor', 'according', 'to', 'the', 'paddings', 'you', 'specify', '.']
->Reconstructed Target:
Pads a tensor. This operation pads a tensor according to the paddings you specify.
->Reconstructed Predication:
pad a tensor to a lengthpad a tensor to a lengthreturn tensor
->Raw Input:
summarize:def pad ( tensor, paddings, mode : "CONSTANT", name : nil ) _op ( :pad, tensor, paddings, mode : mode, name : name ) end
->Raw Target:
Pads a tensor. This operation pads a tensor according to the paddings you specify.
--

273=========
->Original Input:
['def', 'gather', '(', 'params', ',', 'indices', ',', 'validate_indices', ':', 'nil', ',', 'name', ':', 'nil', ',', 'axis', ':', '0', ')', '_op', '(', ':gather', ',', 'params', ',', 'indices', ',', 'validate_indices', ':', 'validate_indices', ',', 'name', ':', 'name', ',', 'axis', ':', 'axis', ')', 'end']
->Original Target:
['Gather', 'slices', 'from', 'params', 'and', 'axis', 'according', 'to', 'indices', '.']
->Reconstructed Target:
Gather slices from params and axis according to indices.
->Reconstructed Predication:
the data to be gathered.the data to be gathered.
->Raw Input:
summarize:def gather ( params, indices, validate_indices : nil, name : nil, axis : 0 ) _op ( :gather, params, indices, validate_indices : validate_indices, name : name, axis : axis ) end
->Raw Target:
Gather slices from params and axis according to indices.
--

274=========
->Original Input:
['def', 'pack', '(', 'values', ',', 'axis', ':', '0', ',', 'name', ':', '"pack"', ')', '_op', '(', ':stack', ',', '*', 'values', ',', 'axis', ':', 'axis', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Same', 'as', 'stack']
->Reconstructed Target:
Same as stack
->Reconstructed Predication:
the array of values tothe array to be packed into
->Raw Input:
summarize:def pack ( values, axis : 0, name : "pack" ) _op ( :stack, * values, axis : axis, name : name ) end
->Raw Target:
Same as stack
--

275=========
->Original Input:
['def', 'unpack', '(', 'value', ',', 'num', ':', 'nil', ',', 'axis', ':', '0', ',', 'name', ':', '"unpack"', ')', 'unstack', '(', 'value', ',', 'num', ':', 'num', ',', 'axis', ':', 'axis', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Same', 'as', 'unstack']
->Reconstructed Target:
Same as unstack
->Reconstructed Predication:
unstack value.  defreturn value.
->Raw Input:
summarize:def unpack ( value, num : nil, axis : 0, name : "unpack" ) unstack ( value, num : num, axis : axis, name : name ) end
->Raw Target:
Same as unstack
--

276=========
->Original Input:
['def', 'case', '(', 'args', '=', '{', '}', ')', 'args', '=', 'args', '.', 'dup', 'default', '=', 'args', '.', 'delete', '(', ':default', ')', 'exclusive', '=', 'args', '.', 'delete', '(', ':exclusive', ')', 'strict', '=', 'args', '.', 'delete', '(', ':strict', ')', 'name', '=', 'args', '.', 'delete', '(', ':name', ')', 'predicates', '=', '[', ']', 'functions', '=', '[', ']', 'args', '.', 'each', 'do', '|', 'k', ',', 'v', '|', 'raise', '"Invalid argment or option #{k}"', 'unless', 'k', '.', 'is_a?', '(', 'Tensor', ')', 'predicates', '<<', 'k', 'functions', '<<', '(', 'v', '.', 'is_a?', '(', 'Proc', ')', '?', 'v', '.', 'call', ':', 'v', ')', 'end', '_op', '(', ':case', ',', 'predicates', ',', 'default', ',', '*', 'functions', ',', 'exclusive', ':', 'exclusive', ',', 'strict', ':', 'strict', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Create', 'a', 'case', 'operation', '.']
->Reconstructed Target:
Create a case operation.
->Reconstructed Predication:
a case of aa case of aa case of aa case of aa case of aa case of a given
->Raw Input:
summarize:def case ( args = { } ) args = args. dup default = args. delete ( :default ) exclusive = args. delete ( :exclusive ) strict = args. delete ( :strict ) name = args. delete ( :name ) predicates = [ ] functions = [ ] args. each do | k, v | raise "Invalid argment or option #{k}" unless k. is_a? ( Tensor ) predicates << k functions << ( v. is_a? ( Proc )? v. call : v ) end _op ( :case, predicates, default, * functions, exclusive : exclusive, strict : strict, name : name ) end
->Raw Target:
Create a case operation.
--

277=========
->Original Input:
['def', 'i_op', '(', 'code', ',', '*', 'args', ')', 'options', '=', 'if', 'args', '.', 'last', '.', 'is_a?', '(', 'Hash', ')', 'args', '.', 'pop', 'else', '{', '}', 'end', 'args', '<<', 'options', '.', 'merge', '(', 'internal', ':', 'true', ')', 'Graph', '.', 'get_default_graph', '.', 'add_op!', '(', 'code', '.', 'to_sym', ',', '*', 'args', ')', 'end']
->Original Target:
['same', 'as', 'op', 'but', 'with', 'a', 'marker', 'that', 'it', 'was', 'internal', 'generated']
->Reconstructed Target:
same as op but with a marker that it was internal generated
->Reconstructed Predication:
the operation to execute.
->Raw Input:
summarize:def i_op ( code, * args ) options = if args. last. is_a? ( Hash ) args. pop else { } end args << options. merge ( internal : true ) Graph. get_default_graph. add_op! ( code. to_sym, * args ) end
->Raw Target:
same as op but with a marker that it was internal generated
--

278=========
->Original Input:
['def', 'broadcast_dimensions', '(', 'input', ',', 'dims', '=', '[', ']', ')', 'return', 'input', 'if', 'dims', '.', 'empty?', 'd', '=', 'dims', '.', 'shift', 'if', 'input', '.', 'is_a?', '(', 'Array', ')', '&&', '(', 'get_rank', '(', 'input', ')', '-', '1', ')', '==', 'dims', '.', 'size', 'row_to_dup', '=', 'input', '.', 'collect', '{', '|', 'item', '|', 'broadcast_dimensions', '(', 'item', ',', 'dims', '.', 'dup', ')', '}', 'row_to_dup', '+', 'Array', '.', 'new', '(', 'd', ')', '{', 'row_to_dup', '}', '.', 'flatten', '(', '1', ')', 'elsif', 'input', '.', 'is_a?', '(', 'Array', ')', 'Array', '.', 'new', '(', 'd', ')', '{', 'broadcast_dimensions', '(', 'input', ',', 'dims', '.', 'dup', ')', '}', 'else', 'Array', '.', 'new', '(', 'd', '+', '1', ')', '{', 'input', '}', 'end', 'end']
->Original Target:
['explicit', 'broadcasting', 'helper']
->Reconstructed Target:
explicit broadcasting helper
->Reconstructed Predication:
the dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe dimensions of the inputthe
->Raw Input:
summarize:def broadcast_dimensions ( input, dims = [ ] ) return input if dims. empty? d = dims. shift if input. is_a? ( Array ) && ( get_rank ( input ) - 1 ) == dims. size row_to_dup = input. collect { | item | broadcast_dimensions ( item, dims. dup ) } row_to_dup + Array. new ( d ) { row_to_dup }. flatten ( 1 ) elsif input. is_a? ( Array ) Array. new ( d ) { broadcast_dimensions ( input, dims. dup ) } else Array. new ( d + 1 ) { input } end end
->Raw Target:
explicit broadcasting helper
--

279=========
->Original Input:
['def', 'vector_op', '(', 'vector', ',', 'vector2', ',', 'switch', '=', 'false', ',', 'safe', '=', 'true', ',', '&', 'block', ')', 'if', 'get_rank', '(', 'vector', ')', '<', 'get_rank', '(', 'vector2', ')', 'duplicated', '=', 'Array', '.', 'new', '(', 'vector2', '.', 'size', ')', '{', 'vector', '}', 'return', 'vector_op', '(', 'duplicated', ',', 'vector2', ',', 'switch', ',', '&', 'block', ')', 'end', 'return', 'yield', '(', 'vector', ',', 'vector2', ')', 'unless', 'vector', '.', 'is_a?', '(', 'Array', ')', 'vector', '.', 'each_with_index', '.', 'collect', '{', '|', 'input', ',', 'index', '|', 'next', 'vector_op', '(', 'input', ',', 'vector2', ',', 'switch', ',', '&', 'block', ')', 'if', 'input', '.', 'is_a?', '(', 'Array', ')', '&&', 'get_rank', '(', 'vector', ')', '>', 'get_rank', '(', 'vector2', ')', 'if', 'safe', '&&', 'vector2', '.', 'is_a?', '(', 'Array', ')', 'next', 'nil', 'if', 'vector2', '.', 'size', '!=', '1', '&&', 'index', '>=', 'vector2', '.', 'size', 'end', 'z', '=', 'if', 'vector2', '.', 'is_a?', '(', 'Array', ')', 'if', 'index', '<', 'vector2', '.', 'size', 'vector2', '[', 'index', ']', 'else', 'raise', '"incompatible tensor shapes used during op"', 'if', 'vector2', '.', 'size', '!=', '1', 'vector2', '[', '0', ']', 'end', 'else', 'vector2', 'end', 'if', 'input', '.', 'is_a?', '(', 'Array', ')', 'vector_op', '(', 'input', ',', 'z', ',', 'switch', ',', '&', 'block', ')', 'else', 'switch', '?', 'yield', '(', 'z', ',', 'input', ')', ':', 'yield', '(', 'input', ',', 'z', ')', 'end', '}', '.', 'compact', 'end']
->Original Target:
['handle', '2', 'tensor', 'math', 'operations']
->Reconstructed Target:
handle 2 tensor math operations
->Reconstructed Predication:
vector2 )vector2 )vector2 )vector2 )vector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 ) > vectorvector2 )
->Raw Input:
summarize:def vector_op ( vector, vector2, switch = false, safe = true, & block ) if get_rank ( vector ) < get_rank ( vector2 ) duplicated = Array. new ( vector2. size ) { vector } return vector_op ( duplicated, vector2, switch, & block ) end return yield ( vector, vector2 ) unless vector. is_a? ( Array ) vector. each_with_index. collect { | input, index | next vector_op ( input, vector2, switch, & block ) if input. is_a? ( Array ) && get_rank ( vector ) > get_rank ( vector2 ) if safe && vector2. is_a? ( Array ) next nil if vector2. size!= 1 && index >= vector2. size end z = if vector2. is_a? ( Array ) if index < vector2. size vector2 [ index ] else raise "incompatible tensor shapes used during op" if vector2. size!= 1 vector2 [ 0 ] end else vector2 end if input. is_a? ( Array ) vector_op ( input, z, switch, & block ) else switch? yield ( z, input ) : yield ( input, z ) end }. compact end
->Raw Target:
handle 2 tensor math operations
--

280=========
->Original Input:
['def', 'transpose_with_perm', '(', 'arr', ',', 'new_arr', ',', 'shape', ',', 'new_shape', ',', 'perm', ')', 'arr_size', '=', 'shape', '.', 'reduce', '(', ':*', ')', 'divisors', '=', 'shape', '.', 'dup', '.', 'drop', '(', '1', ')', '.', 'reverse', '.', 'inject', '(', '[', '1', ']', ')', '{', '|', 'a', ',', 's', '|', 'a', '<<', 's', '*', 'a', '.', 'last', '}', '.', 'reverse', 'multipliers', '=', 'new_shape', '.', 'dup', '.', 'drop', '(', '1', ')', '.', 'reverse', '.', 'inject', '(', '[', '1', ']', ')', '{', '|', 'a', ',', 's', '|', 'a', '<<', 's', '*', 'a', '.', 'last', '}', '.', 'reverse', 'arr_size', '.', 'times', 'do', '|', 'p', '|', 'ptr', '=', 'p', 'index', '=', '[', ']', 'divisors', '.', 'each_with_object', '(', 'index', ')', 'do', '|', 'div', ',', 'a', '|', 'a', '<<', '(', 'ptr', '/', 'div', '.', 'to_f', ')', '.', 'floor', 'ptr', '=', 'ptr', '%', 'div', 'end', 'remaped', '=', 'perm', '.', 'map', '{', '|', 'x', '|', 'index', '[', 'x', ']', '}', 'ptr2', '=', '0', 'multipliers', '.', 'each_with_index', 'do', '|', 'm', ',', 'idx', '|', 'ptr2', '+=', 'remaped', '[', 'idx', ']', '*', 'm', 'end', 'new_arr', '[', 'ptr2', ']', '=', 'arr', '[', 'p', ']', 'end', '[', 'new_arr', ',', 'new_shape', ']', 'end']
->Original Target:
['general', 'case', 'transposition', 'with', 'flat', 'arrays']
->Reconstructed Target:
general case transposition with flat arrays
->Reconstructed Predication:
the array with thethe new array with thethe new arraythe new array with thethe new arraythe new array with thethe new array with thethe new array with thethe new array with thethe new array with thethe new array with thethe new array with thethe new array with thethe new array with thethe new array with the newthe new array with thethe new array with the
->Raw Input:
summarize:def transpose_with_perm ( arr, new_arr, shape, new_shape, perm ) arr_size = shape. reduce ( :* ) divisors = shape. dup. drop ( 1 ). reverse. inject ( [ 1 ] ) { | a, s | a << s * a. last }. reverse multipliers = new_shape. dup. drop ( 1 ). reverse. inject ( [ 1 ] ) { | a, s | a << s * a. last }. reverse arr_size. times do | p | ptr = p index = [ ] divisors. each_with_object ( index ) do | div, a | a << ( ptr / div. to_f ). floor ptr = ptr % div end remaped = perm. map { | x | index [ x ] } ptr2 = 0 multipliers. each_with_index do | m, idx | ptr2 += remaped [ idx ] * m end new_arr [ ptr2 ] = arr [ p ] end [ new_arr, new_shape ] end
->Raw Target:
general case transposition with flat arrays
--

281=========
->Original Input:
['def', 'add', '(', 'input_a', ',', 'input_b', ',', 'name', ':', 'nil', ')', 'input_a', ',', 'input_b', '=', 'apply_data_type_coercion', '(', 'input_a', ',', 'input_b', ')', '_op', '(', ':add', ',', 'input_a', ',', 'input_b', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Returns', 'x', '+', 'y', 'element', '-', 'wise', '.']
->Reconstructed Target:
Returns x + y element - wise.
->Reconstructed Predication:
the input and the output
->Raw Input:
summarize:def add ( input_a, input_b, name : nil ) input_a, input_b = apply_data_type_coercion ( input_a, input_b ) _op ( :add, input_a, input_b, name : name ) end
->Raw Target:
Returns x + y element - wise.
--

282=========
->Original Input:
['def', 'argmax', '(', 'input_a', ',', 'axis', '=', 'nil', ',', 'name', ':', 'nil', ',', 'dimension', ':', 'nil', ',', 'output_type', ':', ':int32', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'NUMERIC_TYPES', ')', 'check_allowed_types', '(', 'axis', ',', 'TensorStream', '::', 'Ops', '::', 'INTEGER_TYPES', ')', '_op', '(', ':argmax', ',', 'input_a', ',', 'axis', ',', 'name', ':', 'name', ',', 'dimension', ':', 'dimension', ',', 'output_type', ':', 'output_type', ')', 'end']
->Original Target:
['Returns', 'the', 'index', 'with', 'the', 'largest', 'value', 'across', 'axes', 'of', 'a', 'tensor', '.']
->Reconstructed Target:
Returns the index with the largest value across axes of a tensor.
->Reconstructed Predication:
the max value of athe max value of athe max value of athe max value of a
->Raw Input:
summarize:def argmax ( input_a, axis = nil, name : nil, dimension : nil, output_type : :int32 ) check_allowed_types ( input_a, TensorStream :: Ops :: NUMERIC_TYPES ) check_allowed_types ( axis, TensorStream :: Ops :: INTEGER_TYPES ) _op ( :argmax, input_a, axis, name : name, dimension : dimension, output_type : output_type ) end
->Raw Target:
Returns the index with the largest value across axes of a tensor.
--

283=========
->Original Input:
['def', 'ceil', '(', 'input_a', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':ceil', ',', 'input_a', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Returns', 'element', '-', 'wise', 'smallest', 'integer', 'in', 'not', 'less', 'than', 'x']
->Reconstructed Target:
Returns element - wise smallest integer in not less than x
->Reconstructed Predication:
summarize a vector of floatsreturn summarize_a.
->Raw Input:
summarize:def ceil ( input_a, name : nil ) check_allowed_types ( input_a, TensorStream :: Ops :: FLOATING_POINT_TYPES ) _op ( :ceil, input_a, name : name ) end
->Raw Target:
Returns element - wise smallest integer in not less than x
--

284=========
->Original Input:
['def', 'cos', '(', 'input_a', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':cos', ',', 'input_a', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'cos', 'of', 'input', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes cos of input element - wise.
->Reconstructed Predication:
summarize a vector ofreturn summarize_a
->Raw Input:
summarize:def cos ( input_a, name : nil ) check_allowed_types ( input_a, TensorStream :: Ops :: FLOATING_POINT_TYPES ) _op ( :cos, input_a, name : name ) end
->Raw Target:
Computes cos of input element - wise.
--

285=========
->Original Input:
['def', 'floor', '(', 'input_a', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':floor', ',', 'input_a', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Returns', 'element', '-', 'wise', 'largest', 'integer', 'not', 'greater', 'than', 'x', '.']
->Reconstructed Target:
Returns element - wise largest integer not greater than x.
->Reconstructed Predication:
summarize a tensorreturn tensor_of_floating_point
->Raw Input:
summarize:def floor ( input_a, name : nil ) check_allowed_types ( input_a, TensorStream :: Ops :: FLOATING_POINT_TYPES ) _op ( :floor, input_a, name : name ) end
->Raw Target:
Returns element - wise largest integer not greater than x.
--

286=========
->Original Input:
['def', 'mod', '(', 'input_a', ',', 'input_b', ',', 'name', ':', 'nil', ')', 'input_a', ',', 'input_b', '=', 'apply_data_type_coercion', '(', 'input_a', ',', 'input_b', ')', '_op', '(', ':mod', ',', 'input_a', ',', 'input_b', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Returns', 'element', '-', 'wise', 'remainder', 'of', 'division', '.']
->Reconstructed Target:
Returns element - wise remainder of division.
->Reconstructed Predication:
mod_a mod_b
->Raw Input:
summarize:def mod ( input_a, input_b, name : nil ) input_a, input_b = apply_data_type_coercion ( input_a, input_b ) _op ( :mod, input_a, input_b, name : name ) end
->Raw Target:
Returns element - wise remainder of division.
--

287=========
->Original Input:
['def', 'pow', '(', 'input_a', ',', 'input_b', ',', 'name', ':', 'nil', ')', 'input_a', ',', 'input_b', '=', 'apply_data_type_coercion', '(', 'input_a', ',', 'input_b', ')', '_op', '(', ':pow', ',', 'input_a', ',', 'input_b', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'the', 'power', 'of', 'one', 'value', 'to', 'another', 'X^Y', 'element', 'wise']
->Reconstructed Target:
Computes the power of one value to another X^Y element wise
->Reconstructed Predication:
the summarize of the input_a andthe summarize of the input_b
->Raw Input:
summarize:def pow ( input_a, input_b, name : nil ) input_a, input_b = apply_data_type_coercion ( input_a, input_b ) _op ( :pow, input_a, input_b, name : name ) end
->Raw Target:
Computes the power of one value to another X^Y element wise
--

288=========
->Original Input:
['def', 'prod', '(', 'input_a', ',', 'axis', '=', 'nil', ',', 'name', ':', 'nil', ',', 'keepdims', ':', 'false', ')', 'check_allowed_types', '(', 'axis', ',', 'TensorStream', '::', 'Ops', '::', 'INTEGER_TYPES', ')', 'input_a', '=', 'TensorStream', '.', 'convert_to_tensor', '(', 'input_a', ')', 'return', 'input_a', 'if', 'input_a', '.', 'shape', '.', 'scalar?', 'axis', '=', 'cast_axis', '(', 'input_a', ',', 'axis', ')', '_op', '(', ':prod', ',', 'input_a', ',', 'axis', ',', 'name', ':', 'name', ',', 'keepdims', ':', 'keepdims', ')', 'end']
->Original Target:
['Computes', 'the', 'product', 'of', 'elements', 'across', 'dimensions', 'of', 'a', 'tensor', '.', 'Reduces', 'input_tensor', 'along', 'the', 'dimensions', 'given', 'in', 'axis', '.', 'Unless', 'keepdims', 'is', 'true', 'the', 'rank', 'of', 'the', 'tensor', 'is', 'reduced', 'by', '1', 'for', 'each', 'entry', 'in', 'axis', '.', 'If', 'keepdims', 'is', 'true', 'the', 'reduced', 'dimensions', 'are', 'retained', 'with', 'length', '1', '.', 'If', 'axis', 'has', 'no', 'entries', 'all', 'dimensions', 'are', 'reduced', 'and', 'a', 'tensor', 'with', 'a', 'single', 'element', 'is', 'returned', '.']
->Reconstructed Target:
Computes the product of elements across dimensions of a tensor. Reduces input_tensor along the dimensions given in axis. Unless keepdims is true the rank of the tensor is reduced by 1 for each entry in axis. If keepdims is true the reduced dimensions are retained with length 1. If axis has no entries all dimensions are reduced and a tensor with a single element is returned.
->Reconstructed Predication:
: return : the summarize of: return : the summarize of thethe summarize of the input_athe summarize of the input_a
->Raw Input:
summarize:def prod ( input_a, axis = nil, name : nil, keepdims : false ) check_allowed_types ( axis, TensorStream :: Ops :: INTEGER_TYPES ) input_a = TensorStream. convert_to_tensor ( input_a ) return input_a if input_a. shape. scalar? axis = cast_axis ( input_a, axis ) _op ( :prod, input_a, axis, name : name, keepdims : keepdims ) end
->Raw Target:
Computes the product of elements across dimensions of a tensor. Reduces input_tensor along the dimensions given in axis. Unless keepdims is true the rank of the tensor is reduced by 1 for each entry in axis. If keepdims is true the reduced dimensions are retained with length 1. If axis has no entries all dimensions are reduced and a tensor with a single element is returned.
--

289=========
->Original Input:
['def', 'random_uniform', '(', 'shape', ',', 'name', ':', 'nil', ',', 'dtype', ':', ':float32', ',', 'minval', ':', '0', ',', 'maxval', ':', '1', ',', 'seed', ':', 'nil', ')', '_op', '(', ':random_uniform', ',', 'shape', ',', 'name', ':', 'name', ',', 'dtype', ':', 'dtype', ',', 'minval', ':', 'minval', ',', 'maxval', ':', 'maxval', ',', 'seed', ':', 'seed', ')', 'end']
->Original Target:
['Outputs', 'random', 'values', 'from', 'a', 'uniform', 'distribution', '.']
->Reconstructed Target:
Outputs random values from a uniform distribution.
->Reconstructed Predication:
the random uniform of the giventhe random uniform of the giventhe random uniform of the giventhe given shape.
->Raw Input:
summarize:def random_uniform ( shape, name : nil, dtype : :float32, minval : 0, maxval : 1, seed : nil ) _op ( :random_uniform, shape, name : name, dtype : dtype, minval : minval, maxval : maxval, seed : seed ) end
->Raw Target:
Outputs random values from a uniform distribution.
--

290=========
->Original Input:
['def', 'range', '(', 'start', '=', '0', ',', 'limit', '=', '0', ',', 'delta', '=', '1', ',', 'name', ':', '"range"', ',', 'dtype', ':', 'nil', ',', 'output_type', ':', ':int32', ')', '_op', '(', ':range', ',', 'start', ',', 'limit', ',', 'delta', ',', 'name', ':', 'name', ',', 'dtype', ':', 'dtype', ',', 'output_type', ':', 'output_type', ')', 'end']
->Original Target:
['Creates', 'a', 'sequence', 'of', 'numbers', '.', 'Creates', 'a', 'sequence', 'of', 'numbers', 'that', 'begins', 'at', 'start', 'and', 'extends', 'by', 'increments', 'of', 'delta', 'up', 'to', 'but', 'not', 'including', 'limit', '.']
->Reconstructed Target:
Creates a sequence of numbers. Creates a sequence of numbers that begins at start and extends by increments of delta up to but not including limit.
->Reconstructed Predication:
range a range of arange a range of a range
->Raw Input:
summarize:def range ( start = 0, limit = 0, delta = 1, name : "range", dtype : nil, output_type : :int32 ) _op ( :range, start, limit, delta, name : name, dtype : dtype, output_type : output_type ) end
->Raw Target:
Creates a sequence of numbers. Creates a sequence of numbers that begins at start and extends by increments of delta up to but not including limit.
--

291=========
->Original Input:
['def', 'rank', '(', 'input', ',', 'name', ':', 'nil', ')', 'input', '=', 'convert_to_tensor', '(', 'input', ')', 'return', 'cons', '(', 'input', '.', 'shape', '.', 'ndims', ')', 'if', 'input', '.', 'shape', '.', 'known?', '_op', '(', ':rank', ',', 'input', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Returns', 'the', 'rank', 'of', 'a', 'tensor']
->Reconstructed Target:
Returns the rank of a tensor
->Reconstructed Predication:
the rank of the tensor
->Raw Input:
summarize:def rank ( input, name : nil ) input = convert_to_tensor ( input ) return cons ( input. shape. ndims ) if input. shape. known? _op ( :rank, input, name : name ) end
->Raw Target:
Returns the rank of a tensor
--

292=========
->Original Input:
['def', 'round', '(', 'input_a', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':round', ',', 'input_a', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Rounds', 'the', 'values', 'of', 'a', 'tensor', 'to', 'the', 'nearest', 'integer', 'element', '-', 'wise']
->Reconstructed Target:
Rounds the values of a tensor to the nearest integer element - wise
->Reconstructed Predication:
the input value of thethe input value of the input
->Raw Input:
summarize:def round ( input_a, name : nil ) check_allowed_types ( input_a, TensorStream :: Ops :: FLOATING_POINT_TYPES ) _op ( :round, input_a, name : name ) end
->Raw Target:
Rounds the values of a tensor to the nearest integer element - wise
--

293=========
->Original Input:
['def', 'rsqrt', '(', 'input_a', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':rsqrt', ',', 'input_a', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'reciprocal', 'of', 'square', 'root', 'of', 'x', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes reciprocal of square root of x element - wise.
->Reconstructed Predication:
summarize a tensorreturn a tensor
->Raw Input:
summarize:def rsqrt ( input_a, name : nil ) check_allowed_types ( input_a, TensorStream :: Ops :: FLOATING_POINT_TYPES ) _op ( :rsqrt, input_a, name : name ) end
->Raw Target:
Computes reciprocal of square root of x element - wise.
--

294=========
->Original Input:
['def', 'shape', '(', 'input', ',', 'name', ':', 'nil', ',', 'out_type', ':', ':int32', ')', 'return', 'constant', '(', 'shape_eval', '(', 'input', ',', 'out_type', ')', ',', 'dtype', ':', 'out_type', ',', 'name', ':', '"Shape/#{name}"', ')', 'if', 'input', '.', 'is_a?', '(', 'Array', ')', '&&', '!', 'input', '[', '0', ']', '.', 'is_a?', '(', 'Tensor', ')', 'return', 'constant', '(', 'input', '.', 'shape', '.', 'shape', ',', 'dtype', ':', 'out_type', ',', 'name', ':', '"Shape/#{input.name}_c"', ')', 'if', 'shape_full_specified', '(', 'input', ')', '_op', '(', ':shape', ',', 'input', ',', 'name', ':', 'name', ',', 'out_type', ':', 'out_type', ')', 'end']
->Original Target:
['This', 'operation', 'returns', 'a', '1', '-', 'D', 'integer', 'tensor', 'representing', 'the', 'shape', 'of', 'input']
->Reconstructed Target:
This operation returns a 1 - D integer tensor representing the shape of input
->Reconstructed Predication:
: int32: int32 ) end  def
->Raw Input:
summarize:def shape ( input, name : nil, out_type : :int32 ) return constant ( shape_eval ( input, out_type ), dtype : out_type, name : "Shape/#{name}" ) if input. is_a? ( Array ) &&! input [ 0 ]. is_a? ( Tensor ) return constant ( input. shape. shape, dtype : out_type, name : "Shape/#{input.name}_c" ) if shape_full_specified ( input ) _op ( :shape, input, name : name, out_type : out_type ) end
->Raw Target:
This operation returns a 1 - D integer tensor representing the shape of input
--

295=========
->Original Input:
['def', 'sigmoid', '(', 'input_a', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':sigmoid', ',', 'input_a', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'sigmoid', 'of', 'x', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes sigmoid of x element - wise.
->Reconstructed Predication:
the input tensor.  defreturn input_a
->Raw Input:
summarize:def sigmoid ( input_a, name : nil ) check_allowed_types ( input_a, TensorStream :: Ops :: FLOATING_POINT_TYPES ) _op ( :sigmoid, input_a, name : name ) end
->Raw Target:
Computes sigmoid of x element - wise.
--

296=========
->Original Input:
['def', 'sin', '(', 'input_a', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':sin', ',', 'input_a', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'sin', 'of', 'input', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes sin of input element - wise.
->Reconstructed Predication:
summarize a vector of areturn a vector of a vector
->Raw Input:
summarize:def sin ( input_a, name : nil ) check_allowed_types ( input_a, TensorStream :: Ops :: FLOATING_POINT_TYPES ) _op ( :sin, input_a, name : name ) end
->Raw Target:
Computes sin of input element - wise.
--

297=========
->Original Input:
['def', 'sub', '(', 'input_a', ',', 'input_b', ',', 'name', ':', 'nil', ')', 'input_a', ',', 'input_b', '=', 'apply_data_type_coercion', '(', 'input_a', ',', 'input_b', ')', '_op', '(', ':sub', ',', 'input_a', ',', 'input_b', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Returns', 'x', '-', 'y', 'element', '-', 'wise', '.']
->Reconstructed Target:
Returns x - y element - wise.
->Reconstructed Predication:
the input and the output.
->Raw Input:
summarize:def sub ( input_a, input_b, name : nil ) input_a, input_b = apply_data_type_coercion ( input_a, input_b ) _op ( :sub, input_a, input_b, name : name ) end
->Raw Target:
Returns x - y element - wise.
--

298=========
->Original Input:
['def', 'sum', '(', 'input_a', ',', 'axis_p', '=', 'nil', ',', 'axis', ':', 'nil', ',', 'name', ':', 'nil', ',', 'keepdims', ':', 'false', ')', 'check_allowed_types', '(', 'axis_p', ',', 'TensorStream', '::', 'Ops', '::', 'INTEGER_TYPES', ')', 'input_a', '=', 'TensorStream', '.', 'convert_to_tensor', '(', 'input_a', ')', 'return', 'input_a', 'if', 'input_a', '.', 'shape', '.', 'scalar?', 'axis_p', '=', 'axis_p', '||', 'axis', 'axis_p', '=', 'cast_axis', '(', 'input_a', ',', 'axis_p', ')', '_op', '(', ':sum', ',', 'input_a', ',', 'axis_p', ',', 'name', ':', 'name', ',', 'keepdims', ':', 'keepdims', ')', 'end']
->Original Target:
['Computes', 'the', 'sum', 'of', 'elements', 'across', 'dimensions', 'of', 'a', 'tensor', '.', 'Reduces', 'input_tensor', 'along', 'the', 'dimensions', 'given', 'in', 'axis', '.', 'Unless', 'keepdims', 'is', 'true', 'the', 'rank', 'of', 'the', 'tensor', 'is', 'reduced', 'by', '1', 'for', 'each', 'entry', 'in', 'axis', '.', 'If', 'keepdims', 'is', 'true', 'the', 'reduced', 'dimensions', 'are', 'retained', 'with', 'length', '1', '.', 'If', 'axis', 'has', 'no', 'entries', 'all', 'dimensions', 'are', 'reduced', 'and', 'a', 'tensor', 'with', 'a', 'single', 'element', 'is', 'returned', '.']
->Reconstructed Target:
Computes the sum of elements across dimensions of a tensor. Reduces input_tensor along the dimensions given in axis. Unless keepdims is true the rank of the tensor is reduced by 1 for each entry in axis. If keepdims is true the reduced dimensions are retained with length 1. If axis has no entries all dimensions are reduced and a tensor with a single element is returned.
->Reconstructed Predication:
summarize a tensoraxis_p = nil name =input_a = TensorStream. convert_to_tensor
->Raw Input:
summarize:def sum ( input_a, axis_p = nil, axis : nil, name : nil, keepdims : false ) check_allowed_types ( axis_p, TensorStream :: Ops :: INTEGER_TYPES ) input_a = TensorStream. convert_to_tensor ( input_a ) return input_a if input_a. shape. scalar? axis_p = axis_p || axis axis_p = cast_axis ( input_a, axis_p ) _op ( :sum, input_a, axis_p, name : name, keepdims : keepdims ) end
->Raw Target:
Computes the sum of elements across dimensions of a tensor. Reduces input_tensor along the dimensions given in axis. Unless keepdims is true the rank of the tensor is reduced by 1 for each entry in axis. If keepdims is true the reduced dimensions are retained with length 1. If axis has no entries all dimensions are reduced and a tensor with a single element is returned.
--

299=========
->Original Input:
['def', 'tan', '(', 'input_a', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':tan', ',', 'input_a', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'tan', 'of', 'input', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes tan of input element - wise.
->Reconstructed Predication:
summarize a tensorreturn tensor_stream
->Raw Input:
summarize:def tan ( input_a, name : nil ) check_allowed_types ( input_a, TensorStream :: Ops :: FLOATING_POINT_TYPES ) _op ( :tan, input_a, name : name ) end
->Raw Target:
Computes tan of input element - wise.
--

300=========
->Original Input:
['def', 'tanh', '(', 'input_a', ',', 'name', ':', 'nil', ')', 'check_allowed_types', '(', 'input_a', ',', 'TensorStream', '::', 'Ops', '::', 'FLOATING_POINT_TYPES', ')', '_op', '(', ':tanh', ',', 'input_a', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Computes', 'tanh', 'of', 'input', 'element', '-', 'wise', '.']
->Reconstructed Target:
Computes tanh of input element - wise.
->Reconstructed Predication:
summarize a tensorreturn tensor_stream
->Raw Input:
summarize:def tanh ( input_a, name : nil ) check_allowed_types ( input_a, TensorStream :: Ops :: FLOATING_POINT_TYPES ) _op ( :tanh, input_a, name : name ) end
->Raw Target:
Computes tanh of input element - wise.
--

301=========
->Original Input:
['def', 'top_k', '(', 'input', ',', 'k', '=', '1', ',', 'sorted', ':', 'true', ',', 'name', ':', 'nil', ')', 'result', '=', '_op', '(', ':top_k', ',', 'input', ',', 'k', ',', 'sorted', ':', 'sorted', ',', 'name', ':', 'name', ')', '[', 'result', '[', '0', ']', ',', 'result', '[', '1', ']', ']', 'end']
->Original Target:
['Finds', 'values', 'and', 'indices', 'of', 'the', 'k', 'largest', 'entries', 'for', 'the', 'last', 'dimension', '.']
->Reconstructed Target:
Finds values and indices of the k largest entries for the last dimension.
->Reconstructed Predication:
the top k elements of thethe top k elements of the
->Raw Input:
summarize:def top_k ( input, k = 1, sorted : true, name : nil ) result = _op ( :top_k, input, k, sorted : sorted, name : name ) [ result [ 0 ], result [ 1 ] ] end
->Raw Target:
Finds values and indices of the k largest entries for the last dimension.
--

302=========
->Original Input:
['def', 'zeros', '(', 'shape', ',', 'dtype', ':', ':float32', ',', 'name', ':', 'nil', ')', '_op', '(', ':zeros', ',', 'shape', ',', 'dtype', ':', 'dtype', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Creates', 'a', 'tensor', 'with', 'all', 'elements', 'set', 'to', 'zero']
->Reconstructed Target:
Creates a tensor with all elements set to zero
->Reconstructed Predication:
zeros a given array ofreturn zeros
->Raw Input:
summarize:def zeros ( shape, dtype : :float32, name : nil ) _op ( :zeros, shape, dtype : dtype, name : name ) end
->Raw Target:
Creates a tensor with all elements set to zero
--

303=========
->Original Input:
['def', 'convert', '(', 'session', ',', 'checkpoint_folder', ',', 'output_file', ')', 'model_file', '=', 'File', '.', 'join', '(', 'checkpoint_folder', ',', '"model.yaml"', ')', 'TensorStream', '.', 'graph', '.', 'as_default', 'do', '|', 'current_graph', '|', 'YamlLoader', '.', 'new', '.', 'load_from_string', '(', 'File', '.', 'read', '(', 'model_file', ')', ')', 'saver', '=', 'TensorStream', '::', 'Train', '::', 'Saver', '.', 'new', 'saver', '.', 'restore', '(', 'session', ',', 'checkpoint_folder', ')', 'remove_nodes', '=', 'Set', '.', 'new', '(', 'current_graph', '.', 'nodes', '.', 'values', '.', 'select', '{', '|', 'op', '|', 'op', '.', 'is_a?', '(', 'TensorStream', '::', 'Operation', ')', '&&', 'op', '.', 'operation', '==', ':assign', '}', '.', 'map', '{', '|', 'op', '|', 'op', '.', 'consumers', '.', 'to_a', '}', '.', 'flatten', '.', 'uniq', ')', 'output_buffer', '=', 'TensorStream', '::', 'Yaml', '.', 'new', '.', 'get_string', '(', 'current_graph', ')', '{', '|', 'graph', ',', 'node_key', '|', 'node', '=', 'graph', '.', 'get_tensor_by_name', '(', 'node_key', ')', 'case', 'node', '.', 'operation', 'when', ':variable_v2', 'value', '=', 'node', '.', 'container', 'options', '=', '{', 'value', ':', 'value', ',', 'data_type', ':', 'node', '.', 'data_type', ',', 'shape', ':', 'shape_eval', '(', 'value', ')', ',', '}', 'const_op', '=', 'TensorStream', '::', 'Operation', '.', 'new', '(', 'current_graph', ',', 'inputs', ':', '[', ']', ',', 'options', ':', 'options', ')', 'const_op', '.', 'name', '=', 'node', '.', 'name', 'const_op', '.', 'operation', '=', ':const', 'const_op', '.', 'data_type', '=', 'node', '.', 'data_type', 'const_op', '.', 'shape', '=', 'TensorShape', '.', 'new', '(', 'shape_eval', '(', 'value', ')', ')', 'const_op', 'when', ':assign', 'nil', 'else', 'remove_nodes', '.', 'include?', '(', 'node', '.', 'name', ')', '?', 'nil', ':', 'node', 'end', '}', 'File', '.', 'write', '(', 'output_file', ',', 'output_buffer', ')', 'end', 'end']
->Original Target:
['Utility', 'class', 'to', 'convert', 'variables', 'to', 'constants', 'for', 'production', 'deployment']
->Reconstructed Target:
Utility class to convert variables to constants for production deployment
->Reconstructed Predication:
...............
->Raw Input:
summarize:def convert ( session, checkpoint_folder, output_file ) model_file = File. join ( checkpoint_folder, "model.yaml" ) TensorStream. graph. as_default do | current_graph | YamlLoader. new. load_from_string ( File. read ( model_file ) ) saver = TensorStream :: Train :: Saver. new saver. restore ( session, checkpoint_folder ) remove_nodes = Set. new ( current_graph. nodes. values. select { | op | op. is_a? ( TensorStream :: Operation ) && op. operation == :assign }. map { | op | op. consumers. to_a }. flatten. uniq ) output_buffer = TensorStream :: Yaml. new. get_string ( current_graph ) { | graph, node_key | node = graph. get_tensor_by_name ( node_key ) case node. operation when :variable_v2 value = node. container options = { value : value, data_type : node. data_type, shape : shape_eval ( value ), } const_op = TensorStream :: Operation. new ( current_graph, inputs : [ ], options : options ) const_op. name = node. name const_op. operation = :const const_op. data_type = node. data_type const_op. shape = TensorShape. new ( shape_eval ( value ) ) const_op when :assign nil else remove_nodes. include? ( node. name )? nil : node end } File. write ( output_file, output_buffer ) end end
->Raw Target:
Utility class to convert variables to constants for production deployment
--

304=========
->Original Input:
['def', 'device', '(', 'device_name', ')', 'Thread', '.', 'current', '[', '"ts_graph_#{object_id}"', ']', '||=', '{', '}', 'Thread', '.', 'current', '[', '"ts_graph_#{object_id}"', ']', '[', ':default_device', ']', '||=', '[', ']', 'Thread', '.', 'current', '[', '"ts_graph_#{object_id}"', ']', '[', ':default_device', ']', '<<', 'device_name', 'begin', 'yield', 'ensure', 'Thread', '.', 'current', '[', '"ts_graph_#{object_id}"', ']', '[', ':default_device', ']', '.', 'pop', 'end', 'end']
->Original Target:
['Returns', 'a', 'context', 'manager', 'that', 'specifies', 'the', 'default', 'device', 'to', 'use', '.']
->Reconstructed Target:
Returns a context manager that specifies the default device to use.
->Reconstructed Predication:
the default device for the
->Raw Input:
summarize:def device ( device_name ) Thread. current [ "ts_graph_#{object_id}" ] ||= { } Thread. current [ "ts_graph_#{object_id}" ] [ :default_device ] ||= [ ] Thread. current [ "ts_graph_#{object_id}" ] [ :default_device ] << device_name begin yield ensure Thread. current [ "ts_graph_#{object_id}" ] [ :default_device ]. pop end end
->Raw Target:
Returns a context manager that specifies the default device to use.
--

305=========
->Original Input:
['def', 'load_from_string', '(', 'buffer', ')', 'serialized_ops', '=', 'YAML', '.', 'safe_load', '(', 'buffer', ',', '[', 'Symbol', ']', ',', '[', ']', ',', 'true', ')', 'serialized_ops', '.', 'each', 'do', '|', 'op_def', '|', 'inputs', '=', 'op_def', '[', ':inputs', ']', '.', 'map', '{', '|', 'i', '|', '@graph', '.', 'get_tensor_by_name', '(', 'i', ')', '}', 'options', '=', '{', '}', 'new_var', '=', 'nil', 'if', 'op_def', '.', 'dig', '(', ':attrs', ',', ':container', ')', 'new_var', '=', 'Variable', '.', 'new', '(', 'op_def', '.', 'dig', '(', ':attrs', ',', ':data_type', ')', ')', 'var_shape', '=', 'op_def', '.', 'dig', '(', ':attrs', ',', ':container', ',', ':shape', ')', 'var_options', '=', 'op_def', '.', 'dig', '(', ':attrs', ',', ':container', ',', ':options', ')', 'var_options', '[', ':name', ']', '=', 'op_def', '[', ':name', ']', 'new_var', '.', 'prepare', '(', 'var_shape', '.', 'size', ',', 'var_shape', ',', 'TensorStream', '.', 'get_variable_scope', ',', 'var_options', ')', 'options', '[', ':container', ']', '=', 'new_var', '@graph', '.', 'add_variable', '(', 'new_var', ',', 'var_options', ')', 'end', 'new_op', '=', 'Operation', '.', 'new', '(', '@graph', ',', 'inputs', ':', 'inputs', ',', 'options', ':', 'op_def', '[', ':attrs', ']', '.', 'merge', '(', 'options', ')', ')', 'new_op', '.', 'operation', '=', 'op_def', '[', ':op', ']', '.', 'to_sym', 'new_op', '.', 'name', '=', 'op_def', '[', ':name', ']', 'new_op', '.', 'shape', '=', 'TensorShape', '.', 'new', '(', 'TensorStream', '::', 'InferShape', '.', 'infer_shape', '(', 'new_op', ')', ')', 'new_op', '.', 'rank', '=', 'new_op', '.', 'shape', '.', 'rank', 'new_op', '.', 'data_type', '=', 'new_op', '.', 'set_data_type', '(', 'op_def', '.', 'dig', '(', ':attrs', ',', ':data_type', ')', ')', 'new_op', '.', 'is_const', '=', 'new_op', '.', 'infer_const', 'new_op', '.', 'given_name', '=', 'new_op', '.', 'name', 'new_var', '.', 'op', '=', 'new_op', 'if', 'new_var', '@graph', '.', 'add_node', '(', 'new_op', ')', 'end', '@graph', 'end']
->Original Target:
['Loads', 'a', 'model', 'Yaml', 'file', 'and', 'builds', 'the', 'model', 'from', 'it']
->Reconstructed Target:
Loads a model Yaml file and builds the model from it
->Reconstructed Predication:
:name ]. to_sym:op ]. to_sym..... shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape. rank. shape.
->Raw Input:
summarize:def load_from_string ( buffer ) serialized_ops = YAML. safe_load ( buffer, [ Symbol ], [ ], true ) serialized_ops. each do | op_def | inputs = op_def [ :inputs ]. map { | i | @graph. get_tensor_by_name ( i ) } options = { } new_var = nil if op_def. dig ( :attrs, :container ) new_var = Variable. new ( op_def. dig ( :attrs, :data_type ) ) var_shape = op_def. dig ( :attrs, :container, :shape ) var_options = op_def. dig ( :attrs, :container, :options ) var_options [ :name ] = op_def [ :name ] new_var. prepare ( var_shape. size, var_shape, TensorStream. get_variable_scope, var_options ) options [ :container ] = new_var @graph. add_variable ( new_var, var_options ) end new_op = Operation. new ( @graph, inputs : inputs, options : op_def [ :attrs ]. merge ( options ) ) new_op. operation = op_def [ :op ]. to_sym new_op. name = op_def [ :name ] new_op. shape = TensorShape. new ( TensorStream :: InferShape. infer_shape ( new_op ) ) new_op. rank = new_op. shape. rank new_op. data_type = new_op. set_data_type ( op_def. dig ( :attrs, :data_type ) ) new_op. is_const = new_op. infer_const new_op. given_name = new_op. name new_var. op = new_op if new_var @graph. add_node ( new_op ) end @graph end
->Raw Target:
Loads a model Yaml file and builds the model from it
--

306=========
->Original Input:
['def', 'variable', '(', 'value', ',', 'name', ':', 'nil', ',', 'initializer', ':', 'nil', ',', 'graph', ':', 'nil', ',', 'dtype', ':', 'nil', ',', 'trainable', ':', 'true', ')', 'op', '=', 'Graph', '.', 'get_default_graph', '.', 'add_op', '(', ':assign', ',', 'nil', ',', 'value', ')', 'common_options', '=', '{', 'initializer', ':', 'initializer', '||', 'op', ',', 'name', ':', 'name', ',', 'graph', ':', 'graph', ',', 'dtype', ':', 'dtype', ',', 'trainable', ':', 'trainable', ',', '}', 'tensor', '=', 'if', 'value', '.', 'is_a?', '(', 'String', ')', 'i_var', '(', 'dtype', '||', ':string', ',', '0', ',', '[', ']', ',', 'get_variable_scope', ',', 'common_options', ')', 'elsif', 'value', '.', 'is_a?', '(', 'Integer', ')', 'i_var', '(', 'dtype', '||', ':int32', ',', '0', ',', '[', ']', ',', 'get_variable_scope', ',', 'common_options', ')', 'elsif', 'value', '.', 'is_a?', '(', 'Float', ')', 'i_var', '(', 'dtype', '||', ':float32', ',', '0', ',', '[', ']', ',', 'get_variable_scope', ',', 'common_options', ')', 'else', 'i_var', '(', 'dtype', '||', ':float32', ',', '0', ',', 'nil', ',', 'get_variable_scope', ',', 'common_options', ')', 'end', 'op', '.', 'set_input', '(', '0', ',', 'tensor', '.', 'op', ')', 'Graph', '.', 'get_default_graph', '.', 'add_node', '(', 'op', ')', 'tensor', 'end']
->Original Target:
['Creates', 'a', 'variable', 'A', 'variable', 'maintains', 'state', 'across', 'sessions']
->Reconstructed Target:
Creates a variable A variable maintains state across sessions
->Reconstructed Predication:
:variable:variable, name : name:variable, name : name:variable, name : name:variable, name : name:name,:name,:name,:name,:name,:name,:name,:name,:name,:name,:name,:name,:name,:name,:name,:name,:name
->Raw Input:
summarize:def variable ( value, name : nil, initializer : nil, graph : nil, dtype : nil, trainable : true ) op = Graph. get_default_graph. add_op ( :assign, nil, value ) common_options = { initializer : initializer || op, name : name, graph : graph, dtype : dtype, trainable : trainable, } tensor = if value. is_a? ( String ) i_var ( dtype || :string, 0, [ ], get_variable_scope, common_options ) elsif value. is_a? ( Integer ) i_var ( dtype || :int32, 0, [ ], get_variable_scope, common_options ) elsif value. is_a? ( Float ) i_var ( dtype || :float32, 0, [ ], get_variable_scope, common_options ) else i_var ( dtype || :float32, 0, nil, get_variable_scope, common_options ) end op. set_input ( 0, tensor. op ) Graph. get_default_graph. add_node ( op ) tensor end
->Raw Target:
Creates a variable A variable maintains state across sessions
--

307=========
->Original Input:
['def', 'variable_scope', '(', 'scope', '=', 'nil', ',', 'default_name', '=', 'nil', ',', 'reuse', ':', 'nil', ',', 'initializer', ':', 'nil', ')', 'Thread', '.', 'current', '[', ':tensor_stream_variable_scope', ']', '||=', '[', 'VariableScope', '.', 'new', ']', 'if', 'scope', '.', 'nil?', '&&', 'default_name', 'same_names', '=', 'get_variable_scope', '.', 'used_names', '.', 'select', '{', '|', 's', '|', 's', '.', 'start_with?', '(', 'default_name', ')', '}', 'new_name', '=', 'default_name', 'index', '=', '1', 'while', 'same_names', '.', 'include?', '(', 'new_name', ')', 'new_name', '=', '"#{default_name}_#{index}"', 'index', '+=', '1', 'end', 'scope', '=', 'new_name', 'end', 'variable_scope', '=', 'VariableScope', '.', 'new', '(', 'name', ':', 'scope', ',', 'reuse', ':', 'reuse', ',', 'initializer', ':', 'initializer', ')', 'get_variable_scope', '.', 'register_name', '(', 'scope', '||', '""', ')', 'Thread', '.', 'current', '[', ':tensor_stream_variable_scope', ']', '<<', 'variable_scope', 'scope_name', '=', '__v_scope_name', 'if', 'block_given?', 'begin', 'TensorStream', '.', 'get_default_graph', '.', 'name_scope', '(', 'scope', ')', 'do', 'yield', '(', 'scope_name', ')', 'end', 'ensure', 'Thread', '.', 'current', '[', ':tensor_stream_variable_scope', ']', '.', 'pop', 'end', 'else', 'variable_scope', 'end', 'end']
->Original Target:
['Defines', 'a', 'variable', 'context', 'manager']
->Reconstructed Target:
Defines a variable context manager
->Reconstructed Predication:
variable_scope. register_name ( scopevariable_scope. register_name ( scopevariable_scope. register_name ( scopevariable_scope. register_name ( scopevariable_scope. register_name ( scope_namevariable_scope. register_name ( scope_namevariable_scope. register_name ( scope_namevariable_scope. register_name ( scope_namevariable_scope. register_name ( scope
->Raw Input:
summarize:def variable_scope ( scope = nil, default_name = nil, reuse : nil, initializer : nil ) Thread. current [ :tensor_stream_variable_scope ] ||= [ VariableScope. new ] if scope. nil? && default_name same_names = get_variable_scope. used_names. select { | s | s. start_with? ( default_name ) } new_name = default_name index = 1 while same_names. include? ( new_name ) new_name = "#{default_name}_#{index}" index += 1 end scope = new_name end variable_scope = VariableScope. new ( name : scope, reuse : reuse, initializer : initializer ) get_variable_scope. register_name ( scope || "" ) Thread. current [ :tensor_stream_variable_scope ] << variable_scope scope_name = __v_scope_name if block_given? begin TensorStream. get_default_graph. name_scope ( scope ) do yield ( scope_name ) end ensure Thread. current [ :tensor_stream_variable_scope ]. pop end else variable_scope end end
->Raw Target:
Defines a variable context manager
--

308=========
->Original Input:
['def', 'session', '(', 'evaluator', '=', 'nil', ',', 'thread_pool_class', ':', 'Concurrent', '::', 'ImmediateExecutor', ',', 'log_device_placement', ':', 'false', ',', 'profile_enabled', ':', 'false', ')', 'session', '=', 'TensorStream', '::', 'Session', '.', 'new', '(', 'evaluator', ',', 'thread_pool_class', ':', 'thread_pool_class', ',', 'log_device_placement', ':', 'log_device_placement', ',', 'profile_enabled', ':', 'profile_enabled', ')', 'yield', 'session', 'if', 'block_given?', 'session', 'end']
->Original Target:
['Creates', 'a', 'session', 'context', 'where', 'operations', 'can', 'be', 'executed']
->Reconstructed Target:
Creates a session context where operations can be executed
->Reconstructed Predication:
session  def session
->Raw Input:
summarize:def session ( evaluator = nil, thread_pool_class : Concurrent :: ImmediateExecutor, log_device_placement : false, profile_enabled : false ) session = TensorStream :: Session. new ( evaluator, thread_pool_class : thread_pool_class, log_device_placement : log_device_placement, profile_enabled : profile_enabled ) yield session if block_given? session end
->Raw Target:
Creates a session context where operations can be executed
--

309=========
->Original Input:
['def', 'placeholder', '(', 'dtype', ',', 'shape', ':', 'nil', ',', 'name', ':', 'nil', ')', 'TensorStream', '::', 'Placeholder', '.', 'new', '(', 'dtype', ',', 'nil', ',', 'shape', ',', 'name', ':', 'name', ')', 'end']
->Original Target:
['Inserts', 'a', 'placeholder', 'for', 'a', 'tensor', 'that', 'will', 'be', 'always', 'fed', '.']
->Reconstructed Target:
Inserts a placeholder for a tensor that will be always fed.
->Reconstructed Predication:
the placeholder for a TensorStream.
->Raw Input:
summarize:def placeholder ( dtype, shape : nil, name : nil ) TensorStream :: Placeholder. new ( dtype, nil, shape, name : name ) end
->Raw Target:
Inserts a placeholder for a tensor that will be always fed.
--

310=========
->Original Input:
['def', 'check_if_dense', '(', 'value', ',', 'expected_shape', '=', 'nil', ')', 'return', 'unless', 'value', '.', 'is_a?', '(', 'Array', ')', 'return', 'if', 'value', '.', 'empty?', 'expected_shape', '||=', 'shape_eval', '(', 'value', ')', 's', '=', 'expected_shape', '.', 'shift', 'raise', 'TensorStream', '::', 'ValueError', ',', '"Argument must be a dense tensor: #{value}, expected size #{s} got #{value.size}"', 'if', 'value', '.', 'size', '!=', 's', 'return', 'if', 'expected_shape', '.', 'empty?', 'value', '.', 'each', 'do', '|', 'item', '|', 'check_if_dense', '(', 'item', ',', 'expected_shape', '.', 'dup', ')', 'end', 'end']
->Original Target:
['Check', 'to', 'make', 'sure', 'passed', 'array', 'is', 'dense']
->Reconstructed Target:
Check to make sure passed array is dense
->Reconstructed Predication:
the tensor to be densethe tensor to be dense.
->Raw Input:
summarize:def check_if_dense ( value, expected_shape = nil ) return unless value. is_a? ( Array ) return if value. empty? expected_shape ||= shape_eval ( value ) s = expected_shape. shift raise TensorStream :: ValueError, "Argument must be a dense tensor: #{value}, expected size #{s} got #{value.size}" if value. size!= s return if expected_shape. empty? value. each do | item | check_if_dense ( item, expected_shape. dup ) end end
->Raw Target:
Check to make sure passed array is dense
--

311=========
->Original Input:
['def', 'apply_data_type_coercion', '(', '*', 'args', ')', 'coerced_type', '=', 'check_data_types', '(', '*', 'args', ')', 'args', '.', 'map', '{', '|', 'a', '|', 'a', '.', 'is_a?', '(', 'Tensor', ')', '?', 'a', ':', 'convert_to_tensor', '(', 'a', ',', 'dtype', ':', 'coerced_type', ')', '}', 'end']
->Original Target:
['Auto', 'cast', 'ruby', 'constant', 'data', 'types', 'to', 'the', 'same', 'tensor', 'types', 'of', 'other', 'operands']
->Reconstructed Target:
Auto cast ruby constant data types to the same tensor types of other operands
->Reconstructed Predication:
the data type of the given
->Raw Input:
summarize:def apply_data_type_coercion ( * args ) coerced_type = check_data_types ( * args ) args. map { | a | a. is_a? ( Tensor )? a : convert_to_tensor ( a, dtype : coerced_type ) } end
->Raw Target:
Auto cast ruby constant data types to the same tensor types of other operands
--

312=========
->Original Input:
['def', 'add_audio', '(', 'customization_id', ':', ',', 'audio_name', ':', ',', 'audio_resource', ':', ',', 'contained_content_type', ':', 'nil', ',', 'allow_overwrite', ':', 'nil', ',', 'content_type', ':', 'nil', ')', 'raise', 'ArgumentError', '.', 'new', '(', '"customization_id must be provided"', ')', 'if', 'customization_id', '.', 'nil?', 'raise', 'ArgumentError', '.', 'new', '(', '"audio_name must be provided"', ')', 'if', 'audio_name', '.', 'nil?', 'raise', 'ArgumentError', '.', 'new', '(', '"audio_resource must be provided"', ')', 'if', 'audio_resource', '.', 'nil?', 'headers', '=', '{', '"Contained-Content-Type"', '=>', 'contained_content_type', ',', '"Content-Type"', '=>', 'content_type', '}', 'sdk_headers', '=', 'Common', '.', 'new', '.', 'get_sdk_headers', '(', '"speech_to_text"', ',', '"V1"', ',', '"add_audio"', ')', 'headers', '.', 'merge!', '(', 'sdk_headers', ')', 'params', '=', '{', '"allow_overwrite"', '=>', 'allow_overwrite', '}', 'data', '=', 'audio_resource', 'method_url', '=', '"/v1/acoustic_customizations/%s/audio/%s"', '%', '[', 'ERB', '::', 'Util', '.', 'url_encode', '(', 'customization_id', ')', ',', 'ERB', '::', 'Util', '.', 'url_encode', '(', 'audio_name', ')', ']', 'request', '(', 'method', ':', '"POST"', ',', 'url', ':', 'method_url', ',', 'headers', ':', 'headers', ',', 'params', ':', 'params', ',', 'data', ':', 'data', ',', 'accept_json', ':', 'true', ')', 'nil', 'end']
->Original Target:
['Custom', 'audio', 'resources']
->Reconstructed Target:
Custom audio resources
->Reconstructed Predication:
the audio to be added... json
->Raw Input:
summarize:def add_audio ( customization_id :, audio_name :, audio_resource :, contained_content_type : nil, allow_overwrite : nil, content_type : nil ) raise ArgumentError. new ( "customization_id must be provided" ) if customization_id. nil? raise ArgumentError. new ( "audio_name must be provided" ) if audio_name. nil? raise ArgumentError. new ( "audio_resource must be provided" ) if audio_resource. nil? headers = { "Contained-Content-Type" => contained_content_type, "Content-Type" => content_type } sdk_headers = Common. new. get_sdk_headers ( "speech_to_text", "V1", "add_audio" ) headers. merge! ( sdk_headers ) params = { "allow_overwrite" => allow_overwrite } data = audio_resource method_url = "/v1/acoustic_customizations/%s/audio/%s" % [ ERB :: Util. url_encode ( customization_id ), ERB :: Util. url_encode ( audio_name ) ] request ( method : "POST", url : method_url, headers : headers, params : params, data : data, accept_json : true ) nil end
->Raw Target:
Custom audio resources
--

313=========
->Original Input:
['def', 'create_event', '(', 'type', ':', ',', 'data', ':', ')', 'raise', 'ArgumentError', '.', 'new', '(', '"type must be provided"', ')', 'if', 'type', '.', 'nil?', 'raise', 'ArgumentError', '.', 'new', '(', '"data must be provided"', ')', 'if', 'data', '.', 'nil?', 'headers', '=', '{', '}', 'sdk_headers', '=', 'Common', '.', 'new', '.', 'get_sdk_headers', '(', '"discovery"', ',', '"V1"', ',', '"create_event"', ')', 'headers', '.', 'merge!', '(', 'sdk_headers', ')', 'params', '=', '{', '"version"', '=>', '@version', '}', 'data', '=', '{', '"type"', '=>', 'type', ',', '"data"', '=>', 'data', '}', 'method_url', '=', '"/v1/events"', 'response', '=', 'request', '(', 'method', ':', '"POST"', ',', 'url', ':', 'method_url', ',', 'headers', ':', 'headers', ',', 'params', ':', 'params', ',', 'json', ':', 'data', ',', 'accept_json', ':', 'true', ')', 'response', 'end']
->Original Target:
['Events', 'and', 'feedback']
->Reconstructed Target:
Events and feedback
->Reconstructed Predication:
the event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe event to be createdthe
->Raw Input:
summarize:def create_event ( type :, data : ) raise ArgumentError. new ( "type must be provided" ) if type. nil? raise ArgumentError. new ( "data must be provided" ) if data. nil? headers = { } sdk_headers = Common. new. get_sdk_headers ( "discovery", "V1", "create_event" ) headers. merge! ( sdk_headers ) params = { "version" => @version } data = { "type" => type, "data" => data } method_url = "/v1/events" response = request ( method : "POST", url : method_url, headers : headers, params : params, json : data, accept_json : true ) response end
->Raw Target:
Events and feedback
--

314=========
->Original Input:
['def', 'zero_pad', '(', 'n', ',', 'message', ')', 'len', '=', 'message', '.', 'bytesize', 'if', 'len', '==', 'n', 'message', 'elsif', 'len', '>', 'n', 'raise', 'LengthError', ',', '"String too long for zero-padding to #{n} bytes"', 'else', 'message', '+', 'zeros', '(', 'n', '-', 'len', ')', 'end', 'end']
->Original Target:
['Pad', 'a', 'string', 'out', 'to', 'n', 'characters', 'with', 'zeros']
->Reconstructed Target:
Pad a string out to n characters with zeros
->Reconstructed Predication:
the string to zero padding
->Raw Input:
summarize:def zero_pad ( n, message ) len = message. bytesize if len == n message elsif len > n raise LengthError, "String too long for zero-padding to #{n} bytes" else message + zeros ( n - len ) end end
->Raw Target:
Pad a string out to n characters with zeros
--

315=========
->Original Input:
['def', 'check_length', '(', 'string', ',', 'length', ',', 'description', ')', 'if', 'string', '.', 'nil?', 'raise', 'LengthError', ',', '"#{description} was nil (Expected #{length.to_int})"', ',', 'caller', 'end', 'if', 'string', '.', 'bytesize', '!=', 'length', '.', 'to_int', 'raise', 'LengthError', ',', '"#{description} was #{string.bytesize} bytes (Expected #{length.to_int})"', ',', 'caller', 'end', 'true', 'end']
->Original Target:
['Check', 'the', 'length', 'of', 'the', 'passed', 'in', 'string']
->Reconstructed Target:
Check the length of the passed in string
->Reconstructed Predication:
length of the given string
->Raw Input:
summarize:def check_length ( string, length, description ) if string. nil? raise LengthError, "#{description} was nil (Expected #{length.to_int})", caller end if string. bytesize!= length. to_int raise LengthError, "#{description} was #{string.bytesize} bytes (Expected #{length.to_int})", caller end true end
->Raw Target:
Check the length of the passed in string
--

316=========
->Original Input:
['def', 'check_string', '(', 'string', ',', 'length', ',', 'description', ')', 'check_string_validation', '(', 'string', ')', 'string', '=', 'string', '.', 'to_s', 'check_length', '(', 'string', ',', 'length', ',', 'description', ')', 'string', 'end']
->Original Target:
['Check', 'a', 'passed', 'in', 'string', 'converting', 'the', 'argument', 'if', 'necessary']
->Reconstructed Target:
Check a passed in string converting the argument if necessary
->Reconstructed Predication:
 def validate_string ( string
->Raw Input:
summarize:def check_string ( string, length, description ) check_string_validation ( string ) string = string. to_s check_length ( string, length, description ) string end
->Raw Target:
Check a passed in string converting the argument if necessary
--

317=========
->Original Input:
['def', 'check_hmac_key', '(', 'string', ',', '_description', ')', 'check_string_validation', '(', 'string', ')', 'string', '=', 'string', '.', 'to_str', 'if', 'string', '.', 'bytesize', '.', 'zero?', 'raise', 'LengthError', ',', '"#{Description} was #{string.bytesize} bytes (Expected more than 0)"', ',', 'caller', 'end', 'string', 'end']
->Original Target:
['Check', 'a', 'passed', 'in', 'string', 'convertion', 'if', 'necessary']
->Reconstructed Target:
Check a passed in string convertion if necessary
->Reconstructed Predication:
the hmac key for the given
->Raw Input:
summarize:def check_hmac_key ( string, _description ) check_string_validation ( string ) string = string. to_str if string. bytesize. zero? raise LengthError, "#{Description} was #{string.bytesize} bytes (Expected more than 0)", caller end string end
->Raw Target:
Check a passed in string convertion if necessary
--

318=========
->Original Input:
['def', 'check_string_validation', '(', 'string', ')', 'raise', 'TypeError', ',', '"can\'t convert #{string.class} into String with #to_str"', 'unless', 'string', '.', 'respond_to?', ':to_str', 'string', '=', 'string', '.', 'to_str', 'raise', 'EncodingError', ',', '"strings must use BINARY encoding (got #{string.encoding})"', 'if', 'string', '.', 'encoding', '!=', 'Encoding', '::', 'BINARY', 'end']
->Original Target:
['Check', 'a', 'passed', 'string', 'is', 'it', 'valid']
->Reconstructed Target:
Check a passed string is it valid
->Reconstructed Predication:
a string to be encoded
->Raw Input:
summarize:def check_string_validation ( string ) raise TypeError, "can't convert #{string.class} into String with #to_str" unless string. respond_to? :to_str string = string. to_str raise EncodingError, "strings must use BINARY encoding (got #{string.encoding})" if string. encoding!= Encoding :: BINARY end
->Raw Target:
Check a passed string is it valid
--

319=========
->Original Input:
['def', 'auth', '(', 'message', ')', 'authenticator', '=', 'Util', '.', 'zeros', '(', 'tag_bytes', ')', 'message', '=', 'message', '.', 'to_str', 'compute_authenticator', '(', 'authenticator', ',', 'message', ')', 'authenticator', 'end']
->Original Target:
['Compute', 'authenticator', 'for', 'message']
->Reconstructed Target:
Compute authenticator for message
->Reconstructed Predication:
authenticator = auth_from_message ( message )
->Raw Input:
summarize:def auth ( message ) authenticator = Util. zeros ( tag_bytes ) message = message. to_str compute_authenticator ( authenticator, message ) authenticator end
->Raw Target:
Compute authenticator for message
--

320=========
->Original Input:
['def', 'verify', '(', 'authenticator', ',', 'message', ')', 'auth', '=', 'authenticator', '.', 'to_s', 'Util', '.', 'check_length', '(', 'auth', ',', 'tag_bytes', ',', '"Provided authenticator"', ')', 'verify_message', '(', 'auth', ',', 'message', ')', '||', 'raise', '(', 'BadAuthenticatorError', ',', '"Invalid authenticator provided, message is corrupt"', ')', 'end']
->Original Target:
['Verifies', 'the', 'given', 'authenticator', 'with', 'the', 'message', '.']
->Reconstructed Target:
Verifies the given authenticator with the message.
->Reconstructed Predication:
authenticator = auth. to_s
->Raw Input:
summarize:def verify ( authenticator, message ) auth = authenticator. to_s Util. check_length ( auth, tag_bytes, "Provided authenticator" ) verify_message ( auth, message ) || raise ( BadAuthenticatorError, "Invalid authenticator provided, message is corrupt" ) end
->Raw Target:
Verifies the given authenticator with the message.
--

321=========
->Original Input:
['def', 'box', '(', 'message', ')', 'nonce', '=', 'generate_nonce', 'cipher_text', '=', '@box', '.', 'box', '(', 'nonce', ',', 'message', ')', 'nonce', '+', 'cipher_text', 'end']
->Original Target:
['Encrypts', 'the', 'message', 'with', 'a', 'random', 'nonce']
->Reconstructed Target:
Encrypts the message with a random nonce
->Reconstructed Predication:
the message to be encrypted with
->Raw Input:
summarize:def box ( message ) nonce = generate_nonce cipher_text = @box. box ( nonce, message ) nonce + cipher_text end
->Raw Target:
Encrypts the message with a random nonce
--

322=========
->Original Input:
['def', 'open', '(', 'enciphered_message', ')', 'nonce', ',', 'ciphertext', '=', 'extract_nonce', '(', 'enciphered_message', '.', 'to_s', ')', '@box', '.', 'open', '(', 'nonce', ',', 'ciphertext', ')', 'end']
->Original Target:
['Decrypts', 'the', 'ciphertext', 'with', 'a', 'random', 'nonce']
->Reconstructed Target:
Decrypts the ciphertext with a random nonce
->Reconstructed Predication:
 def open ( enciphered_message )
->Raw Input:
summarize:def open ( enciphered_message ) nonce, ciphertext = extract_nonce ( enciphered_message. to_s ) @box. open ( nonce, ciphertext ) end
->Raw Target:
Decrypts the ciphertext with a random nonce
--

323=========
->Original Input:
['def', 'reopen', 'each', 'do', '|', 'appender', '|', 'begin', 'next', 'unless', 'appender', '.', 'respond_to?', '(', ':reopen', ')', 'logger', '.', 'trace', '"Reopening appender: #{appender.name}"', 'appender', '.', 'reopen', 'rescue', 'Exception', '=>', 'exc', 'logger', '.', 'error', '"Failed to re-open appender: #{appender.inspect}"', ',', 'exc', 'end', 'end', 'logger', '.', 'trace', "'All appenders re-opened'", 'end']
->Original Target:
['After', 'a', 'fork', 'the', 'appender', 'thread', 'is', 'not', 'running', 'start', 'it', 'if', 'it', 'is', 'not', 'running', '.']
->Reconstructed Target:
After a fork the appender thread is not running start it if it is not running.
->Reconstructed Predication:
the appenders to be re-opened'
->Raw Input:
summarize:def reopen each do | appender | begin next unless appender. respond_to? ( :reopen ) logger. trace "Reopening appender: #{appender.name}" appender. reopen rescue Exception => exc logger. error "Failed to re-open appender: #{appender.inspect}", exc end end logger. trace 'All appenders re-opened' end
->Raw Target:
After a fork the appender thread is not running start it if it is not running.
--

324=========
->Original Input:
['def', 'logger', '@logger', '||=', 'begin', 'logger', '=', 'SemanticLogger', '::', 'Processor', '.', 'logger', '.', 'clone', 'logger', '.', 'name', '=', 'self', '.', 'class', '.', 'name', 'logger', 'end', 'end']
->Original Target:
['Give', 'each', 'appender', 'its', 'own', 'logger', 'for', 'logging', '.', 'For', 'example', 'trace', 'messages', 'sent', 'to', 'services', 'or', 'errors', 'when', 'something', 'fails', '.']
->Reconstructed Target:
Give each appender its own logger for logging. For example trace messages sent to services or errors when something fails.
->Reconstructed Predication:
logger  def logger
->Raw Input:
summarize:def logger @logger ||= begin logger = SemanticLogger :: Processor. logger. clone logger. name = self. class. name logger end end
->Raw Target:
Give each appender its own logger for logging. For example trace messages sent to services or errors when something fails.
--

325=========
->Original Input:
['def', 'measure', '(', 'level', ',', 'message', ',', 'params', '=', '{', '}', ',', '&', 'block', ')', 'index', '=', 'Levels', '.', 'index', '(', 'level', ')', 'if', 'level_index', '<=', 'index', 'measure_internal', '(', 'level', ',', 'index', ',', 'message', ',', 'params', ',', '&', 'block', ')', 'elsif', 'block', 'yield', '(', 'params', ')', 'end', 'end']
->Original Target:
['Dynamically', 'supply', 'the', 'log', 'level', 'with', 'every', 'measurement', 'call']
->Reconstructed Target:
Dynamically supply the log level with every measurement call
->Reconstructed Predication:
the message to be displayed
->Raw Input:
summarize:def measure ( level, message, params = { }, & block ) index = Levels. index ( level ) if level_index <= index measure_internal ( level, index, message, params, & block ) elsif block yield ( params ) end end
->Raw Target:
Dynamically supply the log level with every measurement call
--

326=========
->Original Input:
['def', 'backtrace', '(', 'thread', ':', 'Thread', '.', 'current', ',', 'level', ':', ':warn', ',', 'message', ':', "'Backtrace:'", ',', 'payload', ':', 'nil', ',', 'metric', ':', 'nil', ',', 'metric_amount', ':', 'nil', ')', 'log', '=', 'Log', '.', 'new', '(', 'name', ',', 'level', ')', 'return', 'false', 'unless', 'meets_log_level?', '(', 'log', ')', 'backtrace', '=', 'if', 'thread', '==', 'Thread', '.', 'current', 'Utils', '.', 'extract_backtrace', 'else', 'log', '.', 'thread_name', '=', 'thread', '.', 'name', 'log', '.', 'tags', '=', '(', 'thread', '[', ':semantic_logger_tags', ']', '||', '[', ']', ')', '.', 'clone', 'log', '.', 'named_tags', '=', '(', 'thread', '[', ':semantic_logger_named_tags', ']', '||', '{', '}', ')', '.', 'clone', 'thread', '.', 'backtrace', 'end', 'if', 'backtrace', 'message', '+=', '"\\n"', 'message', '<<', 'backtrace', '.', 'join', '(', '"\\n"', ')', 'end', 'if', 'log', '.', 'assign', '(', 'message', ':', 'message', ',', 'backtrace', ':', 'backtrace', ',', 'payload', ':', 'payload', ',', 'metric', ':', 'metric', ',', 'metric_amount', ':', 'metric_amount', ')', '&&', '!', 'filtered?', '(', 'log', ')', 'self', '.', 'log', '(', 'log', ')', 'else', 'false', 'end', 'end']
->Original Target:
['Log', 'a', 'thread', 'backtrace']
->Reconstructed Target:
Log a thread backtrace
->Reconstructed Predication:
:::::: metric_amount )
->Raw Input:
summarize:def backtrace ( thread : Thread. current, level : :warn, message : 'Backtrace:', payload : nil, metric : nil, metric_amount : nil ) log = Log. new ( name, level ) return false unless meets_log_level? ( log ) backtrace = if thread == Thread. current Utils. extract_backtrace else log. thread_name = thread. name log. tags = ( thread [ :semantic_logger_tags ] || [ ] ). clone log. named_tags = ( thread [ :semantic_logger_named_tags ] || { } ). clone thread. backtrace end if backtrace message += "\n" message << backtrace. join ( "\n" ) end if log. assign ( message : message, backtrace : backtrace, payload : payload, metric : metric, metric_amount : metric_amount ) &&! filtered? ( log ) self. log ( log ) else false end end
->Raw Target:
Log a thread backtrace
--

327=========
->Original Input:
['def', 'tagged', '(', '*', 'tags', ',', '&', 'block', ')', 'if', 'tags', '.', 'size', '==', '1', 'tag', '=', 'tags', '[', '0', ']', 'return', 'yield', 'if', 'tag', '.', 'nil?', '||', 'tag', '==', "''", 'return', 'tag', '.', 'is_a?', '(', 'Hash', ')', '?', 'SemanticLogger', '.', 'named_tagged', '(', 'tag', ',', '&', 'block', ')', ':', 'SemanticLogger', '.', 'fast_tag', '(', 'tag', '.', 'to_s', ',', '&', 'block', ')', 'end', 'new_tags', '=', 'tags', '.', 'flatten', '.', 'collect', '(', '&', ':to_s', ')', '.', 'reject', '(', '&', ':empty?', ')', 'SemanticLogger', '.', 'tagged', '(', '*', 'new_tags', ',', '&', 'block', ')', 'end']
->Original Target:
['Add', 'the', 'tags', 'or', 'named', 'tags', 'to', 'the', 'list', 'of', 'tags', 'to', 'log', 'for', 'this', 'thread', 'whilst', 'the', 'supplied', 'block', 'is', 'active', '.']
->Reconstructed Target:
Add the tags or named tags to the list of tags to log for this thread whilst the supplied block is active.
->Reconstructed Predication:
tag = nil blocktag = nil block =tag = nil block =block = nil block =block = nil block =block = block_given? block_returnedblock_returned block if block_returned block
->Raw Input:
summarize:def tagged ( * tags, & block ) if tags. size == 1 tag = tags [ 0 ] return yield if tag. nil? || tag == '' return tag. is_a? ( Hash )? SemanticLogger. named_tagged ( tag, & block ) : SemanticLogger. fast_tag ( tag. to_s, & block ) end new_tags = tags. flatten. collect ( & :to_s ). reject ( & :empty? ) SemanticLogger. tagged ( * new_tags, & block ) end
->Raw Target:
Add the tags or named tags to the list of tags to log for this thread whilst the supplied block is active.
--

328=========
->Original Input:
['def', 'push_tags', '(', '*', 'tags', ')', 'new_tags', '=', 'tags', '.', 'flatten', '.', 'collect', '(', '&', ':to_s', ')', '.', 'reject', '(', '&', ':empty?', ')', 'SemanticLogger', '.', 'push_tags', '(', '*', 'new_tags', ')', 'end']
->Original Target:
['Returns', 'the', 'list', 'of', 'tags', 'pushed', 'after', 'flattening', 'them', 'out', 'and', 'removing', 'blanks']
->Reconstructed Target:
Returns the list of tags pushed after flattening them out and removing blanks
->Reconstructed Predication:
push a set of tags
->Raw Input:
summarize:def push_tags ( * tags ) new_tags = tags. flatten. collect ( & :to_s ). reject ( & :empty? ) SemanticLogger. push_tags ( * new_tags ) end
->Raw Target:
Returns the list of tags pushed after flattening them out and removing blanks
--

329=========
->Original Input:
['def', 'filtered?', '(', 'log', ')', 'return', 'false', 'if', '@filter', '.', 'nil?', '@filter', '.', 'is_a?', '(', 'Regexp', ')', '?', '(', '@filter', '=~', 'log', '.', 'name', ')', '.', 'nil?', ':', '@filter', '.', 'call', '(', 'log', ')', '!=', 'true', 'end']
->Original Target:
['Whether', 'to', 'log', 'the', 'supplied', 'message', 'based', 'on', 'the', 'current', 'filter', 'if', 'any']
->Reconstructed Target:
Whether to log the supplied message based on the current filter if any
->Reconstructed Predication:
return true if the filter
->Raw Input:
summarize:def filtered? ( log ) return false if @filter. nil? @filter. is_a? ( Regexp )? ( @filter =~ log. name ). nil? : @filter. call ( log )!= true end
->Raw Target:
Whether to log the supplied message based on the current filter if any
--

330=========
->Original Input:
['def', 'log_internal', '(', 'level', ',', 'index', ',', 'message', '=', 'nil', ',', 'payload', '=', 'nil', ',', 'exception', '=', 'nil', ',', '&', 'block', ')', 'log', '=', 'Log', '.', 'new', '(', 'name', ',', 'level', ',', 'index', ')', 'should_log', '=', 'if', 'payload', '.', 'nil?', '&&', 'exception', '.', 'nil?', '&&', 'message', '.', 'is_a?', '(', 'Hash', ')', 'if', 'message', '.', 'key?', '(', ':message', ')', '||', 'message', '.', 'key?', '(', ':payload', ')', '||', 'message', '.', 'key?', '(', ':exception', ')', '||', 'message', '.', 'key?', '(', ':metric', ')', 'log', '.', 'assign', '(', 'message', ')', 'else', 'log', '.', 'assign_positional', '(', 'nil', ',', 'message', ',', 'nil', ',', '&', 'block', ')', 'end', 'else', 'log', '.', 'assign_positional', '(', 'message', ',', 'payload', ',', 'exception', ',', '&', 'block', ')', 'end', 'self', '.', 'log', '(', 'log', ')', 'if', 'should_log', '&&', 'should_log?', '(', 'log', ')', 'end']
->Original Target:
['Log', 'message', 'at', 'the', 'specified', 'level']
->Reconstructed Target:
Log message at the specified level
->Reconstructed Predication:
the log message and thethe log message and thethe log messagethe log messagethe logthe log message and thethe logthe log message and thethe log message and thethe log message and thethe log message and thethe log message and thethe log message and thethe log messagethe log message and thethe log messagethe log messagethe logthe logthe log messagethe
->Raw Input:
summarize:def log_internal ( level, index, message = nil, payload = nil, exception = nil, & block ) log = Log. new ( name, level, index ) should_log = if payload. nil? && exception. nil? && message. is_a? ( Hash ) if message. key? ( :message ) || message. key? ( :payload ) || message. key? ( :exception ) || message. key? ( :metric ) log. assign ( message ) else log. assign_positional ( nil, message, nil, & block ) end else log. assign_positional ( message, payload, exception, & block ) end self. log ( log ) if should_log && should_log? ( log ) end
->Raw Target:
Log message at the specified level
--

331=========
->Original Input:
['def', 'measure_internal', '(', 'level', ',', 'index', ',', 'message', ',', 'params', ')', 'exception', '=', 'nil', 'result', '=', 'nil', 'if', 'params', '.', 'empty?', '&&', 'message', '.', 'is_a?', '(', 'Hash', ')', 'params', '=', 'message', 'message', '=', 'nil', 'end', 'start', '=', 'Process', '.', 'clock_gettime', '(', 'Process', '::', 'CLOCK_MONOTONIC', ')', 'begin', 'if', 'block_given?', 'result', '=', 'if', '(', 'silence_level', '=', 'params', '[', ':silence', ']', ')', 'silence_level', '=', ':error', 'if', 'silence_level', '==', 'true', 'silence', '(', 'silence_level', ')', '{', 'yield', '(', 'params', ')', '}', 'else', 'yield', '(', 'params', ')', 'end', 'end', 'rescue', 'Exception', '=>', 'exc', 'exception', '=', 'exc', 'ensure', 'log', '=', 'Log', '.', 'new', '(', 'name', ',', 'level', ',', 'index', ')', 'exception', '||=', 'params', '[', ':exception', ']', 'message', '=', 'params', '[', ':message', ']', 'if', 'params', '[', ':message', ']', 'duration', '=', 'if', 'block_given?', '1_000.0', '*', '(', 'Process', '.', 'clock_gettime', '(', 'Process', '::', 'CLOCK_MONOTONIC', ')', '-', 'start', ')', 'else', 'params', '[', ':duration', ']', '||', 'raise', '(', "'Mandatory block missing when :duration option is not supplied'", ')', 'end', 'payload', '=', 'params', '[', ':payload', ']', 'should_log', '=', 'log', '.', 'assign', '(', 'message', ':', 'message', ',', 'payload', ':', 'payload', ',', 'min_duration', ':', 'params', '[', ':min_duration', ']', '||', '0.0', ',', 'exception', ':', 'exception', ',', 'metric', ':', 'params', '[', ':metric', ']', ',', 'metric_amount', ':', 'params', '[', ':metric_amount', ']', ',', 'duration', ':', 'duration', ',', 'log_exception', ':', 'params', '[', ':log_exception', ']', '||', ':partial', ',', 'on_exception_level', ':', 'params', '[', ':on_exception_level', ']', ')', 'self', '.', 'log', '(', 'log', ')', 'if', 'should_log', '&&', 'should_log?', '(', 'log', ')', 'raise', 'exception', 'if', 'exception', 'result', 'end', 'end']
->Original Target:
['Measure', 'the', 'supplied', 'block', 'and', 'log', 'the', 'message']
->Reconstructed Target:
Measure the supplied block and log the message
->Reconstructed Predication:
()( params )( params )( params )( params )( params )( params )( params )( params )( params )( params )( params )( params )( params )
->Raw Input:
summarize:def measure_internal ( level, index, message, params ) exception = nil result = nil if params. empty? && message. is_a? ( Hash ) params = message message = nil end start = Process. clock_gettime ( Process :: CLOCK_MONOTONIC ) begin if block_given? result = if ( silence_level = params [ :silence ] ) silence_level = :error if silence_level == true silence ( silence_level ) { yield ( params ) } else yield ( params ) end end rescue Exception => exc exception = exc ensure log = Log. new ( name, level, index ) exception ||= params [ :exception ] message = params [ :message ] if params [ :message ] duration = if block_given? 1_000.0 * ( Process. clock_gettime ( Process :: CLOCK_MONOTONIC ) - start ) else params [ :duration ] || raise ( 'Mandatory block missing when :duration option is not supplied' ) end payload = params [ :payload ] should_log = log. assign ( message : message, payload : payload, min_duration : params [ :min_duration ] || 0.0, exception : exception, metric : params [ :metric ], metric_amount : params [ :metric_amount ], duration : duration, log_exception : params [ :log_exception ] || :partial, on_exception_level : params [ :on_exception_level ] ) self. log ( log ) if should_log && should_log? ( log ) raise exception if exception result end end
->Raw Target:
Measure the supplied block and log the message
--

332=========
->Original Input:
['def', 'measure_method', '(', 'index', ':', ',', 'level', ':', ',', 'message', ':', ',', 'min_duration', ':', ',', 'metric', ':', ',', 'log_exception', ':', ',', 'on_exception_level', ':', ')', 'exception', '=', 'nil', 'start', '=', 'Process', '.', 'clock_gettime', '(', 'Process', '::', 'CLOCK_MONOTONIC', ')', 'begin', 'yield', 'rescue', 'Exception', '=>', 'exc', 'exception', '=', 'exc', 'ensure', 'log', '=', 'Log', '.', 'new', '(', 'name', ',', 'level', ',', 'index', ')', 'should_log', '=', 'log', '.', 'assign', '(', 'message', ':', 'message', ',', 'min_duration', ':', 'min_duration', ',', 'exception', ':', 'exception', ',', 'metric', ':', 'metric', ',', 'duration', ':', '1_000.0', '*', '(', 'Process', '.', 'clock_gettime', '(', 'Process', '::', 'CLOCK_MONOTONIC', ')', '-', 'start', ')', ',', 'log_exception', ':', 'log_exception', ',', 'on_exception_level', ':', 'on_exception_level', ')', 'log', '(', 'log', ')', 'if', 'should_log', '&&', 'should_log?', '(', 'log', ')', 'raise', 'exception', 'if', 'exception', 'end', 'end']
->Original Target:
['For', 'measuring', 'methods', 'and', 'logging', 'their', 'duration', '.']
->Reconstructed Target:
For measuring methods and logging their duration.
->Reconstructed Predication:
the log of a metric. log_level ( level ). log_level ( level )) end
->Raw Input:
summarize:def measure_method ( index :, level :, message :, min_duration :, metric :, log_exception :, on_exception_level : ) exception = nil start = Process. clock_gettime ( Process :: CLOCK_MONOTONIC ) begin yield rescue Exception => exc exception = exc ensure log = Log. new ( name, level, index ) should_log = log. assign ( message : message, min_duration : min_duration, exception : exception, metric : metric, duration : 1_000.0 * ( Process. clock_gettime ( Process :: CLOCK_MONOTONIC ) - start ), log_exception : log_exception, on_exception_level : on_exception_level ) log ( log ) if should_log && should_log? ( log ) raise exception if exception end end
->Raw Target:
For measuring methods and logging their duration.
--

333=========
->Original Input:
['def', 'log', '(', 'log', ',', 'message', '=', 'nil', ',', 'progname', '=', 'nil', ',', '&', 'block', ')', 'return', 'add', '(', 'log', ',', 'message', ',', 'progname', ',', '&', 'block', ')', 'unless', 'log', '.', 'is_a?', '(', 'SemanticLogger', '::', 'Log', ')', 'Logger', '.', 'call_subscribers', '(', 'log', ')', 'Logger', '.', 'processor', '.', 'log', '(', 'log', ')', 'end']
->Original Target:
['Returns', 'a', 'Logger', 'instance']
->Reconstructed Target:
Returns a Logger instance
->Reconstructed Predication:
 def log ( message)
->Raw Input:
summarize:def log ( log, message = nil, progname = nil, & block ) return add ( log, message, progname, & block ) unless log. is_a? ( SemanticLogger :: Log ) Logger. call_subscribers ( log ) Logger. processor. log ( log ) end
->Raw Target:
Returns a Logger instance
--

334=========
->Original Input:
['def', 'assign', '(', 'message', ':', 'nil', ',', 'payload', ':', 'nil', ',', 'min_duration', ':', '0.0', ',', 'exception', ':', 'nil', ',', 'metric', ':', 'nil', ',', 'metric_amount', ':', 'nil', ',', 'duration', ':', 'nil', ',', 'backtrace', ':', 'nil', ',', 'log_exception', ':', ':full', ',', 'on_exception_level', ':', 'nil', ',', 'dimensions', ':', 'nil', ')', 'if', 'duration', 'self', '.', 'duration', '=', 'duration', 'return', 'false', 'if', '(', 'duration', '<', 'min_duration', ')', '&&', 'exception', '.', 'nil?', 'end', 'self', '.', 'message', '=', 'message', 'if', 'payload', '&&', 'payload', '.', 'is_a?', '(', 'Hash', ')', 'self', '.', 'payload', '=', 'payload', 'elsif', 'payload', 'self', '.', 'message', '=', 'message', '.', 'nil?', '?', 'payload', '.', 'to_s', ':', '"#{message} -- #{payload}"', 'self', '.', 'payload', '=', 'nil', 'end', 'if', 'exception', 'case', 'log_exception', 'when', ':full', 'self', '.', 'exception', '=', 'exception', 'when', ':partial', 'self', '.', 'message', '=', '"#{message} -- Exception: #{exception.class}: #{exception.message}"', 'when', 'nil', ',', ':none', 'nil', 'else', 'raise', '(', 'ArgumentError', ',', '"Invalid value:#{log_exception.inspect} for argument :log_exception"', ')', 'end', 'if', 'on_exception_level', 'self', '.', 'level', '=', 'on_exception_level', 'self', '.', 'level_index', '=', 'Levels', '.', 'index', '(', 'level', ')', 'end', 'end', 'if', 'backtrace', 'self', '.', 'backtrace', '=', 'Utils', '.', 'extract_backtrace', '(', 'backtrace', ')', 'elsif', 'level_index', '>=', 'SemanticLogger', '.', 'backtrace_level_index', 'self', '.', 'backtrace', '=', 'Utils', '.', 'extract_backtrace', 'end', 'if', 'metric', 'self', '.', 'metric', '=', 'metric', 'self', '.', 'metric_amount', '=', 'metric_amount', 'self', '.', 'dimensions', '=', 'dimensions', 'end', 'true', 'end']
->Original Target:
['Assign', 'named', 'arguments', 'to', 'this', 'log', 'entry', 'supplying', 'defaults', 'where', 'applicable']
->Reconstructed Target:
Assign named arguments to this log entry supplying defaults where applicable
->Reconstructed Predication:
the...... metric_amount = metric_amount. metric_amount = metric_amount. dimensions = dimensions. metric_amount = metric_amount. metric_amount = metric_amount self. dimensions = dimensions. metric_amount = metric_amount self. dimensions = dimensions. metric_amount = metric_amount self. dimensions = dimensions. metric_amount = metric_amount
->Raw Input:
summarize:def assign ( message : nil, payload : nil, min_duration : 0.0, exception : nil, metric : nil, metric_amount : nil, duration : nil, backtrace : nil, log_exception : :full, on_exception_level : nil, dimensions : nil ) if duration self. duration = duration return false if ( duration < min_duration ) && exception. nil? end self. message = message if payload && payload. is_a? ( Hash ) self. payload = payload elsif payload self. message = message. nil?? payload. to_s : "#{message} -- #{payload}" self. payload = nil end if exception case log_exception when :full self. exception = exception when :partial self. message = "#{message} -- Exception: #{exception.class}: #{exception.message}" when nil, :none nil else raise ( ArgumentError, "Invalid value:#{log_exception.inspect} for argument :log_exception" ) end if on_exception_level self. level = on_exception_level self. level_index = Levels. index ( level ) end end if backtrace self. backtrace = Utils. extract_backtrace ( backtrace ) elsif level_index >= SemanticLogger. backtrace_level_index self. backtrace = Utils. extract_backtrace end if metric self. metric = metric self. metric_amount = metric_amount self. dimensions = dimensions end true end
->Raw Target:
Assign named arguments to this log entry supplying defaults where applicable
--

335=========
->Original Input:
['def', 'assign_positional', '(', 'message', '=', 'nil', ',', 'payload', '=', 'nil', ',', 'exception', '=', 'nil', ')', 'if', 'exception', '.', 'nil?', '&&', 'payload', '.', 'nil?', '&&', 'message', '.', 'respond_to?', '(', ':backtrace', ')', '&&', 'message', '.', 'respond_to?', '(', ':message', ')', 'exception', '=', 'message', 'message', '=', 'nil', 'elsif', 'exception', '.', 'nil?', '&&', 'payload', '&&', 'payload', '.', 'respond_to?', '(', ':backtrace', ')', '&&', 'payload', '.', 'respond_to?', '(', ':message', ')', 'exception', '=', 'payload', 'payload', '=', 'nil', 'elsif', 'payload', '&&', '!', 'payload', '.', 'is_a?', '(', 'Hash', ')', 'message', '=', 'message', '.', 'nil?', '?', 'payload', ':', '"#{message} -- #{payload}"', 'payload', '=', 'nil', 'end', 'if', 'block_given?', '&&', '(', 'result', '=', 'yield', ')', 'if', 'result', '.', 'is_a?', '(', 'String', ')', 'message', '=', 'message', '.', 'nil?', '?', 'result', ':', '"#{message} -- #{result}"', 'assign', '(', 'message', ':', 'message', ',', 'payload', ':', 'payload', ',', 'exception', ':', 'exception', ')', 'elsif', 'message', '.', 'nil?', '&&', 'result', '.', 'is_a?', '(', 'Hash', ')', '&&', '%i[', 'message', 'payload', 'exception', ']', '.', 'any?', '{', '|', 'k', '|', 'result', '.', 'key?', 'k', '}', 'assign', '(', 'result', ')', 'elsif', 'payload', '&.', 'respond_to?', '(', ':merge', ')', 'assign', '(', 'message', ':', 'message', ',', 'payload', ':', 'payload', '.', 'merge', '(', 'result', ')', ',', 'exception', ':', 'exception', ')', 'else', 'assign', '(', 'message', ':', 'message', ',', 'payload', ':', 'result', ',', 'exception', ':', 'exception', ')', 'end', 'else', 'assign', '(', 'message', ':', 'message', ',', 'payload', ':', 'payload', ',', 'exception', ':', 'exception', ')', 'end', 'end']
->Original Target:
['Assign', 'positional', 'arguments', 'to', 'this', 'log', 'entry', 'supplying', 'defaults', 'where', 'applicable']
->Reconstructed Target:
Assign positional arguments to this log entry supplying defaults where applicable
->Reconstructed Predication:
message : message, payloadpayload : payload, exception: exception ): exception ): exception ): exception ): exception ): exception ): exception ): exception ): exception ): exception ): exception ): exception ): exception )
->Raw Input:
summarize:def assign_positional ( message = nil, payload = nil, exception = nil ) if exception. nil? && payload. nil? && message. respond_to? ( :backtrace ) && message. respond_to? ( :message ) exception = message message = nil elsif exception. nil? && payload && payload. respond_to? ( :backtrace ) && payload. respond_to? ( :message ) exception = payload payload = nil elsif payload &&! payload. is_a? ( Hash ) message = message. nil?? payload : "#{message} -- #{payload}" payload = nil end if block_given? && ( result = yield ) if result. is_a? ( String ) message = message. nil?? result : "#{message} -- #{result}" assign ( message : message, payload : payload, exception : exception ) elsif message. nil? && result. is_a? ( Hash ) && %i[ message payload exception ]. any? { | k | result. key? k } assign ( result ) elsif payload &. respond_to? ( :merge ) assign ( message : message, payload : payload. merge ( result ), exception : exception ) else assign ( message : message, payload : result, exception : exception ) end else assign ( message : message, payload : payload, exception : exception ) end end
->Raw Target:
Assign positional arguments to this log entry supplying defaults where applicable
--

336=========
->Original Input:
['def', 'each_exception', 'depth', '=', '0', 'exceptions', '=', '[', ']', 'ex', '=', 'exception', 'while', '!', 'ex', '.', 'nil?', '&&', '!', 'exceptions', '.', 'include?', '(', 'ex', ')', '&&', 'exceptions', '.', 'length', '<', 'MAX_EXCEPTIONS_TO_UNWRAP', 'exceptions', '<<', 'ex', 'yield', '(', 'ex', ',', 'depth', ')', 'depth', '+=', '1', 'ex', '=', 'if', 'ex', '.', 'respond_to?', '(', ':cause', ')', '&&', 'ex', '.', 'cause', 'ex', '.', 'cause', 'elsif', 'ex', '.', 'respond_to?', '(', ':continued_exception', ')', '&&', 'ex', '.', 'continued_exception', 'ex', '.', 'continued_exception', 'elsif', 'ex', '.', 'respond_to?', '(', ':original_exception', ')', '&&', 'ex', '.', 'original_exception', 'ex', '.', 'original_exception', 'end', 'end', 'end']
->Original Target:
['Call', 'the', 'block', 'for', 'exception', 'and', 'any', 'nested', 'exception']
->Reconstructed Target:
Call the block for exception and any nested exception
->Reconstructed Predication:
the exception to be unwrapped
->Raw Input:
summarize:def each_exception depth = 0 exceptions = [ ] ex = exception while! ex. nil? &&! exceptions. include? ( ex ) && exceptions. length < MAX_EXCEPTIONS_TO_UNWRAP exceptions << ex yield ( ex, depth ) depth += 1 ex = if ex. respond_to? ( :cause ) && ex. cause ex. cause elsif ex. respond_to? ( :continued_exception ) && ex. continued_exception ex. continued_exception elsif ex. respond_to? ( :original_exception ) && ex. original_exception ex. original_exception end end end
->Raw Target:
Call the block for exception and any nested exception
--

337=========
->Original Input:
['def', 'extract_file_and_line', '(', 'stack', ',', 'short_name', '=', 'false', ')', 'match', '=', 'CALLER_REGEXP', '.', 'match', '(', 'stack', '.', 'first', ')', '[', 'short_name', '?', 'File', '.', 'basename', '(', 'match', '[', '1', ']', ')', ':', 'match', '[', '1', ']', ',', 'match', '[', '2', ']', '.', 'to_i', ']', 'end']
->Original Target:
['Extract', 'the', 'filename', 'and', 'line', 'number', 'from', 'the', 'last', 'entry', 'in', 'the', 'supplied', 'backtrace']
->Reconstructed Target:
Extract the filename and line number from the last entry in the supplied backtrace
->Reconstructed Predication:
the file and line of the
->Raw Input:
summarize:def extract_file_and_line ( stack, short_name = false ) match = CALLER_REGEXP. match ( stack. first ) [ short_name? File. basename ( match [ 1 ] ) : match [ 1 ], match [ 2 ]. to_i ] end
->Raw Target:
Extract the filename and line number from the last entry in the supplied backtrace
--

338=========
->Original Input:
['def', 'message_for', '(', 'corrections', ')', 'return', '""', 'if', 'corrections', '.', 'empty?', 'output', '=', '"\\n\\n    Did you mean? "', '.', 'dup', 'output', '<<', 'corrections', '.', 'join', '(', '"\\n                  "', ')', 'output', '<<', '"\\n "', 'end']
->Original Target:
['Returns', 'a', 'human', 'readable', 'string', 'that', 'contains', '+', 'corrections', '+', '.', 'This', 'formatter', 'is', 'designed', 'to', 'be', 'less', 'verbose', 'to', 'not', 'take', 'too', 'much', 'screen', 'space', 'while', 'being', 'helpful', 'enough', 'to', 'the', 'user', '.']
->Reconstructed Target:
Returns a human readable string that contains + corrections +. This formatter is designed to be less verbose to not take too much screen space while being helpful enough to the user.
->Reconstructed Predication:
The given corrections are the
->Raw Input:
summarize:def message_for ( corrections ) return "" if corrections. empty? output = "\n\n    Did you mean? ". dup output << corrections. join ( "\n                  " ) output << "\n " end
->Raw Target:
Returns a human readable string that contains + corrections +. This formatter is designed to be less verbose to not take too much screen space while being helpful enough to the user.
--

339=========
->Original Input:
['def', 'gather_vars', '(', 'executor', ',', 'tconf', ',', 'message', ')', 'return', 'nil', 'if', '(', 'tconf', '.', 'keys', '&', '%w[', 'include_vars', 'exclude_vars', ']', ')', '.', 'empty?', 'iv', '=', 'expand_filter', '(', 'tconf', '[', "'include_vars'", ']', ')', 'return', 'nil', 'if', 'iv', '==', 'false', 'ev', '=', 'expand_filter', '(', 'tconf', '[', "'exclude_vars'", ']', ')', 'return', '{', '}', 'if', 'ev', '==', 'true', 'vars', '=', 'executor', '.', 'vars', '(', 'message', '[', "'nid'", ']', ')', 'return', 'vars', 'if', 'iv', '==', 'true', 'vars', '=', 'vars', '.', 'select', '{', '|', 'k', ',', 'v', '|', 'var_match', '(', 'k', ',', 'iv', ')', '}', 'if', 'iv', 'vars', '=', 'vars', '.', 'reject', '{', '|', 'k', ',', 'v', '|', 'var_match', '(', 'k', ',', 'ev', ')', '}', 'if', 'ev', 'vars', 'end']
->Original Target:
['By', 'default', 'taskers', 'don', 't', 'see', 'the', 'flor', 'variables', 'in', 'the', 'execution', '.', 'If', 'include_vars', 'or', 'exclude_vars', 'is', 'present', 'in', 'the', 'configuration', 'of', 'the', 'tasker', 'some', 'or', 'all', 'of', 'the', 'variables', 'are', 'passed', '.']
->Reconstructed Target:
By default taskers don t see the flor variables in the execution. If include_vars or exclude_vars is present in the configuration of the tasker some or all of the variables are passed.
->Reconstructed Predication:
thethe variable to gatherthe variable to gatherthe variable to gather.
->Raw Input:
summarize:def gather_vars ( executor, tconf, message ) return nil if ( tconf. keys & %w[ include_vars exclude_vars ] ). empty? iv = expand_filter ( tconf [ 'include_vars' ] ) return nil if iv == false ev = expand_filter ( tconf [ 'exclude_vars' ] ) return { } if ev == true vars = executor. vars ( message [ 'nid' ] ) return vars if iv == true vars = vars. select { | k, v | var_match ( k, iv ) } if iv vars = vars. reject { | k, v | var_match ( k, ev ) } if ev vars end
->Raw Target:
By default taskers don t see the flor variables in the execution. If include_vars or exclude_vars is present in the configuration of the tasker some or all of the variables are passed.
--

340=========
->Original Input:
['def', 'do_run', '@unit', '.', 'logger', '.', 'log_run_start', '(', 'self', ')', 'counter_next', '(', "'runs'", ')', 't0', '=', 'Time', '.', 'now', '(', '@unit', '.', 'conf', '[', "'exe_max_messages'", ']', '||', '77', ')', '.', 'times', 'do', '|', 'i', '|', 'break', 'if', '@shutdown', 'm', '=', '@messages', '.', 'shift', 'break', 'unless', 'm', 'm', '=', '(', '@messages', '<<', 'm', ')', '.', 'shift', 'if', 'm', '[', "'point'", ']', '==', "'terminated'", '&&', '@messages', '.', 'any?', 'ms', '=', 'process', '(', 'm', ')', '@consumed', '<<', 'm', 'ims', ',', 'oms', '=', 'ms', '.', 'partition', '{', '|', 'mm', '|', 'mm', '[', "'exid'", ']', '==', '@exid', '}', 'counter_add', '(', "'omsgs'", ',', 'oms', '.', 'size', ')', '@messages', '.', 'concat', '(', 'ims', ')', '@unit', '.', 'storage', '.', 'put_messages', '(', 'oms', ')', 'end', '@alive', '=', 'false', '@execution', '.', 'merge!', '(', 'closing_messages', ':', '@consumed', '.', 'select', '{', '|', 'm', '|', 'CLOSING_POINTS', '.', 'include?', '(', 'm', '[', "'point'", ']', ')', '}', ')', '@unit', '.', 'storage', '.', 'put_execution', '(', '@execution', ')', '@unit', '.', 'storage', '.', 'consume', '(', '@consumed', ')', '@unit', '.', 'storage', '.', 'put_messages', '(', '@messages', ')', 'du', '=', 'Time', '.', 'now', '-', 't0', 't0', '=', 'Flor', '.', 'tstamp', '(', 't0', ')', '@unit', '.', 'logger', '.', 'log_run_end', '(', 'self', ',', 't0', ',', 'du', ')', '@unit', '.', 'hooker', '.', 'notify', '(', 'self', ',', 'make_end_message', '(', 't0', ',', 'du', ',', '@execution', '[', "'size'", ']', ')', ')', '@consumed', '.', 'clear', 'rescue', 'Exception', '=>', 'exc', 'fn', '=', '[', "'flor'", ',', '@unit', '.', 'conf', '[', "'env'", ']', ',', '@unit', '.', 'identifier', ',', '@exid', ',', "'r'", '+', 'counter', '(', "'runs'", ')', '.', 'to_s', ']', '.', 'collect', '(', '&', ':to_s', ')', '.', 'join', '(', "'_'", ')', '+', "'.dump'", '@unit', '.', 'logger', '.', 'error', '(', '"#{self.class}#do_run()"', ',', 'exc', ',', '"(dumping to #{fn})"', ')', 'File', '.', 'open', '(', 'fn', ',', "'wb'", ')', 'do', '|', 'f', '|', 'f', '.', 'puts', '(', 'Flor', '.', 'to_pretty_s', '(', '{', 'execution', ':', '@execution', ',', 'messages', ':', '@messages', ',', 'consumed', ':', '@consumed', ',', 'traps', ':', '@traps', '.', 'collect', '(', '&', ':to_h', ')', ',', 'exid', ':', '@exid', ',', 'alive', ':', '@alive', ',', 'shutdown', ':', '@shutdown', ',', 'thread', ':', '[', '@thread', '.', 'object_id', ',', '@thread', '.', 'to_s', ']', '}', ')', ')', 'f', '.', 'puts', '(', "'-'", '*', '80', ')', 'f', '.', 'puts', '(', 'on_do_run_exc', '(', 'exc', ')', ')', 'end', 'end']
->Original Target:
['point', 'for', 'messages', 'that', 'after', 'consumption', 'are', 'conserved', 'in', 'the', 'execution', 's', 'closing_messages', 'array']
->Reconstructed Target:
point for messages that after consumption are conserved in the execution s closing_messages array
->Reconstructed Predication:
....(.................... to_s,. to_s, @execution [
->Raw Input:
summarize:def do_run @unit. logger. log_run_start ( self ) counter_next ( 'runs' ) t0 = Time. now ( @unit. conf [ 'exe_max_messages' ] || 77 ). times do | i | break if @shutdown m = @messages. shift break unless m m = ( @messages << m ). shift if m [ 'point' ] == 'terminated' && @messages. any? ms = process ( m ) @consumed << m ims, oms = ms. partition { | mm | mm [ 'exid' ] == @exid } counter_add ( 'omsgs', oms. size ) @messages. concat ( ims ) @unit. storage. put_messages ( oms ) end @alive = false @execution. merge! ( closing_messages : @consumed. select { | m | CLOSING_POINTS. include? ( m [ 'point' ] ) } ) @unit. storage. put_execution ( @execution ) @unit. storage. consume ( @consumed ) @unit. storage. put_messages ( @messages ) du = Time. now - t0 t0 = Flor. tstamp ( t0 ) @unit. logger. log_run_end ( self, t0, du ) @unit. hooker. notify ( self, make_end_message ( t0, du, @execution ['size' ] ) ) @consumed. clear rescue Exception => exc fn = [ 'flor', @unit. conf [ 'env' ], @unit. identifier, @exid, 'r' + counter ( 'runs' ). to_s ]. collect ( & :to_s ). join ( '_' ) + '.dump' @unit. logger. error ( "#{self.class}#do_run()", exc, "(dumping to #{fn})" ) File. open ( fn, 'wb' ) do | f | f. puts ( Flor. to_pretty_s ( { execution : @execution, messages : @messages, consumed : @consumed, traps : @traps. collect ( & :to_h ), exid : @exid, alive : @alive, shutdown : @shutdown, thread : [ @thread. object_id, @thread. to_s ] } ) ) f. puts ( '-' * 80 ) f
->Raw Target:
point for messages that after consumption are conserved in the execution s closing_messages array
--

341=========
->Original Input:
['def', 'route', '(', 'name', ')', 'if', 'name', '.', 'is_a?', '(', 'String', ')', '[', 'Flor', '.', 'dup_and_merge', '(', '@message', ',', "'tasker'", '=>', 'name', ',', "'original_tasker'", '=>', '@message', '[', "'tasker'", ']', ',', "'routed'", '=>', 'true', ')', ']', 'else', '[', 'Flor', '.', 'dup_and_merge', '(', '@message', ',', "'routed'", '=>', '!', '!', 'name', ')', ']', 'end', 'end']
->Original Target:
['For', 'domain', 'taskers']
->Reconstructed Target:
For domain taskers
->Reconstructed Predication:
the route to the specified tasker
->Raw Input:
summarize:def route ( name ) if name. is_a? ( String ) [ Flor. dup_and_merge ( @message, 'tasker' => name, 'original_tasker' => @message [ 'tasker' ], 'routed' => true ) ] else [ Flor. dup_and_merge ( @message, 'routed' =>!! name ) ] end end
->Raw Target:
For domain taskers
--

342=========
->Original Input:
['def', 'row_waiter?', '@serie', '.', 'find', '{', '|', '_', ',', 'points', '|', 'points', '.', 'find', '{', '|', 'po', '|', 'pos', '=', 'po', '.', 'split', '(', "':'", ')', 'pos', '.', 'length', '>', '1', '&&', 'ROW_PSEUDO_POINTS', '.', 'include?', '(', 'pos', '[', '0', ']', ')', '}', '}', 'end']
->Original Target:
['tasker', 'not', 'task', 'since', 'task', 'is', 'already', 'a', 'message', 'point']
->Reconstructed Target:
tasker not task since task is already a message point
->Reconstructed Predication:
return the waiter for a
->Raw Input:
summarize:def row_waiter? @serie. find { | _, points | points. find { | po | pos = po. split ( ':' ) pos. length > 1 && ROW_PSEUDO_POINTS. include? ( pos [ 0 ] ) } } end
->Raw Target:
tasker not task since task is already a message point
--

343=========
->Original Input:
['def', 'node', '(', 'reload', '=', 'false', ')', 'nid', '=', '@values', '[', ':nid', ']', ';', 'return', 'nil', 'unless', 'nid', 'exe', '=', 'execution', '(', 'reload', ')', ';', 'return', 'nil', 'unless', 'exe', 'nodes', '=', 'exe', '.', 'data', '[', "'nodes'", ']', ';', 'return', 'nil', 'unless', 'nodes', 'nodes', '[', 'nid', ']', 'end']
->Original Target:
['Returns', 'the', 'node', 'hash', 'linked', 'to', 'this', 'model']
->Reconstructed Target:
Returns the node hash linked to this model
->Reconstructed Predication:
the node to be used for
->Raw Input:
summarize:def node ( reload = false ) nid = @values [ :nid ] ; return nil unless nid exe = execution ( reload ) ; return nil unless exe nodes = exe. data [ 'nodes' ] ; return nil unless nodes nodes [ nid ] end
->Raw Target:
Returns the node hash linked to this model
--

344=========
->Original Input:
['def', 'vars', '(', 'nid', ',', 'vs', '=', '{', '}', ')', 'n', '=', 'node', '(', 'nid', ')', ';', 'return', 'vs', 'unless', 'n', '(', 'n', '[', "'vars'", ']', '||', '{', '}', ')', '.', 'each', '{', '|', 'k', ',', 'v', '|', 'vs', '[', 'k', ']', '=', 'Flor', '.', 'dup', '(', 'v', ')', 'unless', 'vs', '.', 'has_key?', '(', 'k', ')', '}', 'pnid', '=', 'n', '[', "'parent'", ']', 'if', '@unit', '.', 'loader', '&&', 'pnid', '==', 'nil', '&&', 'n', '[', "'vdomain'", ']', '!=', 'false', '@unit', '.', 'loader', '.', 'variables', '(', 'n', '[', "'vdomain'", ']', '||', 'Flor', '.', 'domain', '(', '@exid', ')', ')', '.', 'each', '{', '|', 'k', ',', 'v', '|', 'vs', '[', 'k', ']', '=', 'Flor', '.', 'dup', '(', 'v', ')', 'unless', 'vs', '.', 'has_key?', '(', 'k', ')', '}', 'end', 'if', 'cn', '=', 'n', '[', "'cnid'", ']', ';', 'vars', '(', 'cn', ',', 'vs', ')', ';', 'end', 'vars', '(', 'pnid', ',', 'vs', ')', 'if', 'pnid', 'vs', 'end']
->Original Target:
['Given', 'a', 'nid', 'returns', 'a', 'copy', 'of', 'all', 'the', 'var', 'the', 'node', 'sees', 'at', 'that', 'point', '.']
->Reconstructed Target:
Given a nid returns a copy of all the var the node sees at that point.
->Reconstructed Predication:
{{{{{ }{ } ;
->Raw Input:
summarize:def vars ( nid, vs = { } ) n = node ( nid ) ; return vs unless n ( n [ 'vars' ] || { } ). each { | k, v | vs [ k ] = Flor. dup ( v ) unless vs. has_key? ( k ) } pnid = n [ 'parent' ] if @unit. loader && pnid == nil && n [ 'vdomain' ]!= false @unit. loader. variables ( n [ 'vdomain' ] || Flor. domain ( @exid ) ). each { | k, v | vs [ k ] = Flor. dup ( v ) unless vs. has_key? ( k ) } end if cn = n [ 'cnid' ] ; vars ( cn, vs ) ; end vars ( pnid, vs ) if pnid vs end
->Raw Target:
Given a nid returns a copy of all the var the node sees at that point.
--

345=========
->Original Input:
['def', 'lookup_on_error_parent', '(', 'message', ')', 'nd', '=', 'Flor', '::', 'Node', '.', 'new', '(', 'self', ',', 'nil', ',', 'message', ')', '.', 'on_error_parent', 'nd', '?', 'nd', '.', 'to_procedure_node', ':', 'nil', 'end']
->Original Target:
['Return', 'an', 'empty', 'array', 'of', 'new', 'messages', '.', 'No', 'direct', 'effect', '.']
->Reconstructed Target:
Return an empty array of new messages. No direct effect.
->Reconstructed Predication:
the error parent of the
->Raw Input:
summarize:def lookup_on_error_parent ( message ) nd = Flor :: Node. new ( self, nil, message ). on_error_parent nd? nd. to_procedure_node : nil end
->Raw Target:
Return an empty array of new messages. No direct effect.
--

346=========
->Original Input:
['def', 'decrement', 'c', '=', 'data', '[', "'count'", ']', 'return', 'false', 'unless', 'c', 'c', '=', 'c', '-', '1', 'data', '[', "'count'", ']', '=', 'c', 'self', '[', ':status', ']', '=', 's', '=', '(', 'c', '>', '0', ')', '?', "'active'", ':', "'consumed'", 'self', '.', 'update', '(', 'content', ':', 'Flor', '::', 'Storage', '.', 'to_blob', '(', '@flor_model_cache_data', ')', ',', 'status', ':', 's', ')', 'c', '<', '1', 'end']
->Original Target:
['returns', 'true', 'if', 'the', 'trap', 'should', 'be', 'removed', 'from', 'the', 'execution', 's', 'list', 'of', 'traps']
->Reconstructed Target:
returns true if the trap should be removed from the execution s list of traps
->Reconstructed Predication:
the total count of thethe total count of the
->Raw Input:
summarize:def decrement c = data [ 'count' ] return false unless c c = c - 1 data [ 'count' ] = c self [ :status ] = s = ( c > 0 )? 'active' : 'consumed' self. update ( content : Flor :: Storage. to_blob ( @flor_model_cache_data ), status : s ) c < 1 end
->Raw Target:
returns true if the trap should be removed from the execution s list of traps
--

347=========
->Original Input:
['def', 'work', 'queue', ',', 'job', '=', 'lock_job', 'if', 'queue', '&&', 'job', 'QC', '.', 'log_yield', '(', ':at', '=>', '"work"', ',', ':job', '=>', 'job', '[', ':id', ']', ')', 'do', 'process', '(', 'queue', ',', 'job', ')', 'end', 'end', 'end']
->Original Target:
['Blocks', 'on', 'locking', 'a', 'job', 'and', 'once', 'a', 'job', 'is', 'locked', 'it', 'will', 'process', 'the', 'job', '.']
->Reconstructed Target:
Blocks on locking a job and once a job is locked it will process the job.
->Reconstructed Predication:
the job to be processed
->Raw Input:
summarize:def work queue, job = lock_job if queue && job QC. log_yield ( :at => "work", :job => job [ :id ] ) do process ( queue, job ) end end end
->Raw Target:
Blocks on locking a job and once a job is locked it will process the job.
--

348=========
->Original Input:
['def', 'lock_job', 'log', '(', ':at', '=>', '"lock_job"', ')', 'job', '=', 'nil', 'while', '@running', '@queues', '.', 'each', 'do', '|', 'queue', '|', 'if', 'job', '=', 'queue', '.', 'lock', 'return', '[', 'queue', ',', 'job', ']', 'end', 'end', '@conn_adapter', '.', 'wait', '(', '@wait_interval', ',', '*', '@queues', '.', 'map', '{', '|', 'q', '|', 'q', '.', 'name', '}', ')', 'end', 'end']
->Original Target:
['Attempt', 'to', 'lock', 'a', 'job', 'in', 'the', 'queue', 's', 'table', '.', 'If', 'a', 'job', 'can', 'be', 'locked', 'this', 'method', 'returns', 'an', 'array', 'with', '2', 'elements', '.', 'The', 'first', 'element', 'is', 'the', 'queue', 'from', 'which', 'the', 'job', 'was', 'locked', 'and', 'the', 'second', 'is', 'a', 'hash', 'representation', 'of', 'the', 'job', '.', 'If', 'a', 'job', 'is', 'returned', 'its', 'locked_at', 'column', 'has', 'been', 'set', 'in', 'the', 'job', 's', 'row', '.', 'It', 'is', 'the', 'caller', 's', 'responsibility', 'to', 'delete', 'the', 'job', 'row', 'from', 'the', 'table', 'when', 'the', 'job', 'is', 'complete', '.']
->Reconstructed Target:
Attempt to lock a job in the queue s table. If a job can be locked this method returns an array with 2 elements. The first element is the queue from which the job was locked and the second is a hash representation of the job. If a job is returned its locked_at column has been set in the job s row. It is the caller s responsibility to delete the job row from the table when the job is complete.
->Reconstructed Predication:
the job to be lockedthe job to be locked
->Raw Input:
summarize:def lock_job log ( :at => "lock_job" ) job = nil while @running @queues. each do | queue | if job = queue. lock return [ queue, job ] end end @conn_adapter. wait ( @wait_interval, * @queues. map { | q | q. name } ) end end
->Raw Target:
Attempt to lock a job in the queue s table. If a job can be locked this method returns an array with 2 elements. The first element is the queue from which the job was locked and the second is a hash representation of the job. If a job is returned its locked_at column has been set in the job s row. It is the caller s responsibility to delete the job row from the table when the job is complete.
--

349=========
->Original Input:
['def', 'call', '(', 'job', ')', 'args', '=', 'job', '[', ':args', ']', 'receiver_str', ',', '_', ',', 'message', '=', 'job', '[', ':method', ']', '.', 'rpartition', '(', "'.'", ')', 'receiver', '=', 'eval', '(', 'receiver_str', ')', 'receiver', '.', 'send', '(', 'message', ',', '*', 'args', ')', 'end']
->Original Target:
['Each', 'job', 'includes', 'a', 'method', 'column', '.', 'We', 'will', 'use', 'ruby', 's', 'eval', 'to', 'grab', 'the', 'ruby', 'object', 'from', 'memory', '.', 'We', 'send', 'the', 'method', 'to', 'the', 'object', 'and', 'pass', 'the', 'args', '.']
->Reconstructed Target:
Each job includes a method column. We will use ruby s eval to grab the ruby object from memory. We send the method to the object and pass the args.
->Reconstructed Predication:
the job to the receiver
->Raw Input:
summarize:def call ( job ) args = job [ :args ] receiver_str, _, message = job [ :method ]. rpartition ( '.' ) receiver = eval ( receiver_str ) receiver. send ( message, * args ) end
->Raw Target:
Each job includes a method column. We will use ruby s eval to grab the ruby object from memory. We send the method to the object and pass the args.
--

350=========
->Original Input:
['def', 'method_missing', '(', 'meth', ',', 'opts', '=', '{', '}', ')', 'if', 'meth', '.', 'to_s', '==', "'to_ary'", 'super', 'end', 'if', 'meth', '.', 'to_s', '.', 'end_with?', "'!'", 'deep_merge_options', 'meth', '[', '0', '..', '-', '2', ']', '.', 'to_sym', ',', 'opts', 'else', 'merge_options', 'meth', ',', 'opts', 'end', 'end']
->Original Target:
['Pass', 'other', 'methods', 'through', 'to', 'the', 'javascript', 'high_chart', 'object', '.']
->Reconstructed Target:
Pass other methods through to the javascript high_chart object.
->Reconstructed Predication:
the method to be called with
->Raw Input:
summarize:def method_missing ( meth, opts = { } ) if meth. to_s == 'to_ary' super end if meth. to_s. end_with? '!' deep_merge_options meth [ 0.. - 2 ]. to_sym, opts else merge_options meth, opts end end
->Raw Target:
Pass other methods through to the javascript high_chart object.
--

351=========
->Original Input:
['def', 'remove_params', '(', 'params', ')', 'self', '.', 'tap', 'do', '|', 'u', '|', 'u', '.', 'query_values', '=', '(', 'u', '.', 'query_values', '||', '{', '}', ')', '.', 'tap', 'do', '|', 'qv', '|', 'params', '.', 'each', 'do', '|', 'key', ',', 'value', '|', 'qv', '.', 'delete', 'key', 'end', 'end', 'if', 'u', '.', 'query_values', '.', 'empty?', 'u', '.', 'query_values', '=', 'nil', 'end', 'end', 'end']
->Original Target:
['params', 'can', 'be', 'an', 'array', 'or', 'a', 'hash']
->Reconstructed Target:
params can be an array or a hash
->Reconstructed Predication:
the query values to remove
->Raw Input:
summarize:def remove_params ( params ) self. tap do | u | u. query_values = ( u. query_values || { } ). tap do | qv | params. each do | key, value | qv. delete key end end if u. query_values. empty? u. query_values = nil end end end
->Raw Target:
params can be an array or a hash
--

352=========
->Original Input:
['def', 'parse_user_info', '(', 'node', ')', 'return', 'nil', 'if', 'node', '.', 'nil?', '{', '}', '.', 'tap', 'do', '|', 'hash', '|', 'node', '.', 'children', '.', 'each', 'do', '|', 'e', '|', 'unless', 'e', '.', 'kind_of?', '(', 'Nokogiri', '::', 'XML', '::', 'Text', ')', '||', 'e', '.', 'name', '==', "'proxies'", 'if', 'e', '.', 'element_children', '.', 'count', '==', '0', 'if', 'hash', '.', 'has_key?', '(', 'e', '.', 'name', ')', 'hash', '[', 'e', '.', 'name', ']', '=', '[', 'hash', '[', 'e', '.', 'name', ']', ']', 'if', 'hash', '[', 'e', '.', 'name', ']', '.', 'is_a?', 'String', 'hash', '[', 'e', '.', 'name', ']', '<<', 'e', '.', 'content', 'else', 'hash', '[', 'e', '.', 'name', ']', '=', 'e', '.', 'content', 'end', 'elsif', 'e', '.', 'element_children', '.', 'count', 'if', 'e', '.', 'name', '==', "'attributes'", 'hash', '.', 'merge!', '(', 'parse_user_info', '(', 'e', ')', ')', 'else', 'hash', '[', 'e', '.', 'name', ']', '=', '[', ']', 'if', 'hash', '[', 'e', '.', 'name', ']', '.', 'nil?', 'hash', '[', 'e', '.', 'name', ']', '=', '[', 'hash', '[', 'e', '.', 'name', ']', ']', 'if', 'hash', '[', 'e', '.', 'name', ']', '.', 'is_a?', 'String', 'hash', '[', 'e', '.', 'name', ']', '.', 'push', '(', 'parse_user_info', '(', 'e', ')', ')', 'end', 'end', 'end', 'end', 'end', 'end']
->Original Target:
['initially', 'borrowed', 'from', 'omniauth', '-', 'cas']
->Reconstructed Target:
initially borrowed from omniauth - cas
->Reconstructed Predication:
the user infothethethethethethethethethethethethethethe user infothe user infothe user infothe user infothe user infothe user infothe user infothe user infothe user infothe user infothe user infothe
->Raw Input:
summarize:def parse_user_info ( node ) return nil if node. nil? { }. tap do | hash | node. children. each do | e | unless e. kind_of? ( Nokogiri :: XML :: Text ) || e. name == 'proxies' if e. element_children. count == 0 if hash. has_key? ( e. name ) hash [ e. name ] = [ hash [ e. name ] ] if hash [ e. name ]. is_a? String hash [ e. name ] << e. content else hash [ e. name ] = e. content end elsif e. element_children. count if e. name == 'attributes' hash. merge! ( parse_user_info ( e ) ) else hash [ e. name ] = [ ] if hash [ e. name ]. nil? hash [ e. name ] = [ hash [ e. name ] ] if hash [ e. name ]. is_a? String hash [ e. name ]. push ( parse_user_info ( e ) ) end end end end end end
->Raw Target:
initially borrowed from omniauth - cas
--

353=========
->Original Input:
['def', 'run_async', '(', 'command', ')', 'raise', "'Async command already in progress'", 'if', '@started', '@started', '=', 'false', '@user_method', '.', 'reset', 'session', '.', 'open_channel', 'do', '|', 'channel', '|', 'channel', '.', 'request_pty', 'channel', '.', 'on_data', 'do', '|', 'ch', ',', 'data', '|', 'publish_data', '(', 'data', ',', "'stdout'", ')', 'unless', '@user_method', '.', 'filter_password?', '(', 'data', ')', '@user_method', '.', 'on_data', '(', 'data', ',', 'ch', ')', 'end', 'channel', '.', 'on_extended_data', '{', '|', 'ch', ',', 'type', ',', 'data', '|', 'publish_data', '(', 'data', ',', "'stderr'", ')', '}', 'channel', '.', 'on_request', '(', "'exit-status'", ')', '{', '|', 'ch', ',', 'data', '|', 'publish_exit_status', '(', 'data', '.', 'read_long', ')', '}', 'channel', '.', 'on_request', '(', "'exit-signal'", ')', 'do', '|', 'ch', ',', 'data', '|', 'publish_exit_status', '(', 'data', '.', 'read_string', ')', 'ch', '.', 'close', 'ch', '.', 'wait', 'end', 'channel', '.', 'exec', '(', 'command', ')', 'do', '|', '_', ',', 'success', '|', '@started', '=', 'true', 'raise', '(', "'Error initializing command'", ')', 'unless', 'success', 'end', 'end', 'session', '.', 'process', '(', '0', ')', '{', '!', 'run_started?', '}', 'return', 'true', 'end']
->Original Target:
['Initiates', 'run', 'of', 'the', 'remote', 'command', 'and', 'yields', 'the', 'data', 'when', 'available', '.', 'The', 'yielding', 'doesn', 't', 'happen', 'automatically', 'but', 'as', 'part', 'of', 'calling', 'the', 'refresh', 'method', '.']
->Reconstructed Target:
Initiates run of the remote command and yields the data when available. The yielding doesn t happen automatically but as part of calling the refresh method.
->Reconstructed Predication:
the command to runthe command to runthe command to run' )return false end
->Raw Input:
summarize:def run_async ( command ) raise 'Async command already in progress' if @started @started = false @user_method. reset session. open_channel do | channel | channel. request_pty channel. on_data do | ch, data | publish_data ( data,'stdout' ) unless @user_method. filter_password? ( data ) @user_method. on_data ( data, ch ) end channel. on_extended_data { | ch, type, data | publish_data ( data,'stderr' ) } channel. on_request ( 'exit-status' ) { | ch, data | publish_exit_status ( data. read_long ) } channel. on_request ( 'exit-signal' ) do | ch, data | publish_exit_status ( data. read_string ) ch. close ch. wait end channel. exec ( command ) do | _, success | @started = true raise ( 'Error initializing command' ) unless success end end session. process ( 0 ) {! run_started? } return true end
->Raw Target:
Initiates run of the remote command and yields the data when available. The yielding doesn t happen automatically but as part of calling the refresh method.
--

354=========
->Original Input:
['def', 'exit_code', 'fail_chance', '=', 'ENV', '.', 'fetch', '(', "'REX_SIMULATE_FAIL_CHANCE'", ',', '0', ')', '.', 'to_i', 'fail_exitcode', '=', 'ENV', '.', 'fetch', '(', "'REX_SIMULATE_EXIT'", ',', '0', ')', '.', 'to_i', 'if', 'fail_exitcode', '==', '0', '||', 'fail_chance', '<', '(', 'Random', '.', 'rand', '*', '100', ')', '.', 'round', '0', 'else', 'fail_exitcode', 'end', 'end']
->Original Target:
['Decide', 'if', 'the', 'execution', 'should', 'fail', 'or', 'not']
->Reconstructed Target:
Decide if the execution should fail or not
->Reconstructed Predication:
the exit code
->Raw Input:
summarize:def exit_code fail_chance = ENV. fetch ( 'REX_SIMULATE_FAIL_CHANCE', 0 ). to_i fail_exitcode = ENV. fetch ( 'REX_SIMULATE_EXIT', 0 ). to_i if fail_exitcode == 0 || fail_chance < ( Random. rand * 100 ). round 0 else fail_exitcode end end
->Raw Target:
Decide if the execution should fail or not
--

355=========
->Original Input:
['def', 'import_method', '(', 'source', ',', 'name', ',', 'new_name', '=', 'name', ')', 'from', '=', 'name', '.', 'to_sym', 'to', '=', 'new_name', '.', 'to_sym', 'fn', '=', 'source', '.', 'is_a?', '(', 'Registry', ')', '?', 'source', '.', 'fetch', '(', 'from', ')', ':', 'source', '.', 'method', '(', 'from', ')', 'self', '.', 'class', '.', 'new', '(', 'methods', '.', 'merge', '(', 'to', '=>', 'fn', ')', ')', 'end']
->Original Target:
['Creates', 'new', 'immutable', 'collection', 'from', 'the', 'current', 'one', 'updated', 'with', 'either', 'the', 'module', 's', 'singleton', 'method', 'or', 'the', 'proc', 'having', 'been', 'imported', 'from', 'another', 'module', '.']
->Reconstructed Target:
Creates new immutable collection from the current one updated with either the module s singleton method or the proc having been imported from another module.
->Reconstructed Predication:
a method to a method
->Raw Input:
summarize:def import_method ( source, name, new_name = name ) from = name. to_sym to = new_name. to_sym fn = source. is_a? ( Registry )? source. fetch ( from ) : source. method ( from ) self. class. new ( methods. merge ( to => fn ) ) end
->Raw Target:
Creates new immutable collection from the current one updated with either the module s singleton method or the proc having been imported from another module.
--

356=========
->Original Input:
['def', 'import_methods', '(', 'source', ',', 'names', ')', 'names', '.', 'inject', '(', 'self', ')', '{', '|', 'a', ',', 'e', '|', 'a', '.', 'import_method', '(', 'source', ',', 'e', ')', '}', 'end']
->Original Target:
['Creates', 'new', 'immutable', 'collection', 'from', 'the', 'current', 'one', 'updated', 'with', 'either', 'the', 'module', 's', 'singleton', 'methods', 'or', 'the', 'procs', 'having', 'been', 'imported', 'from', 'another', 'module', '.']
->Reconstructed Target:
Creates new immutable collection from the current one updated with either the module s singleton methods or the procs having been imported from another module.
->Reconstructed Predication:
the methods to be imported
->Raw Input:
summarize:def import_methods ( source, names ) names. inject ( self ) { | a, e | a. import_method ( source, e ) } end
->Raw Target:
Creates new immutable collection from the current one updated with either the module s singleton methods or the procs having been imported from another module.
--

357=========
->Original Input:
['def', 'import_all', '(', 'source', ')', 'names', '=', 'source', '.', 'public_methods', '-', 'Registry', '.', 'instance_methods', '-', 'Module', '.', 'methods', 'names', '-=', '[', ':initialize', ']', 'names', '+=', 'source', '.', 'store', '.', 'methods', '.', 'keys', 'if', 'source', '.', 'is_a?', 'Registry', 'import_methods', '(', 'source', ',', 'names', ')', 'end']
->Original Target:
['Creates', 'new', 'immutable', 'collection', 'from', 'the', 'current', 'one', 'updated', 'with', 'all', 'singleton', 'methods', 'and', 'imported', 'methods', 'from', 'the', 'other', 'module']
->Reconstructed Target:
Creates new immutable collection from the current one updated with all singleton methods and imported methods from the other module
->Reconstructed Predication:
the methods of the given module
->Raw Input:
summarize:def import_all ( source ) names = source. public_methods - Registry. instance_methods - Module. methods names -= [ :initialize ] names += source. store. methods. keys if source. is_a? Registry import_methods ( source, names ) end
->Raw Target:
Creates new immutable collection from the current one updated with all singleton methods and imported methods from the other module
--

358=========
->Original Input:
['def', '[]', '(', 'fn', ',', '*', 'args', ')', 'fetched', '=', 'fetch', '(', 'fn', ')', 'return', 'Function', '.', 'new', '(', 'fetched', ',', 'args', ':', 'args', ',', 'name', ':', 'fn', ')', 'unless', 'already_wrapped?', '(', 'fetched', ')', 'args', '.', 'empty?', '?', 'fetched', ':', 'fetched', '.', 'with', '(', '*', 'args', ')', 'end']
->Original Target:
['Builds', 'the', 'transformation']
->Reconstructed Target:
Builds the transformation
->Reconstructed Predication:
the function to be returned
->Raw Input:
summarize:def [] ( fn, * args ) fetched = fetch ( fn ) return Function. new ( fetched, args : args, name : fn ) unless already_wrapped? ( fetched ) args. empty?? fetched : fetched. with ( * args ) end
->Raw Target:
Builds the transformation
--

359=========
->Original Input:
['def', 'fetch', '(', 'fn', ')', 'return', 'fn', 'unless', 'fn', '.', 'instance_of?', 'Symbol', 'respond_to?', '(', 'fn', ')', '?', 'method', '(', 'fn', ')', ':', 'store', '.', 'fetch', '(', 'fn', ')', 'rescue', 'raise', 'FunctionNotFoundError', '.', 'new', '(', 'fn', ',', 'self', ')', 'end']
->Original Target:
['Gets', 'the', 'procedure', 'for', 'creating', 'a', 'transproc']
->Reconstructed Target:
Gets the procedure for creating a transproc
->Reconstructed Predication:
the function to retrieve. 
->Raw Input:
summarize:def fetch ( fn ) return fn unless fn. instance_of? Symbol respond_to? ( fn )? method ( fn ) : store. fetch ( fn ) rescue raise FunctionNotFoundError. new ( fn, self ) end
->Raw Target:
Gets the procedure for creating a transproc
--

360=========
->Original Input:
['def', 'to_ast', 'args_ast', '=', 'args', '.', 'map', '{', '|', 'arg', '|', 'arg', '.', 'respond_to?', '(', ':to_ast', ')', '?', 'arg', '.', 'to_ast', ':', 'arg', '}', '[', 'name', ',', 'args_ast', ']', 'end']
->Original Target:
['Return', 'a', 'simple', 'AST', 'representation', 'of', 'this', 'function']
->Reconstructed Target:
Return a simple AST representation of this function
->Reconstructed Predication:
the ast to be used for
->Raw Input:
summarize:def to_ast args_ast = args. map { | arg | arg. respond_to? ( :to_ast )? arg. to_ast : arg } [ name, args_ast ] end
->Raw Target:
Return a simple AST representation of this function
--

361=========
->Original Input:
['def', 'to_proc', 'if', 'args', '.', 'size', '>', '0', 'proc', '{', '|', '*', 'value', '|', 'fn', '.', 'call', '(', '*', 'value', ',', '*', 'args', ')', '}', 'else', 'fn', '.', 'to_proc', 'end', 'end']
->Original Target:
['Converts', 'a', 'transproc', 'to', 'a', 'simple', 'proc']
->Reconstructed Target:
Converts a transproc to a simple proc
->Reconstructed Predication:
the result of the
->Raw Input:
summarize:def to_proc if args. size > 0 proc { | * value | fn. call ( * value, * args ) } else fn. to_proc end end
->Raw Target:
Converts a transproc to a simple proc
--

362=========
->Original Input:
['def', 'from_pattern_match', '(', 'keys', ',', 'pattern', ',', 'match', ')', 'keys', '.', 'each_with_index', '.', 'map', 'do', '|', 'key', ',', 'idx', '|', 'if', 'pattern', '[', 'key', ']', 'interpolate', '(', 'pattern', '[', 'key', ']', ',', 'match', ')', 'else', 'match', '[', 'idx', '+', '1', ']', 'end', 'end', 'end']
->Original Target:
['Maps', 'replacement', 'keys', 'to', 'their', 'values']
->Reconstructed Target:
Maps replacement keys to their values
->Reconstructed Predication:
the pattern and the match
->Raw Input:
summarize:def from_pattern_match ( keys, pattern, match ) keys. each_with_index. map do | key, idx | if pattern [ key ] interpolate ( pattern [ key ], match ) else match [ idx + 1 ] end end end
->Raw Target:
Maps replacement keys to their values
--

363=========
->Original Input:
['def', 'interpolate', '(', 'replacement', ',', 'match', ')', 'group_idx', '=', 'replacement', '.', 'index', '(', "'$'", ')', 'return', 'replacement', 'if', 'group_idx', '.', 'nil?', 'group_nbr', '=', 'replacement', '[', 'group_idx', '+', '1', ']', 'replacement', '.', 'sub', '(', '"$#{group_nbr}"', ',', 'match', '[', 'group_nbr', '.', 'to_i', ']', ')', 'end']
->Original Target:
['Interpolates', 'a', 'string', 'with', 'data', 'from', 'matches', 'if', 'specified']
->Reconstructed Target:
Interpolates a string with data from matches if specified
->Reconstructed Predication:
the replacement string. 
->Raw Input:
summarize:def interpolate ( replacement, match ) group_idx = replacement. index ( '$' ) return replacement if group_idx. nil? group_nbr = replacement [ group_idx + 1 ] replacement. sub ( "$#{group_nbr}", match [ group_nbr. to_i ] ) end
->Raw Target:
Interpolates a string with data from matches if specified
--

364=========
->Original Input:
['def', 'before', '(', '*', 'commands', ',', '&', 'block', ')', 'context', '=', '(', '@_context', '[', ':before', ']', '||=', '[', ']', ')', 'block_given?', '?', 'run_context', '(', 'context', ',', '&', 'block', ')', ':', 'context', '.', 'concat', '(', 'commands', ')', 'end']
->Original Target:
['Run', 'commands', 'prior', 'to', 'each', 'tab', 'context', '.']
->Reconstructed Target:
Run commands prior to each tab context.
->Reconstructed Predication:
the context to be used
->Raw Input:
summarize:def before ( * commands, & block ) context = ( @_context [ :before ] ||= [ ] ) block_given?? run_context ( context, & block ) : context. concat ( commands ) end
->Raw Target:
Run commands prior to each tab context.
--

365=========
->Original Input:
['def', 'window', '(', '*', 'args', ',', '&', 'block', ')', 'key', '=', '"window#{@_windows.keys.size}"', 'options', '=', 'args', '.', 'extract_options!', 'options', '[', ':name', ']', '=', 'args', '.', 'first', 'unless', 'args', '.', 'empty?', 'context', '=', '(', '@_windows', '[', 'key', ']', '=', 'window_hash', '.', 'merge', '(', ':options', '=>', 'options', ')', ')', 'run_context', 'context', ',', '&', 'block', 'end']
->Original Target:
['Run', 'commands', 'in', 'the', 'conext', 'of', 'a', 'window', '.']
->Reconstructed Target:
Run commands in the conext of a window.
->Reconstructed Predication:
the window to be displayed
->Raw Input:
summarize:def window ( * args, & block ) key = "window#{@_windows.keys.size}" options = args. extract_options! options [ :name ] = args. first unless args. empty? context = ( @_windows [ key ] = window_hash. merge ( :options => options ) ) run_context context, & block end
->Raw Target:
Run commands in the conext of a window.
--

366=========
->Original Input:
['def', 'tab', '(', '*', 'args', ',', '&', 'block', ')', 'tabs', '=', '@_context', '[', ':tabs', ']', 'key', '=', '"tab#{tabs.keys.size}"', 'return', '(', 'tabs', '[', 'key', ']', '=', '{', ':commands', '=>', 'args', '}', ')', 'unless', 'block_given?', 'context', '=', '(', 'tabs', '[', 'key', ']', '=', '{', ':commands', '=>', '[', ']', '}', ')', 'options', '=', 'args', '.', 'extract_options!', 'options', '[', ':name', ']', '=', 'args', '.', 'first', 'unless', 'args', '.', 'empty?', 'context', '[', ':options', ']', '=', 'options', 'run_context', 'context', ',', '&', 'block', '@_context', '=', '@_windows', '[', '@_windows', '.', 'keys', '.', 'last', ']', 'end']
->Original Target:
['Run', 'commands', 'in', 'the', 'context', 'of', 'a', 'tab', '.']
->Reconstructed Target:
Run commands in the context of a tab.
->Reconstructed Predication:
the tab to be displayed
->Raw Input:
summarize:def tab ( * args, & block ) tabs = @_context [ :tabs ] key = "tab#{tabs.keys.size}" return ( tabs [ key ] = { :commands => args } ) unless block_given? context = ( tabs [ key ] = { :commands => [ ] } ) options = args. extract_options! options [ :name ] = args. first unless args. empty? context [ :options ] = options run_context context, & block @_context = @_windows [ @_windows. keys. last ] end
->Raw Target:
Run commands in the context of a tab.
--

367=========
->Original Input:
['def', 'run', '(', '*', 'commands', ')', 'context', '=', 'case', 'when', '@_context', '.', 'is_a?', '(', 'Hash', ')', '&&', '@_context', '[', ':tabs', ']', '@_context', '[', ':tabs', ']', '[', "'default'", ']', '[', ':commands', ']', 'when', '@_context', '.', 'is_a?', '(', 'Hash', ')', '@_context', '[', ':commands', ']', 'else', '@_context', 'end', 'context', '<<', 'commands', '.', 'map', '{', '|', 'c', '|', 'c', '=~', '/', '/', '?', '"(#{c})"', ':', 'c', '}', '.', 'join', '(', '" && "', ')', 'end']
->Original Target:
['Store', 'commands', 'to', 'run', 'in', 'context', '.']
->Reconstructed Target:
Store commands to run in context.
->Reconstructed Predication:
the command to run thethe command to run the command
->Raw Input:
summarize:def run ( * commands ) context = case when @_context. is_a? ( Hash ) && @_context [ :tabs ] @_context [ :tabs ] [ 'default' ] [ :commands ] when @_context. is_a? ( Hash ) @_context [ :commands ] else @_context end context << commands. map { | c | c =~ / /? "(#{c})" : c }. join ( " && " ) end
->Raw Target:
Store commands to run in context.
--

368=========
->Original Input:
['def', 'set_write', '(', 'policy', ',', 'operation', ',', 'key', ',', 'bins', ')', 'begin_cmd', 'field_count', '=', 'estimate_key_size', '(', 'key', ',', 'policy', ')', 'bins', '.', 'each', 'do', '|', 'bin', '|', 'estimate_operation_size_for_bin', '(', 'bin', ')', 'end', 'size_buffer', 'write_header_with_policy', '(', 'policy', ',', '0', ',', 'INFO2_WRITE', ',', 'field_count', ',', 'bins', '.', 'length', ')', 'write_key', '(', 'key', ',', 'policy', ')', 'bins', '.', 'each', 'do', '|', 'bin', '|', 'write_operation_for_bin', '(', 'bin', ',', 'operation', ')', 'end', 'end_cmd', 'end']
->Original Target:
['Writes', 'the', 'command', 'for', 'write', 'operations']
->Reconstructed Target:
Writes the command for write operations
->Reconstructed Predication:
the write operation to the specified
->Raw Input:
summarize:def set_write ( policy, operation, key, bins ) begin_cmd field_count = estimate_key_size ( key, policy ) bins. each do | bin | estimate_operation_size_for_bin ( bin ) end size_buffer write_header_with_policy ( policy, 0, INFO2_WRITE, field_count, bins. length ) write_key ( key, policy ) bins. each do | bin | write_operation_for_bin ( bin, operation ) end end_cmd end
->Raw Target:
Writes the command for write operations
--

369=========
->Original Input:
['def', 'set_delete', '(', 'policy', ',', 'key', ')', 'begin_cmd', 'field_count', '=', 'estimate_key_size', '(', 'key', ')', 'size_buffer', 'write_header_with_policy', '(', 'policy', ',', '0', ',', 'INFO2_WRITE', '|', 'INFO2_DELETE', ',', 'field_count', ',', '0', ')', 'write_key', '(', 'key', ')', 'end_cmd', 'end']
->Original Target:
['Writes', 'the', 'command', 'for', 'delete', 'operations']
->Reconstructed Target:
Writes the command for delete operations
->Reconstructed Predication:
the key to be deleted
->Raw Input:
summarize:def set_delete ( policy, key ) begin_cmd field_count = estimate_key_size ( key ) size_buffer write_header_with_policy ( policy, 0, INFO2_WRITE | INFO2_DELETE, field_count, 0 ) write_key ( key ) end_cmd end
->Raw Target:
Writes the command for delete operations
--

370=========
->Original Input:
['def', 'set_touch', '(', 'policy', ',', 'key', ')', 'begin_cmd', 'field_count', '=', 'estimate_key_size', '(', 'key', ')', 'estimate_operation_size', 'size_buffer', 'write_header_with_policy', '(', 'policy', ',', '0', ',', 'INFO2_WRITE', ',', 'field_count', ',', '1', ')', 'write_key', '(', 'key', ')', 'write_operation_for_operation_type', '(', 'Aerospike', '::', 'Operation', '::', 'TOUCH', ')', 'end_cmd', 'end']
->Original Target:
['Writes', 'the', 'command', 'for', 'touch', 'operations']
->Reconstructed Target:
Writes the command for touch operations
->Reconstructed Predication:
the operation to touch the key
->Raw Input:
summarize:def set_touch ( policy, key ) begin_cmd field_count = estimate_key_size ( key ) estimate_operation_size size_buffer write_header_with_policy ( policy, 0, INFO2_WRITE, field_count, 1 ) write_key ( key ) write_operation_for_operation_type ( Aerospike :: Operation :: TOUCH ) end_cmd end
->Raw Target:
Writes the command for touch operations
--

371=========
->Original Input:
['def', 'set_exists', '(', 'policy', ',', 'key', ')', 'begin_cmd', 'field_count', '=', 'estimate_key_size', '(', 'key', ')', 'size_buffer', 'write_header', '(', 'policy', ',', 'INFO1_READ', '|', 'INFO1_NOBINDATA', ',', '0', ',', 'field_count', ',', '0', ')', 'write_key', '(', 'key', ')', 'end_cmd', 'end']
->Original Target:
['Writes', 'the', 'command', 'for', 'exist', 'operations']
->Reconstructed Target:
Writes the command for exist operations
->Reconstructed Predication:
the exists attribute of the specified
->Raw Input:
summarize:def set_exists ( policy, key ) begin_cmd field_count = estimate_key_size ( key ) size_buffer write_header ( policy, INFO1_READ | INFO1_NOBINDATA, 0, field_count, 0 ) write_key ( key ) end_cmd end
->Raw Target:
Writes the command for exist operations
--

372=========
->Original Input:
['def', 'set_read_header', '(', 'policy', ',', 'key', ')', 'begin_cmd', 'field_count', '=', 'estimate_key_size', '(', 'key', ')', 'estimate_operation_size_for_bin_name', '(', "''", ')', 'size_buffer', 'write_header', '(', 'policy', ',', 'INFO1_READ', ',', '0', ',', 'field_count', ',', '1', ')', 'write_key', '(', 'key', ')', 'write_operation_for_bin_name', '(', "''", ',', 'Aerospike', '::', 'Operation', '::', 'READ', ')', 'end_cmd', 'end']
->Original Target:
['Writes', 'the', 'command', 'for', 'getting', 'metadata', 'operations']
->Reconstructed Target:
Writes the command for getting metadata operations
->Reconstructed Predication:
the header for a read operation
->Raw Input:
summarize:def set_read_header ( policy, key ) begin_cmd field_count = estimate_key_size ( key ) estimate_operation_size_for_bin_name ( '' ) size_buffer write_header ( policy, INFO1_READ, 0, field_count, 1 ) write_key ( key ) write_operation_for_bin_name ( '', Aerospike :: Operation :: READ ) end_cmd end
->Raw Target:
Writes the command for getting metadata operations
--

373=========
->Original Input:
['def', 'set_operate', '(', 'policy', ',', 'key', ',', 'operations', ')', 'begin_cmd', 'field_count', '=', 'estimate_key_size', '(', 'key', ',', 'policy', ')', 'read_attr', '=', '0', 'write_attr', '=', '0', 'read_header', '=', 'false', 'operations', '.', 'each', 'do', '|', 'operation', '|', 'case', 'operation', '.', 'op_type', 'when', 'Aerospike', '::', 'Operation', '::', 'READ', 'read_attr', '|=', 'INFO1_READ', 'read_attr', '|=', 'INFO1_GET_ALL', 'unless', 'operation', '.', 'bin_name', 'when', 'Aerospike', '::', 'Operation', '::', 'READ_HEADER', 'read_attr', '|=', 'INFO1_READ', 'read_header', '=', 'true', 'else', 'write_attr', '=', 'INFO2_WRITE', 'end', 'estimate_operation_size_for_operation', '(', 'operation', ')', 'end', 'size_buffer', 'if', 'write_attr', '!=', '0', 'write_header_with_policy', '(', 'policy', ',', 'read_attr', ',', 'write_attr', ',', 'field_count', ',', 'operations', '.', 'length', ')', 'else', 'write_header', '(', 'policy', ',', 'read_attr', ',', 'write_attr', ',', 'field_count', ',', 'operations', '.', 'length', ')', 'end', 'write_key', '(', 'key', ',', 'policy', ')', 'operations', '.', 'each', 'do', '|', 'operation', '|', 'write_operation_for_operation', '(', 'operation', ')', 'end', 'write_operation_for_bin', '(', 'nil', ',', 'Aerospike', '::', 'Operation', '::', 'READ', ')', 'if', 'read_header', 'end_cmd', 'end']
->Original Target:
['Implements', 'different', 'command', 'operations']
->Reconstructed Target:
Implements different command operations
->Reconstructed Predication:
write_key ( key, policywrite_operation_for_bin ( operations.write_operation_for_bin ( operations.write_operation_for_bin ( operations.write_operation_for_bin ( operations.write_operation_for_bin ( operations.write_operation_for_bin ( operations.write_operation_for_bin ( operations.write_operation_for_bin ( operations.write
->Raw Input:
summarize:def set_operate ( policy, key, operations ) begin_cmd field_count = estimate_key_size ( key, policy ) read_attr = 0 write_attr = 0 read_header = false operations. each do | operation | case operation. op_type when Aerospike :: Operation :: READ read_attr |= INFO1_READ read_attr |= INFO1_GET_ALL unless operation. bin_name when Aerospike :: Operation :: READ_HEADER read_attr |= INFO1_READ read_header = true else write_attr = INFO2_WRITE end estimate_operation_size_for_operation ( operation ) end size_buffer if write_attr!= 0 write_header_with_policy ( policy, read_attr, write_attr, field_count, operations. length ) else write_header ( policy, read_attr, write_attr, field_count, operations. length ) end write_key ( key, policy ) operations. each do | operation | write_operation_for_operation ( operation ) end write_operation_for_bin ( nil, Aerospike :: Operation :: READ ) if read_header end_cmd end
->Raw Target:
Implements different command operations
--

374=========
->Original Input:
['def', 'write_header', '(', 'policy', ',', 'read_attr', ',', 'write_attr', ',', 'field_count', ',', 'operation_count', ')', 'read_attr', '|=', 'INFO1_CONSISTENCY_ALL', 'if', 'policy', '.', 'consistency_level', '==', 'Aerospike', '::', 'ConsistencyLevel', '::', 'CONSISTENCY_ALL', '@data_buffer', '.', 'write_byte', '(', 'MSG_REMAINING_HEADER_SIZE', ',', '8', ')', '@data_buffer', '.', 'write_byte', '(', 'read_attr', ',', '9', ')', '@data_buffer', '.', 'write_byte', '(', 'write_attr', ',', '10', ')', 'i', '=', '11', 'while', 'i', '<=', '25', '@data_buffer', '.', 'write_byte', '(', '0', ',', 'i', ')', 'i', '=', 'i', '.', 'succ', 'end', '@data_buffer', '.', 'write_int16', '(', 'field_count', ',', '26', ')', '@data_buffer', '.', 'write_int16', '(', 'operation_count', ',', '28', ')', '@data_offset', '=', 'MSG_TOTAL_HEADER_SIZE', 'end']
->Original Target:
['Generic', 'header', 'write', '.']
->Reconstructed Target:
Generic header write.
->Reconstructed Predication:
write_byte ( read_attr, write_attrwrite_byte ( write_attr, field_countwrite_byte ( write_attr,write_byte ( field_count,write_byte ( write_attr,write_byte ( write_attr,write_byte ( write_attr,write_byte ( write_attr,write_byte ( write_attr, field_countwrite_byte ( write_attr
->Raw Input:
summarize:def write_header ( policy, read_attr, write_attr, field_count, operation_count ) read_attr |= INFO1_CONSISTENCY_ALL if policy. consistency_level == Aerospike :: ConsistencyLevel :: CONSISTENCY_ALL @data_buffer. write_byte ( MSG_REMAINING_HEADER_SIZE, 8 ) @data_buffer. write_byte ( read_attr, 9 ) @data_buffer. write_byte ( write_attr, 10 ) i = 11 while i <= 25 @data_buffer. write_byte ( 0, i ) i = i. succ end @data_buffer. write_int16 ( field_count, 26 ) @data_buffer. write_int16 ( operation_count, 28 ) @data_offset = MSG_TOTAL_HEADER_SIZE end
->Raw Target:
Generic header write.
--

375=========
->Original Input:
['def', 'write_header_with_policy', '(', 'policy', ',', 'read_attr', ',', 'write_attr', ',', 'field_count', ',', 'operation_count', ')', 'generation', '=', 'Integer', '(', '0', ')', 'info_attr', '=', 'Integer', '(', '0', ')', 'case', 'policy', '.', 'record_exists_action', 'when', 'Aerospike', '::', 'RecordExistsAction', '::', 'UPDATE', 'when', 'Aerospike', '::', 'RecordExistsAction', '::', 'UPDATE_ONLY', 'info_attr', '|=', 'INFO3_UPDATE_ONLY', 'when', 'Aerospike', '::', 'RecordExistsAction', '::', 'REPLACE', 'info_attr', '|=', 'INFO3_CREATE_OR_REPLACE', 'when', 'Aerospike', '::', 'RecordExistsAction', '::', 'REPLACE_ONLY', 'info_attr', '|=', 'INFO3_REPLACE_ONLY', 'when', 'Aerospike', '::', 'RecordExistsAction', '::', 'CREATE_ONLY', 'write_attr', '|=', 'INFO2_CREATE_ONLY', 'end', 'case', 'policy', '.', 'generation_policy', 'when', 'Aerospike', '::', 'GenerationPolicy', '::', 'NONE', 'when', 'Aerospike', '::', 'GenerationPolicy', '::', 'EXPECT_GEN_EQUAL', 'generation', '=', 'policy', '.', 'generation', 'write_attr', '|=', 'INFO2_GENERATION', 'when', 'Aerospike', '::', 'GenerationPolicy', '::', 'EXPECT_GEN_GT', 'generation', '=', 'policy', '.', 'generation', 'write_attr', '|=', 'INFO2_GENERATION_GT', 'end', 'info_attr', '|=', 'INFO3_COMMIT_MASTER', 'if', 'policy', '.', 'commit_level', '==', 'Aerospike', '::', 'CommitLevel', '::', 'COMMIT_MASTER', 'read_attr', '|=', 'INFO1_CONSISTENCY_ALL', 'if', 'policy', '.', 'consistency_level', '==', 'Aerospike', '::', 'ConsistencyLevel', '::', 'CONSISTENCY_ALL', 'write_attr', '|=', 'INFO2_DURABLE_DELETE', 'if', 'policy', '.', 'durable_delete', '@data_buffer', '.', 'write_byte', '(', 'MSG_REMAINING_HEADER_SIZE', ',', '8', ')', '@data_buffer', '.', 'write_byte', '(', 'read_attr', ',', '9', ')', '@data_buffer', '.', 'write_byte', '(', 'write_attr', ',', '10', ')', '@data_buffer', '.', 'write_byte', '(', 'info_attr', ',', '11', ')', '@data_buffer', '.', 'write_byte', '(', '0', ',', '12', ')', '@data_buffer', '.', 'write_byte', '(', '0', ',', '13', ')', '@data_buffer', '.', 'write_uint32', '(', 'generation', ',', '14', ')', '@data_buffer', '.', 'write_uint32', '(', 'policy', '.', 'ttl', ',', '18', ')', '@data_buffer', '.', 'write_byte', '(', '0', ',', '22', ')', '@data_buffer', '.', 'write_byte', '(', '0', ',', '23', ')', '@data_buffer', '.', 'write_byte', '(', '0', ',', '24', ')', '@data_buffer', '.', 'write_byte', '(', '0', ',', '25', ')', '@data_buffer', '.', 'write_int16', '(', 'field_count', ',', '26', ')', '@data_buffer', '.', 'write_int16', '(', 'operation_count', ',', '28', ')', '@data_offset', '=', 'MSG_TOTAL_HEADER_SIZE', 'end']
->Original Target:
['Header', 'write', 'for', 'write', 'operations', '.']
->Reconstructed Target:
Header write for write operations.
->Reconstructed Predication:
write_header_with_policy (write_int16 ( operation_count,write_int16 ( field_count,write_int16 (write_int16 (write_int16 (write_int16 (write_int16 (write_int16 (write_int16 (write_int16 (write_int16 (write_int16 (write_int16 (write_
->Raw Input:
summarize:def write_header_with_policy ( policy, read_attr, write_attr, field_count, operation_count ) generation = Integer ( 0 ) info_attr = Integer ( 0 ) case policy. record_exists_action when Aerospike :: RecordExistsAction :: UPDATE when Aerospike :: RecordExistsAction :: UPDATE_ONLY info_attr |= INFO3_UPDATE_ONLY when Aerospike :: RecordExistsAction :: REPLACE info_attr |= INFO3_CREATE_OR_REPLACE when Aerospike :: RecordExistsAction :: REPLACE_ONLY info_attr |= INFO3_REPLACE_ONLY when Aerospike :: RecordExistsAction :: CREATE_ONLY write_attr |= INFO2_CREATE_ONLY end case policy. generation_policy when Aerospike :: GenerationPolicy :: NONE when Aerospike :: GenerationPolicy :: EXPECT_GEN_EQUAL generation = policy. generation write_attr |= INFO2_GENERATION when Aerospike :: GenerationPolicy :: EXPECT_GEN_GT generation = policy. generation write_attr |= INFO2_GENERATION_GT end info_attr |= INFO3_COMMIT_MASTER if policy. commit_level == Aerospike :: CommitLevel :: COMMIT_MASTER read_attr |= INFO1_CONSISTENCY_ALL if policy. consistency_level == Aerospike :: ConsistencyLevel :: CONSISTENCY_ALL write_attr |= INFO2_DURABLE_DELETE if policy. durable_delete @data_buffer. write_byte ( MSG_REMAINING_HEADER_SIZE, 8 ) @data_buffer. write_byte ( read_attr, 9 ) @data_buffer. write_byte ( write_attr, 10 ) @data_buffer. write_byte ( info_attr, 11 ) @data_buffer. write_byte ( 0, 12 ) @data_buffer. write_byte ( 0, 13 ) @data_buffer. write_uint32 ( generation, 14 ) @data_buffer. write_uint32 ( policy. ttl, 18 ) @data_buffer. write_byte ( 0, 22 ) @data_buffer. write_byte ( 0, 23 ) @data_buffer. write_byte ( 0, 24 ) @data_buffer. write_byte ( 0, 25 ) @data_buffer. write_int16 ( field_count, 26 ) @data_buffer
->Raw Target:
Header write for write operations.
--

376=========
->Original Input:
['def', 'all_nodes_done?', 'if', '@scan', 'command', '=', "'scan-list'", 'else', 'command', '=', "'query-list'", 'end', 'nodes', '=', '@cluster', '.', 'nodes', 'done', '=', 'false', 'nodes', '.', 'each', 'do', '|', 'node', '|', 'conn', '=', 'node', '.', 'get_connection', '(', '0', ')', 'responseMap', ',', '_', '=', 'Info', '.', 'request', '(', 'conn', ',', 'command', ')', 'node', '.', 'put_connection', '(', 'conn', ')', 'response', '=', 'responseMap', '[', 'command', ']', 'find', '=', '"job_id=#{@task_id}:"', 'index', '=', 'response', '.', 'index', '(', 'find', ')', 'unless', 'index', 'done', '=', 'true', 'next', 'end', 'b', '=', 'index', '+', 'find', '.', 'length', 'response', '=', 'response', '[', 'b', ',', 'response', '.', 'length', ']', 'find', '=', "'job_status='", 'index', '=', 'response', '.', 'index', '(', 'find', ')', 'next', 'unless', 'index', 'b', '=', 'index', '+', 'find', '.', 'length', 'response', '=', 'response', '[', 'b', ',', 'response', '.', 'length', ']', 'e', '=', 'response', '.', 'index', '(', "':'", ')', 'status', '=', 'response', '[', '0', ',', 'e', ']', 'case', 'status', 'when', "'ABORTED'", 'raise', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'QueryTerminated', 'when', "'IN PROGRESS'", 'return', 'false', 'when', "'DONE'", 'done', '=', 'true', 'end', 'end', 'done', 'end']
->Original Target:
['NewExecuteTask', 'initializes', 'task', 'with', 'fields', 'needed', 'to', 'query', 'server', 'nodes', '.', 'IsDone', 'queries', 'all', 'nodes', 'for', 'task', 'completion', 'status', '.']
->Reconstructed Target:
NewExecuteTask initializes task with fields needed to query server nodes. IsDone queries all nodes for task completion status.
->Reconstructed Predication:
nodes = @cluster. nodes.........
->Raw Input:
summarize:def all_nodes_done? if @scan command ='scan-list' else command = 'query-list' end nodes = @cluster. nodes done = false nodes. each do | node | conn = node. get_connection ( 0 ) responseMap, _ = Info. request ( conn, command ) node. put_connection ( conn ) response = responseMap [ command ] find = "job_id=#{@task_id}:" index = response. index ( find ) unless index done = true next end b = index + find. length response = response [ b, response. length ] find = 'job_status=' index = response. index ( find ) next unless index b = index + find. length response = response [ b, response. length ] e = response. index ( ':' ) status = response [ 0, e ] case status when 'ABORTED' raise raise Aerospike :: Exceptions :: QueryTerminated when 'IN PROGRESS' return false when 'DONE' done = true end end done end
->Raw Target:
NewExecuteTask initializes task with fields needed to query server nodes. IsDone queries all nodes for task completion status.
--

377=========
->Original Input:
['def', 'get_connection', '(', 'timeout', ')', 'loop', 'do', 'conn', '=', '@connections', '.', 'poll', 'if', 'conn', '.', 'connected?', 'conn', '.', 'timeout', '=', 'timeout', '.', 'to_f', 'return', 'conn', 'end', 'end', 'end']
->Original Target:
['Initialize', 'server', 'node', 'with', 'connection', 'parameters', '.', 'Get', 'a', 'connection', 'to', 'the', 'node', '.', 'If', 'no', 'cached', 'connection', 'is', 'not', 'available', 'a', 'new', 'connection', 'will', 'be', 'created']
->Reconstructed Target:
Initialize server node with connection parameters. Get a connection to the node. If no cached connection is not available a new connection will be created
->Reconstructed Predication:
the connection to the server.
->Raw Input:
summarize:def get_connection ( timeout ) loop do conn = @connections. poll if conn. connected? conn. timeout = timeout. to_f return conn end end end
->Raw Target:
Initialize server node with connection parameters. Get a connection to the node. If no cached connection is not available a new connection will be created
--

378=========
->Original Input:
['def', 'parse_record', '(', 'key', ',', 'op_count', ',', 'generation', ',', 'expiration', ')', 'bins', '=', 'op_count', '>', '0', '?', '{', '}', ':', 'nil', 'i', '=', '0', 'while', 'i', '<', 'op_count', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'QueryTerminated', '.', 'new', 'unless', 'valid?', 'read_bytes', '(', '8', ')', 'op_size', '=', '@data_buffer', '.', 'read_int32', '(', '0', ')', '.', 'ord', 'particle_type', '=', '@data_buffer', '.', 'read', '(', '5', ')', '.', 'ord', 'name_size', '=', '@data_buffer', '.', 'read', '(', '7', ')', '.', 'ord', 'read_bytes', '(', 'name_size', ')', 'name', '=', '@data_buffer', '.', 'read', '(', '0', ',', 'name_size', ')', '.', 'force_encoding', '(', "'utf-8'", ')', 'particle_bytes_size', '=', 'op_size', '-', '(', '4', '+', 'name_size', ')', 'read_bytes', '(', 'particle_bytes_size', ')', 'value', '=', 'Aerospike', '.', 'bytes_to_particle', '(', 'particle_type', ',', '@data_buffer', ',', '0', ',', 'particle_bytes_size', ')', 'bins', '[', 'name', ']', '=', 'value', 'i', '=', 'i', '.', 'succ', 'end', 'Record', '.', 'new', '(', '@node', ',', 'key', ',', 'bins', ',', 'generation', ',', 'expiration', ')', 'end']
->Original Target:
['Parses', 'the', 'given', 'byte', 'buffer', 'and', 'populate', 'the', 'result', 'object', '.', 'Returns', 'the', 'number', 'of', 'bytes', 'that', 'were', 'parsed', 'from', 'the', 'given', 'buffer', '.']
->Reconstructed Target:
Parses the given byte buffer and populate the result object. Returns the number of bytes that were parsed from the given buffer.
->Reconstructed Predication:
the recordthe record isthe recordthe record isthe record isthe record isthe record isthe record isthe record is thethe record is thethe record is thethe record is thethe record is thethe record is thethe record is the record
->Raw Input:
summarize:def parse_record ( key, op_count, generation, expiration ) bins = op_count > 0? { } : nil i = 0 while i < op_count raise Aerospike :: Exceptions :: QueryTerminated. new unless valid? read_bytes ( 8 ) op_size = @data_buffer. read_int32 ( 0 ). ord particle_type = @data_buffer. read ( 5 ). ord name_size = @data_buffer. read ( 7 ). ord read_bytes ( name_size ) name = @data_buffer. read ( 0, name_size ). force_encoding ( 'utf-8' ) particle_bytes_size = op_size - ( 4 + name_size ) read_bytes ( particle_bytes_size ) value = Aerospike. bytes_to_particle ( particle_type, @data_buffer, 0, particle_bytes_size ) bins [ name ] = value i = i. succ end Record. new ( @node, key, bins, generation, expiration ) end
->Raw Target:
Parses the given byte buffer and populate the result object. Returns the number of bytes that were parsed from the given buffer.
--

379=========
->Original Input:
['def', 'random_node', 'node_array', '=', 'nodes', 'length', '=', 'node_array', '.', 'length', 'i', '=', '0', 'while', 'i', '<', 'length', 'index', '=', '(', '@node_index', '.', 'update', '{', '|', 'v', '|', 'v', '+', '1', '}', '%', 'node_array', '.', 'length', ')', '.', 'abs', 'node', '=', 'node_array', '[', 'index', ']', 'return', 'node', 'if', 'node', '.', 'active?', 'i', '=', 'i', '.', 'succ', 'end', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'InvalidNode', 'end']
->Original Target:
['Returns', 'a', 'random', 'node', 'on', 'the', 'cluster']
->Reconstructed Target:
Returns a random node on the cluster
->Reconstructed Predication:
a random node.  def
->Raw Input:
summarize:def random_node node_array = nodes length = node_array. length i = 0 while i < length index = ( @node_index. update { | v | v + 1 } % node_array. length ). abs node = node_array [ index ] return node if node. active? i = i. succ end raise Aerospike :: Exceptions :: InvalidNode end
->Raw Target:
Returns a random node on the cluster
--

380=========
->Original Input:
['def', 'get_node_by_name', '(', 'node_name', ')', 'node', '=', 'find_node_by_name', '(', 'node_name', ')', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'InvalidNode', 'unless', 'node', 'node', 'end']
->Original Target:
['Find', 'a', 'node', 'by', 'name', 'and', 'returns', 'an', 'error', 'if', 'not', 'found']
->Reconstructed Target:
Find a node by name and returns an error if not found
->Reconstructed Predication:
the node with the given name
->Raw Input:
summarize:def get_node_by_name ( node_name ) node = find_node_by_name ( node_name ) raise Aerospike :: Exceptions :: InvalidNode unless node node end
->Raw Target:
Find a node by name and returns an error if not found
--

381=========
->Original Input:
['def', 'prepend', '(', 'key', ',', 'bins', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'WritePolicy', ',', 'default_write_policy', ')', 'command', '=', 'WriteCommand', '.', 'new', '(', '@cluster', ',', 'policy', ',', 'key', ',', 'hash_to_bins', '(', 'bins', ')', ',', 'Aerospike', '::', 'Operation', '::', 'PREPEND', ')', 'execute_command', '(', 'command', ')', 'end']
->Original Target:
['Prepends', 'bin', 'values', 'string', 'to', 'existing', 'record', 'bin', 'values', '.', 'The', 'policy', 'specifies', 'the', 'transaction', 'timeout', 'record', 'expiration', 'and', 'how', 'the', 'transaction', 'is', 'handled', 'when', 'the', 'record', 'already', 'exists', '.']
->Reconstructed Target:
Prepends bin values string to existing record bin values. The policy specifies the transaction timeout record expiration and how the transaction is handled when the record already exists.
->Reconstructed Predication:
the key to prepend bins tothe key to prepend bins to
->Raw Input:
summarize:def prepend ( key, bins, options = nil ) policy = create_policy ( options, WritePolicy, default_write_policy ) command = WriteCommand. new ( @cluster, policy, key, hash_to_bins ( bins ), Aerospike :: Operation :: PREPEND ) execute_command ( command ) end
->Raw Target:
Prepends bin values string to existing record bin values. The policy specifies the transaction timeout record expiration and how the transaction is handled when the record already exists.
--

382=========
->Original Input:
['def', 'get_header', '(', 'key', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'Policy', ',', 'default_read_policy', ')', 'command', '=', 'ReadHeaderCommand', '.', 'new', '(', '@cluster', ',', 'policy', ',', 'key', ')', 'execute_command', '(', 'command', ')', 'command', '.', 'record', 'end']
->Original Target:
['Read', 'record', 'generation', 'and', 'expiration', 'only', 'for', 'specified', 'key', '.', 'Bins', 'are', 'not', 'read', '.', 'The', 'policy', 'can', 'be', 'used', 'to', 'specify', 'timeouts', '.']
->Reconstructed Target:
Read record generation and expiration only for specified key. Bins are not read. The policy can be used to specify timeouts.
->Reconstructed Predication:
the header for the specified key
->Raw Input:
summarize:def get_header ( key, options = nil ) policy = create_policy ( options, Policy, default_read_policy ) command = ReadHeaderCommand. new ( @cluster, policy, key ) execute_command ( command ) command. record end
->Raw Target:
Read record generation and expiration only for specified key. Bins are not read. The policy can be used to specify timeouts.
--

383=========
->Original Input:
['def', 'batch_exists', '(', 'keys', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'BatchPolicy', ',', 'default_batch_policy', ')', 'results', '=', 'Array', '.', 'new', '(', 'keys', '.', 'length', ')', 'if', 'policy', '.', 'use_batch_direct', 'key_map', '=', 'BatchItem', '.', 'generate_map', '(', 'keys', ')', 'execute_batch_direct_commands', '(', 'keys', ')', 'do', '|', 'node', ',', 'batch', '|', 'BatchDirectExistsCommand', '.', 'new', '(', 'node', ',', 'batch', ',', 'policy', ',', 'key_map', ',', 'results', ')', 'end', 'else', 'execute_batch_index_commands', '(', 'keys', ')', 'do', '|', 'node', ',', 'batch', '|', 'BatchIndexExistsCommand', '.', 'new', '(', 'node', ',', 'batch', ',', 'policy', ',', 'results', ')', 'end', 'end', 'results', 'end']
->Original Target:
['Check', 'if', 'multiple', 'record', 'keys', 'exist', 'in', 'one', 'batch', 'call', '.', 'The', 'returned', 'boolean', 'array', 'is', 'in', 'positional', 'order', 'with', 'the', 'original', 'key', 'array', 'order', '.', 'The', 'policy', 'can', 'be', 'used', 'to', 'specify', 'timeouts', 'and', 'protocol', 'type', '.']
->Reconstructed Target:
Check if multiple record keys exist in one batch call. The returned boolean array is in positional order with the original key array order. The policy can be used to specify timeouts and protocol type.
->Reconstructed Predication:
the batch exists for the giventhe batch exists for the given
->Raw Input:
summarize:def batch_exists ( keys, options = nil ) policy = create_policy ( options, BatchPolicy, default_batch_policy ) results = Array. new ( keys. length ) if policy. use_batch_direct key_map = BatchItem. generate_map ( keys ) execute_batch_direct_commands ( keys ) do | node, batch | BatchDirectExistsCommand. new ( node, batch, policy, key_map, results ) end else execute_batch_index_commands ( keys ) do | node, batch | BatchIndexExistsCommand. new ( node, batch, policy, results ) end end results end
->Raw Target:
Check if multiple record keys exist in one batch call. The returned boolean array is in positional order with the original key array order. The policy can be used to specify timeouts and protocol type.
--

384=========
->Original Input:
['def', 'register_udf', '(', 'udf_body', ',', 'server_path', ',', 'language', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'Policy', ',', 'default_info_policy', ')', 'content', '=', 'Base64', '.', 'strict_encode64', '(', 'udf_body', ')', '.', 'force_encoding', '(', "'binary'", ')', 'str_cmd', '=', '"udf-put:filename=#{server_path};content=#{content};"', 'str_cmd', '<<', '"content-len=#{content.length};udf-type=#{language};"', 'response_map', '=', '@cluster', '.', 'request_info', '(', 'policy', ',', 'str_cmd', ')', 'res', '=', '{', '}', 'response_map', '.', 'each', 'do', '|', 'k', ',', 'response', '|', 'vals', '=', 'response', '.', 'to_s', '.', 'split', '(', "';'", ')', 'vals', '.', 'each', 'do', '|', 'pair', '|', 'k', ',', 'v', '=', 'pair', '.', 'split', '(', '"="', ',', '2', ')', 'res', '[', 'k', ']', '=', 'v', 'end', 'end', 'if', 'res', '[', "'error'", ']', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'CommandRejected', '.', 'new', '(', '"Registration failed: #{res[\'error\']}\\nFile: #{res[\'file\']}\\nLine: #{res[\'line\']}\\nMessage: #{res[\'message\']}"', ')', 'end', 'UdfRegisterTask', '.', 'new', '(', '@cluster', ',', 'server_path', ')', 'end']
->Original Target:
['Register', 'package', 'containing', 'user', 'defined', 'functions', 'with', 'server', '.', 'This', 'asynchronous', 'server', 'call', 'will', 'return', 'before', 'command', 'is', 'complete', '.', 'The', 'user', 'can', 'optionally', 'wait', 'for', 'command', 'completion', 'by', 'using', 'the', 'returned', 'RegisterTask', 'instance', '.']
->Reconstructed Target:
Register package containing user defined functions with server. This asynchronous server call will return before command is complete. The user can optionally wait for command completion by using the returned RegisterTask instance.
->Reconstructed Predication:
thethethethethethethe
->Raw Input:
summarize:def register_udf ( udf_body, server_path, language, options = nil ) policy = create_policy ( options, Policy, default_info_policy ) content = Base64. strict_encode64 ( udf_body ). force_encoding ( 'binary' ) str_cmd = "udf-put:filename=#{server_path};content=#{content};" str_cmd << "content-len=#{content.length};udf-type=#{language};" response_map = @cluster. request_info ( policy, str_cmd ) res = { } response_map. each do | k, response | vals = response. to_s. split ( ';' ) vals. each do | pair | k, v = pair. split ( "=", 2 ) res [ k ] = v end end if res [ 'error' ] raise Aerospike :: Exceptions :: CommandRejected. new ( "Registration failed: #{res['error']}\nFile: #{res['file']}\nLine: #{res['line']}\nMessage: #{res['message']}" ) end UdfRegisterTask. new ( @cluster, server_path ) end
->Raw Target:
Register package containing user defined functions with server. This asynchronous server call will return before command is complete. The user can optionally wait for command completion by using the returned RegisterTask instance.
--

385=========
->Original Input:
['def', 'remove_udf', '(', 'udf_name', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'Policy', ',', 'default_info_policy', ')', 'str_cmd', '=', '"udf-remove:filename=#{udf_name};"', 'response_map', '=', '@cluster', '.', 'request_info', '(', 'policy', ',', 'str_cmd', ')', '_', ',', 'response', '=', 'response_map', '.', 'first', 'if', 'response', '==', "'ok'", 'UdfRemoveTask', '.', 'new', '(', '@cluster', ',', 'udf_name', ')', 'else', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'Aerospike', '.', 'new', '(', 'Aerospike', '::', 'ResultCode', '::', 'SERVER_ERROR', ',', 'response', ')', 'end', 'end']
->Original Target:
['RemoveUDF', 'removes', 'a', 'package', 'containing', 'user', 'defined', 'functions', 'in', 'the', 'server', '.', 'This', 'asynchronous', 'server', 'call', 'will', 'return', 'before', 'command', 'is', 'complete', '.', 'The', 'user', 'can', 'optionally', 'wait', 'for', 'command', 'completion', 'by', 'using', 'the', 'returned', 'RemoveTask', 'instance', '.']
->Reconstructed Target:
RemoveUDF removes a package containing user defined functions in the server. This asynchronous server call will return before command is complete. The user can optionally wait for command completion by using the returned RemoveTask instance.
->Reconstructed Predication:
the udf to be removed
->Raw Input:
summarize:def remove_udf ( udf_name, options = nil ) policy = create_policy ( options, Policy, default_info_policy ) str_cmd = "udf-remove:filename=#{udf_name};" response_map = @cluster. request_info ( policy, str_cmd ) _, response = response_map. first if response == 'ok' UdfRemoveTask. new ( @cluster, udf_name ) else raise Aerospike :: Exceptions :: Aerospike. new ( Aerospike :: ResultCode :: SERVER_ERROR, response ) end end
->Raw Target:
RemoveUDF removes a package containing user defined functions in the server. This asynchronous server call will return before command is complete. The user can optionally wait for command completion by using the returned RemoveTask instance.
--

386=========
->Original Input:
['def', 'list_udf', '(', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'Policy', ',', 'default_info_policy', ')', 'str_cmd', '=', "'udf-list'", 'response_map', '=', '@cluster', '.', 'request_info', '(', 'policy', ',', 'str_cmd', ')', '_', ',', 'response', '=', 'response_map', '.', 'first', 'vals', '=', 'response', '.', 'split', '(', "';'", ')', 'vals', '.', 'map', 'do', '|', 'udf_info', '|', 'next', 'if', 'udf_info', '.', 'strip!', '==', "''", 'udf_parts', '=', 'udf_info', '.', 'split', '(', "','", ')', 'udf', '=', 'UDF', '.', 'new', 'udf_parts', '.', 'each', 'do', '|', 'values', '|', 'k', ',', 'v', '=', 'values', '.', 'split', '(', "'='", ',', '2', ')', 'case', 'k', 'when', "'filename'", 'udf', '.', 'filename', '=', 'v', 'when', "'hash'", 'udf', '.', 'hash', '=', 'v', 'when', "'type'", 'udf', '.', 'language', '=', 'v', 'end', 'end', 'udf', 'end', 'end']
->Original Target:
['ListUDF', 'lists', 'all', 'packages', 'containing', 'user', 'defined', 'functions', 'in', 'the', 'server', '.', 'This', 'method', 'is', 'only', 'supported', 'by', 'Aerospike', '3', 'servers', '.']
->Reconstructed Target:
ListUDF lists all packages containing user defined functions in the server. This method is only supported by Aerospike 3 servers.
->Reconstructed Predication:
the list of all thethe list of all thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of thethe list of the
->Raw Input:
summarize:def list_udf ( options = nil ) policy = create_policy ( options, Policy, default_info_policy ) str_cmd = 'udf-list' response_map = @cluster. request_info ( policy, str_cmd ) _, response = response_map. first vals = response. split ( ';' ) vals. map do | udf_info | next if udf_info. strip! == '' udf_parts = udf_info. split ( ',' ) udf = UDF. new udf_parts. each do | values | k, v = values. split ( '=', 2 ) case k when 'filename' udf. filename = v when 'hash' udf. hash = v when 'type' udf. language = v end end udf end end
->Raw Target:
ListUDF lists all packages containing user defined functions in the server. This method is only supported by Aerospike 3 servers.
--

387=========
->Original Input:
['def', 'execute_udf_on_query', '(', 'statement', ',', 'package_name', ',', 'function_name', ',', 'function_args', '=', '[', ']', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'QueryPolicy', ',', 'default_query_policy', ')', 'nodes', '=', '@cluster', '.', 'nodes', 'if', 'nodes', '.', 'empty?', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'Aerospike', '.', 'new', '(', 'Aerospike', '::', 'ResultCode', '::', 'SERVER_NOT_AVAILABLE', ',', '"Executing UDF failed because cluster is empty."', ')', 'end', 'statement', '.', 'set_aggregate_function', '(', 'package_name', ',', 'function_name', ',', 'function_args', ',', 'false', ')', 'nodes', '.', 'each', 'do', '|', 'node', '|', 'Thread', '.', 'new', 'do', 'Thread', '.', 'current', '.', 'abort_on_exception', '=', 'true', 'begin', 'command', '=', 'QueryCommand', '.', 'new', '(', 'node', ',', 'policy', ',', 'statement', ',', 'nil', ')', 'execute_command', '(', 'command', ')', 'rescue', '=>', 'e', 'Aerospike', '.', 'logger', '.', 'error', '(', 'e', ')', 'raise', 'e', 'end', 'end', 'end', 'ExecuteTask', '.', 'new', '(', '@cluster', ',', 'statement', ')', 'end']
->Original Target:
['execute_udf_on_query', 'applies', 'user', 'defined', 'function', 'on', 'records', 'that', 'match', 'the', 'statement', 'filter', '.', 'Records', 'are', 'not', 'returned', 'to', 'the', 'client', '.', 'This', 'asynchronous', 'server', 'call', 'will', 'return', 'before', 'command', 'is', 'complete', '.', 'The', 'user', 'can', 'optionally', 'wait', 'for', 'command', 'completion', 'by', 'using', 'the', 'returned', 'ExecuteTask', 'instance', '.']
->Reconstructed Target:
execute_udf_on_query applies user defined function on records that match the statement filter. Records are not returned to the client. This asynchronous server call will return before command is complete. The user can optionally wait for command completion by using the returned ExecuteTask instance.
->Reconstructed Predication:
the UDF on the specifiedthe specifiedthe specified functionthe specified functionthe specified functionthe specified function. The functionthe specified function is executedthe specified function is executedthe specified function is executedthe specified function. The function is
->Raw Input:
summarize:def execute_udf_on_query ( statement, package_name, function_name, function_args = [ ], options = nil ) policy = create_policy ( options, QueryPolicy, default_query_policy ) nodes = @cluster. nodes if nodes. empty? raise Aerospike :: Exceptions :: Aerospike. new ( Aerospike :: ResultCode :: SERVER_NOT_AVAILABLE, "Executing UDF failed because cluster is empty." ) end statement. set_aggregate_function ( package_name, function_name, function_args, false ) nodes. each do | node | Thread. new do Thread. current. abort_on_exception = true begin command = QueryCommand. new ( node, policy, statement, nil ) execute_command ( command ) rescue => e Aerospike. logger. error ( e ) raise e end end end ExecuteTask. new ( @cluster, statement ) end
->Raw Target:
execute_udf_on_query applies user defined function on records that match the statement filter. Records are not returned to the client. This asynchronous server call will return before command is complete. The user can optionally wait for command completion by using the returned ExecuteTask instance.
--

388=========
->Original Input:
['def', 'create_index', '(', 'namespace', ',', 'set_name', ',', 'index_name', ',', 'bin_name', ',', 'index_type', ',', 'collection_type', '=', 'nil', ',', 'options', '=', 'nil', ')', 'if', 'options', '.', 'nil?', '&&', 'collection_type', '.', 'is_a?', '(', 'Hash', ')', 'options', ',', 'collection_type', '=', 'collection_type', ',', 'nil', 'end', 'policy', '=', 'create_policy', '(', 'options', ',', 'Policy', ',', 'default_info_policy', ')', 'str_cmd', '=', '"sindex-create:ns=#{namespace}"', 'str_cmd', '<<', '";set=#{set_name}"', 'unless', 'set_name', '.', 'to_s', '.', 'strip', '.', 'empty?', 'str_cmd', '<<', '";indexname=#{index_name};numbins=1"', 'str_cmd', '<<', '";indextype=#{collection_type.to_s.upcase}"', 'if', 'collection_type', 'str_cmd', '<<', '";indexdata=#{bin_name},#{index_type.to_s.upcase}"', 'str_cmd', '<<', '";priority=normal"', 'response', '=', 'send_info_command', '(', 'policy', ',', 'str_cmd', ')', '.', 'upcase', 'if', 'response', '==', "'OK'", 'return', 'IndexTask', '.', 'new', '(', '@cluster', ',', 'namespace', ',', 'index_name', ')', 'end', 'if', 'response', '.', 'start_with?', '(', "'FAIL:200'", ')', 'return', 'IndexTask', '.', 'new', '(', '@cluster', ',', 'namespace', ',', 'index_name', ',', 'true', ')', 'end', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'Aerospike', '.', 'new', '(', 'Aerospike', '::', 'ResultCode', '::', 'INDEX_GENERIC', ',', '"Create index failed: #{response}"', ')', 'end']
->Original Target:
['Create', 'secondary', 'index', '.', 'This', 'asynchronous', 'server', 'call', 'will', 'return', 'before', 'command', 'is', 'complete', '.', 'The', 'user', 'can', 'optionally', 'wait', 'for', 'command', 'completion', 'by', 'using', 'the', 'returned', 'IndexTask', 'instance', '.']
->Reconstructed Target:
Create secondary index. This asynchronous server call will return before command is complete. The user can optionally wait for command completion by using the returned IndexTask instance.
->Reconstructed Predication:
indexindex_name, bin_name )index_name, bin_name )
->Raw Input:
summarize:def create_index ( namespace, set_name, index_name, bin_name, index_type, collection_type = nil, options = nil ) if options. nil? && collection_type. is_a? ( Hash ) options, collection_type = collection_type, nil end policy = create_policy ( options, Policy, default_info_policy ) str_cmd = "sindex-create:ns=#{namespace}" str_cmd << ";set=#{set_name}" unless set_name. to_s. strip. empty? str_cmd << ";indexname=#{index_name};numbins=1" str_cmd << ";indextype=#{collection_type.to_s.upcase}" if collection_type str_cmd << ";indexdata=#{bin_name},#{index_type.to_s.upcase}" str_cmd << ";priority=normal" response = send_info_command ( policy, str_cmd ). upcase if response == 'OK' return IndexTask. new ( @cluster, namespace, index_name ) end if response. start_with? ( 'FAIL:200' ) return IndexTask. new ( @cluster, namespace, index_name, true ) end raise Aerospike :: Exceptions :: Aerospike. new ( Aerospike :: ResultCode :: INDEX_GENERIC, "Create index failed: #{response}" ) end
->Raw Target:
Create secondary index. This asynchronous server call will return before command is complete. The user can optionally wait for command completion by using the returned IndexTask instance.
--

389=========
->Original Input:
['def', 'drop_index', '(', 'namespace', ',', 'set_name', ',', 'index_name', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'Policy', ',', 'default_info_policy', ')', 'str_cmd', '=', '"sindex-delete:ns=#{namespace}"', 'str_cmd', '<<', '";set=#{set_name}"', 'unless', 'set_name', '.', 'to_s', '.', 'strip', '.', 'empty?', 'str_cmd', '<<', '";indexname=#{index_name}"', 'response', '=', 'send_info_command', '(', 'policy', ',', 'str_cmd', ')', '.', 'upcase', 'return', 'if', 'response', '==', "'OK'", 'return', 'if', 'response', '.', 'start_with?', '(', "'FAIL:201'", ')', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'Aerospike', '.', 'new', '(', 'Aerospike', '::', 'ResultCode', '::', 'INDEX_GENERIC', ',', '"Drop index failed: #{response}"', ')', 'end']
->Original Target:
['Delete', 'secondary', 'index', '.', 'This', 'method', 'is', 'only', 'supported', 'by', 'Aerospike', '3', 'servers', '.']
->Reconstructed Target:
Delete secondary index. This method is only supported by Aerospike 3 servers.
->Reconstructed Predication:
the index to be deleted.
->Raw Input:
summarize:def drop_index ( namespace, set_name, index_name, options = nil ) policy = create_policy ( options, Policy, default_info_policy ) str_cmd = "sindex-delete:ns=#{namespace}" str_cmd << ";set=#{set_name}" unless set_name. to_s. strip. empty? str_cmd << ";indexname=#{index_name}" response = send_info_command ( policy, str_cmd ). upcase return if response == 'OK' return if response. start_with? ( 'FAIL:201' ) raise Aerospike :: Exceptions :: Aerospike. new ( Aerospike :: ResultCode :: INDEX_GENERIC, "Drop index failed: #{response}" ) end
->Raw Target:
Delete secondary index. This method is only supported by Aerospike 3 servers.
--

390=========
->Original Input:
['def', 'scan_node', '(', 'node', ',', 'namespace', ',', 'set_name', ',', 'bin_names', '=', 'nil', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'ScanPolicy', ',', 'default_scan_policy', ')', 'new_policy', '=', 'policy', '.', 'clone', 'new_policy', '.', 'max_retries', '=', '0', 'node', '=', '@cluster', '.', 'get_node_by_name', '(', 'node', ')', 'unless', 'node', '.', 'is_a?', '(', 'Aerospike', '::', 'Node', ')', 'recordset', '=', 'Recordset', '.', 'new', '(', 'policy', '.', 'record_queue_size', ',', '1', ',', ':scan', ')', 'Thread', '.', 'new', 'do', 'Thread', '.', 'current', '.', 'abort_on_exception', '=', 'true', 'command', '=', 'ScanCommand', '.', 'new', '(', 'node', ',', 'new_policy', ',', 'namespace', ',', 'set_name', ',', 'bin_names', ',', 'recordset', ')', 'begin', 'execute_command', '(', 'command', ')', 'rescue', '=>', 'e', 'Aerospike', '.', 'logger', '.', 'error', '(', 'e', '.', 'backtrace', '.', 'join', '(', '"\\n"', ')', ')', 'unless', 'e', '==', 'SCAN_TERMINATED_EXCEPTION', 'recordset', '.', 'cancel', '(', 'e', ')', 'ensure', 'recordset', '.', 'thread_finished', 'end', 'end', 'recordset', 'end']
->Original Target:
['ScanNode', 'reads', 'all', 'records', 'in', 'specified', 'namespace', 'and', 'set', 'from', 'one', 'node', 'only', '.', 'The', 'policy', 'can', 'be', 'used', 'to', 'specify', 'timeouts', '.']
->Reconstructed Target:
ScanNode reads all records in specified namespace and set from one node only. The policy can be used to specify timeouts.
->Reconstructed Predication:
nodenode, namespace, set_name, bin_names ))
->Raw Input:
summarize:def scan_node ( node, namespace, set_name, bin_names = nil, options = nil ) policy = create_policy ( options, ScanPolicy, default_scan_policy ) new_policy = policy. clone new_policy. max_retries = 0 node = @cluster. get_node_by_name ( node ) unless node. is_a? ( Aerospike :: Node ) recordset = Recordset. new ( policy. record_queue_size, 1, :scan ) Thread. new do Thread. current. abort_on_exception = true command = ScanCommand. new ( node, new_policy, namespace, set_name, bin_names, recordset ) begin execute_command ( command ) rescue => e Aerospike. logger. error ( e. backtrace. join ( "\n" ) ) unless e == SCAN_TERMINATED_EXCEPTION recordset. cancel ( e ) ensure recordset. thread_finished end end recordset end
->Raw Target:
ScanNode reads all records in specified namespace and set from one node only. The policy can be used to specify timeouts.
--

391=========
->Original Input:
['def', 'drop_user', '(', 'user', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'AdminPolicy', ',', 'default_admin_policy', ')', 'command', '=', 'AdminCommand', '.', 'new', 'command', '.', 'drop_user', '(', '@cluster', ',', 'policy', ',', 'user', ')', 'end']
->Original Target:
['Remove', 'user', 'from', 'cluster', '.']
->Reconstructed Target:
Remove user from cluster.
->Reconstructed Predication:
the user to be deleted
->Raw Input:
summarize:def drop_user ( user, options = nil ) policy = create_policy ( options, AdminPolicy, default_admin_policy ) command = AdminCommand. new command. drop_user ( @cluster, policy, user ) end
->Raw Target:
Remove user from cluster.
--

392=========
->Original Input:
['def', 'change_password', '(', 'user', ',', 'password', ',', 'options', '=', 'nil', ')', 'raise', 'Aerospike', '::', 'Exceptions', '::', 'Aerospike', '.', 'new', '(', 'INVALID_USER', ')', 'unless', '@cluster', '.', 'user', '&&', '@cluster', '.', 'user', '!=', '""', 'policy', '=', 'create_policy', '(', 'options', ',', 'AdminPolicy', ',', 'default_admin_policy', ')', 'hash', '=', 'AdminCommand', '.', 'hash_password', '(', 'password', ')', 'command', '=', 'AdminCommand', '.', 'new', 'if', 'user', '==', '@cluster', '.', 'user', 'command', '.', 'change_password', '(', '@cluster', ',', 'policy', ',', 'user', ',', 'hash', ')', 'else', 'command', '.', 'set_password', '(', '@cluster', ',', 'policy', ',', 'user', ',', 'hash', ')', 'end', '@cluster', '.', 'change_password', '(', 'user', ',', 'hash', ')', 'end']
->Original Target:
['Change', 'user', 's', 'password', '.', 'Clear', '-', 'text', 'password', 'will', 'be', 'hashed', 'using', 'bcrypt', 'before', 'sending', 'to', 'server', '.']
->Reconstructed Target:
Change user s password. Clear - text password will be hashed using bcrypt before sending to server.
->Reconstructed Predication:
the password to change thethe password to change the
->Raw Input:
summarize:def change_password ( user, password, options = nil ) raise Aerospike :: Exceptions :: Aerospike. new ( INVALID_USER ) unless @cluster. user && @cluster. user!= "" policy = create_policy ( options, AdminPolicy, default_admin_policy ) hash = AdminCommand. hash_password ( password ) command = AdminCommand. new if user == @cluster. user command. change_password ( @cluster, policy, user, hash ) else command. set_password ( @cluster, policy, user, hash ) end @cluster. change_password ( user, hash ) end
->Raw Target:
Change user s password. Clear - text password will be hashed using bcrypt before sending to server.
--

393=========
->Original Input:
['def', 'grant_roles', '(', 'user', ',', 'roles', ',', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'AdminPolicy', ',', 'default_admin_policy', ')', 'command', '=', 'AdminCommand', '.', 'new', 'command', '.', 'grant_roles', '(', '@cluster', ',', 'policy', ',', 'user', ',', 'roles', ')', 'end']
->Original Target:
['Add', 'roles', 'to', 'user', 's', 'list', 'of', 'roles', '.']
->Reconstructed Target:
Add roles to user s list of roles.
->Reconstructed Predication:
the user to grant roles
->Raw Input:
summarize:def grant_roles ( user, roles, options = nil ) policy = create_policy ( options, AdminPolicy, default_admin_policy ) command = AdminCommand. new command. grant_roles ( @cluster, policy, user, roles ) end
->Raw Target:
Add roles to user s list of roles.
--

394=========
->Original Input:
['def', 'query_users', '(', 'options', '=', 'nil', ')', 'policy', '=', 'create_policy', '(', 'options', ',', 'AdminPolicy', ',', 'default_admin_policy', ')', 'command', '=', 'AdminCommand', '.', 'new', 'command', '.', 'query_users', '(', '@cluster', ',', 'policy', ')', 'end']
->Original Target:
['Retrieve', 'all', 'users', 'and', 'their', 'roles', '.']
->Reconstructed Target:
Retrieve all users and their roles.
->Reconstructed Predication:
the users to query. 
->Raw Input:
summarize:def query_users ( options = nil ) policy = create_policy ( options, AdminPolicy, default_admin_policy ) command = AdminCommand. new command. query_users ( @cluster, policy ) end
->Raw Target:
Retrieve all users and their roles.
--

395=========
->Original Input:
['def', 'next_record', 'raise', '@thread_exception', '.', 'get', 'unless', '@thread_exception', '.', 'get', '.', 'nil?', 'r', '=', '@records', '.', 'deq', 'set_exception', 'if', 'r', '.', 'nil?', 'r', 'end']
->Original Target:
['fetches', 'and', 'return', 'the', 'first', 'record', 'from', 'the', 'queue', 'if', 'the', 'operation', 'is', 'not', 'finished', 'and', 'the', 'queue', 'is', 'empty', 'it', 'blocks', 'and', 'waits', 'for', 'new', 'records', 'it', 'sets', 'the', 'exception', 'if', 'it', 'reaches', 'the', 'EOF', 'mark', 'and', 'returns', 'nil', 'EOF', 'means', 'the', 'operation', 'has', 'finished', 'and', 'no', 'more', 'records', 'are', 'comming', 'from', 'server', 'nodes', 'it', 're', '-', 'raises', 'the', 'exception', 'occurred', 'in', 'threads', 'or', 'which', 'was', 'set', 'after', 'reaching', 'the', 'EOF', 'in', 'the', 'previous', 'call']
->Reconstructed Target:
fetches and return the first record from the queue if the operation is not finished and the queue is empty it blocks and waits for new records it sets the exception if it reaches the EOF mark and returns nil EOF means the operation has finished and no more records are comming from server nodes it re - raises the exception occurred in threads or which was set after reaching the EOF in the previous call
->Reconstructed Predication:
return nil if @records. empty?
->Raw Input:
summarize:def next_record raise @thread_exception. get unless @thread_exception. get. nil? r = @records. deq set_exception if r. nil? r end
->Raw Target:
fetches and return the first record from the queue if the operation is not finished and the queue is empty it blocks and waits for new records it sets the exception if it reaches the EOF mark and returns nil EOF means the operation has finished and no more records are comming from server nodes it re - raises the exception occurred in threads or which was set after reaching the EOF in the previous call
--

396=========
->Original Input:
['def', 'each', '(', '&', 'block', ')', 'r', '=', 'true', 'while', 'r', 'r', '=', 'next_record', 'unless', 'r', '.', 'nil?', 'block', '.', 'call', '(', 'r', ')', 'else', 'break', 'end', 'end', 'end']
->Original Target:
['fetches', 'and', 'returns', 'all', 'the', 'records', 'from', 'the', 'queue', 'until', 'the', 'whole', 'operation', 'is', 'finished', 'and', 'it', 'reaches', 'an', 'EOF', 'mark', 'calling', 'cancel', 'inside', 'the', 'each', 'block', 'raises', 'an', 'exception', 'to', 'signal', 'other', 'consumer', 'threads']
->Reconstructed Target:
fetches and returns all the records from the queue until the whole operation is finished and it reaches an EOF mark calling cancel inside the each block raises an exception to signal other consumer threads
->Reconstructed Predication:
the record to be summarizeed.
->Raw Input:
summarize:def each ( & block ) r = true while r r = next_record unless r. nil? block. call ( r ) else break end end end
->Raw Target:
fetches and returns all the records from the queue until the whole operation is finished and it reaches an EOF mark calling cancel inside the each block raises an exception to signal other consumer threads
--

397=========
->Original Input:
['def', 'intercom_script_tag', '(', 'user_details', '=', 'nil', ',', 'options', '=', '{', '}', ')', 'controller', '.', 'instance_variable_set', '(', 'IntercomRails', '::', 'SCRIPT_TAG_HELPER_CALLED_INSTANCE_VARIABLE', ',', 'true', ')', 'if', 'defined?', '(', 'controller', ')', 'options', '[', ':user_details', ']', '=', 'user_details', 'if', 'user_details', '.', 'present?', 'options', '[', ':find_current_user_details', ']', '=', '!', 'options', '[', ':user_details', ']', 'options', '[', ':find_current_company_details', ']', '=', '!', '(', 'options', '[', ':user_details', ']', '&&', 'options', '[', ':user_details', ']', '[', ':company', ']', ')', 'options', '[', ':controller', ']', '=', 'controller', 'if', 'defined?', '(', 'controller', ')', 'ScriptTag', '.', 'new', '(', 'options', ')', 'end']
->Original Target:
['Generate', 'an', 'intercom', 'script', 'tag', '.']
->Reconstructed Target:
Generate an intercom script tag.
->Reconstructed Predication:
the script tag to render
->Raw Input:
summarize:def intercom_script_tag ( user_details = nil, options = { } ) controller. instance_variable_set ( IntercomRails :: SCRIPT_TAG_HELPER_CALLED_INSTANCE_VARIABLE, true ) if defined? ( controller ) options [ :user_details ] = user_details if user_details. present? options [ :find_current_user_details ] =! options [ :user_details ] options [ :find_current_company_details ] =! ( options [ :user_details ] && options [ :user_details ] [ :company ] ) options [ :controller ] = controller if defined? ( controller ) ScriptTag. new ( options ) end
->Raw Target:
Generate an intercom script tag.
--

398=========
->Original Input:
['def', 'move_free', '(', 'aim', ',', 'speed', ')', 'if', 'aim', '.', 'is_a?', 'Vector', 'x_d', '=', 'aim', '.', 'x', '-', '@x', ';', 'y_d', '=', 'aim', '.', 'y', '-', '@y', 'distance', '=', 'Math', '.', 'sqrt', '(', 'x_d', '**', '2', '+', 'y_d', '**', '2', ')', 'if', 'distance', '==', '0', '@speed', '.', 'x', '=', '@speed', '.', 'y', '=', '0', 'return', 'end', '@speed', '.', 'x', '=', '1.0', '*', 'x_d', '*', 'speed', '/', 'distance', '@speed', '.', 'y', '=', '1.0', '*', 'y_d', '*', 'speed', '/', 'distance', 'if', '(', '@speed', '.', 'x', '<', '0', 'and', '@x', '+', '@speed', '.', 'x', '<=', 'aim', '.', 'x', ')', 'or', '(', '@speed', '.', 'x', '>=', '0', 'and', '@x', '+', '@speed', '.', 'x', '>=', 'aim', '.', 'x', ')', '@x', '=', 'aim', '.', 'x', '@speed', '.', 'x', '=', '0', 'else', '@x', '+=', '@speed', '.', 'x', 'end', 'if', '(', '@speed', '.', 'y', '<', '0', 'and', '@y', '+', '@speed', '.', 'y', '<=', 'aim', '.', 'y', ')', 'or', '(', '@speed', '.', 'y', '>=', '0', 'and', '@y', '+', '@speed', '.', 'y', '>=', 'aim', '.', 'y', ')', '@y', '=', 'aim', '.', 'y', '@speed', '.', 'y', '=', '0', 'else', '@y', '+=', '@speed', '.', 'y', 'end', 'else', 'rads', '=', 'aim', '*', 'Math', '::', 'PI', '/', '180', '@speed', '.', 'x', '=', 'speed', '*', 'Math', '.', 'cos', '(', 'rads', ')', '@speed', '.', 'y', '=', 'speed', '*', 'Math', '.', 'sin', '(', 'rads', ')', '@x', '+=', '@speed', '.', 'x', '@y', '+=', '@speed', '.', 'y', 'end', 'end']
->Original Target:
['Moves', 'this', 'object', 'without', 'performing', 'any', 'collision', 'checking', 'towards', 'a', 'specified', 'point', 'or', 'in', 'a', 'specified', 'direction', '.']
->Reconstructed Target:
Moves this object without performing any collision checking towards a specified point or in a specified direction.
->Reconstructed Predication:
speed = speed * speed@speed. y = speed@speed. x = speed@speed. y = speed@speed. y = speed@speed. x = speed@speed. y = speed@speed. x = speed@speed. y = speed@speed. y = speed@speed. x = speed@speed. y = speed@speed. y = speed@speed. y = speed
->Raw Input:
summarize:def move_free ( aim, speed ) if aim. is_a? Vector x_d = aim. x - @x ; y_d = aim. y - @y distance = Math. sqrt ( x_d ** 2 + y_d ** 2 ) if distance == 0 @speed. x = @speed. y = 0 return end @speed. x = 1.0 * x_d * speed / distance @speed. y = 1.0 * y_d * speed / distance if ( @speed. x < 0 and @x + @speed. x <= aim. x ) or ( @speed. x >= 0 and @x + @speed. x >= aim. x ) @x = aim. x @speed. x = 0 else @x += @speed. x end if ( @speed. y < 0 and @y + @speed. y <= aim. y ) or ( @speed. y >= 0 and @y + @speed. y >= aim. y ) @y = aim. y @speed. y = 0 else @y += @speed. y end else rads = aim * Math :: PI / 180 @speed. x = speed * Math. cos ( rads ) @speed. y = speed * Math. sin ( rads ) @x += @speed. x @y += @speed. y end end
->Raw Target:
Moves this object without performing any collision checking towards a specified point or in a specified direction.
--

399=========
->Original Input:
['def', 'get_absolute_size', 'return', 'Vector', '.', 'new', '(', '@tile_size', '.', 'x', '*', '@size', '.', 'x', ',', '@tile_size', '.', 'y', '*', '@size', '.', 'y', ')', 'unless', '@isometric', 'avg', '=', '(', '@size', '.', 'x', '+', '@size', '.', 'y', ')', '*', '0.5', 'Vector', '.', 'new', '(', 'avg', '*', '@tile_size', '.', 'x', ')', '.', 'to_i', ',', '(', 'avg', '*', '@tile_size', '.', 'y', ')', '.', 'to_i', 'end']
->Original Target:
['Creates', 'a', 'new', 'map', '.']
->Reconstructed Target:
Creates a new map.
->Reconstructed Predication:
the tile size of the tile
->Raw Input:
summarize:def get_absolute_size return Vector. new ( @tile_size. x * @size. x, @tile_size. y * @size. y ) unless @isometric avg = ( @size. x + @size. y ) * 0.5 Vector. new ( avg * @tile_size. x ). to_i, ( avg * @tile_size. y ). to_i end
->Raw Target:
Creates a new map.
--

400=========
->Original Input:
['def', 'get_screen_pos', '(', 'map_x', ',', 'map_y', ')', 'return', 'Vector', '.', 'new', '(', 'map_x', '*', '@tile_size', '.', 'x', '-', '@cam', '.', 'x', ',', 'map_y', '*', '@tile_size', '.', 'y', '-', '@cam', '.', 'y', ')', 'unless', '@isometric', 'Vector', '.', 'new', '(', '(', 'map_x', '-', 'map_y', '-', '1', ')', '*', '@tile_size', '.', 'x', '*', '0.5', ')', '-', '@cam', '.', 'x', '+', '@x_offset', ',', '(', '(', 'map_x', '+', 'map_y', ')', '*', '@tile_size', '.', 'y', '*', '0.5', ')', '-', '@cam', '.', 'y', 'end']
->Original Target:
['Returns', 'the', 'position', 'in', 'the', 'screen', 'corresponding', 'to', 'the', 'given', 'tile', 'indices', '.']
->Reconstructed Target:
Returns the position in the screen corresponding to the given tile indices.
->Reconstructed Predication:
map_x + map_y )
->Raw Input:
summarize:def get_screen_pos ( map_x, map_y ) return Vector. new ( map_x * @tile_size. x - @cam. x, map_y * @tile_size. y - @cam. y ) unless @isometric Vector. new ( ( map_x - map_y - 1 ) * @tile_size. x * 0.5 ) - @cam. x + @x_offset, ( ( map_x + map_y ) * @tile_size. y * 0.5 ) - @cam. y end
->Raw Target:
Returns the position in the screen corresponding to the given tile indices.
--

401=========
->Original Input:
['def', 'get_map_pos', '(', 'scr_x', ',', 'scr_y', ')', 'return', 'Vector', '.', 'new', '(', '(', 'scr_x', '+', '@cam', '.', 'x', ')', '/', '@tile_size', '.', 'x', ',', '(', 'scr_y', '+', '@cam', '.', 'y', ')', '/', '@tile_size', '.', 'y', ')', 'unless', '@isometric', 'v', '=', 'get_isometric_position', 'scr_x', ',', 'scr_y', 'Vector', '.', 'new', '(', '(', 'v', '.', 'x', '*', '@inverse_square_size', ')', '.', 'to_i', ',', '(', 'v', '.', 'y', '*', '@inverse_square_size', ')', '.', 'to_i', ')', 'end']
->Original Target:
['Returns', 'the', 'tile', 'in', 'the', 'map', 'that', 'corresponds', 'to', 'the', 'given', 'position', 'in', 'the', 'screen', 'as', 'a', 'Vector', 'where', 'x', 'is', 'the', 'horizontal', 'index', 'and', 'y', 'the', 'vertical', 'index', '.']
->Reconstructed Target:
Returns the tile in the map that corresponds to the given position in the screen as a Vector where x is the horizontal index and y the vertical index.
->Reconstructed Predication:
the map position of the
->Raw Input:
summarize:def get_map_pos ( scr_x, scr_y ) return Vector. new ( ( scr_x + @cam. x ) / @tile_size. x, ( scr_y + @cam. y ) / @tile_size. y ) unless @isometric v = get_isometric_position scr_x, scr_y Vector. new ( ( v. x * @inverse_square_size ). to_i, ( v. y * @inverse_square_size ). to_i ) end
->Raw Target:
Returns the tile in the map that corresponds to the given position in the screen as a Vector where x is the horizontal index and y the vertical index.
--

402=========
->Original Input:
['def', 'is_in_map', '(', 'v', ')', 'v', '.', 'x', '>=', '0', '&&', 'v', '.', 'y', '>=', '0', '&&', 'v', '.', 'x', '<', '@size', '.', 'x', '&&', 'v', '.', 'y', '<', '@size', '.', 'y', 'end']
->Original Target:
['Verifies', 'whether', 'a', 'tile', 'is', 'inside', 'the', 'map', '.']
->Reconstructed Target:
Verifies whether a tile is inside the map.
->Reconstructed Predication:
x y in map
->Raw Input:
summarize:def is_in_map ( v ) v. x >= 0 && v. y >= 0 && v. x < @size. x && v. y < @size. y end
->Raw Target:
Verifies whether a tile is inside the map.
--

403=========
->Original Input:
['def', 'animate_once', '(', 'indices', ',', 'interval', ')', 'if', '@animate_once_control', '==', '2', 'return', 'if', 'indices', '==', '@animate_once_indices', '&&', 'interval', '==', '@animate_once_interval', '@animate_once_control', '=', '0', 'end', 'unless', '@animate_once_control', '==', '1', '@anim_counter', '=', '0', '@img_index', '=', 'indices', '[', '0', ']', '@index_index', '=', '0', '@animate_once_indices', '=', 'indices', '@animate_once_interval', '=', 'interval', '@animate_once_control', '=', '1', 'return', 'end', '@anim_counter', '+=', '1', 'return', 'unless', '@anim_counter', '>=', 'interval', '@index_index', '+=', '1', '@img_index', '=', 'indices', '[', '@index_index', ']', '@anim_counter', '=', '0', '@animate_once_control', '=', '2', 'if', '@index_index', '==', 'indices', '.', 'length', '-', '1', 'end']
->Original Target:
['Causes', 'the', 'sprite', 'to', 'animate', 'through', 'the', '+', 'indices', '+', 'array', 'exactly', 'once', 'so', 'that', 'the', 'animation', 'stops', 'once', 'it', 'reaches', 'the', 'last', 'index', 'in', 'the', 'array', '.', 'Subsequent', 'calls', 'with', 'the', 'same', 'parameters', 'will', 'have', 'no', 'effect', 'but', 'if', 'the', 'index', 'or', 'interval', 'changes', 'or', 'if', '+', 'set_animation', '+', 'is', 'called', 'then', 'a', 'new', 'animation', 'cycle', 'will', 'begin', '.']
->Reconstructed Target:
Causes the sprite to animate through the + indices + array exactly once so that the animation stops once it reaches the last index in the array. Subsequent calls with the same parameters will have no effect but if the index or interval changes or if + set_animation + is called then a new animation cycle will begin.
->Reconstructed Predication:
animating the image
->Raw Input:
summarize:def animate_once ( indices, interval ) if @animate_once_control == 2 return if indices == @animate_once_indices && interval == @animate_once_interval @animate_once_control = 0 end unless @animate_once_control == 1 @anim_counter = 0 @img_index = indices [ 0 ] @index_index = 0 @animate_once_indices = indices @animate_once_interval = interval @animate_once_control = 1 return end @anim_counter += 1 return unless @anim_counter >= interval @index_index += 1 @img_index = indices [ @index_index ] @anim_counter = 0 @animate_once_control = 2 if @index_index == indices. length - 1 end
->Raw Target:
Causes the sprite to animate through the + indices + array exactly once so that the animation stops once it reaches the last index in the array. Subsequent calls with the same parameters will have no effect but if the index or interval changes or if + set_animation + is called then a new animation cycle will begin.
--

404=========
->Original Input:
['def', 'draw', '(', 'map', '=', 'nil', ',', 'scale_x', '=', '1', ',', 'scale_y', '=', '1', ',', 'alpha', '=', '0xff', ',', 'color', '=', '0xffffff', ',', 'angle', '=', 'nil', ',', 'flip', '=', 'nil', ',', 'z_index', '=', '0', ',', 'round', '=', 'false', ')', 'if', 'map', '.', 'is_a?', 'Hash', 'scale_x', '=', 'map', '.', 'fetch', '(', ':scale_x', ',', '1', ')', 'scale_y', '=', 'map', '.', 'fetch', '(', ':scale_y', ',', '1', ')', 'alpha', '=', 'map', '.', 'fetch', '(', ':alpha', ',', '0xff', ')', 'color', '=', 'map', '.', 'fetch', '(', ':color', ',', '0xffffff', ')', 'angle', '=', 'map', '.', 'fetch', '(', ':angle', ',', 'nil', ')', 'flip', '=', 'map', '.', 'fetch', '(', ':flip', ',', 'nil', ')', 'z_index', '=', 'map', '.', 'fetch', '(', ':z_index', ',', '0', ')', 'round', '=', 'map', '.', 'fetch', '(', ':round', ',', 'false', ')', 'map', '=', 'map', '.', 'fetch', '(', ':map', ',', 'nil', ')', 'end', 'color', '=', '(', 'alpha', '<<', '24', ')', '|', 'color', 'if', 'angle', '@img', '[', '@img_index', ']', '.', 'draw_rot', '@x', '-', '(', 'map', '?', 'map', '.', 'cam', '.', 'x', ':', '0', ')', '+', '@img', '[', '0', ']', '.', 'width', '*', 'scale_x', '*', '0.5', ',', '@y', '-', '(', 'map', '?', 'map', '.', 'cam', '.', 'y', ':', '0', ')', '+', '@img', '[', '0', ']', '.', 'height', '*', 'scale_y', '*', '0.5', ',', 'z_index', ',', 'angle', ',', '0.5', ',', '0.5', ',', '(', 'flip', '==', ':horiz', '?', '-', 'scale_x', ':', 'scale_x', ')', ',', '(', 'flip', '==', ':vert', '?', '-', 'scale_y', ':', 'scale_y', ')', ',', 'color', 'else', 'x', '=', '@x', '-', '(', 'map', '?', 'map', '.', 'cam', '.', 'x', ':', '0', ')', '+', '(', 'flip', '==', ':horiz', '?', 'scale_x', '*', '@img', '[', '0', ']', '.', 'width', ':', '0', ')', 'y', '=', '@y', '-', '(', 'map', '?', 'map', '.', 'cam', '.', 'y', ':', '0', ')', '+', '(', 'flip', '==', ':vert', '?', 'scale_y', '*', '@img', '[', '0', ']', '.', 'height', ':', '0', ')', '@img', '[', '@img_index', ']', '.', 'draw', '(', 'round', '?', 'x', '.', 'round', ':', 'x', ')', ',', '(', 'round', '?', 'y', '.', 'round', ':', 'y', ')', ',', 'z_index', ',', '(', 'flip', '==', ':horiz', '?', '-', 'scale_x', ':', 'scale_x', ')', ',', '(', 'flip', '==', ':vert', '?', '-', 'scale_y', ':', 'scale_y', ')', ',', 'color', 'end', 'end']
->Original Target:
['Draws', 'the', 'sprite', 'in', 'the', 'screen']
->Reconstructed Target:
Draws the sprite in the screen
->Reconstructed Predication:
( map )= nil flip = nilflip = nilflip = nil if flipflip == :vert?: scale_y ), color: scale_x ), (: scale_y ), color( flip == :horiz?: scale_y ), color( flip == :vert?: scale_x ), (: scale_y ), color( flip == :horiz?
->Raw Input:
summarize:def draw ( map = nil, scale_x = 1, scale_y = 1, alpha = 0xff, color = 0xffffff, angle = nil, flip = nil, z_index = 0, round = false ) if map. is_a? Hash scale_x = map. fetch ( :scale_x, 1 ) scale_y = map. fetch ( :scale_y, 1 ) alpha = map. fetch ( :alpha, 0xff ) color = map. fetch ( :color, 0xffffff ) angle = map. fetch ( :angle, nil ) flip = map. fetch ( :flip, nil ) z_index = map. fetch ( :z_index, 0 ) round = map. fetch ( :round, false ) map = map. fetch ( :map, nil ) end color = ( alpha << 24 ) | color if angle @img [ @img_index ]. draw_rot @x - ( map? map. cam. x : 0 ) + @img [ 0 ]. width * scale_x * 0.5, @y - ( map? map. cam. y : 0 ) + @img [ 0 ]. height * scale_y * 0.5, z_index, angle, 0.5, 0.5, ( flip == :horiz? - scale_x : scale_x ), ( flip == :vert? - scale_y : scale_y ), color else x = @x - ( map? map. cam. x : 0 ) + ( flip == :horiz? scale_x * @img [ 0 ]. width : 0 ) y = @y - ( map? map. cam. y : 0 ) + ( flip == :vert? scale_y * @img [ 0 ]. height : 0 ) @img [ @img_index ]. draw ( round? x. round : x ), ( round? y. round : y ), z_index, ( flip == :horiz? - scale_x : scale_x ), ( flip == :vert? - scale_y : scale_y ), color end end
->Raw Target:
Draws the sprite in the screen
--

405=========
->Original Input:
['def', 'update', 'return', 'unless', '@enabled', 'and', '@visible', 'mouse_over', '=', 'Mouse', '.', 'over?', '@x', ',', '@y', ',', '@w', ',', '@h', 'mouse_press', '=', 'Mouse', '.', 'button_pressed?', ':left', 'mouse_rel', '=', 'Mouse', '.', 'button_released?', ':left', 'if', '@state', '==', ':up', 'if', 'mouse_over', '@img_index', '=', '1', '@state', '=', ':over', 'else', '@img_index', '=', '0', 'end', 'elsif', '@state', '==', ':over', 'if', 'not', 'mouse_over', '@img_index', '=', '0', '@state', '=', ':up', 'elsif', 'mouse_press', '@img_index', '=', '2', '@state', '=', ':down', 'else', '@img_index', '=', '1', 'end', 'elsif', '@state', '==', ':down', 'if', 'not', 'mouse_over', '@img_index', '=', '0', '@state', '=', ':down_out', 'elsif', 'mouse_rel', '@img_index', '=', '1', '@state', '=', ':over', 'click', 'else', '@img_index', '=', '2', 'end', 'else', 'if', 'mouse_over', '@img_index', '=', '2', '@state', '=', ':down', 'elsif', 'mouse_rel', '@img_index', '=', '0', '@state', '=', ':up', 'else', '@img_index', '=', '0', 'end', 'end', 'end']
->Original Target:
['Creates', 'a', 'button', '.']
->Reconstructed Target:
Creates a button.
->Reconstructed Predication:
@img_index = 0 @state =@img_index = 0 @img_index =@img_index = 0 @img_index =@img_index = 0 @img_index =@img_index = 0 @img_index =@img_index = 0 @img_index =@img_index = 0 @img_index@img_index =@img_index = 0 @img_index
->Raw Input:
summarize:def update return unless @enabled and @visible mouse_over = Mouse. over? @x, @y, @w, @h mouse_press = Mouse. button_pressed? :left mouse_rel = Mouse. button_released? :left if @state == :up if mouse_over @img_index = 1 @state = :over else @img_index = 0 end elsif @state == :over if not mouse_over @img_index = 0 @state = :up elsif mouse_press @img_index = 2 @state = :down else @img_index = 1 end elsif @state == :down if not mouse_over @img_index = 0 @state = :down_out elsif mouse_rel @img_index = 1 @state = :over click else @img_index = 2 end else if mouse_over @img_index = 2 @state = :down elsif mouse_rel @img_index = 0 @state = :up else @img_index = 0 end end end
->Raw Target:
Creates a button.
--

406=========
->Original Input:
['def', 'draw', '(', 'alpha', '=', '0xff', ',', 'z_index', '=', '0', ',', 'color', '=', '0xffffff', ')', 'return', 'unless', '@visible', 'color', '=', '(', 'alpha', '<<', '24', ')', '|', 'color', 'text_color', '=', 'if', '@enabled', 'if', '@state', '==', ':down', '@down_text_color', 'else', '@state', '==', ':over', '?', '@over_text_color', ':', '@text_color', 'end', 'else', '@disabled_text_color', 'end', 'text_color', '=', '(', 'alpha', '<<', '24', ')', '|', 'text_color', '@img', '[', '@img_index', ']', '.', 'draw', '@x', ',', '@y', ',', 'z_index', ',', '@scale_x', ',', '@scale_y', ',', 'color', 'if', '@img', 'if', '@text', 'if', '@center_x', 'or', '@center_y', 'rel_x', '=', '@center_x', '?', '0.5', ':', '0', 'rel_y', '=', '@center_y', '?', '0.5', ':', '0', '@font', '.', 'draw_text_rel', '@text', ',', '@text_x', ',', '@text_y', ',', 'z_index', ',', 'rel_x', ',', 'rel_y', ',', '@scale_x', ',', '@scale_y', ',', 'text_color', 'else', '@font', '.', 'draw_text', '@text', ',', '@text_x', ',', '@text_y', ',', 'z_index', ',', '@scale_x', ',', '@scale_y', ',', 'text_color', 'end', 'end', 'end']
->Original Target:
['Draws', 'the', 'button', 'in', 'the', 'screen', '.']
->Reconstructed Target:
Draws the button in the screen.
->Reconstructed Predication:
@text_color = color if @text_color@text_color = text_color if @text_color@text_color = text_color if@text_color if @text_color if @text_color@text_color if @text_color if@text_color if @text_color@text_color if @text_color@text_color if @text_color@text_color if
->Raw Input:
summarize:def draw ( alpha = 0xff, z_index = 0, color = 0xffffff ) return unless @visible color = ( alpha << 24 ) | color text_color = if @enabled if @state == :down @down_text_color else @state == :over? @over_text_color : @text_color end else @disabled_text_color end text_color = ( alpha << 24 ) | text_color @img [ @img_index ]. draw @x, @y, z_index, @scale_x, @scale_y, color if @img if @text if @center_x or @center_y rel_x = @center_x? 0.5 : 0 rel_y = @center_y? 0.5 : 0 @font. draw_text_rel @text, @text_x, @text_y, z_index, rel_x, rel_y, @scale_x, @scale_y, text_color else @font. draw_text @text, @text_x, @text_y, z_index, @scale_x, @scale_y, text_color end end end
->Raw Target:
Draws the button in the screen.
--

407=========
->Original Input:
['def', 'text', '=', '(', 'value', ',', 'trigger_changed', '=', 'true', ')', '@text', '=', 'value', '[', '0', '...', '@max_length', ']', '@nodes', '.', 'clear', ';', '@nodes', '<<', '@text_x', 'x', '=', '@nodes', '[', '0', ']', '@text', '.', 'chars', '.', 'each', '{', '|', 'char', '|', 'x', '+=', '@font', '.', 'text_width', '(', 'char', ')', '*', '@scale_x', '@nodes', '<<', 'x', '}', '@cur_node', '=', '@nodes', '.', 'size', '-', '1', '@anchor1', '=', 'nil', '@anchor2', '=', 'nil', 'set_cursor_visible', '@on_text_changed', '.', 'call', '@text', ',', '@params', 'if', 'trigger_changed', '&&', '@on_text_changed', 'end']
->Original Target:
['Sets', 'the', 'text', 'of', 'the', 'text', 'field', 'to', 'the', 'specified', 'value', '.']
->Reconstructed Target:
Sets the text of the text field to the specified value.
->Reconstructed Predication:
@text_x = 0 @text_y =@text_y = 0 @text_y = 0
->Raw Input:
summarize:def text = ( value, trigger_changed = true ) @text = value [ 0... @max_length ] @nodes. clear ; @nodes << @text_x x = @nodes [ 0 ] @text. chars. each { | char | x += @font. text_width ( char ) * @scale_x @nodes << x } @cur_node = @nodes. size - 1 @anchor1 = nil @anchor2 = nil set_cursor_visible @on_text_changed. call @text, @params if trigger_changed && @on_text_changed end
->Raw Target:
Sets the text of the text field to the specified value.
--

408=========
->Original Input:
['def', 'set_position', '(', 'x', ',', 'y', ')', 'd_x', '=', 'x', '-', '@x', 'd_y', '=', 'y', '-', '@y', '@x', '=', 'x', ';', '@y', '=', 'y', '@text_x', '+=', 'd_x', '@text_y', '+=', 'd_y', '@nodes', '.', 'map!', 'do', '|', 'n', '|', 'n', '+', 'd_x', 'end', 'end']
->Original Target:
['Sets', 'the', 'position', 'of', 'the', 'text', 'field', 'in', 'the', 'screen', '.']
->Reconstructed Target:
Sets the position of the text field in the screen.
->Reconstructed Predication:
the position of the node
->Raw Input:
summarize:def set_position ( x, y ) d_x = x - @x d_y = y - @y @x = x ; @y = y @text_x += d_x @text_y += d_y @nodes. map! do | n | n + d_x end end
->Raw Target:
Sets the position of the text field in the screen.
--

409=========
->Original Input:
['def', 'draw', '(', 'alpha', '=', '0xff', ',', 'z_index', '=', '0', ',', 'color', '=', '0xffffff', ',', 'disabled_color', '=', '0x808080', ')', 'return', 'unless', '@visible', 'color', '=', '(', 'alpha', '<<', '24', ')', '|', '(', '(', '@enabled', 'or', '@disabled_img', ')', '?', 'color', ':', 'disabled_color', ')', 'text_color', '=', '(', 'alpha', '<<', '24', ')', '|', '(', '@enabled', '?', '@text_color', ':', '@disabled_text_color', ')', 'img', '=', '(', '(', '@enabled', 'or', '@disabled_img', '.', 'nil?', ')', '?', '@img', ':', '@disabled_img', ')', 'img', '.', 'draw', '@x', ',', '@y', ',', 'z_index', ',', '@scale_x', ',', '@scale_y', ',', 'color', '@font', '.', 'draw_text', '@text', ',', '@text_x', ',', '@text_y', ',', 'z_index', ',', '@scale_x', ',', '@scale_y', ',', 'text_color', 'if', '@anchor1', 'and', '@anchor2', 'selection_color', '=', '(', '(', 'alpha', '/', '2', ')', '<<', '24', ')', '|', '@selection_color', 'G', '.', 'window', '.', 'draw_quad', '@nodes', '[', '@anchor1', ']', ',', '@text_y', ',', 'selection_color', ',', '@nodes', '[', '@anchor2', ']', '+', '1', ',', '@text_y', ',', 'selection_color', ',', '@nodes', '[', '@anchor2', ']', '+', '1', ',', '@text_y', '+', '@font', '.', 'height', '*', '@scale_y', ',', 'selection_color', ',', '@nodes', '[', '@anchor1', ']', ',', '@text_y', '+', '@font', '.', 'height', '*', '@scale_y', ',', 'selection_color', ',', 'z_index', 'end', 'if', '@cursor_visible', 'if', '@cursor_img', '@cursor_img', '.', 'draw', '@nodes', '[', '@cur_node', ']', '-', '(', '@cursor_img', '.', 'width', '*', '@scale_x', ')', '/', '2', ',', '@text_y', ',', 'z_index', ',', '@scale_x', ',', '@scale_y', 'else', 'cursor_color', '=', 'alpha', '<<', '24', 'G', '.', 'window', '.', 'draw_quad', '@nodes', '[', '@cur_node', ']', ',', '@text_y', ',', 'cursor_color', ',', '@nodes', '[', '@cur_node', ']', '+', '1', ',', '@text_y', ',', 'cursor_color', ',', '@nodes', '[', '@cur_node', ']', '+', '1', ',', '@text_y', '+', '@font', '.', 'height', '*', '@scale_y', ',', 'cursor_color', ',', '@nodes', '[', '@cur_node', ']', ',', '@text_y', '+', '@font', '.', 'height', '*', '@scale_y', ',', 'cursor_color', ',', 'z_index', 'end', 'end', 'end']
->Original Target:
['Draws', 'the', 'text', 'field', 'in', 'the', 'screen', '.']
->Reconstructed Target:
Draws the text field in the screen.
->Reconstructed Predication:
@text_y, z_index,@text_color : @disabled_text_color )@text_y, z_index,@text_y, z_index,@text_y, z_index,@text_y, z_index,@text_y, z_index,@text_y, z_index, @text_color@text_y, z_index,
->Raw Input:
summarize:def draw ( alpha = 0xff, z_index = 0, color = 0xffffff, disabled_color = 0x808080 ) return unless @visible color = ( alpha << 24 ) | ( ( @enabled or @disabled_img )? color : disabled_color ) text_color = ( alpha << 24 ) | ( @enabled? @text_color : @disabled_text_color ) img = ( ( @enabled or @disabled_img. nil? )? @img : @disabled_img ) img. draw @x, @y, z_index, @scale_x, @scale_y, color @font. draw_text @text, @text_x, @text_y, z_index, @scale_x, @scale_y, text_color if @anchor1 and @anchor2 selection_color = ( ( alpha / 2 ) << 24 ) | @selection_color G. window. draw_quad @nodes [ @anchor1 ], @text_y, selection_color, @nodes [ @anchor2 ] + 1, @text_y, selection_color, @nodes [ @anchor2 ] + 1, @text_y + @font. height * @scale_y, selection_color, @nodes [ @anchor1 ], @text_y + @font. height * @scale_y, selection_color, z_index end if @cursor_visible if @cursor_img @cursor_img. draw @nodes [ @cur_node ] - ( @cursor_img. width * @scale_x ) / 2, @text_y, z_index, @scale_x, @scale_y else cursor_color = alpha << 24 G. window. draw_quad @nodes [ @cur_node ], @text_y, cursor_color, @nodes [ @cur_node ] + 1, @text_y, cursor_color, @nodes [ @cur_node ] + 1, @text_y + @font. height * @scale_y, cursor_color, @nodes [ @cur_node ], @text_y + @font. height * @scale_y, cursor_color, z_index end end end
->Raw Target:
Draws the text field in the screen.
--

410=========
->Original Input:
['def', 'draw', '(', 'alpha', '=', '0xff', ',', 'z_index', '=', '0', ',', 'color', '=', '0xffffff', ')', 'return', 'unless', '@visible', 'if', '@bg', 'c', '=', '(', 'alpha', '<<', '24', ')', '|', 'color', '@bg', '.', 'draw', '@x', ',', '@y', ',', 'z_index', ',', '@scale_x', ',', '@scale_y', ',', 'c', 'else', 'c', '=', '(', 'alpha', '<<', '24', ')', '|', '@bg_color', 'G', '.', 'window', '.', 'draw_quad', '@x', ',', '@y', ',', 'c', ',', '@x', '+', '@w', ',', '@y', ',', 'c', ',', '@x', '+', '@w', ',', '@y', '+', '@h', ',', 'c', ',', '@x', ',', '@y', '+', '@h', ',', 'c', ',', 'z_index', 'end', 'if', '@fg', 'c', '=', '(', 'alpha', '<<', '24', ')', '|', 'color', 'w1', '=', '@fg', '.', 'width', '*', '@scale_x', 'w2', '=', '(', '@value', '.', 'to_f', '/', '@max_value', '*', '@w', ')', '.', 'round', 'x0', '=', '@x', '+', '@fg_margin_x', 'x', '=', '0', 'while', 'x', '<=', 'w2', '-', 'w1', '@fg', '.', 'draw', 'x0', '+', 'x', ',', '@y', '+', '@fg_margin_y', ',', 'z_index', ',', '@scale_x', ',', '@scale_y', ',', 'c', 'x', '+=', 'w1', 'end', 'if', 'w2', '-', 'x', '>', '0', 'img', '=', 'Gosu', '::', 'Image', '.', 'new', '(', '@fg_path', ',', 'tileable', ':', 'true', ',', 'retro', ':', '@retro', ',', 'rect', ':', '[', '0', ',', '0', ',', '(', '(', 'w2', '-', 'x', ')', '/', '@scale_x', ')', '.', 'round', ',', '@fg', '.', 'height', ']', ')', 'img', '.', 'draw', 'x0', '+', 'x', ',', '@y', '+', '@fg_margin_y', ',', 'z_index', ',', '@scale_x', ',', '@scale_y', ',', 'c', 'end', 'else', 'c', '=', '(', 'alpha', '<<', '24', ')', '|', '@fg_color', 'rect_r', '=', '@x', '+', '(', '@value', '.', 'to_f', '/', '@max_value', '*', '@w', ')', '.', 'round', 'G', '.', 'window', '.', 'draw_quad', '@x', ',', '@y', ',', 'c', ',', 'rect_r', ',', '@y', ',', 'c', ',', 'rect_r', ',', '@y', '+', '@h', ',', 'c', ',', '@x', ',', '@y', '+', '@h', ',', 'c', ',', 'z_index', 'end', 'if', '@font', 'c', '=', '(', 'alpha', '<<', '24', ')', '|', '@text_color', '@text', '=', '@format', '==', "'%'", '?', '"#{(@value.to_f / @max_value * 100).round}%"', ':', '"#{@value}/#{@max_value}"', '@font', '.', 'draw_text_rel', '@text', ',', '@x', '+', '@w', '/', '2', ',', '@y', '+', '@h', '/', '2', ',', 'z_index', ',', '0.5', ',', '0.5', ',', '@scale_x', ',', '@scale_y', ',', 'c', 'end', 'end']
->Original Target:
['Draws', 'the', 'progress', 'bar', '.']
->Reconstructed Target:
Draws the progress bar.
->Reconstructed Predication:
@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@font.@
->Raw Input:
summarize:def draw ( alpha = 0xff, z_index = 0, color = 0xffffff ) return unless @visible if @bg c = ( alpha << 24 ) | color @bg. draw @x, @y, z_index, @scale_x, @scale_y, c else c = ( alpha << 24 ) | @bg_color G. window. draw_quad @x, @y, c, @x + @w, @y, c, @x + @w, @y + @h, c, @x, @y + @h, c, z_index end if @fg c = ( alpha << 24 ) | color w1 = @fg. width * @scale_x w2 = ( @value. to_f / @max_value * @w ). round x0 = @x + @fg_margin_x x = 0 while x <= w2 - w1 @fg. draw x0 + x, @y + @fg_margin_y, z_index, @scale_x, @scale_y, c x += w1 end if w2 - x > 0 img = Gosu :: Image. new ( @fg_path, tileable : true, retro : @retro, rect : [ 0, 0, ( ( w2 - x ) / @scale_x ). round, @fg. height ] ) img. draw x0 + x, @y + @fg_margin_y, z_index, @scale_x, @scale_y, c end else c = ( alpha << 24 ) | @fg_color rect_r = @x + ( @value. to_f / @max_value * @w ). round G. window. draw_quad @x, @y, c, rect_r, @y, c, rect_r, @y + @h, c, @x, @y + @h, c, z_index end if @font c = ( alpha << 24 ) | @text_color @text = @format == '%'? "#{(@value.to_f / @max_value * 100).round}%" : "#{@value}/#{@max_value}" @font. draw_text_rel @text, @x + @w / 2, @y + @h / 2, z_index, 0.5,
->Raw Target:
Draws the progress bar.
--

411=========
->Original Input:
['def', 'update', 'return', 'unless', '@enabled', 'and', '@visible', 'if', '@open', 'and', 'Mouse', '.', 'button_pressed?', ':left', 'and', 'not', 'Mouse', '.', 'over?', '(', '@x', ',', '@y', ',', '@w', ',', '@max_h', ')', 'toggle', 'return', 'end', '@buttons', '.', 'each', '{', '|', 'b', '|', 'b', '.', 'update', '}', 'end']
->Original Target:
['Creates', 'a', 'new', 'drop', '-', 'down', 'list', '.']
->Reconstructed Target:
Creates a new drop - down list.
->Reconstructed Predication:
the mouse button.  def
->Raw Input:
summarize:def update return unless @enabled and @visible if @open and Mouse. button_pressed? :left and not Mouse. over? ( @x, @y, @w, @max_h ) toggle return end @buttons. each { | b | b. update } end
->Raw Target:
Creates a new drop - down list.
--

412=========
->Original Input:
['def', 'value', '=', '(', 'val', ')', 'if', '@options', '.', 'include?', 'val', 'old', '=', '@value', '@value', '=', '@buttons', '[', '0', ']', '.', 'text', '=', 'val', '@on_changed', '.', 'call', '(', 'old', ',', 'val', ')', 'if', '@on_changed', 'end', 'end']
->Original Target:
['Sets', 'the', 'currently', 'selected', 'value', 'of', 'the', 'drop', '-', 'down', 'list', '.', 'It', 'is', 'ignored', 'if', 'it', 'is', 'not', 'among', 'the', 'available', 'options', '.']
->Reconstructed Target:
Sets the currently selected value of the drop - down list. It is ignored if it is not among the available options.
->Reconstructed Predication:
the value of the button.
->Raw Input:
summarize:def value = ( val ) if @options. include? val old = @value @value = @buttons [ 0 ]. text = val @on_changed. call ( old, val ) if @on_changed end end
->Raw Target:
Sets the currently selected value of the drop - down list. It is ignored if it is not among the available options.
--

413=========
->Original Input:
['def', 'draw', '(', 'alpha', '=', '0xff', ',', 'z_index', '=', '0', ',', 'color', '=', '0xffffff', ',', 'over_color', '=', '0xcccccc', ')', 'return', 'unless', '@visible', 'unless', '@img', 'bottom', '=', '@y', '+', '(', '@open', '?', '@max_h', ':', '@h', ')', '+', '@scale_y', 'b_color', '=', '(', 'alpha', '<<', '24', ')', 'G', '.', 'window', '.', 'draw_quad', '@x', '-', '@scale_x', ',', '@y', '-', '@scale_y', ',', 'b_color', ',', '@x', '+', '@w', '+', '@scale_x', ',', '@y', '-', '@scale_y', ',', 'b_color', ',', '@x', '+', '@w', '+', '@scale_x', ',', 'bottom', ',', 'b_color', ',', '@x', '-', '@scale_x', ',', 'bottom', ',', 'b_color', ',', 'z_index', '@buttons', '.', 'each', 'do', '|', 'b', '|', 'c', '=', '(', 'alpha', '<<', '24', ')', '|', '(', 'b', '.', 'state', '==', ':over', '?', 'over_color', ':', 'color', ')', 'G', '.', 'window', '.', 'draw_quad', 'b', '.', 'x', ',', 'b', '.', 'y', ',', 'c', ',', 'b', '.', 'x', '+', 'b', '.', 'w', ',', 'b', '.', 'y', ',', 'c', ',', 'b', '.', 'x', '+', 'b', '.', 'w', ',', 'b', '.', 'y', '+', 'b', '.', 'h', ',', 'c', ',', 'b', '.', 'x', ',', 'b', '.', 'y', '+', 'b', '.', 'h', ',', 'c', ',', 'z_index', '+', '1', 'if', 'b', '.', 'visible', 'end', 'end', '@buttons', '[', '0', ']', '.', 'draw', '(', 'alpha', ',', 'z_index', ',', 'color', ')', '@buttons', '[', '1', '..', '-', '1', ']', '.', 'each', '{', '|', 'b', '|', 'b', '.', 'draw', 'alpha', ',', 'z_index', '+', '1', ',', 'color', '}', 'end']
->Original Target:
['Draws', 'the', 'drop', '-', 'down', 'list', '.']
->Reconstructed Target:
Draws the drop - down list.
->Reconstructed Predication:
@buttons [ 0 ].. draw ( alpha,1, color )@buttons [ 1 ].. draw ( alpha,1, color ) @buttons1 ]. draw (, color ) @buttons [1 ]. draw (, color ) @buttons [1 ]. draw (1, color )@buttons [ 1 ].. draw ( alpha,1, color )@buttons [ 1
->Raw Input:
summarize:def draw ( alpha = 0xff, z_index = 0, color = 0xffffff, over_color = 0xcccccc ) return unless @visible unless @img bottom = @y + ( @open? @max_h : @h ) + @scale_y b_color = ( alpha << 24 ) G. window. draw_quad @x - @scale_x, @y - @scale_y, b_color, @x + @w + @scale_x, @y - @scale_y, b_color, @x + @w + @scale_x, bottom, b_color, @x - @scale_x, bottom, b_color, z_index @buttons. each do | b | c = ( alpha << 24 ) | ( b. state == :over? over_color : color ) G. window. draw_quad b. x, b. y, c, b. x + b. w, b. y, c, b. x + b. w, b. y + b. h, c, b. x, b. y + b. h, c, z_index + 1 if b. visible end end @buttons [ 0 ]. draw ( alpha, z_index, color ) @buttons [ 1.. - 1 ]. each { | b | b. draw alpha, z_index + 1, color } end
->Raw Target:
Draws the drop - down list.
--

414=========
->Original Input:
['def', 'draw', '(', 'alpha', '=', '255', ',', 'z_index', '=', '0', ',', 'color', '=', '0xffffff', ')', 'c', '=', '@enabled', '?', '@text_color', ':', '@disabled_text_color', 'r1', '=', 'c', '>>', '16', 'g1', '=', '(', 'c', '&', '0xff00', ')', '>>', '8', 'b1', '=', '(', 'c', '&', '0xff', ')', 'r2', '=', 'color', '>>', '16', 'g2', '=', '(', 'color', '&', '0xff00', ')', '>>', '8', 'b2', '=', '(', 'color', '&', '0xff', ')', 'r1', '*=', 'r2', ';', 'r1', '/=', '255', 'g1', '*=', 'g2', ';', 'g1', '/=', '255', 'b1', '*=', 'b2', ';', 'b1', '/=', '255', 'color', '=', '(', 'alpha', '<<', '24', ')', '|', '(', 'r1', '<<', '16', ')', '|', '(', 'g1', '<<', '8', ')', '|', 'b1', '@font', '.', 'draw_text', '(', '@text', ',', '@x', ',', '@y', ',', 'z_index', ',', '@scale_x', ',', '@scale_y', ',', 'color', ')', 'end']
->Original Target:
['Creates', 'a', 'new', 'label', '.']
->Reconstructed Target:
Creates a new label.
->Reconstructed Predication:
the text to be drawnthe text to be drawnthe text to be drawnthe text to be drawnthe text to be drawnthe text to be drawnthe text to be drawnthe text to be drawnthe text to be drawnthe text to be drawnthe text to be drawnthe text to be drawnthe text to be drawn. The textthe text to be drawnthe text to be drawn. The textthe
->Raw Input:
summarize:def draw ( alpha = 255, z_index = 0, color = 0xffffff ) c = @enabled? @text_color : @disabled_text_color r1 = c >> 16 g1 = ( c & 0xff00 ) >> 8 b1 = ( c & 0xff ) r2 = color >> 16 g2 = ( color & 0xff00 ) >> 8 b2 = ( color & 0xff ) r1 *= r2 ; r1 /= 255 g1 *= g2 ; g1 /= 255 b1 *= b2 ; b1 /= 255 color = ( alpha << 24 ) | ( r1 << 16 ) | ( g1 << 8 ) | b1 @font. draw_text ( @text, @x, @y, z_index, @scale_x, @scale_y, color ) end
->Raw Target:
Creates a new label.
--

415=========
->Original Input:
['def', 'write_line', '(', 'text', ',', 'x', '=', 'nil', ',', 'y', '=', 'nil', ',', 'mode', '=', ':left', ',', 'color', '=', '0', ',', 'alpha', '=', '0xff', ',', 'effect', '=', 'nil', ',', 'effect_color', '=', '0', ',', 'effect_size', '=', '1', ',', 'effect_alpha', '=', '0xff', ',', 'z_index', '=', '0', ')', 'if', 'text', '.', 'is_a?', 'Hash', 'x', '=', 'text', '[', ':x', ']', 'y', '=', 'text', '[', ':y', ']', 'mode', '=', 'text', '.', 'fetch', '(', ':mode', ',', ':left', ')', 'color', '=', 'text', '.', 'fetch', '(', ':color', ',', '0', ')', 'alpha', '=', 'text', '.', 'fetch', '(', ':alpha', ',', '0xff', ')', 'effect', '=', 'text', '.', 'fetch', '(', ':effect', ',', 'nil', ')', 'effect_color', '=', 'text', '.', 'fetch', '(', ':effect_color', ',', '0', ')', 'effect_size', '=', 'text', '.', 'fetch', '(', ':effect_size', ',', '1', ')', 'effect_alpha', '=', 'text', '.', 'fetch', '(', ':effect_alpha', ',', '0xff', ')', 'z_index', '=', 'text', '.', 'fetch', '(', ':z_index', ',', '0', ')', 'text', '=', 'text', '[', ':text', ']', 'end', 'color', '=', '(', 'alpha', '<<', '24', ')', '|', 'color', 'rel', '=', 'case', 'mode', 'when', ':left', 'then', '0', 'when', ':center', 'then', '0.5', 'when', ':right', 'then', '1', 'else', '0', 'end', 'if', 'effect', 'effect_color', '=', '(', 'effect_alpha', '<<', '24', ')', '|', 'effect_color', 'if', 'effect', '==', ':border', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', '-', 'effect_size', ',', 'y', '-', 'effect_size', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'effect_color', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', ',', 'y', '-', 'effect_size', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'effect_color', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', '+', 'effect_size', ',', 'y', '-', 'effect_size', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'effect_color', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', '+', 'effect_size', ',', 'y', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'effect_color', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', '+', 'effect_size', ',', 'y', '+', 'effect_size', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'effect_color', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', ',', 'y', '+', 'effect_size', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'effect_color', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', '-', 'effect_size', ',', 'y', '+', 'effect_size', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'effect_color', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', '-', 'effect_size', ',', 'y', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'effect_color', 'elsif', 'effect', '==', ':shadow', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', '+', 'effect_size', ',', 'y', '+', 'effect_size', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'effect_color', 'end', 'end', '@font', '.', 'draw_markup_rel', 'text', ',', 'x', ',', 'y', ',', 'z_index', ',', 'rel', ',', '0', ',', '1', ',', '1', ',', 'color', 'end']
->Original Target:
['Creates', 'a', 'TextHelper', '.']
->Reconstructed Target:
Creates a TextHelper.
->Reconstructed Predication:
, y, z_index,, z_index,effect_color @font. draw_markup_rel textx - effect_size, yz_index,effect_color @font. draw_markup_rel textx - effect_size, yz_index,effect_color @font. draw_markup_rel textx - effect_size, yz_index,effect_color @
->Raw Input:
summarize:def write_line ( text, x = nil, y = nil, mode = :left, color = 0, alpha = 0xff, effect = nil, effect_color = 0, effect_size = 1, effect_alpha = 0xff, z_index = 0 ) if text. is_a? Hash x = text [ :x ] y = text [ :y ] mode = text. fetch ( :mode, :left ) color = text. fetch ( :color, 0 ) alpha = text. fetch ( :alpha, 0xff ) effect = text. fetch ( :effect, nil ) effect_color = text. fetch ( :effect_color, 0 ) effect_size = text. fetch ( :effect_size, 1 ) effect_alpha = text. fetch ( :effect_alpha, 0xff ) z_index = text. fetch ( :z_index, 0 ) text = text [ :text ] end color = ( alpha << 24 ) | color rel = case mode when :left then 0 when :center then 0.5 when :right then 1 else 0 end if effect effect_color = ( effect_alpha << 24 ) | effect_color if effect == :border @font. draw_markup_rel text, x - effect_size, y - effect_size, z_index, rel, 0, 1, 1, effect_color @font. draw_markup_rel text, x, y - effect_size, z_index, rel, 0, 1, 1, effect_color @font. draw_markup_rel text, x + effect_size, y - effect_size, z_index, rel, 0, 1, 1, effect_color @font. draw_markup_rel text, x + effect_size, y, z_index, rel, 0, 1, 1, effect_color @font. draw_markup_rel text, x + effect_size, y + effect_size, z_index, rel, 0, 1, 1, effect_color @font. draw_markup_rel text, x, y + effect_size, z_index, rel, 0, 1, 1, effect_color @font. draw_markup_rel text, x - effect_size, y + effect_size, z_index, rel, 0, 1, 1, effect_color @font. draw_markup_rel text,
->Raw Target:
Creates a TextHelper.
--

416=========
->Original Input:
['def', 'write_breaking', '(', 'text', ',', 'x', ',', 'y', ',', 'width', ',', 'mode', '=', ':left', ',', 'color', '=', '0', ',', 'alpha', '=', '0xff', ',', 'z_index', '=', '0', ')', 'color', '=', '(', 'alpha', '<<', '24', ')', '|', 'color', 'text', '.', 'split', '(', '"\\n"', ')', '.', 'each', 'do', '|', 'p', '|', 'if', 'mode', '==', ':justified', 'y', '=', 'write_paragraph_justified', 'p', ',', 'x', ',', 'y', ',', 'width', ',', 'color', ',', 'z_index', 'else', 'rel', '=', 'case', 'mode', 'when', ':left', 'then', '0', 'when', ':center', 'then', '0.5', 'when', ':right', 'then', '1', 'else', '0', 'end', 'y', '=', 'write_paragraph', 'p', ',', 'x', ',', 'y', ',', 'width', ',', 'rel', ',', 'color', ',', 'z_index', 'end', 'end', 'end']
->Original Target:
['Draws', 'text', 'breaking', 'lines', 'when', 'needed', 'and', 'when', 'explicitly', 'caused', 'by', 'the', '\\', 'n', 'character', '.']
->Reconstructed Target:
Draws text breaking lines when needed and when explicitly caused by the \ n character.
->Reconstructed Predication:
texty, width,
->Raw Input:
summarize:def write_breaking ( text, x, y, width, mode = :left, color = 0, alpha = 0xff, z_index = 0 ) color = ( alpha << 24 ) | color text. split ( "\n" ). each do | p | if mode == :justified y = write_paragraph_justified p, x, y, width, color, z_index else rel = case mode when :left then 0 when :center then 0.5 when :right then 1 else 0 end y = write_paragraph p, x, y, width, rel, color, z_index end end end
->Raw Target:
Draws text breaking lines when needed and when explicitly caused by the \ n character.
--

417=========
->Original Input:
['def', 'add_global', '(', 'message', ')', 'unless', '(', 'slot', '=', '@entries', '.', 'index', '{', '|', 'e', '|', 'e', '.', 'nil?', '}', ')', 'slot', '=', '0', '0', '.', 'upto', '(', '15', ')', 'do', '|', 'i', '|', 'if', 'i', '!=', 'slot', '&&', '@entries', '[', 'slot', ']', '.', 'last_use', '>', '@entries', '[', 'i', ']', '.', 'last_use', 'slot', '=', 'i', 'end', 'end', 'end', '@entries', '[', 'slot', ']', '=', 'Entry', '.', 'new', '(', 'message', ',', 'Time', '.', 'now', ')', 'slot', 'end']
->Original Target:
['Add', 'a', 'new', 'GlobalFitMessage', 'to', 'the', 'mapper', 'and', 'return', 'the', 'local', 'message', 'number', '.']
->Reconstructed Target:
Add a new GlobalFitMessage to the mapper and return the local message number.
->Reconstructed Predication:
the global entry to be added
->Raw Input:
summarize:def add_global ( message ) unless ( slot = @entries. index { | e | e. nil? } ) slot = 0 0. upto ( 15 ) do | i | if i!= slot && @entries [ slot ]. last_use > @entries [ i ]. last_use slot = i end end end @entries [ slot ] = Entry. new ( message, Time. now ) slot end
->Raw Target:
Add a new GlobalFitMessage to the mapper and return the local message number.
--

418=========
->Original Input:
['def', 'get_local', '(', 'message', ')', '0', '.', 'upto', '(', '15', ')', 'do', '|', 'i', '|', 'if', '(', 'entry', '=', '@entries', '[', 'i', ']', ')', '&&', 'entry', '.', 'global_message', '==', 'message', 'entry', '.', 'last_use', '=', 'Time', '.', 'now', 'return', 'i', 'end', 'end', 'nil', 'end']
->Original Target:
['Get', 'the', 'local', 'message', 'number', 'for', 'a', 'given', 'GlobalFitMessage', '.', 'If', 'there', 'is', 'no', 'message', 'number', 'nil', 'is', 'returned', '.']
->Reconstructed Target:
Get the local message number for a given GlobalFitMessage. If there is no message number nil is returned.
->Reconstructed Predication:
the local message for the given
->Raw Input:
summarize:def get_local ( message ) 0. upto ( 15 ) do | i | if ( entry = @entries [ i ] ) && entry. global_message == message entry. last_use = Time. now return i end end nil end
->Raw Target:
Get the local message number for a given GlobalFitMessage. If there is no message number nil is returned.
--

419=========
->Original Input:
['def', 'check', 'last_timestamp', '=', 'ts_16_offset', '=', 'nil', 'last_ts_16', '=', 'nil', '@monitorings', '.', 'each', 'do', '|', 'record', '|', 'if', 'last_ts_16', '&&', 'ts_16_offset', '&&', 'record', '.', 'timestamp_16', '&&', 'record', '.', 'timestamp_16', '<', 'last_ts_16', 'ts_16_offset', '+=', '2', '**', '16', 'end', 'if', 'ts_16_offset', 'if', 'record', '.', 'timestamp_16', 'record', '.', 'timestamp', '=', 'ts_16_offset', '+', 'record', '.', 'timestamp_16', 'last_ts_16', '=', 'record', '.', 'timestamp_16', 'end', 'else', 'if', 'record', '.', 'timestamp_16', '&&', 'last_timestamp', 'ts_16_offset', '=', 'last_timestamp', '+', '60', '-', 'record', '.', 'timestamp_16', 'record', '.', 'timestamp', '=', 'ts_16_offset', '+', 'record', '.', 'timestamp_16', 'last_ts_16', '=', 'record', '.', 'timestamp_16', 'else', 'last_timestamp', '=', 'record', '.', 'timestamp', 'end', 'end', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'Monitoring_B', 'object', '.']
->Reconstructed Target:
Create a new Monitoring_B object.
->Reconstructed Predication:
thethe time the monitoring is
->Raw Input:
summarize:def check last_timestamp = ts_16_offset = nil last_ts_16 = nil @monitorings. each do | record | if last_ts_16 && ts_16_offset && record. timestamp_16 && record. timestamp_16 < last_ts_16 ts_16_offset += 2 ** 16 end if ts_16_offset if record. timestamp_16 record. timestamp = ts_16_offset + record. timestamp_16 last_ts_16 = record. timestamp_16 end else if record. timestamp_16 && last_timestamp ts_16_offset = last_timestamp + 60 - record. timestamp_16 record. timestamp = ts_16_offset + record. timestamp_16 last_ts_16 = record. timestamp_16 else last_timestamp = record. timestamp end end end end
->Raw Target:
Create a new Monitoring_B object.
--

420=========
->Original Input:
['def', 'create_global_definition', '(', 'fit_entity', ')', 'messages', '=', 'fit_entity', '.', 'developer_fit_messages', 'unless', '(', 'gfm', '=', 'GlobalFitMessages', '[', '@native_mesg_num', ']', ')', 'Log', '.', 'error', '"Developer field description references unknown global "', '+', '"message number #{@native_mesg_num}"', 'return', 'end', 'if', '@developer_data_index', '>=', 'fit_entity', '.', 'top_level_record', '.', 'developer_data_ids', '.', 'size', 'Log', '.', 'error', '"Developer data index #{@developer_data_index} is too large"', 'return', 'end', 'msg', '=', 'messages', '[', '@native_mesg_num', ']', '||', 'messages', '.', 'message', '(', '@native_mesg_num', ',', 'gfm', '.', 'name', ')', 'unless', '(', '@fit_base_type_id', '&', '0x7F', ')', '<', 'FIT_TYPE_DEFS', '.', 'size', 'Log', '.', 'error', '"fit_base_type_id #{@fit_base_type_id} is too large"', 'return', 'end', 'options', '=', '{', '}', 'options', '[', ':scale', ']', '=', '@scale', 'if', '@scale', 'options', '[', ':offset', ']', '=', '@offset', 'if', '@offset', 'options', '[', ':array', ']', '=', '@array', 'if', '@array', 'options', '[', ':unit', ']', '=', '@units', 'msg', '.', 'field', '(', '@field_definition_number', ',', 'FIT_TYPE_DEFS', '[', '@fit_base_type_id', '&', '0x7F', ']', '[', '1', ']', ',', '"_#{@developer_data_index}_#{@field_name}"', ',', 'options', ')', 'end']
->Original Target:
['Create', 'a', 'new', 'FieldDescription', 'object', '.']
->Reconstructed Target:
Create a new FieldDescription object.
->Reconstructed Predication:
. field ( @field_definition_number,, options ). field ( @field_definition_number,, options ). field ( @field_definition_number,, options ). field ( @field_definition_number,, options ). field ( @field_definition_number,, options ) end
->Raw Input:
summarize:def create_global_definition ( fit_entity ) messages = fit_entity. developer_fit_messages unless ( gfm = GlobalFitMessages [ @native_mesg_num ] ) Log. error "Developer field description references unknown global " + "message number #{@native_mesg_num}" return end if @developer_data_index >= fit_entity. top_level_record. developer_data_ids. size Log. error "Developer data index #{@developer_data_index} is too large" return end msg = messages [ @native_mesg_num ] || messages. message ( @native_mesg_num, gfm. name ) unless ( @fit_base_type_id & 0x7F ) < FIT_TYPE_DEFS. size Log. error "fit_base_type_id #{@fit_base_type_id} is too large" return end options = { } options [ :scale ] = @scale if @scale options [ :offset ] = @offset if @offset options [ :array ] = @array if @array options [ :unit ] = @units msg. field ( @field_definition_number, FIT_TYPE_DEFS [ @fit_base_type_id & 0x7F ] [ 1 ], "_#{@developer_data_index}_#{@field_name}", options ) end
->Raw Target:
Create a new FieldDescription object.
--

421=========
->Original Input:
['def', 'check', '(', 'index', ')', 'unless', '@device_index', 'Log', '.', 'fatal', "'device info record must have a device_index'", 'end', 'if', '@device_index', '==', '0', 'unless', '@manufacturer', 'Log', '.', 'fatal', "'device info record 0 must have a manufacturer field set'", 'end', 'if', '@manufacturer', '==', "'garmin'", 'unless', '@garmin_product', 'Log', '.', 'fatal', "'device info record 0 must have a garman_product '", '+', "'field set'", 'end', 'else', 'unless', '@product', 'Log', '.', 'fatal', "'device info record 0 must have a product field set'", 'end', 'end', 'if', '@serial_number', '.', 'nil?', 'Log', '.', 'fatal', "'device info record 0 must have a serial number set'", 'end', 'end', 'end']
->Original Target:
['Ensure', 'that', 'FitDataRecords', 'have', 'a', 'deterministic', 'sequence', '.', 'Device', 'infos', 'are', 'sorted', 'by', 'device_index', '.']
->Reconstructed Target:
Ensure that FitDataRecords have a deterministic sequence. Device infos are sorted by device_index.
->Reconstructed Predication:
a device info record
->Raw Input:
summarize:def check ( index ) unless @device_index Log. fatal 'device info record must have a device_index' end if @device_index == 0 unless @manufacturer Log. fatal 'device info record 0 must have a manufacturer field set' end if @manufacturer == 'garmin' unless @garmin_product Log. fatal 'device info record 0 must have a garman_product'+ 'field set' end else unless @product Log. fatal 'device info record 0 must have a product field set' end end if @serial_number. nil? Log. fatal 'device info record 0 must have a serial number set' end end end
->Raw Target:
Ensure that FitDataRecords have a deterministic sequence. Device infos are sorted by device_index.
--

422=========
->Original Input:
['def', 'open', '(', 'io', ')', 'begin', '@@logger', '=', 'Logger', '.', 'new', '(', 'io', ')', 'rescue', '=>', 'e', '@@logger', '=', 'Logger', '.', 'new', '(', '$stderr', ')', 'Log', '.', 'fatal', '"Cannot open log file: #{e.message}"', 'end', 'end']
->Original Target:
['Redirect', 'all', 'log', 'messages', 'to', 'the', 'given', 'IO', '.']
->Reconstructed Target:
Redirect all log messages to the given IO.
->Reconstructed Predication:
 def open ( io
->Raw Input:
summarize:def open ( io ) begin @@logger = Logger. new ( io ) rescue => e @@logger = Logger. new ( $stderr ) Log. fatal "Cannot open log file: #{e.message}" end end
->Raw Target:
Redirect all log messages to the given IO.
--

423=========
->Original Input:
['def', 'set_type', '(', 'type', ')', 'if', '@top_level_record', 'Log', '.', 'fatal', '"FIT file type has already been set to "', '+', '"#{@top_level_record.class}"', 'end', 'case', 'type', 'when', '4', ',', "'activity'", '@top_level_record', '=', 'Activity', '.', 'new', '@type', '=', "'activity'", 'when', '32', ',', "'monitoring_b'", '@top_level_record', '=', 'Monitoring_B', '.', 'new', '@type', '=', "'monitoring_b'", 'when', '44', ',', "'metrics'", '@top_level_record', '=', 'Metrics', '.', 'new', '@type', '=', "'metrics'", 'else', 'Log', '.', 'error', '"Unsupported FIT file type #{type}"', 'return', 'nil', 'end', '@top_level_record', 'end']
->Original Target:
['Create', 'a', 'FitFileEntity', '.', 'Set', 'what', 'kind', 'of', 'FIT', 'file', 'we', 'are', 'dealing', 'with', '.']
->Reconstructed Target:
Create a FitFileEntity. Set what kind of FIT file we are dealing with.
->Reconstructed Predication:
the file type to be
->Raw Input:
summarize:def set_type ( type ) if @top_level_record Log. fatal "FIT file type has already been set to " + "#{@top_level_record.class}" end case type when 4, 'activity' @top_level_record = Activity. new @type = 'activity' when 32,'monitoring_b' @top_level_record = Monitoring_B. new @type ='monitoring_b' when 44,'metrics' @top_level_record = Metrics. new @type ='metrics' else Log. error "Unsupported FIT file type #{type}" return nil end @top_level_record end
->Raw Target:
Create a FitFileEntity. Set what kind of FIT file we are dealing with.
--

424=========
->Original Input:
['def', 'check', 'unless', '@timestamp', '&&', '@timestamp', '>=', 'Time', '.', 'parse', '(', "'1990-01-01T00:00:00+00:00'", ')', 'Log', '.', 'fatal', '"Activity has no valid timestamp"', 'end', 'unless', '@total_timer_time', 'Log', '.', 'fatal', '"Activity has no valid total_timer_time"', 'end', 'unless', '@device_infos', '.', 'length', '>', '0', 'Log', '.', 'fatal', '"Activity must have at least one device_info section"', 'end', '@device_infos', '.', 'each', '.', 'with_index', '{', '|', 'd', ',', 'index', '|', 'd', '.', 'check', '(', 'index', ')', '}', '@sensor_settings', '.', 'each', '.', 'with_index', '{', '|', 's', ',', 'index', '|', 's', '.', 'check', '(', 'index', ')', '}', 'unless', '@num_sessions', '==', '@sessions', '.', 'count', 'Log', '.', 'fatal', '"Activity record requires #{@num_sessions}, but "', '"#{@sessions.length} session records were found in the "', '"FIT file."', 'end', 'ts', '=', 'Time', '.', 'parse', '(', "'1989-12-31'", ')', 'distance', '=', 'nil', 'invalid_records', '=', '[', ']', '@records', '.', 'each_with_index', 'do', '|', 'r', ',', 'idx', '|', 'Log', '.', 'fatal', '"Record has no timestamp"', 'unless', 'r', '.', 'timestamp', 'if', 'r', '.', 'timestamp', '<', 'ts', 'Log', '.', 'fatal', '"Record has earlier timestamp than previous record"', 'end', 'if', 'r', '.', 'distance', 'if', 'distance', '&&', 'r', '.', 'distance', '<', 'distance', 'Log', '.', 'error', '"Record #{r.timestamp} has smaller distance "', '+', '"(#{r.distance}) than an earlier record (#{distance})."', '(', 'idx', '-', '1', ')', '.', 'downto', '(', '0', ')', 'do', '|', 'i', '|', 'if', '(', 'ri', '=', '@records', '[', 'i', ']', ')', '.', 'distance', '>', 'r', '.', 'distance', 'invalid_records', '<<', 'ri', 'else', 'break', 'end', 'end', 'end', 'distance', '=', 'r', '.', 'distance', 'end', 'ts', '=', 'r', '.', 'timestamp', 'end', 'unless', 'invalid_records', '.', 'empty?', 'Log', '.', 'warn', '"Discarding #{invalid_records.length} earlier records"', '@records', '.', 'delete_if', '{', '|', 'r', '|', 'invalid_records', '.', 'include?', '(', 'r', ')', '}', 'end', '@laps', '.', 'each', '.', 'with_index', 'do', '|', 'lap', ',', 'index', '|', 'lap', '.', 'check', '(', 'index', ')', '@heart_rate_zones', '[', 'index', ']', '.', 'check', '(', 'index', ')', 'if', '@heart_rate_zones', '[', 'index', ']', 'end', '@sessions', '.', 'each', '{', '|', 's', '|', 's', '.', 'check', '(', 'self', ')', '}', 'end']
->Original Target:
['Create', 'a', 'new', 'Activity', 'object', '.']
->Reconstructed Target:
Create a new Activity object.
->Reconstructed Predication:
. info ( "Activitytime@total_timer_time. info ( "Activitytime. info ( "Total timertime is #{ts}. info ( "Total timertime is #{ts}. info ( "Total timertime is #{ts}. info ( "Total timertime is #{ts}. info ( "Total timer. info ( "Total timer. info ( "Total timertime
->Raw Input:
summarize:def check unless @timestamp && @timestamp >= Time. parse ( '1990-01-01T00:00:00+00:00' ) Log. fatal "Activity has no valid timestamp" end unless @total_timer_time Log. fatal "Activity has no valid total_timer_time" end unless @device_infos. length > 0 Log. fatal "Activity must have at least one device_info section" end @device_infos. each. with_index { | d, index | d. check ( index ) } @sensor_settings. each. with_index { | s, index | s. check ( index ) } unless @num_sessions == @sessions. count Log. fatal "Activity record requires #{@num_sessions}, but " "#{@sessions.length} session records were found in the " "FIT file." end ts = Time. parse ( '1989-12-31' ) distance = nil invalid_records = [ ] @records. each_with_index do | r, idx | Log. fatal "Record has no timestamp" unless r. timestamp if r. timestamp < ts Log. fatal "Record has earlier timestamp than previous record" end if r. distance if distance && r. distance < distance Log. error "Record #{r.timestamp} has smaller distance " + "(#{r.distance}) than an earlier record (#{distance})." ( idx - 1 ). downto ( 0 ) do | i | if ( ri = @records [ i ] ). distance > r. distance invalid_records << ri else break end end end distance = r. distance end ts = r. timestamp end unless invalid_records. empty? Log. warn "Discarding #{invalid_records.length} earlier records" @records. delete_if { | r | invalid_records. include? ( r ) } end @laps. each. with_index do | lap, index | lap. check ( index ) @heart_rate_zones [ index ]. check ( index ) if @heart_rate_zones [ index ] end @sessions. each { | s | s. check ( self ) } end
->Raw Target:
Create a new Activity object.
--

425=========
->Original Input:
['def', 'total_gps_distance', 'timer_stops', '=', '[', ']', '@events', '.', 'each', 'do', '|', 'e', '|', 'if', 'e', '.', 'event', '==', "'timer'", '&&', 'e', '.', 'event_type', '==', "'stop_all'", 'timer_stops', '<<', 'e', '.', 'timestamp', 'end', 'end', 'd', '=', '0.0', 'last_lat', '=', 'last_long', '=', 'nil', 'last_timestamp', '=', 'nil', '@records', '.', 'each', 'do', '|', 'r', '|', 'if', '(', 'lat', '=', 'r', '.', 'position_lat', ')', '&&', '(', 'long', '=', 'r', '.', 'position_long', ')', 'if', 'last_lat', '&&', 'last_long', 'distance', '=', 'Fit4Ruby', '::', 'GeoMath', '.', 'distance', '(', 'last_lat', ',', 'last_long', ',', 'lat', ',', 'long', ')', 'd', '+=', 'distance', 'end', 'if', 'last_timestamp', 'speed', '=', 'distance', '/', '(', 'r', '.', 'timestamp', '-', 'last_timestamp', ')', 'end', 'if', 'timer_stops', '[', '0', ']', '==', 'r', '.', 'timestamp', 'last_lat', '=', 'last_long', '=', 'nil', 'last_timestamp', '=', 'nil', 'timer_stops', '.', 'shift', 'else', 'last_lat', '=', 'lat', 'last_long', '=', 'long', 'last_timestamp', '=', 'r', '.', 'timestamp', 'end', 'end', 'end', 'd', 'end']
->Original Target:
['Total', 'distance', 'convered', 'by', 'this', 'activity', 'purely', 'computed', 'by', 'the', 'GPS', 'coordinates', '.', 'This', 'may', 'differ', 'from', 'the', 'distance', 'computed', 'by', 'the', 'device', 'as', 'it', 'can', 'be', 'based', 'on', 'a', 'purely', 'calibrated', 'footpod', '.']
->Reconstructed Target:
Total distance convered by this activity purely computed by the GPS coordinates. This may differ from the distance computed by the device as it can be based on a purely calibrated footpod.
->Reconstructed Predication:
the total distance inthe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total speed in thethe total
->Raw Input:
summarize:def total_gps_distance timer_stops = [ ] @events. each do | e | if e. event == 'timer' && e. event_type =='stop_all' timer_stops << e. timestamp end end d = 0.0 last_lat = last_long = nil last_timestamp = nil @records. each do | r | if ( lat = r. position_lat ) && ( long = r. position_long ) if last_lat && last_long distance = Fit4Ruby :: GeoMath. distance ( last_lat, last_long, lat, long ) d += distance end if last_timestamp speed = distance / ( r. timestamp - last_timestamp ) end if timer_stops [ 0 ] == r. timestamp last_lat = last_long = nil last_timestamp = nil timer_stops. shift else last_lat = lat last_long = long last_timestamp = r. timestamp end end end d end
->Raw Target:
Total distance convered by this activity purely computed by the GPS coordinates. This may differ from the distance computed by the device as it can be based on a purely calibrated footpod.
--

426=========
->Original Input:
['def', 'vo2max', '@events', '.', 'each', 'do', '|', 'e', '|', 'return', 'e', '.', 'vo2max', 'if', 'e', '.', 'event', '==', "'vo2max'", 'end', '@user_data', '.', 'each', 'do', '|', 'u', '|', 'return', 'u', '.', 'metmax', '*', '3.5', 'if', 'u', '.', 'metmax', 'end', 'nil', 'end']
->Original Target:
['Returns', 'the', 'computed', 'VO2max', 'value', '.', 'This', 'value', 'is', 'computed', 'by', 'the', 'device', 'based', 'on', 'multiple', 'previous', 'activities', '.']
->Reconstructed Target:
Returns the computed VO2max value. This value is computed by the device based on multiple previous activities.
->Reconstructed Predication:
return the max
->Raw Input:
summarize:def vo2max @events. each do | e | return e. vo2max if e. event == 'vo2max' end @user_data. each do | u | return u. metmax * 3.5 if u. metmax end nil end
->Raw Target:
Returns the computed VO2max value. This value is computed by the device based on multiple previous activities.
--

427=========
->Original Input:
['def', 'write', '(', 'io', ',', 'id_mapper', ')', '@file_id', '.', 'write', '(', 'io', ',', 'id_mapper', ')', '@file_creator', '.', 'write', '(', 'io', ',', 'id_mapper', ')', '(', '@field_descriptions', '+', '@developer_data_ids', '+', '@device_infos', '+', '@sensor_settings', '+', '@data_sources', '+', '@user_profiles', '+', '@physiological_metrics', '+', '@events', '+', '@sessions', '+', '@laps', '+', '@records', '+', '@heart_rate_zones', '+', '@personal_records', ')', '.', 'sort', '.', 'each', 'do', '|', 's', '|', 's', '.', 'write', '(', 'io', ',', 'id_mapper', ')', 'end', 'super', 'end']
->Original Target:
['Write', 'the', 'Activity', 'data', 'to', 'a', 'file', '.']
->Reconstructed Target:
Write the Activity data to a file.
->Reconstructed Predication:
write ( io, id_mapper
->Raw Input:
summarize:def write ( io, id_mapper ) @file_id. write ( io, id_mapper ) @file_creator. write ( io, id_mapper ) ( @field_descriptions + @developer_data_ids + @device_infos + @sensor_settings + @data_sources + @user_profiles + @physiological_metrics + @events + @sessions + @laps + @records + @heart_rate_zones + @personal_records ). sort. each do | s | s. write ( io, id_mapper ) end super end
->Raw Target:
Write the Activity data to a file.
--

428=========
->Original Input:
['def', 'new_fit_data_record', '(', 'record_type', ',', 'field_values', '=', '{', '}', ')', 'case', 'record_type', 'when', "'file_id'", '@file_id', '=', '(', 'record', '=', 'FileId', '.', 'new', '(', 'field_values', ')', ')', 'when', "'field_description'", '@field_descriptions', '<<', '(', 'record', '=', 'FieldDescription', '.', 'new', '(', 'field_values', ')', ')', 'when', "'developer_data_id'", '@developer_data_ids', '<<', '(', 'record', '=', 'DeveloperDataId', '.', 'new', '(', 'field_values', ')', ')', 'when', "'epo_data'", '@epo_data', '=', '(', 'record', '=', 'EPO_Data', '.', 'new', '(', 'field_values', ')', ')', 'when', "'file_creator'", '@file_creator', '=', '(', 'record', '=', 'FileCreator', '.', 'new', '(', 'field_values', ')', ')', 'when', "'device_info'", '@device_infos', '<<', '(', 'record', '=', 'DeviceInfo', '.', 'new', '(', 'field_values', ')', ')', 'when', "'sensor_settings'", '@sensor_settings', '<<', '(', 'record', '=', 'SensorSettings', '.', 'new', '(', 'field_values', ')', ')', 'when', "'data_sources'", '@data_sources', '<<', '(', 'record', '=', 'DataSources', '.', 'new', '(', 'field_values', ')', ')', 'when', "'user_data'", '@user_data', '<<', '(', 'record', '=', 'UserData', '.', 'new', '(', 'field_values', ')', ')', 'when', "'user_profile'", '@user_profiles', '<<', '(', 'record', '=', 'UserProfile', '.', 'new', '(', 'field_values', ')', ')', 'when', "'physiological_metrics'", '@physiological_metrics', '<<', '(', 'record', '=', 'PhysiologicalMetrics', '.', 'new', '(', 'field_values', ')', ')', 'when', "'event'", '@events', '<<', '(', 'record', '=', 'Event', '.', 'new', '(', 'field_values', ')', ')', 'when', "'session'", 'unless', '@cur_lap_records', '.', 'empty?', 'lap_field_values', '=', '{', '}', '[', ':timestamp', ',', ':sport', ']', '.', 'each', 'do', '|', 'f', '|', 'lap_field_values', '[', 'f', ']', '=', 'field_values', '[', 'f', ']', 'if', 'field_values', '.', 'include?', '(', 'f', ')', 'end', 'record', '=', 'create_new_lap', '(', 'lap_field_values', ')', 'end', '@num_sessions', '+=', '1', '@sessions', '<<', '(', 'record', '=', 'Session', '.', 'new', '(', '@cur_session_laps', ',', '@lap_counter', ',', 'field_values', ')', ')', '@cur_session_laps', '=', '[', ']', 'when', "'lap'", 'record', '=', 'create_new_lap', '(', 'field_values', ')', 'when', "'record'", '@cur_lap_records', '<<', '(', 'record', '=', 'Record', '.', 'new', '(', 'field_values', ')', ')', '@records', '<<', 'record', 'when', "'hrv'", '@hrv', '<<', '(', 'record', '=', 'HRV', '.', 'new', '(', 'field_values', ')', ')', 'when', "'heart_rate_zones'", '@heart_rate_zones', '<<', '(', 'record', '=', 'HeartRateZones', '.', 'new', '(', 'field_values', ')', ')', 'when', "'personal_records'", '@personal_records', '<<', '(', 'record', '=', 'PersonalRecords', '.', 'new', '(', 'field_values', ')', ')', 'else', 'record', '=', 'nil', 'end', 'record', 'end']
->Original Target:
['Check', 'if', 'the', 'current', 'Activity', 'is', 'equal', 'to', 'the', 'passed', 'Activity', '.']
->Reconstructed Target:
Check if the current Activity is equal to the passed Activity.
->Reconstructed Predication:
record = HRV. newrecord = HRV. newrecord = HRV. newrecord = HRV. newrecord = HRV. newrecord = HRV. newrecord = HRV. newrecord = HRV. newrecord = HRV. newrecord = HRV. newrecord = HRV. newrecord = HRV. newrecord
->Raw Input:
summarize:def new_fit_data_record ( record_type, field_values = { } ) case record_type when 'file_id' @file_id = ( record = FileId. new ( field_values ) ) when 'field_description' @field_descriptions << ( record = FieldDescription. new ( field_values ) ) when 'developer_data_id' @developer_data_ids << ( record = DeveloperDataId. new ( field_values ) ) when 'epo_data' @epo_data = ( record = EPO_Data. new ( field_values ) ) when 'file_creator' @file_creator = ( record = FileCreator. new ( field_values ) ) when 'device_info' @device_infos << ( record = DeviceInfo. new ( field_values ) ) when'sensor_settings' @sensor_settings << ( record = SensorSettings. new ( field_values ) ) when 'data_sources' @data_sources << ( record = DataSources. new ( field_values ) ) when 'user_data' @user_data << ( record = UserData. new ( field_values ) ) when 'user_profile' @user_profiles << ( record = UserProfile. new ( field_values ) ) when 'physiological_metrics' @physiological_metrics << ( record = PhysiologicalMetrics. new ( field_values ) ) when 'event' @events << ( record = Event. new ( field_values ) ) when'session' unless @cur_lap_records. empty? lap_field_values = { } [ :timestamp, :sport ]. each do | f | lap_field_values [ f ] = field_values [ f ] if field_values. include? ( f ) end record = create_new_lap ( lap_field_values ) end @num_sessions += 1 @sessions << ( record = Session. new ( @cur_session_laps, @lap_counter, field_values ) ) @cur_session_laps = [ ] when 'lap' record = create_new_lap ( field_values ) when'record' @cur_lap_records << ( record = Record. new ( field_values ) ) @records << record when 'hrv' @hrv << ( record = HRV.
->Raw Target:
Check if the current Activity is equal to the passed Activity.
--

429=========
->Original Input:
['def', 'check', '(', 'activity', ')', 'unless', '@first_lap_index', 'Log', '.', 'fatal', "'first_lap_index is not set'", 'end', 'unless', '@num_laps', 'Log', '.', 'fatal', "'num_laps is not set'", 'end', '@first_lap_index', '.', 'upto', '(', '@first_lap_index', '-', '@num_laps', ')', 'do', '|', 'i', '|', 'if', '(', 'lap', '=', 'activity', '.', 'lap', '[', 'i', ']', ')', '@laps', '<<', 'lap', 'else', 'Log', '.', 'fatal', '"Session references lap #{i} which is not contained in "', '"the FIT file."', 'end', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'Session', 'object', '.']
->Reconstructed Target:
Create a new Session object.
->Reconstructed Predication:
the activity
->Raw Input:
summarize:def check ( activity ) unless @first_lap_index Log. fatal 'first_lap_index is not set' end unless @num_laps Log. fatal 'num_laps is not set' end @first_lap_index. upto ( @first_lap_index - @num_laps ) do | i | if ( lap = activity. lap [ i ] ) @laps << lap else Log. fatal "Session references lap #{i} which is not contained in " "the FIT file." end end end
->Raw Target:
Create a new Session object.
--

430=========
->Original Input:
['def', 'field', '(', 'number', ',', 'type', ',', 'name', ',', 'opts', '=', '{', '}', ')', 'field', '=', 'Field', '.', 'new', '(', 'type', ',', 'name', ',', 'opts', ')', 'register_field_by_name', '(', 'field', ',', 'name', ')', 'register_field_by_number', '(', 'field', ',', 'number', ')', 'end']
->Original Target:
['Create', 'a', 'new', 'GlobalFitMessage', 'definition', '.']
->Reconstructed Target:
Create a new GlobalFitMessage definition.
->Reconstructed Predication:
field  def field
->Raw Input:
summarize:def field ( number, type, name, opts = { } ) field = Field. new ( type, name, opts ) register_field_by_name ( field, name ) register_field_by_number ( field, number ) end
->Raw Target:
Create a new GlobalFitMessage definition.
--

431=========
->Original Input:
['def', 'alt_field', '(', 'number', ',', 'ref_field', ',', '&', 'block', ')', 'unless', '@fields_by_name', '.', 'include?', '(', 'ref_field', ')', 'raise', '"Unknown ref_field: #{ref_field}"', 'end', 'field', '=', 'AltField', '.', 'new', '(', 'self', ',', 'ref_field', ',', '&', 'block', ')', 'register_field_by_number', '(', 'field', ',', 'number', ')', 'end']
->Original Target:
['Define', 'a', 'new', 'set', 'of', 'Field', 'alternatives', 'for', 'this', 'message', 'definition', '.']
->Reconstructed Target:
Define a new set of Field alternatives for this message definition.
->Reconstructed Predication:
field for a field number
->Raw Input:
summarize:def alt_field ( number, ref_field, & block ) unless @fields_by_name. include? ( ref_field ) raise "Unknown ref_field: #{ref_field}" end field = AltField. new ( self, ref_field, & block ) register_field_by_number ( field, number ) end
->Raw Target:
Define a new set of Field alternatives for this message definition.
--

432=========
->Original Input:
['def', 'spam?', 'self', '.', 'class', '.', 'mail_captcha', '.', 'each', 'do', '|', 'field', '|', 'next', 'if', 'send', '(', 'field', ')', '.', 'blank?', 'if', 'defined?', '(', 'Rails', ')', '&&', 'Rails', '.', 'env', '.', 'development?', 'raise', 'ScriptError', ',', '"The captcha field #{field} was supposed to be blank"', 'else', 'return', 'true', 'end', 'end', 'false', 'end']
->Original Target:
['In', 'development', 'raises', 'an', 'error', 'if', 'the', 'captcha', 'field', 'is', 'not', 'blank', '.', 'This', 'is', 'is', 'good', 'to', 'remember', 'that', 'the', 'field', 'should', 'be', 'hidden', 'with', 'CSS', 'and', 'shown', 'only', 'to', 'robots', '.']
->Reconstructed Target:
In development raises an error if the captcha field is not blank. This is is good to remember that the field should be hidden with CSS and shown only to robots.
->Reconstructed Predication:
the captcha field to be
->Raw Input:
summarize:def spam? self. class. mail_captcha. each do | field | next if send ( field ). blank? if defined? ( Rails ) && Rails. env. development? raise ScriptError, "The captcha field #{field} was supposed to be blank" else return true end end false end
->Raw Target:
In development raises an error if the captcha field is not blank. This is is good to remember that the field should be hidden with CSS and shown only to robots.
--

433=========
->Original Input:
['def', 'deliver!', 'mailer', '=', 'MailForm', '::', 'Notifier', '.', 'contact', '(', 'self', ')', 'if', 'mailer', '.', 'respond_to?', '(', ':deliver_now', ')', 'mailer', '.', 'deliver_now', 'else', 'mailer', '.', 'deliver', 'end', 'end']
->Original Target:
['Deliver', 'the', 'resource', 'without', 'running', 'any', 'validation', '.']
->Reconstructed Target:
Deliver the resource without running any validation.
->Reconstructed Predication:
 def deliver!
->Raw Input:
summarize:def deliver! mailer = MailForm :: Notifier. contact ( self ) if mailer. respond_to? ( :deliver_now ) mailer. deliver_now else mailer. deliver end end
->Raw Target:
Deliver the resource without running any validation.
--

434=========
->Original Input:
['def', 'mail_form_attributes', 'self', '.', 'class', '.', 'mail_attributes', '.', 'each_with_object', '(', '{', '}', ')', 'do', '|', 'attr', ',', 'hash', '|', 'hash', '[', 'attr', '.', 'to_s', ']', '=', 'send', '(', 'attr', ')', 'end', 'end']
->Original Target:
['Returns', 'a', 'hash', 'of', 'attributes', 'according', 'to', 'the', 'attributes', 'existent', 'in', 'self', '.', 'class', '.', 'mail_attributes', '.']
->Reconstructed Target:
Returns a hash of attributes according to the attributes existent in self. class. mail_attributes.
->Reconstructed Predication:
the mail attributes to be sent
->Raw Input:
summarize:def mail_form_attributes self. class. mail_attributes. each_with_object ( { } ) do | attr, hash | hash [ attr. to_s ] = send ( attr ) end end
->Raw Target:
Returns a hash of attributes according to the attributes existent in self. class. mail_attributes.
--

435=========
->Original Input:
['def', 'start', 'extract_and_configure', 'if', 'config', '.', 'managed?', 'exec', '(', "'start'", ',', 'p', ':', 'port', ',', 'c', ':', 'config', '.', 'cloud', ')', 'unless', 'status', 'sleep', 'config', '.', 'poll_interval', 'end', 'after_start', 'end', 'end']
->Original Target:
['Start', 'Solr', 'and', 'wait', 'for', 'it', 'to', 'become', 'available']
->Reconstructed Target:
Start Solr and wait for it to become available
->Reconstructed Predication:
 def start
->Raw Input:
summarize:def start extract_and_configure if config. managed? exec ('start', p : port, c : config. cloud ) unless status sleep config. poll_interval end after_start end end
->Raw Target:
Start Solr and wait for it to become available
--

436=========
->Original Input:
['def', 'restart', 'if', 'config', '.', 'managed?', '&&', 'started?', 'exec', '(', "'restart'", ',', 'p', ':', 'port', ',', 'c', ':', 'config', '.', 'cloud', ')', 'end', 'end']
->Original Target:
['Stop', 'Solr', 'and', 'wait', 'for', 'it', 'to', 'finish', 'exiting']
->Reconstructed Target:
Stop Solr and wait for it to finish exiting
->Reconstructed Predication:
restart the server if the serverthe server to restart the server
->Raw Input:
summarize:def restart if config. managed? && started? exec ('restart', p : port, c : config. cloud ) end end
->Raw Target:
Stop Solr and wait for it to finish exiting
--

437=========
->Original Input:
['def', 'create', '(', 'options', '=', '{', '}', ')', 'options', '[', ':name', ']', '||=', 'SecureRandom', '.', 'hex', 'create_options', '=', '{', 'p', ':', 'port', '}', 'create_options', '[', ':c', ']', '=', 'options', '[', ':name', ']', 'if', 'options', '[', ':name', ']', 'create_options', '[', ':n', ']', '=', 'options', '[', ':config_name', ']', 'if', 'options', '[', ':config_name', ']', 'create_options', '[', ':d', ']', '=', 'options', '[', ':dir', ']', 'if', 'options', '[', ':dir', ']', 'Retriable', '.', 'retriable', 'do', 'raise', '"Not started yet"', 'unless', 'started?', 'end', 'return', 'if', 'options', '[', ':persist', ']', '&&', 'create_options', '[', ':c', ']', '&&', 'client', '.', 'exists?', '(', 'create_options', '[', ':c', ']', ')', 'exec', '(', '"create"', ',', 'create_options', ')', 'options', '[', ':name', ']', 'end']
->Original Target:
['Create', 'a', 'new', 'collection', 'in', 'solr']
->Reconstructed Target:
Create a new collection in solr
->Reconstructed Predication:
:persist ] = trueif options [ :persist ]if options [ :persist ]if options [ :persist ]if options [ :persist ]if options [ :persist ]if options [ :persist ]if options [ :persist ]if options [ :persist ]if options [ :persist ]
->Raw Input:
summarize:def create ( options = { } ) options [ :name ] ||= SecureRandom. hex create_options = { p : port } create_options [ :c ] = options [ :name ] if options [ :name ] create_options [ :n ] = options [ :config_name ] if options [ :config_name ] create_options [ :d ] = options [ :dir ] if options [ :dir ] Retriable. retriable do raise "Not started yet" unless started? end return if options [ :persist ] && create_options [ :c ] && client. exists? ( create_options [ :c ] ) exec ( "create", create_options ) options [ :name ] end
->Raw Target:
Create a new collection in solr
--

438=========
->Original Input:
['def', 'upconfig', '(', 'options', '=', '{', '}', ')', 'options', '[', ':name', ']', '||=', 'SecureRandom', '.', 'hex', 'options', '[', ':zkhost', ']', '||=', 'zkhost', 'upconfig_options', '=', '{', 'upconfig', ':', 'true', ',', 'n', ':', 'options', '[', ':name', ']', '}', 'upconfig_options', '[', ':d', ']', '=', 'options', '[', ':dir', ']', 'if', 'options', '[', ':dir', ']', 'upconfig_options', '[', ':z', ']', '=', 'options', '[', ':zkhost', ']', 'if', 'options', '[', ':zkhost', ']', 'exec', "'zk'", ',', 'upconfig_options', 'options', '[', ':name', ']', 'end']
->Original Target:
['Update', 'the', 'collection', 'configuration', 'in', 'zookeeper']
->Reconstructed Target:
Update the collection configuration in zookeeper
->Reconstructed Predication:
the upconfig file and thethe upconfig file to the
->Raw Input:
summarize:def upconfig ( options = { } ) options [ :name ] ||= SecureRandom. hex options [ :zkhost ] ||= zkhost upconfig_options = { upconfig : true, n : options [ :name ] } upconfig_options [ :d ] = options [ :dir ] if options [ :dir ] upconfig_options [ :z ] = options [ :zkhost ] if options [ :zkhost ] exec 'zk', upconfig_options options [ :name ] end
->Raw Target:
Update the collection configuration in zookeeper
--

439=========
->Original Input:
['def', 'downconfig', '(', 'options', '=', '{', '}', ')', 'options', '[', ':name', ']', '||=', 'SecureRandom', '.', 'hex', 'options', '[', ':zkhost', ']', '||=', 'zkhost', 'downconfig_options', '=', '{', 'downconfig', ':', 'true', ',', 'n', ':', 'options', '[', ':name', ']', '}', 'downconfig_options', '[', ':d', ']', '=', 'options', '[', ':dir', ']', 'if', 'options', '[', ':dir', ']', 'downconfig_options', '[', ':z', ']', '=', 'options', '[', ':zkhost', ']', 'if', 'options', '[', ':zkhost', ']', 'exec', "'zk'", ',', 'downconfig_options', 'options', '[', ':name', ']', 'end']
->Original Target:
['Copy', 'the', 'collection', 'configuration', 'from', 'zookeeper', 'to', 'a', 'local', 'directory']
->Reconstructed Target:
Copy the collection configuration from zookeeper to a local directory
->Reconstructed Predication:
the downconfig file to be usedthe downconfig file to be used
->Raw Input:
summarize:def downconfig ( options = { } ) options [ :name ] ||= SecureRandom. hex options [ :zkhost ] ||= zkhost downconfig_options = { downconfig : true, n : options [ :name ] } downconfig_options [ :d ] = options [ :dir ] if options [ :dir ] downconfig_options [ :z ] = options [ :zkhost ] if options [ :zkhost ] exec 'zk', downconfig_options options [ :name ] end
->Raw Target:
Copy the collection configuration from zookeeper to a local directory
--

440=========
->Original Input:
['def', 'with_collection', '(', 'options', '=', '{', '}', ')', 'options', '=', 'config', '.', 'collection_options', '.', 'merge', '(', 'options', ')', 'return', 'yield', 'if', 'options', '.', 'empty?', 'name', '=', 'create', '(', 'options', ')', 'begin', 'yield', 'name', 'ensure', 'delete', 'name', 'unless', 'options', '[', ':persist', ']', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'collection', 'run', 'the', 'block', 'and', 'then', 'clean', 'up', 'the', 'collection']
->Reconstructed Target:
Create a new collection run the block and then clean up the collection
->Reconstructed Predication:
the collection of the objects
->Raw Input:
summarize:def with_collection ( options = { } ) options = config. collection_options. merge ( options ) return yield if options. empty? name = create ( options ) begin yield name ensure delete name unless options [ :persist ] end end
->Raw Target:
Create a new collection run the block and then clean up the collection
--

441=========
->Original Input:
['def', 'clean!', 'stop', 'remove_instance_dir!', 'FileUtils', '.', 'remove_entry', '(', 'config', '.', 'download_dir', ',', 'true', ')', 'if', 'File', '.', 'exist?', '(', 'config', '.', 'download_dir', ')', 'FileUtils', '.', 'remove_entry', '(', 'config', '.', 'tmp_save_dir', ',', 'true', ')', 'if', 'File', '.', 'exist?', 'config', '.', 'tmp_save_dir', 'checksum_validator', '.', 'clean!', 'FileUtils', '.', 'remove_entry', '(', 'config', '.', 'version_file', ')', 'if', 'File', '.', 'exist?', 'config', '.', 'version_file', 'end']
->Original Target:
['Clean', 'up', 'any', 'files', 'solr_wrapper', 'may', 'have', 'downloaded']
->Reconstructed Target:
Clean up any files solr_wrapper may have downloaded
->Reconstructed Predication:
the instance and the checksumthe instance and the checksum
->Raw Input:
summarize:def clean! stop remove_instance_dir! FileUtils. remove_entry ( config. download_dir, true ) if File. exist? ( config. download_dir ) FileUtils. remove_entry ( config. tmp_save_dir, true ) if File. exist? config. tmp_save_dir checksum_validator. clean! FileUtils. remove_entry ( config. version_file ) if File. exist? config. version_file end
->Raw Target:
Clean up any files solr_wrapper may have downloaded
--

442=========
->Original Input:
['def', 'get_signals', 'all_signals', '=', '[', ']', 'current', '=', '@klass', 'while', 'current', '!=', 'Qt', '::', 'Base', 'meta', '=', 'Meta', '[', 'current', '.', 'name', ']', 'if', '!', 'meta', '.', 'nil?', 'all_signals', '.', 'concat', 'meta', '.', 'signals', 'end', 'current', '=', 'current', '.', 'superclass', 'end', 'return', 'all_signals', 'end']
->Original Target:
['Return', 'a', 'list', 'of', 'signals', 'including', 'inherited', 'ones']
->Reconstructed Target:
Return a list of signals including inherited ones
->Reconstructed Predication:
the signals to be sent
->Raw Input:
summarize:def get_signals all_signals = [ ] current = @klass while current!= Qt :: Base meta = Meta [ current. name ] if! meta. nil? all_signals. concat meta. signals end current = current. superclass end return all_signals end
->Raw Target:
Return a list of signals including inherited ones
--

443=========
->Original Input:
['def', '+', '(', 'other', ')', 'if', 'Duration', '===', 'other', 'Duration', '.', 'new', '(', 'value', '+', 'other', '.', 'value', ',', '@parts', '+', 'other', '.', 'parts', ')', 'else', 'Duration', '.', 'new', '(', 'value', '+', 'other', ',', '@parts', '+', '[', '[', ':seconds', ',', 'other', ']', ']', ')', 'end', 'end']
->Original Target:
['Adds', 'another', 'Duration', 'or', 'a', 'Numeric', 'to', 'this', 'Duration', '.', 'Numeric', 'values', 'are', 'treated', 'as', 'seconds', '.']
->Reconstructed Target:
Adds another Duration or a Numeric to this Duration. Numeric values are treated as seconds.
->Reconstructed Predication:
a Duration object. 
->Raw Input:
summarize:def + ( other ) if Duration === other Duration. new ( value + other. value, @parts + other. parts ) else Duration. new ( value + other, @parts + [ [ :seconds, other ] ] ) end end
->Raw Target:
Adds another Duration or a Numeric to this Duration. Numeric values are treated as seconds.
--

444=========
->Original Input:
['def', 'days_to_week_start', '(', 'start_day', '=', 'Date', '.', 'beginning_of_week', ')', 'start_day_number', '=', 'DAYS_INTO_WEEK', '[', 'start_day', ']', 'current_day_number', '=', 'wday', '!=', '0', '?', 'wday', '-', '1', ':', '6', '(', 'current_day_number', '-', 'start_day_number', ')', '%', '7', 'end']
->Original Target:
['Returns', 'the', 'number', 'of', 'days', 'to', 'the', 'start', 'of', 'the', 'week', 'on', 'the', 'given', 'day', '.', 'Week', 'is', 'assumed', 'to', 'start', 'on', '+', 'start_day', '+', 'default', 'is', '+', 'Date', '.', 'beginning_of_week', '+', 'or', '+', 'config', '.', 'beginning_of_week', '+', 'when', 'set', '.']
->Reconstructed Target:
Returns the number of days to the start of the week on the given day. Week is assumed to start on + start_day + default is + Date. beginning_of_week + or + config. beginning_of_week + when set.
->Reconstructed Predication:
the week start
->Raw Input:
summarize:def days_to_week_start ( start_day = Date. beginning_of_week ) start_day_number = DAYS_INTO_WEEK [ start_day ] current_day_number = wday!= 0? wday - 1 : 6 ( current_day_number - start_day_number ) % 7 end
->Raw Target:
Returns the number of days to the start of the week on the given day. Week is assumed to start on + start_day + default is + Date. beginning_of_week + or + config. beginning_of_week + when set.
--

445=========
->Original Input:
['def', 'reset', '@width', '=', '0', 'if', 'no_width', '@render_period', '=', 'frequency', '==', '0', '?', '0', ':', '1.0', '/', 'frequency', '@current', '=', '0', '@last_render_time', '=', 'Time', '.', 'now', '@last_render_width', '=', '0', '@done', '=', 'false', '@stopped', '=', 'false', '@start_at', '=', 'Time', '.', 'now', '@started', '=', 'false', '@tokens', '=', '{', '}', '@meter', '.', 'clear', 'end']
->Original Target:
['Create', 'progress', 'bar']
->Reconstructed Target:
Create progress bar
->Reconstructed Predication:
@meter = Meter. new@meter. reset @meter. reset
->Raw Input:
summarize:def reset @width = 0 if no_width @render_period = frequency == 0? 0 : 1.0 / frequency @current = 0 @last_render_time = Time. now @last_render_width = 0 @done = false @stopped = false @start_at = Time. now @started = false @tokens = { } @meter. clear end
->Raw Target:
Create progress bar
--

446=========
->Original Input:
['def', 'advance', '(', 'progress', '=', '1', ',', 'tokens', '=', '{', '}', ')', 'return', 'if', 'done?', 'synchronize', 'do', 'emit', '(', ':progress', ',', 'progress', ')', 'if', 'progress', '.', 'respond_to?', '(', ':to_hash', ')', 'tokens', ',', 'progress', '=', 'progress', ',', '1', 'end', '@start_at', '=', 'Time', '.', 'now', 'if', '@current', '.', 'zero?', '&&', '!', '@started', '@current', '+=', 'progress', '@tokens', '=', 'tokens', '@meter', '.', 'sample', '(', 'Time', '.', 'now', ',', 'progress', ')', 'if', '!', 'no_width', '&&', '@current', '>=', 'total', 'finish', '&&', 'return', 'end', 'now', '=', 'Time', '.', 'now', 'return', 'if', '(', 'now', '-', '@last_render_time', ')', '<', '@render_period', 'render', 'end', 'end']
->Original Target:
['Advance', 'the', 'progress', 'bar']
->Reconstructed Target:
Advance the progress bar
->Reconstructed Predication:
the currentthe currentthe currentthe currentthe currentthe current
->Raw Input:
summarize:def advance ( progress = 1, tokens = { } ) return if done? synchronize do emit ( :progress, progress ) if progress. respond_to? ( :to_hash ) tokens, progress = progress, 1 end @start_at = Time. now if @current. zero? &&! @started @current += progress @tokens = tokens @meter. sample ( Time. now, progress ) if! no_width && @current >= total finish && return end now = Time. now return if ( now - @last_render_time ) < @render_period render end end
->Raw Target:
Advance the progress bar
--

447=========
->Original Input:
['def', 'iterate', '(', 'collection', ',', 'progress', '=', '1', ',', '&', 'block', ')', 'update', '(', 'total', ':', 'collection', '.', 'count', '*', 'progress', ')', 'unless', 'total', 'progress_enum', '=', 'Enumerator', '.', 'new', 'do', '|', 'iter', '|', 'collection', '.', 'each', 'do', '|', 'elem', '|', 'advance', '(', 'progress', ')', 'iter', '.', 'yield', '(', 'elem', ')', 'end', 'end', 'block_given?', '?', 'progress_enum', '.', 'each', '(', '&', 'block', ')', ':', 'progress_enum', 'end']
->Original Target:
['Iterate', 'over', 'collection', 'either', 'yielding', 'computation', 'to', 'block', 'or', 'provided', 'Enumerator', '.', 'If', 'the', 'bar', 's', 'total', 'was', 'not', 'set', 'it', 'would', 'be', 'taken', 'from', 'collection', '.', 'count', 'otherwise', 'previously', 'set', 'total', 'would', 'be', 'used', '.', 'This', 'allows', 'using', 'the', 'progressbar', 'with', 'infinite', 'lazy', 'or', 'slowly', '-', 'calculated', 'enumerators', '.']
->Reconstructed Target:
Iterate over collection either yielding computation to block or provided Enumerator. If the bar s total was not set it would be taken from collection. count otherwise previously set total would be used. This allows using the progressbar with infinite lazy or slowly - calculated enumerators.
->Reconstructed Predication:
the collection of elements to
->Raw Input:
summarize:def iterate ( collection, progress = 1, & block ) update ( total : collection. count * progress ) unless total progress_enum = Enumerator. new do | iter | collection. each do | elem | advance ( progress ) iter. yield ( elem ) end end block_given?? progress_enum. each ( & block ) : progress_enum end
->Raw Target:
Iterate over collection either yielding computation to block or provided Enumerator. If the bar s total was not set it would be taken from collection. count otherwise previously set total would be used. This allows using the progressbar with infinite lazy or slowly - calculated enumerators.
--

448=========
->Original Input:
['def', 'update', '(', 'options', '=', '{', '}', ')', 'synchronize', 'do', 'options', '.', 'each', 'do', '|', 'name', ',', 'val', '|', 'if', '@configuration', '.', 'respond_to?', '(', '"#{name}="', ')', '@configuration', '.', 'public_send', '(', '"#{name}="', ',', 'val', ')', 'end', 'end', 'end', 'end']
->Original Target:
['Update', 'configuration', 'options', 'for', 'this', 'bar']
->Reconstructed Target:
Update configuration options for this bar
->Reconstructed Predication:
the configuration to be updated
->Raw Input:
summarize:def update ( options = { } ) synchronize do options. each do | name, val | if @configuration. respond_to? ( "#{name}=" ) @configuration. public_send ( "#{name}=", val ) end end end end
->Raw Target:
Update configuration options for this bar
--

449=========
->Original Input:
['def', 'render', 'return', 'if', 'done?', 'if', 'hide_cursor', '&&', '@last_render_width', '==', '0', '&&', '!', '(', '@current', '>=', 'total', ')', 'write', '(', 'TTY', '::', 'Cursor', '.', 'hide', ')', 'end', 'if', '@multibar', 'characters_in', '=', '@multibar', '.', 'line_inset', '(', 'self', ')', 'update', '(', 'inset', ':', 'self', '.', 'class', '.', 'display_columns', '(', 'characters_in', ')', ')', 'end', 'formatted', '=', '@formatter', '.', 'decorate', '(', 'self', ',', '@format', ')', '@tokens', '.', 'each', 'do', '|', 'token', ',', 'val', '|', 'formatted', '=', 'formatted', '.', 'gsub', '(', '":#{token}"', ',', 'val', ')', 'end', 'padded', '=', 'padout', '(', 'formatted', ')', 'write', '(', 'padded', ',', 'true', ')', '@last_render_time', '=', 'Time', '.', 'now', '@last_render_width', '=', 'self', '.', 'class', '.', 'display_columns', '(', 'formatted', ')', 'end']
->Original Target:
['Render', 'progress', 'to', 'the', 'output']
->Reconstructed Target:
Render progress to the output
->Reconstructed Predication:
@last_render_time = Time. now@last_render_width = @last_render_time + @width@current = @current + @width@last_render_width @last_render_time = Time. now@last_render_time + @width @last_render_width = @last_render_width
->Raw Input:
summarize:def render return if done? if hide_cursor && @last_render_width == 0 &&! ( @current >= total ) write ( TTY :: Cursor. hide ) end if @multibar characters_in = @multibar. line_inset ( self ) update ( inset : self. class. display_columns ( characters_in ) ) end formatted = @formatter. decorate ( self, @format ) @tokens. each do | token, val | formatted = formatted. gsub ( ":#{token}", val ) end padded = padout ( formatted ) write ( padded, true ) @last_render_time = Time. now @last_render_width = self. class. display_columns ( formatted ) end
->Raw Target:
Render progress to the output
--

450=========
->Original Input:
['def', 'move_to_row', 'if', '@multibar', 'CURSOR_LOCK', '.', 'synchronize', 'do', 'if', '@first_render', '@row', '=', '@multibar', '.', 'next_row', 'yield', 'if', 'block_given?', 'output', '.', 'print', '"\\n"', '@first_render', '=', 'false', 'else', 'lines_up', '=', '(', '@multibar', '.', 'rows', '+', '1', ')', '-', '@row', 'output', '.', 'print', 'TTY', '::', 'Cursor', '.', 'save', 'output', '.', 'print', 'TTY', '::', 'Cursor', '.', 'up', '(', 'lines_up', ')', 'yield', 'if', 'block_given?', 'output', '.', 'print', 'TTY', '::', 'Cursor', '.', 'restore', 'end', 'end', 'else', 'yield', 'if', 'block_given?', 'end', 'end']
->Original Target:
['Move', 'cursor', 'to', 'a', 'row', 'of', 'the', 'current', 'bar', 'if', 'the', 'bar', 'is', 'rendered', 'under', 'a', 'multibar', '.', 'Otherwise', 'do', 'not', 'move', 'and', 'yield', 'on', 'current', 'row', '.']
->Reconstructed Target:
Move cursor to a row of the current bar if the bar is rendered under a multibar. Otherwise do not move and yield on current row.
->Reconstructed Predication:
@multibar. rows + 1
->Raw Input:
summarize:def move_to_row if @multibar CURSOR_LOCK. synchronize do if @first_render @row = @multibar. next_row yield if block_given? output. print "\n" @first_render = false else lines_up = ( @multibar. rows + 1 ) - @row output. print TTY :: Cursor. save output. print TTY :: Cursor. up ( lines_up ) yield if block_given? output. print TTY :: Cursor. restore end end else yield if block_given? end end
->Raw Target:
Move cursor to a row of the current bar if the bar is rendered under a multibar. Otherwise do not move and yield on current row.
--

451=========
->Original Input:
['def', 'write', '(', 'data', ',', 'clear_first', '=', 'false', ')', 'return', 'unless', 'tty?', 'move_to_row', 'do', 'output', '.', 'print', '(', 'TTY', '::', 'Cursor', '.', 'column', '(', '1', ')', ')', 'if', 'clear_first', 'characters_in', '=', '@multibar', '.', 'line_inset', '(', 'self', ')', 'if', '@multibar', 'output', '.', 'print', '(', '"#{characters_in}#{data}"', ')', 'output', '.', 'flush', 'end', 'end']
->Original Target:
['Write', 'out', 'to', 'the', 'output']
->Reconstructed Target:
Write out to the output
->Reconstructed Predication:
 def write ( data
->Raw Input:
summarize:def write ( data, clear_first = false ) return unless tty? move_to_row do output. print ( TTY :: Cursor. column ( 1 ) ) if clear_first characters_in = @multibar. line_inset ( self ) if @multibar output. print ( "#{characters_in}#{data}" ) output. flush end end
->Raw Target:
Write out to the output
--

452=========
->Original Input:
['def', 'finish', 'return', 'if', 'done?', '@current', '=', 'total', 'unless', 'no_width', 'render', 'clear', '?', 'clear_line', ':', 'write', '(', '"\\n"', ',', 'false', ')', 'ensure', '@meter', '.', 'clear', '@done', '=', 'true', 'if', 'hide_cursor', '&&', '@last_render_width', '!=', '0', 'write', '(', 'TTY', '::', 'Cursor', '.', 'show', ',', 'false', ')', 'end', 'emit', '(', ':done', ')', 'end']
->Original Target:
['End', 'the', 'progress']
->Reconstructed Target:
End the progress
->Reconstructed Predication:
the current line and the
->Raw Input:
summarize:def finish return if done? @current = total unless no_width render clear? clear_line : write ( "\n", false ) ensure @meter. clear @done = true if hide_cursor && @last_render_width!= 0 write ( TTY :: Cursor. show, false ) end emit ( :done ) end
->Raw Target:
End the progress
--

453=========
->Original Input:
['def', 'stop', 'if', 'hide_cursor', '&&', '@last_render_width', '!=', '0', 'write', '(', 'TTY', '::', 'Cursor', '.', 'show', ',', 'false', ')', 'end', 'return', 'if', 'done?', 'render', 'clear', '?', 'clear_line', ':', 'write', '(', '"\\n"', ',', 'false', ')', 'ensure', '@meter', '.', 'clear', '@stopped', '=', 'true', 'emit', '(', ':stopped', ')', 'end']
->Original Target:
['Stop', 'and', 'cancel', 'the', 'progress', 'at', 'the', 'current', 'position']
->Reconstructed Target:
Stop and cancel the progress at the current position
->Reconstructed Predication:
the current line and the
->Raw Input:
summarize:def stop if hide_cursor && @last_render_width!= 0 write ( TTY :: Cursor. show, false ) end return if done? render clear? clear_line : write ( "\n", false ) ensure @meter. clear @stopped = true emit ( :stopped ) end
->Raw Target:
Stop and cancel the progress at the current position
--

454=========
->Original Input:
['def', 'log', '(', 'message', ')', 'sanitized_message', '=', 'message', '.', 'gsub', '(', '/', '\\r', '\\n', '/', ',', "' '", ')', 'if', 'done?', 'write', '(', 'sanitized_message', '+', '"\\n"', ',', 'false', ')', 'return', 'end', 'sanitized_message', '=', 'padout', '(', 'sanitized_message', ')', 'write', '(', 'sanitized_message', '+', '"\\n"', ',', 'true', ')', 'render', 'end']
->Original Target:
['Log', 'message', 'above', 'the', 'current', 'progress', 'bar']
->Reconstructed Target:
Log message above the current progress bar
->Reconstructed Predication:
the log message. 
->Raw Input:
summarize:def log ( message ) sanitized_message = message. gsub ( / \r \n /,'' ) if done? write ( sanitized_message + "\n", false ) return end sanitized_message = padout ( sanitized_message ) write ( sanitized_message + "\n", true ) render end
->Raw Target:
Log message above the current progress bar
--

455=========
->Original Input:
['def', 'padout', '(', 'message', ')', 'message_length', '=', 'self', '.', 'class', '.', 'display_columns', '(', 'message', ')', 'if', '@last_render_width', '>', 'message_length', 'remaining_width', '=', '@last_render_width', '-', 'message_length', 'message', '+=', "' '", '*', 'remaining_width', 'end', 'message', 'end']
->Original Target:
['Pad', 'message', 'out', 'with', 'spaces']
->Reconstructed Target:
Pad message out with spaces
->Reconstructed Predication:
the message to the right
->Raw Input:
summarize:def padout ( message ) message_length = self. class. display_columns ( message ) if @last_render_width > message_length remaining_width = @last_render_width - message_length message +='' * remaining_width end message end
->Raw Target:
Pad message out with spaces
--

456=========
->Original Input:
['def', 'lock_exclusively!', '(', 'max_run_time', ',', 'worker', '=', 'worker_name', ')', 'now', '=', 'self', '.', 'class', '.', 'db_time_now', 'affected_rows', '=', 'if', 'locked_by', '!=', 'worker', 'self', '.', 'class', '.', 'update_all', '(', '[', '"locked_at = ?, locked_by = ?"', ',', 'now', ',', 'worker', ']', ',', '[', '"id = ? and (locked_at is null or locked_at < ?)"', ',', 'id', ',', '(', 'now', '-', 'max_run_time', '.', 'to_i', ')', ']', ')', 'else', 'self', '.', 'class', '.', 'update_all', '(', '[', '"locked_at = ?"', ',', 'now', ']', ',', '[', '"id = ? and locked_by = ?"', ',', 'id', ',', 'worker', ']', ')', 'end', 'if', 'affected_rows', '==', '1', 'self', '.', 'locked_at', '=', 'now', 'self', '.', 'locked_by', '=', 'worker', 'return', 'true', 'else', 'return', 'false', 'end', 'end']
->Original Target:
['Lock', 'this', 'job', 'for', 'this', 'worker', '.', 'Returns', 'true', 'if', 'we', 'have', 'the', 'lock', 'false', 'otherwise', '.']
->Reconstructed Target:
Lock this job for this worker. Returns true if we have the lock false otherwise.
->Reconstructed Predication:
the lock
->Raw Input:
summarize:def lock_exclusively! ( max_run_time, worker = worker_name ) now = self. class. db_time_now affected_rows = if locked_by!= worker self. class. update_all ( [ "locked_at =?, locked_by =?", now, worker ], [ "id =? and (locked_at is null or locked_at <?)", id, ( now - max_run_time. to_i ) ] ) else self. class. update_all ( [ "locked_at =?", now ], [ "id =? and locked_by =?", id, worker ] ) end if affected_rows == 1 self. locked_at = now self. locked_by = worker return true else return false end end
->Raw Target:
Lock this job for this worker. Returns true if we have the lock false otherwise.
--

457=========
->Original Input:
['def', 'setup_tracery', 'dir_path', 'raise', '"Provided path not a directory"', 'unless', 'Dir', '.', 'exist?', '(', 'dir_path', ')', '@grammar', '=', '{', '}', 'Dir', '.', 'open', '(', 'dir_path', ')', 'do', '|', 'dir', '|', 'dir', '.', 'each', 'do', '|', 'file', '|', 'next', 'if', 'file', '=~', '/', '\\.', '\\.', '/', '@grammar', '[', 'file', '.', 'split', '(', "'.'", ')', '.', 'first', ']', '=', 'createGrammar', '(', 'JSON', '.', 'parse', '(', 'File', '.', 'read', '(', '"#{dir_path}/#{file}"', ')', ')', ')', 'end', 'end', 'unless', '@grammar', '[', "'reply'", ']', '.', 'nil?', 'on_reply', '{', '|', 'bot', '|', 'bot', '.', 'reply_with_mentions', '(', "'#default#'", ',', 'rules', ':', "'reply'", ')', '}', 'end', 'end']
->Original Target:
['loads', 'all', 'of', 'our', 'tracery', 'files', 'into', 'our', '+', 'files', '+', 'hash', 'if', 'a', 'file', 'is', 'named', 'default', 'then', 'we', 'load', 'that', 'into', '+', 'grammar', '+']
->Reconstructed Target:
loads all of our tracery files into our + files + hash if a file is named default then we load that into + grammar +
->Reconstructed Predication:
the grammar for the botthe bot to use thethe bot to use thethe bot to use thethe bot to use thethe bot to use the
->Raw Input:
summarize:def setup_tracery dir_path raise "Provided path not a directory" unless Dir. exist? ( dir_path ) @grammar = { } Dir. open ( dir_path ) do | dir | dir. each do | file | next if file =~ / \. \. / @grammar [ file. split ( '.' ). first ] = createGrammar ( JSON. parse ( File. read ( "#{dir_path}/#{file}" ) ) ) end end unless @grammar ['reply' ]. nil? on_reply { | bot | bot. reply_with_mentions ( '#default#', rules :'reply' ) } end end
->Raw Target:
loads all of our tracery files into our + files + hash if a file is named default then we load that into + grammar +
--

458=========
->Original Input:
['def', 'expand_and_post', '(', 'text', ',', '*', 'options', ')', 'opts', '=', 'Hash', '[', '*', 'options', ']', 'rules', '=', 'opts', '.', 'fetch', '(', ':rules', ',', "'default'", ')', 'actually_post', '(', '@grammar', '[', 'rules', ']', '.', 'flatten', '(', 'text', ')', ',', '**', 'opts', '.', 'reject', '{', '|', 'k', '|', 'k', '==', ':rules', '}', ')', 'end']
->Original Target:
['a', 'shortcut', 'fuction', 'for', 'expanding', 'text', 'with', 'tracery', 'before', 'posting']
->Reconstructed Target:
a shortcut fuction for expanding text with tracery before posting
->Reconstructed Predication:
post a text to thethe text to post
->Raw Input:
summarize:def expand_and_post ( text, * options ) opts = Hash [ * options ] rules = opts. fetch ( :rules, 'default' ) actually_post ( @grammar [ rules ]. flatten ( text ), ** opts. reject { | k | k == :rules } ) end
->Raw Target:
a shortcut fuction for expanding text with tracery before posting
--

459=========
->Original Input:
['def', 'run_interact', '@streamer', '.', 'user', 'do', '|', 'update', '|', 'if', 'update', '.', 'kind_of?', 'Mastodon', '::', 'Notification', 'case', 'update', '.', 'type', 'when', "'mention'", 'update', '.', 'status', '.', 'class', '.', 'module_eval', '{', 'alias_method', ':content', ',', ':strip', '}', 'if', '@strip_html', 'store_mention_data', 'update', '.', 'status', '@on_reply', '.', 'call', '(', 'self', ',', 'update', '.', 'status', ')', 'unless', '@on_reply', '.', 'nil?', 'when', "'reblog'", '@on_boost', '.', 'call', '(', 'self', ',', 'update', ')', 'unless', '@on_boost', '.', 'nil?', 'when', "'favourite'", '@on_fave', '.', 'call', '(', 'self', ',', 'update', ')', 'unless', '@on_fave', '.', 'nil?', 'when', "'follow'", '@on_follow', '.', 'call', '(', 'self', ',', 'update', ')', 'unless', '@on_follow', '.', 'nil?', 'end', 'end', 'end', 'end']
->Original Target:
['Starts', 'a', 'loop', 'that', 'checks', 'for', 'any', 'notifications', 'for', 'the', 'authenticated', 'user', 'running', 'the', 'appropriate', 'stored', 'proc', 'when', 'needed']
->Reconstructed Target:
Starts a loop that checks for any notifications for the authenticated user running the appropriate stored proc when needed
->Reconstructed Predication:
thethe update
->Raw Input:
summarize:def run_interact @streamer. user do | update | if update. kind_of? Mastodon :: Notification case update. type when'mention' update. status. class. module_eval { alias_method :content, :strip } if @strip_html store_mention_data update. status @on_reply. call ( self, update. status ) unless @on_reply. nil? when'reblog' @on_boost. call ( self, update ) unless @on_boost. nil? when 'favourite' @on_fave. call ( self, update ) unless @on_fave. nil? when 'follow' @on_follow. call ( self, update ) unless @on_follow. nil? end end end end
->Raw Target:
Starts a loop that checks for any notifications for the authenticated user running the appropriate stored proc when needed
--

460=========
->Original Input:
['def', 'reply', '(', 'text', ',', '*', 'options', ')', 'options', '=', 'Hash', '[', '*', 'options', ']', 'post', '(', '"@#{@mention_data[:account].acct} #{text}"', ',', '**', '@mention_data', '.', 'merge', '(', 'options', ')', '.', 'reject', '{', '|', 'k', '|', 'k', '==', ':mentions', 'or', 'k', '==', ':account', '}', ')', 'end']
->Original Target:
['Replies', 'to', 'the', 'last', 'mention', 'the', 'bot', 'recieved', 'using', 'the', 'mention', 's', 'visibility', 'and', 'spoiler', 'with', '+', 'text', '+']
->Reconstructed Target:
Replies to the last mention the bot recieved using the mention s visibility and spoiler with + text +
->Reconstructed Predication:
the message to the userthe message to the user
->Raw Input:
summarize:def reply ( text, * options ) options = Hash [ * options ] post ( "@#{@mention_data[:account].acct} #{text}", ** @mention_data. merge ( options ). reject { | k | k == :mentions or k == :account } ) end
->Raw Target:
Replies to the last mention the bot recieved using the mention s visibility and spoiler with + text +
--

461=========
->Original Input:
['def', 'run_reply', '@streamer', '.', 'user', 'do', '|', 'update', '|', 'next', 'unless', 'update', '.', 'kind_of?', 'Mastodon', '::', 'Notification', 'and', 'update', '.', 'type', '==', "'mention'", 'update', '.', 'status', '.', 'class', '.', 'module_eval', '{', 'alias_method', ':content', ',', ':strip', '}', 'if', '@strip_html', 'store_mention_data', 'update', '.', 'status', 'if', 'block_given?', 'yield', '(', 'self', ',', 'update', '.', 'status', ')', 'else', '@on_reply', '.', 'call', '(', 'self', ',', 'update', '.', 'status', ')', 'end', 'end', 'end']
->Original Target:
['Starts', 'a', 'loop', 'that', 'checks', 'for', 'mentions', 'from', 'the', 'authenticated', 'user', 'account', 'running', 'a', 'supplied', 'block', 'or', 'if', 'a', 'block', 'is', 'not', 'provided', 'on_reply']
->Reconstructed Target:
Starts a loop that checks for mentions from the authenticated user account running a supplied block or if a block is not provided on_reply
->Reconstructed Predication:
the message to the userend
->Raw Input:
summarize:def run_reply @streamer. user do | update | next unless update. kind_of? Mastodon :: Notification and update. type =='mention' update. status. class. module_eval { alias_method :content, :strip } if @strip_html store_mention_data update. status if block_given? yield ( self, update. status ) else @on_reply. call ( self, update. status ) end end end
->Raw Target:
Starts a loop that checks for mentions from the authenticated user account running a supplied block or if a block is not provided on_reply
--

462=========
->Original Input:
['def', 'store_mention_data', '(', 'mention', ')', '@mention_data', '=', '{', 'reply_id', ':', 'mention', '.', 'id', ',', 'visibility', ':', 'mention', '.', 'visibility', ',', 'spoiler', ':', 'mention', '.', 'spoiler_text', ',', 'hide_media', ':', 'mention', '.', 'sensitive?', ',', 'mentions', ':', 'mention', '.', 'mentions', ',', 'account', ':', 'mention', '.', 'account', '}', 'end']
->Original Target:
['Stores', 'select', 'data', 'about', 'a', 'post', 'into', 'a', 'hash', 'for', 'later', 'use']
->Reconstructed Target:
Stores select data about a post into a hash for later use
->Reconstructed Predication:
the mention data for the
->Raw Input:
summarize:def store_mention_data ( mention ) @mention_data = { reply_id : mention. id, visibility : mention. visibility, spoiler : mention. spoiler_text, hide_media : mention. sensitive?, mentions : mention. mentions, account : mention. account } end
->Raw Target:
Stores select data about a post into a hash for later use
--

463=========
->Original Input:
['def', 'setup_streaming', 'stream_uri', '=', '@client', '.', 'instance', '(', ')', '.', 'attributes', '[', "'urls'", ']', '[', "'streaming_api'", ']', '.', 'gsub', '(', '/', '/', ',', "'https'", ')', '@streamer', '=', 'Mastodon', '::', 'Streaming', '::', 'Client', '.', 'new', '(', 'base_url', ':', 'stream_uri', ',', 'bearer_token', ':', 'ENV', '[', "'TOKEN'", ']', ')', 'end']
->Original Target:
['Creates', 'the', 'stream', 'client']
->Reconstructed Target:
Creates the stream client
->Reconstructed Predication:
the streaming client. 
->Raw Input:
summarize:def setup_streaming stream_uri = @client. instance ( ). attributes [ 'urls' ] ['streaming_api' ]. gsub ( / /, 'https' ) @streamer = Mastodon :: Streaming :: Client. new ( base_url : stream_uri, bearer_token : ENV [ 'TOKEN' ] ) end
->Raw Target:
Creates the stream client
--

464=========
->Original Input:
['def', 'parse_service_name', '(', 'path', ')', 'parts', '=', 'Pathname', '.', 'new', '(', 'path', ')', '.', 'each_filename', '.', 'to_a', '.', 'reverse!', 'parts', '.', 'find', '{', '|', 'seg', '|', '!', 'COMMON_SEGMENTS', '[', 'seg', ']', '}', '||', 'parts', '.', 'first', 'end']
->Original Target:
['Parse', 'the', 'service', 'name', 'from', 'a', 'path', '.', 'Look', 'at', 'the', 'last', 'component', 'of', 'the', 'path', 'ignoring', 'some', 'common', 'names', '.']
->Reconstructed Target:
Parse the service name from a path. Look at the last component of the path ignoring some common names.
->Reconstructed Predication:
the service name. 
->Raw Input:
summarize:def parse_service_name ( path ) parts = Pathname. new ( path ). each_filename. to_a. reverse! parts. find { | seg |! COMMON_SEGMENTS [ seg ] } || parts. first end
->Raw Target:
Parse the service name from a path. Look at the last component of the path ignoring some common names.
--

465=========
->Original Input:
['def', 'connect', 'start_time', '=', 'Time', '.', 'now', 'retries', '=', '0', 'close', 'begin', 'connect_to_server', '(', 'servers', ',', 'policy', ')', 'logger', '.', 'info', '(', 'message', ':', '"Connected to #{address}"', ',', 'duration', ':', '(', 'Time', '.', 'now', '-', 'start_time', ')', '*', '1000', ')', 'if', 'respond_to?', '(', ':logger', ')', 'rescue', 'ConnectionFailure', ',', 'ConnectionTimeout', '=>', 'exception', 'cause', '=', 'exception', '.', 'is_a?', '(', 'ConnectionTimeout', ')', '?', 'exception', ':', 'exception', '.', 'cause', 'if', 'self', '.', 'class', '.', 'reconnect_on_errors', '.', 'include?', '(', 'cause', '.', 'class', ')', '&&', '(', 'retries', '<', 'connect_retry_count', '.', 'to_i', ')', 'retries', '+=', '1', 'logger', '.', 'warn', '"#connect Failed to connect to any of #{servers.join(\',\')}. Sleeping:#{connect_retry_interval}s. Retry: #{retries}"', 'if', 'respond_to?', '(', ':logger', ')', 'sleep', '(', 'connect_retry_interval', ')', 'retry', 'else', 'message', '=', '"#connect Failed to connect to any of #{servers.join(\',\')} after #{retries} retries. #{exception.class}: #{exception.message}"', 'logger', '.', 'benchmark_error', '(', 'message', ',', 'exception', ':', 'exception', ',', 'duration', ':', '(', 'Time', '.', 'now', '-', 'start_time', ')', ')', 'if', 'respond_to?', '(', ':logger', ')', 'raise', 'ConnectionFailure', '.', 'new', '(', 'message', ',', 'address', '.', 'to_s', ',', 'cause', ')', 'end', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'TCP', 'Client', 'connection']
->Reconstructed Target:
Create a new TCP Client connection
->Reconstructed Predication:
.) ) if respond_to? () raise ConnectionTimeout. new, address. to_s,) if respond_to? ( :logger) raise ConnectionFailure. new, address. to_s,) if respond_to? ( :logger) raise ConnectionTimeout. new, address. to_s,) if respond_to? ( :logger) raise ConnectionTimeout. new, address. to
->Raw Input:
summarize:def connect start_time = Time. now retries = 0 close begin connect_to_server ( servers, policy ) logger. info ( message : "Connected to #{address}", duration : ( Time. now - start_time ) * 1000 ) if respond_to? ( :logger ) rescue ConnectionFailure, ConnectionTimeout => exception cause = exception. is_a? ( ConnectionTimeout )? exception : exception. cause if self. class. reconnect_on_errors. include? ( cause. class ) && ( retries < connect_retry_count. to_i ) retries += 1 logger. warn "#connect Failed to connect to any of #{servers.join(',')}. Sleeping:#{connect_retry_interval}s. Retry: #{retries}" if respond_to? ( :logger ) sleep ( connect_retry_interval ) retry else message = "#connect Failed to connect to any of #{servers.join(',')} after #{retries} retries. #{exception.class}: #{exception.message}" logger. benchmark_error ( message, exception : exception, duration : ( Time. now - start_time ) ) if respond_to? ( :logger ) raise ConnectionFailure. new ( message, address. to_s, cause ) end end end
->Raw Target:
Create a new TCP Client connection
--

466=========
->Original Input:
['def', 'write', '(', 'data', ',', 'timeout', '=', 'write_timeout', ')', 'data', '=', 'data', '.', 'to_s', 'if', 'respond_to?', '(', ':logger', ')', 'payload', '=', '{', 'timeout', ':', 'timeout', '}', 'payload', '[', ':data', ']', '=', 'data', 'if', 'logger', '.', 'trace?', 'logger', '.', 'benchmark_debug', '(', "'#write'", ',', 'payload', ':', 'payload', ')', 'do', 'payload', '[', ':bytes', ']', '=', 'socket_write', '(', 'data', ',', 'timeout', ')', 'end', 'else', 'socket_write', '(', 'data', ',', 'timeout', ')', 'end', 'rescue', 'Exception', '=>', 'exc', 'close', 'if', 'close_on_error', 'raise', 'exc', 'end']
->Original Target:
['Write', 'data', 'to', 'the', 'server']
->Reconstructed Target:
Write data to the server
->Reconstructed Predication:
: data : data :: data : data :
->Raw Input:
summarize:def write ( data, timeout = write_timeout ) data = data. to_s if respond_to? ( :logger ) payload = { timeout : timeout } payload [ :data ] = data if logger. trace? logger. benchmark_debug ( '#write', payload : payload ) do payload [ :bytes ] = socket_write ( data, timeout ) end else socket_write ( data, timeout ) end rescue Exception => exc close if close_on_error raise exc end
->Raw Target:
Write data to the server
--

467=========
->Original Input:
['def', 'read', '(', 'length', ',', 'buffer', '=', 'nil', ',', 'timeout', '=', 'read_timeout', ')', 'if', 'respond_to?', '(', ':logger', ')', 'payload', '=', '{', 'bytes', ':', 'length', ',', 'timeout', ':', 'timeout', '}', 'logger', '.', 'benchmark_debug', '(', "'#read'", ',', 'payload', ':', 'payload', ')', 'do', 'data', '=', 'socket_read', '(', 'length', ',', 'buffer', ',', 'timeout', ')', 'payload', '[', ':data', ']', '=', 'data', 'if', 'logger', '.', 'trace?', 'data', 'end', 'else', 'socket_read', '(', 'length', ',', 'buffer', ',', 'timeout', ')', 'end', 'rescue', 'Exception', '=>', 'exc', 'close', 'if', 'close_on_error', 'raise', 'exc', 'end']
->Original Target:
['Returns', 'a', 'response', 'from', 'the', 'server']
->Reconstructed Target:
Returns a response from the server
->Reconstructed Predication:
 def read ( length) end end  defend
->Raw Input:
summarize:def read ( length, buffer = nil, timeout = read_timeout ) if respond_to? ( :logger ) payload = { bytes : length, timeout : timeout } logger. benchmark_debug ( '#read', payload : payload ) do data = socket_read ( length, buffer, timeout ) payload [ :data ] = data if logger. trace? data end else socket_read ( length, buffer, timeout ) end rescue Exception => exc close if close_on_error raise exc end
->Raw Target:
Returns a response from the server
--

468=========
->Original Input:
['def', 'close', 'socket', '.', 'close', 'if', 'socket', '&&', '!', 'socket', '.', 'closed?', '@socket', '=', 'nil', '@address', '=', 'nil', 'true', 'rescue', 'IOError', '=>', 'exception', 'logger', '.', 'warn', '"IOError when attempting to close socket: #{exception.class}: #{exception.message}"', 'if', 'respond_to?', '(', ':logger', ')', 'false', 'end']
->Original Target:
['Close', 'the', 'socket', 'only', 'if', 'it', 'is', 'not', 'already', 'closed']
->Reconstructed Target:
Close the socket only if it is not already closed
->Reconstructed Predication:
the socket to the server
->Raw Input:
summarize:def close socket. close if socket &&! socket. closed? @socket = nil @address = nil true rescue IOError => exception logger. warn "IOError when attempting to close socket: #{exception.class}: #{exception.message}" if respond_to? ( :logger ) false end
->Raw Target:
Close the socket only if it is not already closed
--

469=========
->Original Input:
['def', 'alive?', 'return', 'false', 'if', 'socket', '.', 'nil?', '||', 'closed?', 'if', 'IO', '.', 'select', '(', '[', 'socket', ']', ',', 'nil', ',', 'nil', ',', '0', ')', '!', 'socket', '.', 'eof?', 'rescue', 'false', 'else', 'true', 'end', 'rescue', 'IOError', 'false', 'end']
->Original Target:
['Returns', 'whether', 'the', 'connection', 'to', 'the', 'server', 'is', 'alive']
->Reconstructed Target:
Returns whether the connection to the server is alive
->Reconstructed Predication:
return false if closed?
->Raw Input:
summarize:def alive? return false if socket. nil? || closed? if IO. select ( [ socket ], nil, nil, 0 )! socket. eof? rescue false else true end rescue IOError false end
->Raw Target:
Returns whether the connection to the server is alive
--

470=========
->Original Input:
['def', 'socket_connect', '(', 'socket', ',', 'address', ',', 'timeout', ')', 'socket_address', '=', 'Socket', '.', 'pack_sockaddr_in', '(', 'address', '.', 'port', ',', 'address', '.', 'ip_address', ')', 'return', 'socket', '.', 'connect', '(', 'socket_address', ')', 'if', 'timeout', '==', '-', '1', 'deadline', '=', 'Time', '.', 'now', '.', 'utc', '+', 'timeout', 'begin', 'non_blocking', '(', 'socket', ',', 'deadline', ')', '{', 'socket', '.', 'connect_nonblock', '(', 'socket_address', ')', '}', 'rescue', 'Errno', '::', 'EISCONN', 'rescue', 'NonBlockingTimeout', 'raise', 'ConnectionTimeout', '.', 'new', '(', '"Timed out after #{timeout} seconds trying to connect to #{address}"', ')', 'rescue', 'SystemCallError', ',', 'IOError', '=>', 'exception', 'message', '=', '"#connect Connection failure connecting to \'#{address.to_s}\': #{exception.class}: #{exception.message}"', 'logger', '.', 'error', 'message', 'if', 'respond_to?', '(', ':logger', ')', 'raise', 'ConnectionFailure', '.', 'new', '(', 'message', ',', 'address', '.', 'to_s', ',', 'exception', ')', 'end', 'end']
->Original Target:
['Connect', 'to', 'server']
->Reconstructed Target:
Connect to server
->Reconstructed Predication:
socket_connect ( socket, address) end
->Raw Input:
summarize:def socket_connect ( socket, address, timeout ) socket_address = Socket. pack_sockaddr_in ( address. port, address. ip_address ) return socket. connect ( socket_address ) if timeout == - 1 deadline = Time. now. utc + timeout begin non_blocking ( socket, deadline ) { socket. connect_nonblock ( socket_address ) } rescue Errno :: EISCONN rescue NonBlockingTimeout raise ConnectionTimeout. new ( "Timed out after #{timeout} seconds trying to connect to #{address}" ) rescue SystemCallError, IOError => exception message = "#connect Connection failure connecting to '#{address.to_s}': #{exception.class}: #{exception.message}" logger. error message if respond_to? ( :logger ) raise ConnectionFailure. new ( message, address. to_s, exception ) end end
->Raw Target:
Connect to server
--

471=========
->Original Input:
['def', 'socket_write', '(', 'data', ',', 'timeout', ')', 'if', 'timeout', '<', '0', 'socket', '.', 'write', '(', 'data', ')', 'else', 'deadline', '=', 'Time', '.', 'now', '.', 'utc', '+', 'timeout', 'length', '=', 'data', '.', 'bytesize', 'total_count', '=', '0', 'non_blocking', '(', 'socket', ',', 'deadline', ')', 'do', 'loop', 'do', 'begin', 'count', '=', 'socket', '.', 'write_nonblock', '(', 'data', ')', 'rescue', 'Errno', '::', 'EWOULDBLOCK', 'retry', 'end', 'total_count', '+=', 'count', 'return', 'total_count', 'if', 'total_count', '>=', 'length', 'data', '=', 'data', '.', 'byteslice', '(', 'count', '..', '-', '1', ')', 'end', 'end', 'end', 'rescue', 'NonBlockingTimeout', 'logger', '.', 'warn', '"#write Timeout after #{timeout} seconds"', 'if', 'respond_to?', '(', ':logger', ')', 'raise', 'WriteTimeout', '.', 'new', '(', '"Timed out after #{timeout} seconds trying to write to #{address}"', ')', 'rescue', 'SystemCallError', ',', 'IOError', '=>', 'exception', 'message', '=', '"#write Connection failure while writing to \'#{address.to_s}\': #{exception.class}: #{exception.message}"', 'logger', '.', 'error', 'message', 'if', 'respond_to?', '(', ':logger', ')', 'raise', 'ConnectionFailure', '.', 'new', '(', 'message', ',', 'address', '.', 'to_s', ',', 'exception', ')', 'end']
->Original Target:
['Write', 'to', 'the', 'socket']
->Reconstructed Target:
Write to the socket
->Reconstructed Predication:
to #{address} isto #{address} is notto #{address}" ) end end
->Raw Input:
summarize:def socket_write ( data, timeout ) if timeout < 0 socket. write ( data ) else deadline = Time. now. utc + timeout length = data. bytesize total_count = 0 non_blocking ( socket, deadline ) do loop do begin count = socket. write_nonblock ( data ) rescue Errno :: EWOULDBLOCK retry end total_count += count return total_count if total_count >= length data = data. byteslice ( count.. - 1 ) end end end rescue NonBlockingTimeout logger. warn "#write Timeout after #{timeout} seconds" if respond_to? ( :logger ) raise WriteTimeout. new ( "Timed out after #{timeout} seconds trying to write to #{address}" ) rescue SystemCallError, IOError => exception message = "#write Connection failure while writing to '#{address.to_s}': #{exception.class}: #{exception.message}" logger. error message if respond_to? ( :logger ) raise ConnectionFailure. new ( message, address. to_s, exception ) end
->Raw Target:
Write to the socket
--

472=========
->Original Input:
['def', 'ssl_connect', '(', 'socket', ',', 'address', ',', 'timeout', ')', 'ssl_context', '=', 'OpenSSL', '::', 'SSL', '::', 'SSLContext', '.', 'new', 'ssl_context', '.', 'set_params', '(', 'ssl', '.', 'is_a?', '(', 'Hash', ')', '?', 'ssl', ':', '{', '}', ')', 'ssl_socket', '=', 'OpenSSL', '::', 'SSL', '::', 'SSLSocket', '.', 'new', '(', 'socket', ',', 'ssl_context', ')', 'ssl_socket', '.', 'hostname', '=', 'address', '.', 'host_name', 'ssl_socket', '.', 'sync_close', '=', 'true', 'begin', 'if', 'timeout', '==', '-', '1', 'ssl_socket', '.', 'connect', 'else', 'deadline', '=', 'Time', '.', 'now', '.', 'utc', '+', 'timeout', 'begin', 'non_blocking', '(', 'socket', ',', 'deadline', ')', '{', 'ssl_socket', '.', 'connect_nonblock', '}', 'rescue', 'Errno', '::', 'EISCONN', 'rescue', 'NonBlockingTimeout', 'raise', 'ConnectionTimeout', '.', 'new', '(', '"SSL handshake Timed out after #{timeout} seconds trying to connect to #{address.to_s}"', ')', 'end', 'end', 'rescue', 'SystemCallError', ',', 'OpenSSL', '::', 'SSL', '::', 'SSLError', ',', 'IOError', '=>', 'exception', 'message', '=', '"#connect SSL handshake failure with \'#{address.to_s}\': #{exception.class}: #{exception.message}"', 'logger', '.', 'error', 'message', 'if', 'respond_to?', '(', ':logger', ')', 'raise', 'ConnectionFailure', '.', 'new', '(', 'message', ',', 'address', '.', 'to_s', ',', 'exception', ')', 'end', 'ssl_verify', '(', 'ssl_socket', ',', 'address', ')', 'if', 'ssl_context', '.', 'verify_mode', '!=', 'OpenSSL', '::', 'SSL', '::', 'VERIFY_NONE', 'ssl_socket', 'end']
->Original Target:
['Try', 'connecting', 'to', 'a', 'single', 'server', 'Returns', 'the', 'connected', 'socket']
->Reconstructed Target:
Try connecting to a single server Returns the connected socket
->Reconstructed Predication:
ssl_socket. connectssl_socket.ssl_socket.ssl_socket.end
->Raw Input:
summarize:def ssl_connect ( socket, address, timeout ) ssl_context = OpenSSL :: SSL :: SSLContext. new ssl_context. set_params ( ssl. is_a? ( Hash )? ssl : { } ) ssl_socket = OpenSSL :: SSL :: SSLSocket. new ( socket, ssl_context ) ssl_socket. hostname = address. host_name ssl_socket. sync_close = true begin if timeout == - 1 ssl_socket. connect else deadline = Time. now. utc + timeout begin non_blocking ( socket, deadline ) { ssl_socket. connect_nonblock } rescue Errno :: EISCONN rescue NonBlockingTimeout raise ConnectionTimeout. new ( "SSL handshake Timed out after #{timeout} seconds trying to connect to #{address.to_s}" ) end end rescue SystemCallError, OpenSSL :: SSL :: SSLError, IOError => exception message = "#connect SSL handshake failure with '#{address.to_s}': #{exception.class}: #{exception.message}" logger. error message if respond_to? ( :logger ) raise ConnectionFailure. new ( message, address. to_s, exception ) end ssl_verify ( ssl_socket, address ) if ssl_context. verify_mode!= OpenSSL :: SSL :: VERIFY_NONE ssl_socket end
->Raw Target:
Try connecting to a single server Returns the connected socket
--

473=========
->Original Input:
['def', 'party_mode', 'new_master', '=', 'nil', 'return', 'nil', 'unless', 'speakers', '.', 'length', '>', '1', 'new_master', '=', 'find_party_master', 'if', 'new_master', '.', 'nil?', 'party_over', 'speakers', '.', 'each', 'do', '|', 'slave', '|', 'next', 'if', 'slave', '.', 'uid', '==', 'new_master', '.', 'uid', 'slave', '.', 'join', 'new_master', 'end', 'rescan', '@topology', 'end']
->Original Target:
['Party', 'Mode!', 'Join', 'all', 'speakers', 'into', 'a', 'single', 'group', '.']
->Reconstructed Target:
Party Mode! Join all speakers into a single group.
->Reconstructed Predication:
the speakers to the new master
->Raw Input:
summarize:def party_mode new_master = nil return nil unless speakers. length > 1 new_master = find_party_master if new_master. nil? party_over speakers. each do | slave | next if slave. uid == new_master. uid slave. join new_master end rescan @topology end
->Raw Target:
Party Mode! Join all speakers into a single group.
--

474=========
->Original Input:
['def', 'discover', 'result', '=', 'SSDP', '::', 'Consumer', '.', 'new', '.', 'search', '(', 'service', ':', "'urn:schemas-upnp-org:device:ZonePlayer:1'", ',', 'first_only', ':', 'true', ',', 'timeout', ':', '@timeout', ',', 'filter', ':', 'lambda', '{', '|', 'r', '|', 'r', '[', ':params', ']', '[', '"ST"', ']', '.', 'match', '(', '/', '/', ')', '}', ')', '@first_device_ip', '=', 'result', '[', ':address', ']', 'end']
->Original Target:
['Look', 'for', 'Sonos', 'devices', 'on', 'the', 'network', 'and', 'return', 'the', 'first', 'IP', 'address', 'found']
->Reconstructed Target:
Look for Sonos devices on the network and return the first IP address found
->Reconstructed Predication:
the first devicethe first device is detected.
->Raw Input:
summarize:def discover result = SSDP :: Consumer. new. search ( service : 'urn:schemas-upnp-org:device:ZonePlayer:1', first_only : true, timeout : @timeout, filter : lambda { | r | r [ :params ] [ "ST" ]. match ( / / ) } ) @first_device_ip = result [ :address ] end
->Raw Target:
Look for Sonos devices on the network and return the first IP address found
--

475=========
->Original Input:
['def', 'topology', 'self', '.', 'discover', 'unless', '@first_device_ip', 'return', '[', ']', 'unless', '@first_device_ip', 'doc', '=', 'Nokogiri', '::', 'XML', '(', 'open', '(', '"http://#{@first_device_ip}:#{Sonos::PORT}/status/topology"', ')', ')', 'doc', '.', 'xpath', '(', "'//ZonePlayers/ZonePlayer'", ')', '.', 'map', 'do', '|', 'node', '|', 'TopologyNode', '.', 'new', '(', 'node', ')', 'end', 'end']
->Original Target:
['Find', 'all', 'of', 'the', 'Sonos', 'devices', 'on', 'the', 'network']
->Reconstructed Target:
Find all of the Sonos devices on the network
->Reconstructed Predication:
the topology of the first device
->Raw Input:
summarize:def topology self. discover unless @first_device_ip return [ ] unless @first_device_ip doc = Nokogiri :: XML ( open ( "http://#{@first_device_ip}:#{Sonos::PORT}/status/topology" ) ) doc. xpath ( '//ZonePlayers/ZonePlayer' ). map do | node | TopologyNode. new ( node ) end end
->Raw Target:
Find all of the Sonos devices on the network
--

476=========
->Original Input:
['def', 'find', '(', 'id', ')', 'response', '=', 'RestClient', '.', 'get', '(', '"#{@type.Resource}/#{id}"', ')', 'singular_resource', '=', '@type', '.', 'Resource', '[', '0', '...', '-', '1', ']', 'if', 'response', '.', 'body', '[', 'singular_resource', ']', '.', 'nil?', 'raise', 'ArgumentError', ',', "'Resource not found'", 'end', 'type', '.', 'new', '.', 'from_json', '(', 'response', '.', 'body', '[', 'singular_resource', ']', '.', 'to_json', ')', 'end']
->Original Target:
['Find', 'a', 'single', 'resource', 'by', 'the', 'resource', 'id']
->Reconstructed Target:
Find a single resource by the resource id
->Reconstructed Predication:
the resource with the given id
->Raw Input:
summarize:def find ( id ) response = RestClient. get ( "#{@type.Resource}/#{id}" ) singular_resource = @type. Resource [ 0... - 1 ] if response. body [ singular_resource ]. nil? raise ArgumentError, 'Resource not found' end type. new. from_json ( response. body [ singular_resource ]. to_json ) end
->Raw Target:
Find a single resource by the resource id
--

477=========
->Original Input:
['def', 'all', 'list', '=', '[', ']', 'page', '=', '1', 'fetch_all', '=', 'true', 'if', '@query', '.', 'has_key?', '(', ':page', ')', 'page', '=', '@query', '[', ':page', ']', 'fetch_all', '=', 'false', 'end', 'while', 'true', 'response', '=', 'RestClient', '.', 'get', '(', '@type', '.', 'Resource', ',', '@query', ')', 'data', '=', 'response', '.', 'body', '[', '@type', '.', 'Resource', ']', 'if', '!', 'data', '.', 'empty?', 'data', '.', 'each', '{', '|', 'item', '|', 'list', '<<', '@type', '.', 'new', '.', 'from_json', '(', 'item', '.', 'to_json', ')', '}', 'if', '!', 'fetch_all', 'break', 'else', 'where', '(', 'page', ':', 'page', '+=', '1', ')', 'end', 'else', 'break', 'end', 'end', 'return', 'list', 'end']
->Original Target:
['Get', 'all', 'resources', 'from', 'a', 'query', 'by', 'paging', 'through', 'data']
->Reconstructed Target:
Get all resources from a query by paging through data
->Reconstructed Predication:
the list of items tothe page you want topage : page )
->Raw Input:
summarize:def all list = [ ] page = 1 fetch_all = true if @query. has_key? ( :page ) page = @query [ :page ] fetch_all = false end while true response = RestClient. get ( @type. Resource, @query ) data = response. body [ @type. Resource ] if! data. empty? data. each { | item | list << @type. new. from_json ( item. to_json ) } if! fetch_all break else where ( page : page += 1 ) end else break end end return list end
->Raw Target:
Get all resources from a query by paging through data
--

478=========
->Original Input:
['def', 'validate', '(', 'form', ')', 'property', '=', 'attributes', '.', 'first', 'record', '=', 'form', '.', 'model_for_property', '(', 'property', ')', 'record', '.', 'send', '(', '"#{property}="', ',', 'form', '.', 'send', '(', 'property', ')', ')', '@klass', '=', 'record', '.', 'class', 'super', '(', 'record', ')', '.', 'tap', 'do', '|', 'res', '|', 'form', '.', 'errors', '.', 'add', '(', 'property', ',', 'record', '.', 'errors', '.', 'first', '.', 'last', ')', 'if', 'record', '.', 'errors', '.', 'present?', 'end', 'end']
->Original Target:
['when', 'calling', 'validates', 'it', 'should', 'create', 'the', 'Vali', 'instance', 'already', 'and', 'set']
->Reconstructed Target:
when calling validates it should create the Vali instance already and set
->Reconstructed Predication:
the form.  def
->Raw Input:
summarize:def validate ( form ) property = attributes. first record = form. model_for_property ( property ) record. send ( "#{property}=", form. send ( property ) ) @klass = record. class super ( record ). tap do | res | form. errors. add ( property, record. errors. first. last ) if record. errors. present? end end
->Raw Target:
when calling validates it should create the Vali instance already and set
--

479=========
->Original Input:
['def', 'validates', '(', '*', 'args', ',', '&', 'block', ')', 'validation', '(', 'name', ':', ':default', ',', 'inherit', ':', 'true', ')', '{', 'validates', '*', 'args', ',', '&', 'block', '}', 'end']
->Original Target:
['moved', 'from', 'reform', 'as', 'not', 'applicable', 'to', 'dry']
->Reconstructed Target:
moved from reform as not applicable to dry
->Reconstructed Predication:
validation block for the givenblock to be validated with the
->Raw Input:
summarize:def validates ( * args, & block ) validation ( name : :default, inherit : true ) { validates * args, & block } end
->Raw Target:
moved from reform as not applicable to dry
--

480=========
->Original Input:
['def', 'update_xml', '(', 'xml', ',', 'value', ')', 'wrap', '(', 'xml', ')', '.', 'tap', 'do', '|', 'xml', '|', 'if', 'content?', 'add', '(', 'xml', ',', 'value', ')', 'elsif', 'name?', 'xml', '.', 'name', '=', 'value', 'elsif', 'array?', 'value', '.', 'each', 'do', '|', 'v', '|', 'add', '(', 'XML', '.', 'add_node', '(', 'xml', ',', 'name', ')', ',', 'v', ')', 'end', 'else', 'add', '(', 'XML', '.', 'add_node', '(', 'xml', ',', 'name', ')', ',', 'value', ')', 'end', 'end', 'end']
->Original Target:
['Updates', 'the', 'text', 'in', 'the', 'given', '_xml_', 'block', 'to', 'the', '_value_', 'provided', '.']
->Reconstructed Target:
Updates the text in the given _xml_ block to the _value_ provided.
->Reconstructed Predication:
the xml to be updated
->Raw Input:
summarize:def update_xml ( xml, value ) wrap ( xml ). tap do | xml | if content? add ( xml, value ) elsif name? xml. name = value elsif array? value. each do | v | add ( XML. add_node ( xml, name ), v ) end else add ( XML. add_node ( xml, name ), value ) end end end
->Raw Target:
Updates the text in the given _xml_ block to the _value_ provided.
--

481=========
->Original Input:
['def', 'ipmt', '(', 'rate', ',', 'per', ',', 'nper', ',', 'pv', ',', 'fv', '=', '0', ',', 'end_or_beginning', '=', '0', ')', 'pmt', '=', 'self', '.', 'pmt', '(', 'rate', ',', 'nper', ',', 'pv', ',', 'fv', ',', 'end_or_beginning', ')', 'fv', '=', 'self', '.', 'fv', '(', 'rate', ',', '(', 'per', '-', '1', ')', ',', 'pmt', ',', 'pv', ',', 'end_or_beginning', ')', '*', 'rate', 'temp', '=', 'end_or_beginning', '==', '1', '?', 'fv', '/', '(', '1', '+', 'rate', ')', ':', 'fv', '(', 'per', '==', '1', '&&', 'end_or_beginning', '==', '1', ')', '?', '0.0', ':', 'temp', 'end']
->Original Target:
['Calculates', 'the', 'payment', 'on', 'interest', 'for', 'an', 'investment', 'based', 'on', 'constant', '-', 'amount', 'periodic', 'payments', 'and', 'a', 'constant', 'interest', 'rate', '.']
->Reconstructed Target:
Calculates the payment on interest for an investment based on constant - amount periodic payments and a constant interest rate.
->Reconstructed Predication:
pmt = 0 nper =nper = 0 end_or_beginning = 0pmt = pmt +pmt + nper +pmt + nper +
->Raw Input:
summarize:def ipmt ( rate, per, nper, pv, fv = 0, end_or_beginning = 0 ) pmt = self. pmt ( rate, nper, pv, fv, end_or_beginning ) fv = self. fv ( rate, ( per - 1 ), pmt, pv, end_or_beginning ) * rate temp = end_or_beginning == 1? fv / ( 1 + rate ) : fv ( per == 1 && end_or_beginning == 1 )? 0.0 : temp end
->Raw Target:
Calculates the payment on interest for an investment based on constant - amount periodic payments and a constant interest rate.
--

482=========
->Original Input:
['def', 'nper', '(', 'rate', ',', 'pmt', ',', 'pv', ',', 'fv', '=', '0', ',', 'end_or_beginning', '=', '0', ')', 'z', '=', 'pmt', '*', '(', '1', '+', 'rate', '*', 'end_or_beginning', ')', '/', 'rate', 'temp', '=', 'Math', '.', 'log', '(', '(', '-', 'fv', '+', 'z', ')', '/', '(', 'pv', '+', 'z', ')', ')', 'temp', '/', 'Math', '.', 'log', '(', '1', '+', 'rate', ')', 'end']
->Original Target:
['Calculates', 'the', 'number', 'of', 'payment', 'periods', 'for', 'an', 'investment', 'based', 'on', 'constant', '-', 'amount', 'periodic', 'payments', 'and', 'a', 'constant', 'interest', 'rate', '.']
->Reconstructed Target:
Calculates the number of payment periods for an investment based on constant - amount periodic payments and a constant interest rate.
->Reconstructed Predication:
the number of samples to
->Raw Input:
summarize:def nper ( rate, pmt, pv, fv = 0, end_or_beginning = 0 ) z = pmt * ( 1 + rate * end_or_beginning ) / rate temp = Math. log ( ( - fv + z ) / ( pv + z ) ) temp / Math. log ( 1 + rate ) end
->Raw Target:
Calculates the number of payment periods for an investment based on constant - amount periodic payments and a constant interest rate.
--

483=========
->Original Input:
['def', 'pmt', '(', 'rate', ',', 'nper', ',', 'pv', ',', 'fv', '=', '0', ',', 'end_or_beginning', '=', '0', ')', 'temp', '=', '(', '1', '+', 'rate', ')', '**', 'nper', 'fact', '=', '(', '1', '+', 'rate', '*', 'end_or_beginning', ')', '*', '(', 'temp', '-', '1', ')', '/', 'rate', '-', '(', 'fv', '+', 'pv', '*', 'temp', ')', '/', 'fact', 'end']
->Original Target:
['Calculates', 'the', 'periodic', 'payment', 'for', 'an', 'annuity', 'investment', 'based', 'on', 'constant', '-', 'amount', 'periodic', 'payments', 'and', 'a', 'constant', 'interest', 'rate', '.']
->Reconstructed Target:
Calculates the periodic payment for an annuity investment based on constant - amount periodic payments and a constant interest rate.
->Reconstructed Predication:
the pmt
->Raw Input:
summarize:def pmt ( rate, nper, pv, fv = 0, end_or_beginning = 0 ) temp = ( 1 + rate ) ** nper fact = ( 1 + rate * end_or_beginning ) * ( temp - 1 ) / rate - ( fv + pv * temp ) / fact end
->Raw Target:
Calculates the periodic payment for an annuity investment based on constant - amount periodic payments and a constant interest rate.
--

484=========
->Original Input:
['def', 'rate', '(', 'nper', ',', 'pmt', ',', 'pv', ',', 'fv', '=', '0', ',', 'end_or_beginning', '=', '0', ',', 'rate_guess', '=', '0.10', ')', 'guess', '=', 'rate_guess', 'tolerancy', '=', '1e-6', 'close', '=', 'false', 'begin', 'temp', '=', 'newton_iter', '(', 'guess', ',', 'nper', ',', 'pmt', ',', 'pv', ',', 'fv', ',', 'end_or_beginning', ')', 'next_guess', '=', '(', 'guess', '-', 'temp', ')', '.', 'round', '(', '20', ')', 'diff', '=', '(', 'next_guess', '-', 'guess', ')', '.', 'abs', 'close', '=', 'diff', '<', 'tolerancy', 'guess', '=', 'next_guess', 'end', 'while', '!', 'close', 'next_guess', 'end']
->Original Target:
['Calculates', 'the', 'interest', 'rate', 'of', 'an', 'annuity', 'investment', 'based', 'on', 'constant', '-', 'amount', 'periodic', 'payments', 'and', 'the', 'assumption', 'of', 'a', 'constant', 'interest', 'rate', '.']
->Reconstructed Target:
Calculates the interest rate of an annuity investment based on constant - amount periodic payments and the assumption of a constant interest rate.
->Reconstructed Predication:
pmt, pv, fv
->Raw Input:
summarize:def rate ( nper, pmt, pv, fv = 0, end_or_beginning = 0, rate_guess = 0.10 ) guess = rate_guess tolerancy = 1e-6 close = false begin temp = newton_iter ( guess, nper, pmt, pv, fv, end_or_beginning ) next_guess = ( guess - temp ). round ( 20 ) diff = ( next_guess - guess ). abs close = diff < tolerancy guess = next_guess end while! close next_guess end
->Raw Target:
Calculates the interest rate of an annuity investment based on constant - amount periodic payments and the assumption of a constant interest rate.
--

485=========
->Original Input:
['def', 'npv', '(', 'discount', ',', 'cashflows', ')', 'total', '=', '0', 'cashflows', '.', 'each_with_index', 'do', '|', 'cashflow', ',', 'index', '|', 'total', '+=', '(', 'cashflow', '.', 'to_f', '/', '(', '1', '+', 'discount', '.', 'to_f', ')', '**', '(', 'index', '+', '1', ')', ')', 'end', 'total', 'end']
->Original Target:
['Calculates', 'the', 'net', 'present', 'value', 'of', 'an', 'investment', 'based', 'on', 'a', 'series', 'of', 'periodic', 'cash', 'flows', 'and', 'a', 'discount', 'rate', '.']
->Reconstructed Target:
Calculates the net present value of an investment based on a series of periodic cash flows and a discount rate.
->Reconstructed Predication:
summarize discount discount
->Raw Input:
summarize:def npv ( discount, cashflows ) total = 0 cashflows. each_with_index do | cashflow, index | total += ( cashflow. to_f / ( 1 + discount. to_f ) ** ( index + 1 ) ) end total end
->Raw Target:
Calculates the net present value of an investment based on a series of periodic cash flows and a discount rate.
--

486=========
->Original Input:
['def', 'irr', '(', 'values', ')', 'func', '=', 'Helpers', '::', 'IrrHelper', '.', 'new', '(', 'values', ')', 'guess', '=', '[', 'func', '.', 'eps', ']', 'nlsolve', '(', 'func', ',', 'guess', ')', 'guess', '[', '0', ']', 'end']
->Original Target:
['Calculates', 'the', 'internal', 'rate', 'of', 'return', 'on', 'an', 'investment', 'based', 'on', 'a', 'series', 'of', 'periodic', 'cash', 'flows', '.']
->Reconstructed Target:
Calculates the internal rate of return on an investment based on a series of periodic cash flows.
->Reconstructed Predication:
the values to be used for
->Raw Input:
summarize:def irr ( values ) func = Helpers :: IrrHelper. new ( values ) guess = [ func. eps ] nlsolve ( func, guess ) guess [ 0 ] end
->Raw Target:
Calculates the internal rate of return on an investment based on a series of periodic cash flows.
--

487=========
->Original Input:
['def', 'newton_iter', '(', 'r', ',', 'n', ',', 'p', ',', 'x', ',', 'y', ',', 'w', ')', 't1', '=', '(', 'r', '+', '1', ')', '**', 'n', 't2', '=', '(', 'r', '+', '1', ')', '**', '(', 'n', '-', '1', ')', '(', '(', 'y', '+', 't1', '*', 'x', '+', 'p', '*', '(', 't1', '-', '1', ')', '*', '(', 'r', '*', 'w', '+', '1', ')', '/', 'r', ')', '/', '(', 'n', '*', 't2', '*', 'x', '-', 'p', '*', '(', 't1', '-', '1', ')', '*', '(', 'r', '*', 'w', '+', '1', ')', '/', '(', 'r', '**', '2', ')', '+', 'n', '*', 'p', '*', 't2', '*', '(', 'r', '*', 'w', '+', '1', ')', '/', 'r', '+', 'p', '*', '(', 't1', '-', '1', ')', '*', 'w', '/', 'r', ')', ')', 'end']
->Original Target:
['This', 'method', 'was', 'borrowed', 'from', 'the', 'NumPy', 'rate', 'formula', 'which', 'was', 'generated', 'by', 'Sage']
->Reconstructed Target:
This method was borrowed from the NumPy rate formula which was generated by Sage
->Reconstructed Predication:
thethethe newton iteration
->Raw Input:
summarize:def newton_iter ( r, n, p, x, y, w ) t1 = ( r + 1 ) ** n t2 = ( r + 1 ) ** ( n - 1 ) ( ( y + t1 * x + p * ( t1 - 1 ) * ( r * w + 1 ) / r ) / ( n * t2 * x - p * ( t1 - 1 ) * ( r * w + 1 ) / ( r ** 2 ) + n * p * t2 * ( r * w + 1 ) / r + p * ( t1 - 1 ) * w / r ) ) end
->Raw Target:
This method was borrowed from the NumPy rate formula which was generated by Sage
--

488=========
->Original Input:
['def', 'event_summary', '(', 'trim_at', '=', '100', ')', 'summary', '=', '@event', '[', "'check'", ']', '[', "'notification'", ']', '||', '@event', '[', "'check'", ']', '[', "'description'", ']', 'if', 'summary', '.', 'nil?', 'source', '=', '@event', '[', "'check'", ']', '[', "'source'", ']', '||', '@event', '[', "'client'", ']', '[', "'name'", ']', 'event_context', '=', '[', 'source', ',', '@event', '[', "'check'", ']', '[', "'name'", ']', ']', '.', 'join', '(', "'/'", ')', 'output', '=', '@event', '[', "'check'", ']', '[', "'output'", ']', '.', 'chomp', 'output', '=', 'output', '.', 'length', '>', 'trim_at', '?', 'output', '[', '0', '..', 'trim_at', ']', '+', "'...'", ':', 'output', 'summary', '=', '[', 'event_context', ',', 'output', ']', '.', 'join', '(', "' : '", ')', 'end', 'summary', 'end']
->Original Target:
['Helpers', 'and', 'filters', '.']
->Reconstructed Target:
Helpers and filters.
->Reconstructed Predication:
summary of the event
->Raw Input:
summarize:def event_summary ( trim_at = 100 ) summary = @event [ 'check' ] [ 'notification' ] || @event [ 'check' ] [ 'description' ] if summary. nil? source = @event [ 'check' ] ['source' ] || @event [ 'client' ] [ 'name' ] event_context = [ source, @event [ 'check' ] [ 'name' ] ]. join ( '/' ) output = @event [ 'check' ] [ 'output' ]. chomp output = output. length > trim_at? output [ 0.. trim_at ] + '...' : output summary = [ event_context, output ]. join (':') end summary end
->Raw Target:
Helpers and filters.
--

489=========
->Original Input:
['def', 'load', '@io', '.', 'rewind', 'header_block', '=', '@io', '.', 'read', '512', '@header', '=', 'Header', '.', 'new', 'header_block', '@bbat', '=', 'AllocationTable', '::', 'Big', '.', 'new', 'self', 'bbat_chain', '=', 'header_block', '[', 'Header', '::', 'SIZE', '..', '-', '1', ']', '.', 'unpack', "'V*'", 'mbat_block', '=', '@header', '.', 'mbat_start', '@header', '.', 'num_mbat', '.', 'times', 'do', 'blocks', '=', '@bbat', '.', 'read', '(', '[', 'mbat_block', ']', ')', '.', 'unpack', "'V*'", 'mbat_block', '=', 'blocks', '.', 'pop', 'bbat_chain', '+=', 'blocks', 'end', '@bbat', '.', 'load', '@bbat', '.', 'read', '(', 'bbat_chain', '[', '0', ',', '@header', '.', 'num_bat', ']', ')', '@dirents', '=', '@bbat', '.', 'read', '(', '@header', '.', 'dirent_start', ')', '.', 'to_enum', '(', ':each_chunk', ',', 'Dirent', '::', 'SIZE', ')', '.', 'map', '{', '|', 'str', '|', 'Dirent', '.', 'new', 'self', ',', 'str', '}', 'class', '<<', '@dirents', 'def', 'to_tree', 'idx', '=', '0', 'return', '[', ']', 'if', 'idx', '==', 'Dirent', '::', 'EOT', 'd', '=', 'self', '[', 'idx', ']', 'to_tree', '(', 'd', '.', 'child', ')', '.', 'each', '{', '|', 'child', '|', 'd', '<<', 'child', '}', 'raise', 'FormatError', ',', '"directory #{d.inspect} used twice"', 'if', 'd', '.', 'idx', 'd', '.', 'idx', '=', 'idx', 'to_tree', '(', 'd', '.', 'prev', ')', '+', '[', 'd', ']', '+', 'to_tree', '(', 'd', '.', 'next', ')', 'end', 'end', '@root', '=', '@dirents', '.', 'to_tree', '.', 'first', '@dirents', '.', 'reject!', '{', '|', 'd', '|', 'd', '.', 'type_id', '==', '0', '}', 'unused', '=', '@dirents', '.', 'reject', '(', '&', ':idx', ')', '.', 'length', 'Log', '.', 'warn', '"#{unused} unused directories"', 'if', 'unused', '>', '0', '@sb_file', '=', 'RangesIOResizeable', '.', 'new', '@bbat', ',', ':first_block', '=>', '@root', '.', 'first_block', ',', ':size', '=>', '@root', '.', 'size', '@sbat', '=', 'AllocationTable', '::', 'Small', '.', 'new', 'self', '@sbat', '.', 'load', '@bbat', '.', 'read', '(', '@header', '.', 'sbat_start', ')', 'end']
->Original Target:
['load', 'document', 'from', 'file', '.']
->Reconstructed Target:
load document from file.
->Reconstructed Predication:
. size. size. size. size. size. size. size. size. size. size. size. size. size. sizesizesizesizesizesizesizesizesizesizesize }
->Raw Input:
summarize:def load @io. rewind header_block = @io. read 512 @header = Header. new header_block @bbat = AllocationTable :: Big. new self bbat_chain = header_block [ Header :: SIZE.. - 1 ]. unpack 'V*' mbat_block = @header. mbat_start @header. num_mbat. times do blocks = @bbat. read ( [ mbat_block ] ). unpack 'V*' mbat_block = blocks. pop bbat_chain += blocks end @bbat. load @bbat. read ( bbat_chain [ 0, @header. num_bat ] ) @dirents = @bbat. read ( @header. dirent_start ). to_enum ( :each_chunk, Dirent :: SIZE ). map { | str | Dirent. new self, str } class << @dirents def to_tree idx = 0 return [ ] if idx == Dirent :: EOT d = self [ idx ] to_tree ( d. child ). each { | child | d << child } raise FormatError, "directory #{d.inspect} used twice" if d. idx d. idx = idx to_tree ( d. prev ) + [ d ] + to_tree ( d. next ) end end @root = @dirents. to_tree. first @dirents. reject! { | d | d. type_id == 0 } unused = @dirents. reject ( & :idx ). length Log. warn "#{unused} unused directories" if unused > 0 @sb_file = RangesIOResizeable. new @bbat, :first_block => @root. first_block, :size => @root. size @sbat = AllocationTable :: Small. new self @sbat. load @bbat. read ( @header. sbat_start ) end
->Raw Target:
load document from file.
--

490=========
->Original Input:
['def', 'repack', 'temp', '=', ':file', 'case', 'temp', 'when', ':file', 'Tempfile', '.', 'open', "'ole-repack'", 'do', '|', 'io', '|', 'io', '.', 'binmode', 'repack_using_io', 'io', 'end', 'when', ':mem', ';', 'StringIO', '.', 'open', '(', "''", '.', 'dup', ',', '&', 'method', '(', ':repack_using_io', ')', ')', 'else', 'raise', 'ArgumentError', ',', '"unknown temp backing #{temp.inspect}"', 'end', 'end']
->Original Target:
['could', 'be', 'useful', 'with', 'mis', '-', 'behaving', 'ole', 'documents', '.', 'or', 'to', 'just', 'clean', 'them', 'up', '.']
->Reconstructed Target:
could be useful with mis - behaving ole documents. or to just clean them up.
->Reconstructed Predication:
repacks the file with thethe file with the
->Raw Input:
summarize:def repack temp = :file case temp when :file Tempfile. open 'ole-repack' do | io | io. binmode repack_using_io io end when :mem ; StringIO. open ( ''. dup, & method ( :repack_using_io ) ) else raise ArgumentError, "unknown temp backing #{temp.inspect}" end end
->Raw Target:
could be useful with mis - behaving ole documents. or to just clean them up.
--

491=========
->Original Input:
['def', 'load_relation', '(', 'relationship', ',', 'position', '=', 'nil', ')', 'if', 'objects', '=', '@resource', '.', 'dig', '(', '"_embedded"', ',', 'relationship', ')', 'location', '=', 'position', '?', 'objects', '[', 'position', ']', ':', 'objects', 'begin', 'WpApiClient', '::', 'Collection', '.', 'new', '(', 'location', ')', 'rescue', 'WpApiClient', '::', 'ErrorResponse', 'load_from_links', '(', 'relationship', ',', 'position', ')', 'end', 'else', 'load_from_links', '(', 'relationship', ',', 'position', ')', 'end', 'end']
->Original Target:
['try', 'to', 'load', 'an', 'embedded', 'object', ';', 'call', 'out', 'to', 'the', 'API', 'if', 'not']
->Reconstructed Target:
try to load an embedded object ; call out to the API if not
->Reconstructed Predication:
the relation to the specified
->Raw Input:
summarize:def load_relation ( relationship, position = nil ) if objects = @resource. dig ( "_embedded", relationship ) location = position? objects [ position ] : objects begin WpApiClient :: Collection. new ( location ) rescue WpApiClient :: ErrorResponse load_from_links ( relationship, position ) end else load_from_links ( relationship, position ) end end
->Raw Target:
try to load an embedded object ; call out to the API if not
--

492=========
->Original Input:
['def', 'native_representation_of', '(', 'response_body', ')', 'if', 'response_body', '.', 'is_a?', 'Array', 'WpApiClient', '::', 'Collection', '.', 'new', '(', 'response_body', ',', '@headers', ')', 'else', 'WpApiClient', '::', 'Entities', '::', 'Base', '.', 'build', '(', 'response_body', ')', 'end', 'end']
->Original Target:
['Take', 'the', 'API', 'response', 'and', 'figure', 'out', 'what', 'it', 'is']
->Reconstructed Target:
Take the API response and figure out what it is
->Reconstructed Predication:
the response body as a JSON
->Raw Input:
summarize:def native_representation_of ( response_body ) if response_body. is_a? Array WpApiClient :: Collection. new ( response_body, @headers ) else WpApiClient :: Entities :: Base. build ( response_body ) end end
->Raw Target:
Take the API response and figure out what it is
--

493=========
->Original Input:
['def', 'call_func', '(', 'method', ':', ',', 'params', ':', '[', ']', ',', 'tx', ':', '{', '}', ')', 'data', ',', 'output_types', '=', 'function_data_with_ot', '(', 'method', ',', '*', 'params', ')', 'resp', '=', '@rpc', '.', 'call_rpc', '(', ':call', ',', 'params', ':', '[', 'tx', '.', 'merge', '(', 'data', ':', 'data', ',', 'to', ':', 'address', ')', ',', '"latest"', ']', ')', 'result', '=', 'resp', '[', '"result"', ']', 'data', '=', '[', 'Utils', '.', 'remove_hex_prefix', '(', 'result', ')', ']', '.', 'pack', '(', '"H*"', ')', 'return', 'if', 'data', '.', 'nil?', 're', '=', 'decode_abi', 'output_types', ',', 'data', 're', '.', 'length', '==', '1', '?', 're', '.', 'first', ':', 're', 'end']
->Original Target:
['call', 'contract', 'functions', 'by', 'rpc', 'call', 'method']
->Reconstructed Target:
call contract functions by rpc call method
->Reconstructed Predication:
the result of athe result of a call
->Raw Input:
summarize:def call_func ( method :, params : [ ], tx : { } ) data, output_types = function_data_with_ot ( method, * params ) resp = @rpc. call_rpc ( :call, params : [ tx. merge ( data : data, to : address ), "latest" ] ) result = resp [ "result" ] data = [ Utils. remove_hex_prefix ( result ) ]. pack ( "H*" ) return if data. nil? re = decode_abi output_types, data re. length == 1? re. first : re end
->Raw Target:
call contract functions by rpc call method
--

494=========
->Original Input:
['def', 'send_func', '(', 'tx', ':', ',', 'private_key', ':', ',', 'method', ':', ',', 'params', ':', '[', ']', ')', 'data', ',', '_output_types', '=', 'function_data_with_ot', '(', 'method', ',', '*', 'params', ')', 'transaction', '=', 'if', 'tx', '.', 'is_a?', '(', 'Hash', ')', 'Transaction', '.', 'from_hash', '(', 'tx', ')', 'else', 'tx', 'end', 'transaction', '.', 'data', '=', 'data', 'resp', '=', '@rpc', '.', 'send_transaction', '(', 'transaction', ',', 'private_key', ')', 'resp', '&.', 'dig', '(', '"result"', ')', 'end']
->Original Target:
['call', 'contract', 'functions', 'by', 'sendRawTransaction']
->Reconstructed Target:
call contract functions by sendRawTransaction
->Reconstructed Predication:
the transaction to the server
->Raw Input:
summarize:def send_func ( tx :, private_key :, method :, params : [ ] ) data, _output_types = function_data_with_ot ( method, * params ) transaction = if tx. is_a? ( Hash ) Transaction. from_hash ( tx ) else tx end transaction. data = data resp = @rpc. send_transaction ( transaction, private_key ) resp &. dig ( "result" ) end
->Raw Target:
call contract functions by sendRawTransaction
--

495=========
->Original Input:
['def', 'parse_url', 'uri', '=', 'URI', '.', 'parse', '(', '@url', ')', '@host', '=', 'uri', '.', 'host', '@port', '=', 'uri', '.', 'port', '@scheme', '=', 'uri', '.', 'scheme', 'end']
->Original Target:
['parse', 'url', 'to', 'host', 'port', 'and', 'scheme']
->Reconstructed Target:
parse url to host port and scheme
->Reconstructed Predication:
@url = URI. parse
->Raw Input:
summarize:def parse_url uri = URI. parse ( @url ) @host = uri. host @port = uri. port @scheme = uri. scheme end
->Raw Target:
parse url to host port and scheme
--

496=========
->Original Input:
['def', 'call_rpc', '(', 'method', ',', 'jsonrpc', ':', 'DEFAULT_JSONRPC', ',', 'params', ':', 'DEFAULT_PARAMS', ',', 'id', ':', 'DEFAULT_ID', ')', 'conn', '.', 'post', '(', '"/"', ',', 'rpc_params', '(', 'method', ',', 'jsonrpc', ':', 'jsonrpc', ',', 'params', ':', 'params', ',', 'id', ':', 'id', ')', ')', 'end']
->Original Target:
['wrapper', 'for', 'call', 'rpc', 'method']
->Reconstructed Target:
wrapper for call rpc method
->Reconstructed Predication:
the request to the server
->Raw Input:
summarize:def call_rpc ( method, jsonrpc : DEFAULT_JSONRPC, params : DEFAULT_PARAMS, id : DEFAULT_ID ) conn. post ( "/", rpc_params ( method, jsonrpc : jsonrpc, params : params, id : id ) ) end
->Raw Target:
wrapper for call rpc method
--

497=========
->Original Input:
['def', 'rpc_params', '(', 'method', ',', 'jsonrpc', ':', 'DEFAULT_JSONRPC', ',', 'params', ':', 'DEFAULT_PARAMS', ',', 'id', ':', 'DEFAULT_ID', ')', '{', 'jsonrpc', ':', 'jsonrpc', ',', 'id', ':', 'id', ',', 'method', ':', 'method', ',', 'params', ':', 'params', '}', '.', 'to_json', 'end']
->Original Target:
['wrapper', 'for', 'rpc', 'params']
->Reconstructed Target:
wrapper for rpc params
->Reconstructed Predication:
the method and the params to
->Raw Input:
summarize:def rpc_params ( method, jsonrpc : DEFAULT_JSONRPC, params : DEFAULT_PARAMS, id : DEFAULT_ID ) { jsonrpc : jsonrpc, id : id, method : method, params : params }. to_json end
->Raw Target:
wrapper for rpc params
--

498=========
->Original Input:
['def', 'conn', 'Faraday', '.', 'new', '(', 'url', ':', 'url', ')', 'do', '|', 'faraday', '|', 'faraday', '.', 'headers', '[', '"Content-Type"', ']', '=', '"application/json"', 'faraday', '.', 'request', ':url_encoded', 'faraday', '.', 'adapter', 'Faraday', '.', 'default_adapter', 'end', 'end']
->Original Target:
['wrapper', 'faraday', 'object', 'with', 'CITA', 'URL', 'and', 'Content', '-', 'Type']
->Reconstructed Target:
wrapper faraday object with CITA URL and Content - Type
->Reconstructed Predication:
the connection to the server
->Raw Input:
summarize:def conn Faraday. new ( url : url ) do | faraday | faraday. headers [ "Content-Type" ] = "application/json" faraday. request :url_encoded faraday. adapter Faraday. default_adapter end end
->Raw Target:
wrapper faraday object with CITA URL and Content - Type
--

499=========
->Original Input:
['def', 'transfer', '(', 'to', ':', ',', 'private_key', ':', ',', 'value', ':', ',', 'quota', ':', '30_000', ')', 'valid_until_block', '=', 'block_number', '[', '"result"', ']', '.', 'hex', '+', '88', 'meta_data', '=', 'get_meta_data', '(', '"latest"', ')', '[', '"result"', ']', 'version', '=', 'meta_data', '[', '"version"', ']', 'chain_id', '=', 'if', 'version', '.', 'zero?', 'meta_data', '[', '"chainId"', ']', 'elsif', 'version', '==', '1', 'meta_data', '[', '"chainIdV1"', ']', 'end', 'transaction', '=', 'Transaction', '.', 'new', '(', 'nonce', ':', 'Utils', '.', 'nonce', ',', 'valid_until_block', ':', 'valid_until_block', ',', 'chain_id', ':', 'chain_id', ',', 'to', ':', 'to', ',', 'value', ':', 'value', ',', 'quota', ':', 'quota', ',', 'version', ':', 'version', ')', 'send_transaction', '(', 'transaction', ',', 'private_key', ')', 'end']
->Original Target:
['easy', 'to', 'transfer', 'tokens']
->Reconstructed Target:
easy to transfer tokens
->Reconstructed Predication:
to : toto : to, value :: value, quota : quota
->Raw Input:
summarize:def transfer ( to :, private_key :, value :, quota : 30_000 ) valid_until_block = block_number [ "result" ]. hex + 88 meta_data = get_meta_data ( "latest" ) [ "result" ] version = meta_data [ "version" ] chain_id = if version. zero? meta_data [ "chainId" ] elsif version == 1 meta_data [ "chainIdV1" ] end transaction = Transaction. new ( nonce : Utils. nonce, valid_until_block : valid_until_block, chain_id : chain_id, to : to, value : value, quota : quota, version : version ) send_transaction ( transaction, private_key ) end
->Raw Target:
easy to transfer tokens
--

500=========
->Original Input:
['def', 'replace', '(', 'new', ')', 'if', 'String', '===', 'new', '@data', '.', 'replace', '(', 'JSON', '.', 'parse', '(', 'new', ')', ')', 'else', '@data', '.', 'replace', '(', 'new', ')', 'end', 'end']
->Original Target:
['Replace', 'the', 'current', 'storage', 'with', 'the', 'given', 'one', '.']
->Reconstructed Target:
Replace the current storage with the given one.
->Reconstructed Predication:
@data = new data  def
->Raw Input:
summarize:def replace ( new ) if String === new @data. replace ( JSON. parse ( new ) ) else @data. replace ( new ) end end
->Raw Target:
Replace the current storage with the given one.
--

501=========
->Original Input:
['def', 'to_json', 'io', '=', 'StringIO', '.', 'new', '(', '"{"', ')', 'io', '<<', 'JSON', '.', 'create_id', '.', 'to_json', '<<', '":"', '<<', 'self', '.', 'class', '.', 'name', '.', 'to_json', '<<', '","', '@data', '.', 'each', '{', '|', 'key', ',', 'value', '|', 'io', '<<', 'key', '.', 'to_json', '.', 'to_s', '<<', '":"', '<<', 'value', '.', 'to_json', '<<', '","', '}', 'io', '.', 'seek', '(', '-', '1', ',', 'IO', '::', 'SEEK_CUR', ')', 'io', '<<', '"}"', 'io', '.', 'string', 'end']
->Original Target:
['Convert', 'the', 'storage', 'to', 'JSON', '.']
->Reconstructed Target:
Convert the storage to JSON.
->Reconstructed Predication:
.
->Raw Input:
summarize:def to_json io = StringIO. new ( "{" ) io << JSON. create_id. to_json << ":" << self. class. name. to_json << "," @data. each { | key, value | io << key. to_json. to_s << ":" << value. to_json << "," } io. seek ( - 1, IO :: SEEK_CUR ) io << "}" io. string end
->Raw Target:
Convert the storage to JSON.
--

502=========
->Original Input:
['def', 'time', '(', 'label', ',', '&', 'block', ')', 'raise', 'ArgumentError', ',', '"no block given"', 'unless', 'block', '`', '`', 'begin', 'if', 'block', '.', 'arity', '==', '0', 'instance_exec', '(', '&', 'block', ')', 'else', 'block', '.', 'call', '(', 'self', ')', 'end', 'ensure', '`', '`', 'end', 'end']
->Original Target:
['Time', 'the', 'given', 'block', 'with', 'the', 'given', 'label', '.']
->Reconstructed Target:
Time the given block with the given label.
->Reconstructed Predication:
the time of the given block
->Raw Input:
summarize:def time ( label, & block ) raise ArgumentError, "no block given" unless block ` ` begin if block. arity == 0 instance_exec ( & block ) else block. call ( self ) end ensure ` ` end end
->Raw Target:
Time the given block with the given label.
--

503=========
->Original Input:
['def', 'group', '(', '*', 'args', ',', '&', 'block', ')', 'raise', 'ArgumentError', ',', '"no block given"', 'unless', 'block', '`', '`', 'begin', 'if', 'block', '.', 'arity', '==', '0', 'instance_exec', '(', '&', 'block', ')', 'else', 'block', '.', 'call', '(', 'self', ')', 'end', 'ensure', '`', '`', 'end', 'end']
->Original Target:
['Group', 'the', 'given', 'block', '.']
->Reconstructed Target:
Group the given block.
->Reconstructed Predication:
the group of the given elements
->Raw Input:
summarize:def group ( * args, & block ) raise ArgumentError, "no block given" unless block ` ` begin if block. arity == 0 instance_exec ( & block ) else block. call ( self ) end ensure ` ` end end
->Raw Target:
Group the given block.
--

504=========
->Original Input:
['def', 'group!', '(', '*', 'args', ',', '&', 'block', ')', 'return', 'unless', 'block_given?', '`', '`', 'begin', 'if', 'block', '.', 'arity', '==', '0', 'instance_exec', '(', '&', 'block', ')', 'else', 'block', '.', 'call', '(', 'self', ')', 'end', 'ensure', '`', '`', 'end', 'end']
->Original Target:
['Group', 'the', 'given', 'block', 'but', 'collapse', 'it', '.']
->Reconstructed Target:
Group the given block but collapse it.
->Reconstructed Predication:
the block to be used for
->Raw Input:
summarize:def group! ( * args, & block ) return unless block_given? ` ` begin if block. arity == 0 instance_exec ( & block ) else block. call ( self ) end ensure ` ` end end
->Raw Target:
Group the given block but collapse it.
--

505=========
->Original Input:
['def', 'authenticate!', 'options', '=', 'authentication_handler', '.', 'call', '(', 'self', ',', '@options', ')', '@options', '.', 'merge!', '(', 'options', ')', 'client', '.', 'config', '.', 'soap_header', '=', 'soap_headers', 'end']
->Original Target:
['Internal', 'Calls', 'the', 'authentication', 'handler', 'which', 'should', 'set']
->Reconstructed Target:
Internal Calls the authentication handler which should set
->Reconstructed Predication:
the client to authenticate the user
->Raw Input:
summarize:def authenticate! options = authentication_handler. call ( self, @options ) @options. merge! ( options ) client. config. soap_header = soap_headers end
->Raw Target:
Internal Calls the authentication handler which should set
--

506=========
->Original Input:
['def', 'new_with_uuid', '(', 'klass', ',', 'uuid', ')', 'if', 'klass', '.', 'is_a?', '(', 'String', ')', 'klass', '=', 'Object', '.', 'const_get', '(', 'klass', ')', 'end', 'object', '=', 'klass', '.', 'new', '(', 'self', ',', 'uuid', ')', 'object', '.', 'initialize_defaults', 'object', 'end']
->Original Target:
['Creates', 'a', 'new', 'object', 'with', 'given', 'UUID', '.']
->Reconstructed Target:
Creates a new object with given UUID.
->Reconstructed Predication:
a new object with a given
->Raw Input:
summarize:def new_with_uuid ( klass, uuid ) if klass. is_a? ( String ) klass = Object. const_get ( klass ) end object = klass. new ( self, uuid ) object. initialize_defaults object end
->Raw Target:
Creates a new object with given UUID.
--

507=========
->Original Input:
['def', 'new_reference_with_uuid', '(', 'path', ',', 'uuid', ',', 'source_tree', '=', ':group', ')', 'path', '=', 'Pathname', '.', 'new', '(', 'path', ')', 'ref', '=', 'self', '.', 'project', '.', 'new_with_uuid', '(', 'PBXFileReference', ',', 'uuid', ')', 'self', '.', 'children', '<<', 'ref', 'GroupableHelper', '.', 'set_path_with_source_tree', '(', 'ref', ',', 'path', ',', 'source_tree', ')', 'ref', '.', 'set_last_known_file_type', 'if', 'ref', '.', 'path', '.', 'include?', '(', "'/'", ')', 'ref', '.', 'name', '=', 'ref', '.', 'path', '.', 'split', '(', "'/'", ')', '.', 'last', 'end', 'if', 'File', '.', 'extname', '(', 'ref', '.', 'path', ')', '.', 'downcase', '==', "'.framework'", 'ref', '.', 'include_in_index', '=', 'nil', 'end', 'ref', 'end']
->Original Target:
['Creates', 'a', 'file', 'reference', 'with', 'given', 'UUID', '.']
->Reconstructed Target:
Creates a file reference with given UUID.
->Reconstructed Predication:
pathpath, source_tree = :group
->Raw Input:
summarize:def new_reference_with_uuid ( path, uuid, source_tree = :group ) path = Pathname. new ( path ) ref = self. project. new_with_uuid ( PBXFileReference, uuid ) self. children << ref GroupableHelper. set_path_with_source_tree ( ref, path, source_tree ) ref. set_last_known_file_type if ref. path. include? ( '/' ) ref. name = ref. path. split ( '/' ). last end if File. extname ( ref. path ). downcase == '.framework' ref. include_in_index = nil end ref end
->Raw Target:
Creates a file reference with given UUID.
--

508=========
->Original Input:
['def', 'add_file_reference_with_uuid', '(', 'file_ref', ',', 'uuid', ',', 'avoid_duplicates', '=', 'false', ')', 'if', 'avoid_duplicates', '&&', 'existing', '=', 'build_file', '(', 'file_ref', ')', 'existing', 'else', 'build_file', '=', 'project', '.', 'new_with_uuid', '(', 'PBXBuildFile', ',', 'uuid', ')', 'build_file', '.', 'file_ref', '=', 'file_ref', 'files', '.', 'insert', '(', '0', ',', 'build_file', ')', 'build_file', 'end', 'end']
->Original Target:
['Adds', 'the', 'file', 'reference', 'with', 'given', 'UUID', '.']
->Reconstructed Target:
Adds the file reference with given UUID.
->Reconstructed Predication:
file reference with uuid
->Raw Input:
summarize:def add_file_reference_with_uuid ( file_ref, uuid, avoid_duplicates = false ) if avoid_duplicates && existing = build_file ( file_ref ) existing else build_file = project. new_with_uuid ( PBXBuildFile, uuid ) build_file. file_ref = file_ref files. insert ( 0, build_file ) build_file end end
->Raw Target:
Adds the file reference with given UUID.
--

509=========
->Original Input:
['def', 'remove_seeds', 'removings', '=', 'self', '.', 'locks', '.', 'keys', '-', 'self', '.', 'seeds', '.', 'keys', 'removings', '.', 'each', 'do', '|', 'name', '|', 'say', '"Removing #{name} (#{self.locks[name].version})"', '.', 'red', 'dirname', '=', 'File', '.', 'join', '(', 'self', '.', 'root_path', ',', '"Seeds"', ',', 'name', ')', 'FileUtils', '.', 'rm_rf', '(', 'dirname', ')', 'end', 'end']
->Original Target:
['Removes', 'disused', 'seeds', '.']
->Reconstructed Target:
Removes disused seeds.
->Reconstructed Predication:
the list of seeds to
->Raw Input:
summarize:def remove_seeds removings = self. locks. keys - self. seeds. keys removings. each do | name | say "Removing #{name} (#{self.locks[name].version})". red dirname = File. join ( self. root_path, "Seeds", name ) FileUtils. rm_rf ( dirname ) end end
->Raw Target:
Removes disused seeds.
--

510=========
->Original Input:
['def', 'configure_phase', 'self', '.', 'project', '.', 'targets', '.', 'each', 'do', '|', 'target', '|', 'begin', 'phase', '=', 'target', '.', 'sources_build_phase', 'resource_phase', '=', 'target', '.', 'resources_build_phase', 'next', 'unless', 'phase', 'rescue', 'NoMethodError', 'next', 'end', 'phase', '.', 'files_references', '.', 'each', 'do', '|', 'file', '|', 'begin', 'file', '.', 'real_path', 'rescue', 'phase', '.', 'files', '.', 'each', 'do', '|', 'build_file', '|', 'phase', '.', 'files', '.', 'delete', '(', 'build_file', ')', 'if', 'build_file', '.', 'file_ref', '==', 'file', 'end', 'end', 'end', 'resource_phase', '.', 'files_references', '.', 'each', 'do', '|', 'file', '|', 'begin', 'file', '.', 'real_path', 'rescue', 'resource_phase', '.', 'files', '.', 'each', 'do', '|', 'build_file', '|', 'resource_phase', '.', 'files', '.', 'delete', '(', 'build_file', ')', 'if', 'build_file', '.', 'file_ref', '==', 'file', 'end', 'end', 'end', 'removings', '=', '[', ']', 'addings', '=', '[', ']', 'self', '.', 'targets', '.', 'keys', '.', 'sort', '.', 'each', 'do', '|', 'seed_name', '|', 'target_names', '=', 'self', '.', 'targets', '[', 'seed_name', ']', 'if', 'not', 'target_names', '.', 'include?', '(', 'target', '.', 'name', ')', 'removings', '<<', 'seed_name', 'if', 'not', 'removings', '.', 'include?', '(', 'seed_name', ')', 'else', 'addings', '<<', 'seed_name', 'if', 'not', 'addings', '.', 'include?', '(', 'seed_name', ')', 'end', 'end', 'self', '.', 'file_references', '.', 'each', 'do', '|', 'file', '|', 'removings', '.', 'each', 'do', '|', 'seed_names', '|', 'next', 'if', 'not', 'seed_names', '.', 'include?', '(', 'file', '.', 'parent', '.', 'name', ')', 'phase', '.', 'files', '.', 'each', 'do', '|', 'build_file', '|', 'phase', '.', 'files', '.', 'delete', '(', 'build_file', ')', 'if', 'build_file', '.', 'file_ref', '==', 'file', 'end', 'resource_phase', '.', 'files', '.', 'each', 'do', '|', 'build_file', '|', 'resource_phase', '.', 'files', '.', 'delete', '(', 'build_file', ')', 'if', 'build_file', '.', 'file_ref', '==', 'file', 'end', 'end', 'addings', '.', 'each', 'do', '|', 'seed_names', '|', 'next', 'if', 'file', '.', 'name', '.', 'end_with?', '".h"', 'next', 'if', 'not', 'seed_names', '.', 'include?', '(', 'file', '.', 'parent', '.', 'name', ')', 'uuid', '=', 'Xcodeproj', '::', 'uuid_with_name', '"#{target.name}:#{file.name}"', 'if', 'self', '.', 'valid_source_file?', '(', 'file', ')', 'phase', '.', 'add_file_reference_with_uuid', '(', 'file', ',', 'uuid', ',', 'true', ')', 'else', 'resource_phase', '.', 'add_file_reference_with_uuid', '(', 'file', ',', 'uuid', ',', 'true', ')', 'end', 'end', 'end', 'end', 'end']
->Original Target:
['Adds', 'file', 'references', 'to', 'the', 'Sources', 'Build', 'Phase', '.']
->Reconstructed Target:
Adds file references to the Sources Build Phase.
->Reconstructed Predication:
. project. targets.. each do |file_ref == file end end. each do |file_ref == file end end. each do |file_ref == file end end. each do |file_ref == file end end. each do |file_ref == file end end. each do |file_ref == file end end. each do |file_ref == file end end
->Raw Input:
summarize:def configure_phase self. project. targets. each do | target | begin phase = target. sources_build_phase resource_phase = target. resources_build_phase next unless phase rescue NoMethodError next end phase. files_references. each do | file | begin file. real_path rescue phase. files. each do | build_file | phase. files. delete ( build_file ) if build_file. file_ref == file end end end resource_phase. files_references. each do | file | begin file. real_path rescue resource_phase. files. each do | build_file | resource_phase. files. delete ( build_file ) if build_file. file_ref == file end end end removings = [ ] addings = [ ] self. targets. keys. sort. each do | seed_name | target_names = self. targets [ seed_name ] if not target_names. include? ( target. name ) removings << seed_name if not removings. include? ( seed_name ) else addings << seed_name if not addings. include? ( seed_name ) end end self. file_references. each do | file | removings. each do | seed_names | next if not seed_names. include? ( file. parent. name ) phase. files. each do | build_file | phase. files. delete ( build_file ) if build_file. file_ref == file end resource_phase. files. each do | build_file | resource_phase. files. delete ( build_file ) if build_file. file_ref == file end end addings. each do | seed_names | next if file. name. end_with? ".h" next if not seed_names. include? ( file. parent. name ) uuid = Xcodeproj :: uuid_with_name "#{target.name}:#{file.name}" if self. valid_source_file? ( file ) phase. add_file_reference_with_uuid ( file, uuid, true ) else resource_phase. add_file_reference_with_uuid ( file, uuid, true ) end end end end end
->Raw Target:
Adds file references to the Sources Build Phase.
--

511=========
->Original Input:
['def', 'valid_source_file?', 'filename', 'suffixs', '=', '[', '".h"', ',', '".c"', ',', '".m"', ',', '".mm"', ',', '".swift"', ',', '".cpp"', ']', 'suffixs', '.', 'each', 'do', '|', 'suffix', '|', 'return', 'true', 'if', 'filename', '.', 'name', '.', 'end_with?', 'suffix', 'end', 'return', 'false', 'end']
->Original Target:
['Determines', 'whether', 'there', 's', 'a', 'source', 'file', '.']
->Reconstructed Target:
Determines whether there s a source file.
->Reconstructed Predication:
file name is a valid source
->Raw Input:
summarize:def valid_source_file? filename suffixs = [ ".h", ".c", ".m", ".mm", ".swift", ".cpp" ] suffixs. each do | suffix | return true if filename. name. end_with? suffix end return false end
->Raw Target:
Determines whether there s a source file.
--

512=========
->Original Input:
['def', 'speller', 'return', '@speller', 'if', '@speller', 'begin', 'require', '"raspell"', 'rescue', 'LoadError', '$stderr', '.', 'puts', '"ERROR: Ruby gem \\"raspell\\" is not installed."', 'exit', '1', 'end', '@speller', '=', 'Aspell', '.', 'new', '(', '"en_US"', ')', '@speller', '.', 'suggestion_mode', '=', 'Aspell', '::', 'NORMAL', '@speller', '.', 'set_option', '(', '"mode"', ',', '"html"', ')', '@speller', 'end']
->Original Target:
['create', 'an', 'Aspell', 'speller', 'object']
->Reconstructed Target:
create an Aspell speller object
->Reconstructed Predication:
@speller = Aspell. new
->Raw Input:
summarize:def speller return @speller if @speller begin require "raspell" rescue LoadError $stderr. puts "ERROR: Ruby gem \"raspell\" is not installed." exit 1 end @speller = Aspell. new ( "en_US" ) @speller. suggestion_mode = Aspell :: NORMAL @speller. set_option ( "mode", "html" ) @speller end
->Raw Target:
create an Aspell speller object
--

513=========
->Original Input:
['def', 'files_to_check', 'files', '=', 'config', '[', '"check"', ']', '.', 'reduce', '(', '[', ']', ')', '{', '|', 'a', ',', 'e', '|', 'a', '+', 'Dir', '[', 'e', ']', '}', 'config', '[', '"ignore"', ']', '.', 'reduce', '(', 'files', ')', '{', '|', 'a', ',', 'e', '|', 'a', '-', 'Dir', '[', 'e', ']', '}', 'end']
->Original Target:
['evaluate', 'the', 'files', 'to', 'check']
->Reconstructed Target:
evaluate the files to check
->Reconstructed Predication:
files to check
->Raw Input:
summarize:def files_to_check files = config [ "check" ]. reduce ( [ ] ) { | a, e | a + Dir [ e ] } config [ "ignore" ]. reduce ( files ) { | a, e | a - Dir [ e ] } end
->Raw Target:
evaluate the files to check
--

514=========
->Original Input:
['def', 'read_spell_config', '(', 'file', ')', 'return', '{', '}', 'unless', 'File', '.', 'exist?', '(', 'file', ')', 'puts', '"Loading config file (#{file})..."', 'if', 'verbose', '==', 'true', 'require', '"yaml"', 'YAML', '.', 'load_file', '(', 'file', ')', 'end']
->Original Target:
['read', 'a', 'Yaml', 'config', 'file']
->Reconstructed Target:
read a Yaml config file
->Reconstructed Predication:
the configuration file to loadthe configuration file to load
->Raw Input:
summarize:def read_spell_config ( file ) return { } unless File. exist? ( file ) puts "Loading config file (#{file})..." if verbose == true require "yaml" YAML. load_file ( file ) end
->Raw Target:
read a Yaml config file
--

515=========
->Original Input:
['def', 'report_duplicates', '(', 'dict1', ',', 'dict2', ')', 'duplicates', '=', 'dict1', '&', 'dict2', 'return', 'if', 'duplicates', '.', 'empty?', '$stderr', '.', 'puts', '"Warning: Found dictionary duplicates in the local dictionary "', '"(#{CUSTOM_SPELL_CONFIG_FILE}):\\n"', 'duplicates', '.', 'each', '{', '|', 'duplicate', '|', '$stderr', '.', 'puts', '"  #{duplicate}"', '}', '$stderr', '.', 'puts', 'end']
->Original Target:
['print', 'the', 'duplicate', 'dictionary', 'entries']
->Reconstructed Target:
print the duplicate dictionary entries
->Reconstructed Predication:
the dictionary duplicates in the
->Raw Input:
summarize:def report_duplicates ( dict1, dict2 ) duplicates = dict1 & dict2 return if duplicates. empty? $stderr. puts "Warning: Found dictionary duplicates in the local dictionary " "(#{CUSTOM_SPELL_CONFIG_FILE}):\n" duplicates. each { | duplicate | $stderr. puts "  #{duplicate}" } $stderr. puts end
->Raw Target:
print the duplicate dictionary entries
--

516=========
->Original Input:
['def', 'config', 'return', '@config', 'if', '@config', '@config', '=', 'read_spell_config', '(', 'GLOBAL_SPELL_CONFIG_FILE', ')', 'custom_config', '=', 'read_spell_config', '(', 'CUSTOM_SPELL_CONFIG_FILE', ')', 'report_duplicates', '(', 'config', '[', '"dictionary"', ']', ',', 'custom_config', '[', '"dictionary"', ']', '.', 'to_a', ')', 'custom_config', '[', '"dictionary"', ']', '=', '@config', '[', '"dictionary"', ']', '+', 'custom_config', '[', '"dictionary"', ']', '.', 'to_a', 'custom_config', '[', '"dictionary"', ']', '.', 'uniq!', '@config', '.', 'merge!', '(', 'custom_config', ')', '@config', 'end']
->Original Target:
['return', 'the', 'merged', 'global', 'and', 'the', 'custom', 'spell', 'configs']
->Reconstructed Target:
return the merged global and the custom spell configs
->Reconstructed Predication:
the spell configuration file
->Raw Input:
summarize:def config return @config if @config @config = read_spell_config ( GLOBAL_SPELL_CONFIG_FILE ) custom_config = read_spell_config ( CUSTOM_SPELL_CONFIG_FILE ) report_duplicates ( config [ "dictionary" ], custom_config [ "dictionary" ]. to_a ) custom_config [ "dictionary" ] = @config [ "dictionary" ] + custom_config [ "dictionary" ]. to_a custom_config [ "dictionary" ]. uniq! @config. merge! ( custom_config ) @config end
->Raw Target:
return the merged global and the custom spell configs
--

517=========
->Original Input:
['def', 'check_file', '(', 'file', ')', 'puts', '"Checking #{file}..."', 'if', 'verbose', '==', 'true', 'lines', '=', 'File', '.', 'read', '(', 'file', ')', '.', 'split', '(', '"\\n"', ')', 'success', '=', 'true', 'lines', '.', 'each_with_index', 'do', '|', 'text', ',', 'index', '|', 'misspelled', '=', 'misspelled_on_line', '(', 'text', ')', 'next', 'if', 'misspelled', '.', 'empty?', 'success', '=', 'false', 'print_misspelled', '(', 'misspelled', ',', 'index', ',', 'text', ')', 'end', 'success', 'end']
->Original Target:
['check', 'the', 'file', 'using', 'the', 'spellchecker']
->Reconstructed Target:
check the file using the spellchecker
->Reconstructed Predication:
file is valid andfile is valid.
->Raw Input:
summarize:def check_file ( file ) puts "Checking #{file}..." if verbose == true lines = File. read ( file ). split ( "\n" ) success = true lines. each_with_index do | text, index | misspelled = misspelled_on_line ( text ) next if misspelled. empty? success = false print_misspelled ( misspelled, index, text ) end success end
->Raw Target:
check the file using the spellchecker
--

518=========
->Original Input:
['def', 'check_writable', '(', 'path', ')', 'raise', 'Error', ',', '"\'#{path}\' is not writable"', 'if', 'path', '.', 'exist?', '&&', '!', 'path', '.', 'writable?', '||', '!', 'path', '.', 'parent', '.', 'writable?', 'end']
->Original Target:
['If', 'the', 'path', 'does', 'not', 'exist', 'it', 'will', 'check', 'for', 'the', 'parent', 'directory', 'write', 'permission']
->Reconstructed Target:
If the path does not exist it will check for the parent directory write permission
->Reconstructed Predication:
path is a directory path
->Raw Input:
summarize:def check_writable ( path ) raise Error, "'#{path}' is not writable" if path. exist? &&! path. writable? ||! path. parent. writable? end
->Raw Target:
If the path does not exist it will check for the parent directory write permission
--

519=========
->Original Input:
['def', 'check_option', '(', 'opt', ')', 'raise', 'Error', ',', '"The option is not an OptBase, #{opt.class} supplied"', 'unless', 'opt', '.', 'is_a?', '(', 'OptBase', ')', 'raise', 'Error', ',', '"The option #{opt.to_sym} is already used !"', 'if', '@symbols_used', '.', 'include?', '(', 'opt', '.', 'to_sym', ')', 'end']
->Original Target:
['Ensures', 'the', 'opt', 'given', 'is', 'valid']
->Reconstructed Target:
Ensures the opt given is valid
->Reconstructed Predication:
the option to be used
->Raw Input:
summarize:def check_option ( opt ) raise Error, "The option is not an OptBase, #{opt.class} supplied" unless opt. is_a? ( OptBase ) raise Error, "The option #{opt.to_sym} is already used!" if @symbols_used. include? ( opt. to_sym ) end
->Raw Target:
Ensures the opt given is valid
--

520=========
->Original Input:
['def', 'post_processing', '@opts', '.', 'each', 'do', '|', 'opt', '|', 'raise', 'NoRequiredOption', ',', '"The option #{opt} is required"', 'if', 'opt', '.', 'required?', '&&', '!', '@results', '.', 'key?', '(', 'opt', '.', 'to_sym', ')', 'next', 'if', 'opt', '.', 'required_unless', '.', 'empty?', '||', '@results', '.', 'key?', '(', 'opt', '.', 'to_sym', ')', 'fail_msg', '=', '"One of the following options is required: #{opt}, #{opt.required_unless.join(\', \')}"', 'raise', 'NoRequiredOption', ',', 'fail_msg', 'unless', 'opt', '.', 'required_unless', '.', 'any?', 'do', '|', 'sym', '|', '@results', '.', 'key?', '(', 'sym', ')', 'end', 'end', 'end']
->Original Target:
['Ensure', 'that', 'all', 'required', 'options', 'are', 'supplied', 'Should', 'be', 'overriden', 'to', 'modify', 'the', 'behavior']
->Reconstructed Target:
Ensure that all required options are supplied Should be overriden to modify the behavior
->Reconstructed Predication:
the post-processing of the results
->Raw Input:
summarize:def post_processing @opts. each do | opt | raise NoRequiredOption, "The option #{opt} is required" if opt. required? &&! @results. key? ( opt. to_sym ) next if opt. required_unless. empty? || @results. key? ( opt. to_sym ) fail_msg = "One of the following options is required: #{opt}, #{opt.required_unless.join(', ')}" raise NoRequiredOption, fail_msg unless opt. required_unless. any? do | sym | @results. key? ( sym ) end end end
->Raw Target:
Ensure that all required options are supplied Should be overriden to modify the behavior
--

521=========
->Original Input:
['def', 'subdir_entities', '(', 'dir', '=', '@current_dir', ')', 'Dir', '.', 'glob', '(', 'dir', '[', ':path', ']', '.', 'gsub', '(', '/', '\\\\', '\\[', '\\]', '/', ',', "'\\\\\\\\\\0'", ')', '+', "'/*'", ')', '.', 'map!', '{', '|', 'path', '|', '{', 'path', ':', 'path', ',', 'time', ':', 'File', '.', 'mtime', '(', 'path', ')', ',', 'name', ':', 'File', '.', 'basename', '(', 'path', ')', '}', '}', 'end']
->Original Target:
['Conversions', 'Get', 'entities', 'of', 'files', 'in', 'dir']
->Reconstructed Target:
Conversions Get entities of files in dir
->Reconstructed Predication:
the directory of the subdirectory
->Raw Input:
summarize:def subdir_entities ( dir = @current_dir ) Dir. glob ( dir [ :path ]. gsub ( / \\ \[ \] /, '\\\\\0' ) + '/*' ). map! { | path | { path : path, time : File. mtime ( path ), name : File. basename ( path ) } } end
->Raw Target:
Conversions Get entities of files in dir
--

522=========
->Original Input:
['def', 'string_to_bytes', '(', 'str', ')', 'unless', '@e', '.', 'nil?', '||', '@e', '==', ':utf8', 'if', '@e', '==', ':shift_jis', 'begin', 'str', '=', 'str', '.', 'gsub', '/', '\\\\', '\\uff5e', '/', ',', "''", 'str', '.', 'encode!', "'Shift_JIS'", ',', ':invalid', '=>', ':replace', ',', ':undef', '=>', ':replace', ',', ':replace', '=>', "''", 'rescue', '=>', 'e', 'end', 'end', 'end', '[', 'str', ']', '.', 'pack', '(', "'a*'", ')', 'end']
->Original Target:
['Create', 'ASCII', '-', '8bits', 'string', '.', 'Also', 'convert', 'encoding', 'if', 'needed', '.']
->Reconstructed Target:
Create ASCII - 8bits string. Also convert encoding if needed.
->Reconstructed Predication:
the string to a byte string
->Raw Input:
summarize:def string_to_bytes ( str ) unless @e. nil? || @e == :utf8 if @e == :shift_jis begin str = str. gsub / \\ \uff5e /, '' str. encode! 'Shift_JIS', :invalid => :replace, :undef => :replace, :replace => '' rescue => e end end end [ str ]. pack ( 'a*' ) end
->Raw Target:
Create ASCII - 8bits string. Also convert encoding if needed.
--

523=========
->Original Input:
['def', 'pack', '(', 'files', ')', 'entities', '=', 'Entity', '.', 'entities_from', 'files', 'return', 'if', 'entities', '.', 'empty?', 'reset_state', 'pack_entities', 'entities', 'while', 'has_dir?', 'cd', 'next_dir', 'pack_current_dir', 'end', 'end']
->Original Target:
['Compression', 'operations', 'Pack', 'file', 'and', 'directory', 'entities', 'and', 'output', 'to', 'stream', '.']
->Reconstructed Target:
Compression operations Pack file and directory entities and output to stream.
->Reconstructed Predication:
the files to be packed.
->Raw Input:
summarize:def pack ( files ) entities = Entity. entities_from files return if entities. empty? reset_state pack_entities entities while has_dir? cd next_dir pack_current_dir end end
->Raw Target:
Compression operations Pack file and directory entities and output to stream.
--

524=========
->Original Input:
['def', 'pack_symlinks', 'reset_state', '@l', '.', 'each', 'do', '|', 'link', '|', 'if', '@w', '.', 'path_exists?', 'Entity', '.', 'linked_path', '(', 'link', '[', ':abs_path', ']', ',', 'File', '.', 'readlink', '(', 'link', '[', ':path', ']', ')', ')', 'link', '[', ':name', ']', '=', 'link', '[', ':abs_path', ']', 'pack_symbolic_link_entity', 'link', 'end', 'end', 'end']
->Original Target:
['Pack', 'symlinks', 'if', 'its', 'link', 'path', 'exists', 'in', 'zip']
->Reconstructed Target:
Pack symlinks if its link path exists in zip
->Reconstructed Predication:
the symlinks of the given
->Raw Input:
summarize:def pack_symlinks reset_state @l. each do | link | if @w. path_exists? Entity. linked_path ( link [ :abs_path ], File. readlink ( link [ :path ] ) ) link [ :name ] = link [ :abs_path ] pack_symbolic_link_entity link end end end
->Raw Target:
Pack symlinks if its link path exists in zip
--

525=========
->Original Input:
['def', 'pack_entities', '(', 'entities', ')', 'entities', '.', 'each', 'do', '|', 'entity', '|', 'next', 'unless', 'entity', '.', 'is_a?', '(', 'Hash', ')', '&&', 'entity', '[', ':path', ']', 'path', '=', 'entity', '[', ':path', ']', 'if', 'File', '.', 'symlink?', 'path', 'postpone_symlink', 'entity', 'elsif', 'File', '.', 'directory?', 'path', 'postpone_dir', 'entity', 'elsif', 'File', '.', 'file?', 'path', 'pack_file_entity', 'entity', 'end', 'end', 'end']
->Original Target:
['Pack', 'file', 'entities', '.', 'Directory', 'entities', 'are', 'queued', 'not', 'packed', 'in', 'this', 'method', '.']
->Reconstructed Target:
Pack file entities. Directory entities are queued not packed in this method.
->Reconstructed Predication:
entities
->Raw Input:
summarize:def pack_entities ( entities ) entities. each do | entity | next unless entity. is_a? ( Hash ) && entity [ :path ] path = entity [ :path ] if File. symlink? path postpone_symlink entity elsif File. directory? path postpone_dir entity elsif File. file? path pack_file_entity entity end end end
->Raw Target:
Pack file entities. Directory entities are queued not packed in this method.
--

526=========
->Original Input:
['def', 'header', 'content', '=', 'nil', ',', 'options', '=', 'nil', ',', 'html_options', '=', 'nil', ',', '&', 'block', '@header', '=', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Lists', '::', 'Components', '::', 'ListHeader', '.', 'new', 'content', ',', 'options', ',', 'html_options', ',', '&', 'block', 'end']
->Original Target:
['Add', 'header', 'which', 'is', 'a', 'component']
->Reconstructed Target:
Add header which is a component
->Reconstructed Predication:
header.
->Raw Input:
summarize:def header content = nil, options = nil, html_options = nil, & block @header = UiBibz :: Ui :: Core :: Lists :: Components :: ListHeader. new content, options, html_options, & block end
->Raw Target:
Add header which is a component
--

527=========
->Original Input:
['def', 'body', 'content', '=', 'nil', ',', 'options', '=', 'nil', ',', 'html_options', '=', 'nil', ',', '&', 'block', '@body', '=', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Lists', '::', 'Components', '::', 'ListBody', '.', 'new', 'content', ',', 'options', ',', 'html_options', ',', '&', 'block', 'end']
->Original Target:
['Add', 'body', 'which', 'is', 'a', 'component']
->Reconstructed Target:
Add body which is a component
->Reconstructed Predication:
the body of the list
->Raw Input:
summarize:def body content = nil, options = nil, html_options = nil, & block @body = UiBibz :: Ui :: Core :: Lists :: Components :: ListBody. new content, options, html_options, & block end
->Raw Target:
Add body which is a component
--

528=========
->Original Input:
['def', 'td_content', 'record', ',', 'col', 'content', '=', 'col', '.', 'count', '?', 'record', '.', 'send', '(', 'col', '.', 'data_index', ')', '.', 'count', ':', 'record', '.', 'send', '(', 'col', '.', 'data_index', ')', 'unless', 'content', '.', 'nil?', 'content', '=', 'content', '.', 'strftime', '(', 'col', '.', 'date_format', ')', 'unless', 'col', '.', 'date_format', '.', 'nil?', 'content', '=', 'link_to', 'content', ',', 'action', '.', 'inject_url', '(', 'col', '.', 'link', ',', 'record', ')', 'unless', 'col', '.', 'link', '.', 'nil?', 'content', '=', 'col', '.', 'format', '.', 'call', '(', '@store', '.', 'records', ',', 'record', ')', 'unless', 'col', '.', 'format', '.', 'nil?', 'end', 'content', '=', 'As', '.', 'new', '(', 'col', ',', 'record', ',', 'content', ',', '@options', ')', '.', 'render', 'unless', 'col', '.', 'as', '.', 'nil?', 'content', 'end']
->Original Target:
['Maybe', 'create', 'a', 'class', 'for', 'td_content']
->Reconstructed Target:
Maybe create a class for td_content
->Reconstructed Predication:
..
->Raw Input:
summarize:def td_content record, col content = col. count? record. send ( col. data_index ). count : record. send ( col. data_index ) unless content. nil? content = content. strftime ( col. date_format ) unless col. date_format. nil? content = link_to content, action. inject_url ( col. link, record ) unless col. link. nil? content = col. format. call ( @store. records, record ) unless col. format. nil? end content = As. new ( col, record, content, @options ). render unless col. as. nil? content end
->Raw Target:
Maybe create a class for td_content
--

529=========
->Original Input:
['def', 'body', 'content', '=', 'nil', ',', 'options', '=', 'nil', ',', 'html_options', '=', 'nil', ',', '&', 'block', 'options', ',', 'content', '=', 'inherit_options', '(', 'content', ',', 'options', ',', 'block', ')', 'if', 'is_tap', '(', 'content', ',', 'options', ')', 'content', '=', '(', 'content', '||', '{', '}', ')', '.', 'merge', '(', 'collapse', ':', 'options', '.', 'try', '(', ':[]', ',', ':collapse', ')', ',', 'parent_collapse', ':', '@options', '[', ':parent_collapse', ']', ')', '@items', '<<', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Boxes', '::', 'Components', '::', 'CardBody', '.', 'new', '(', 'content', ',', 'options', ',', 'html_options', ')', '.', 'tap', '(', '&', 'block', ')', '.', 'render', 'else', 'options', '=', '(', 'options', '||', '{', '}', ')', '.', 'merge', '(', 'collapse', ':', 'options', '.', 'try', '(', ':[]', ',', ':collapse', ')', ',', 'parent_collapse', ':', '@options', '[', ':parent_collapse', ']', ')', '@items', '<<', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Boxes', '::', 'Components', '::', 'CardBody', '.', 'new', '(', 'content', ',', 'options', ',', 'html_options', ',', '&', 'block', ')', '.', 'render', 'end', 'end']
->Original Target:
['Add', 'Body', 'div', 'which', 'is', 'a', 'component']
->Reconstructed Target:
Add Body div which is a component
->Reconstructed Predication:
..... merge (:parent_collapse ] ). merge:parent_collapse ] ). merge:parent_collapse ] ). merge. merge (:parent_collapse ] ). merge
->Raw Input:
summarize:def body content = nil, options = nil, html_options = nil, & block options, content = inherit_options ( content, options, block ) if is_tap ( content, options ) content = ( content || { } ). merge ( collapse : options. try ( :[], :collapse ), parent_collapse : @options [ :parent_collapse ] ) @items << UiBibz :: Ui :: Core :: Boxes :: Components :: CardBody. new ( content, options, html_options ). tap ( & block ). render else options = ( options || { } ). merge ( collapse : options. try ( :[], :collapse ), parent_collapse : @options [ :parent_collapse ] ) @items << UiBibz :: Ui :: Core :: Boxes :: Components :: CardBody. new ( content, options, html_options, & block ). render end end
->Raw Target:
Add Body div which is a component
--

530=========
->Original Input:
['def', 'footer', 'content', '=', 'nil', ',', 'options', '=', 'nil', ',', 'html_options', '=', 'nil', ',', '&', 'block', 'options', ',', 'content', '=', 'inherit_options', '(', 'content', ',', 'options', ',', 'block', ')', '@footer', '=', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Boxes', '::', 'Components', '::', 'CardFooter', '.', 'new', '(', 'content', ',', 'options', ',', 'html_options', ',', '&', 'block', ')', '.', 'render', 'end']
->Original Target:
['Add', 'Footer', 'which', 'is', 'a', 'component']
->Reconstructed Target:
Add Footer which is a component
->Reconstructed Predication:
footer content.  def footer
->Raw Input:
summarize:def footer content = nil, options = nil, html_options = nil, & block options, content = inherit_options ( content, options, block ) @footer = UiBibz :: Ui :: Core :: Boxes :: Components :: CardFooter. new ( content, options, html_options, & block ). render end
->Raw Target:
Add Footer which is a component
--

531=========
->Original Input:
['def', 'list_group', 'content', '=', 'nil', ',', 'options', '=', 'nil', ',', 'html_options', '=', 'nil', ',', '&', 'block', '@items', '<<', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Boxes', '::', 'Components', '::', 'CardListGroup', '.', 'new', '(', 'content', ',', 'options', ',', 'html_options', ')', '.', 'tap', '(', '&', 'block', ')', '.', 'render', 'end']
->Original Target:
['Add', 'List', 'group', 'which', 'is', 'a', 'component']
->Reconstructed Target:
Add List group which is a component
->Reconstructed Predication:
list items
->Raw Input:
summarize:def list_group content = nil, options = nil, html_options = nil, & block @items << UiBibz :: Ui :: Core :: Boxes :: Components :: CardListGroup. new ( content, options, html_options ). tap ( & block ). render end
->Raw Target:
Add List group which is a component
--

532=========
->Original Input:
['def', 'image', 'content', '=', 'nil', ',', 'options', '=', 'nil', ',', 'html_options', '=', 'nil', ',', '&', 'block', '@items', '<<', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Boxes', '::', 'Components', '::', 'CardImage', '.', 'new', '(', 'content', ',', 'options', ',', 'html_options', ',', '&', 'block', ')', '.', 'render', 'end']
->Original Target:
['Add', 'Image', 'which', 'is', 'a', 'component']
->Reconstructed Target:
Add Image which is a component
->Reconstructed Predication:
the image to be rendered
->Raw Input:
summarize:def image content = nil, options = nil, html_options = nil, & block @items << UiBibz :: Ui :: Core :: Boxes :: Components :: CardImage. new ( content, options, html_options, & block ). render end
->Raw Target:
Add Image which is a component
--

533=========
->Original Input:
['def', 'html', 'content', '=', 'nil', ',', '&', 'block', 'if', '!', 'block', '.', 'nil?', 'context', '=', 'eval', '(', '"self"', ',', 'block', '.', 'binding', ')', '@items', '<<', 'context', '.', 'capture', '(', '&', 'block', ')', 'else', '@items', '<<', 'content', 'end', 'end']
->Original Target:
['Add', 'html', 'component']
->Reconstructed Target:
Add html component
->Reconstructed Predication:
content to be rendered
->Raw Input:
summarize:def html content = nil, & block if! block. nil? context = eval ( "self", block. binding ) @items << context. capture ( & block ) else @items << content end end
->Raw Target:
Add html component
--

534=========
->Original Input:
['def', 'component_html_options', 'super', '.', 'merge', '(', '{', 'multiple', ':', 'options', '[', ':multiple', ']', ',', 'disabled', ':', 'options', '[', ':state', ']', '==', ':disabled', ',', 'include_blank', ':', 'options', '[', ':include_blank', ']', ',', 'prompt', ':', 'options', '[', ':prompt', ']', '}', ')', 'end']
->Original Target:
['Try', 'to', 'put', 'it', 'on', 'a', 'line']
->Reconstructed Target:
Try to put it on a line
->Reconstructed Predication:
the component to be rendered
->Raw Input:
summarize:def component_html_options super. merge ( { multiple : options [ :multiple ], disabled : options [ :state ] == :disabled, include_blank : options [ :include_blank ], prompt : options [ :prompt ] } ) end
->Raw Target:
Try to put it on a line
--

535=========
->Original Input:
['def', 'nav', 'content', '=', 'nil', ',', 'options', '=', '{', '}', ',', 'html_options', '=', 'nil', ',', '&', 'block', '@items', '<<', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Component', '.', 'new', '(', 'Nav', '.', 'new', '(', 'content', ',', 'options', ')', '.', 'tap', '(', '&', 'block', ')', '.', 'render', ',', '{', '}', ',', 'html_options', ')', 'end']
->Original Target:
['Add', 'nav', 'in', 'nav']
->Reconstructed Target:
Add nav in nav
->Reconstructed Predication:
 def nav ( content
->Raw Input:
summarize:def nav content = nil, options = { }, html_options = nil, & block @items << UiBibz :: Ui :: Core :: Component. new ( Nav. new ( content, options ). tap ( & block ). render, { }, html_options ) end
->Raw Target:
Add nav in nav
--

536=========
->Original Input:
['def', 'body', 'content', '=', 'nil', ',', 'options', '=', 'nil', ',', 'html_options', '=', 'nil', ',', '&', 'block', '@body', '=', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Notifications', '::', 'Components', '::', 'AlertBody', '.', 'new', '(', 'content', ',', 'options', ',', 'html_options', ',', '&', 'block', ')', '.', 'render', 'end']
->Original Target:
['Add', 'Body', 'which', 'is', 'a', 'component']
->Reconstructed Target:
Add Body which is a component
->Reconstructed Predication:
the body of the alert
->Raw Input:
summarize:def body content = nil, options = nil, html_options = nil, & block @body = UiBibz :: Ui :: Core :: Notifications :: Components :: AlertBody. new ( content, options, html_options, & block ). render end
->Raw Target:
Add Body which is a component
--

537=========
->Original Input:
['def', 'is_tap', 'content', ',', 'options', '(', 'content', '[', ':tap', ']', 'if', 'content', '.', 'kind_of?', '(', 'Hash', ')', ')', '||', '(', 'options', '[', ':tap', ']', 'unless', 'options', '.', 'nil?', ')', 'end']
->Original Target:
['Know', 'if', 'component', 'is', 'tapped', 'or', 'not']
->Reconstructed Target:
Know if component is tapped or not
->Reconstructed Predication:
the content to be checked for
->Raw Input:
summarize:def is_tap content, options ( content [ :tap ] if content. kind_of? ( Hash ) ) || ( options [ :tap ] unless options. nil? ) end
->Raw Target:
Know if component is tapped or not
--

538=========
->Original Input:
['def', 'component_html_data', 'data_target', '=', 'html_options', '.', 'try', '(', ':[]', ',', ':data', ')', '.', 'try', '(', ':[]', ',', ':target', ')', '||', 'options', '.', 'try', '(', ':delete', ',', ':target', ')', 'add_html_data', '(', ':target', ',', 'data_target', ')', 'unless', 'data_target', '.', 'nil?', 'data_controller', '=', 'html_options', '.', 'try', '(', ':[]', ',', ':data', ')', '.', 'try', '(', ':[]', ',', ':controller', ')', '||', 'options', '.', 'try', '(', ':delete', ',', ':controller', ')', 'add_html_data', '(', ':controller', ',', 'data_controller', ')', 'unless', 'data_controller', '.', 'nil?', 'data_action', '=', 'html_options', '.', 'try', '(', ':[]', ',', ':data', ')', '.', 'try', '(', ':[]', ',', ':action', ')', '||', 'options', '.', 'try', '(', ':delete', ',', ':action', ')', 'add_html_data', '(', ':action', ',', 'data_action', ')', 'unless', 'data_action', '.', 'nil?', 'data_turbolinks', '=', 'html_options', '.', 'try', '(', ':[]', ',', ':data', ')', '.', 'try', '(', ':[]', ',', ':turbolinks', ')', '||', 'options', '.', 'try', '(', ':delete', ',', ':turbolinks', ')', 'add_html_data', '(', ':turbolinks', ',', 'data_turbolinks', ')', 'unless', 'data_turbolinks', '.', 'nil?', 'end']
->Original Target:
['Override', 'this', 'method', 'to', 'add', 'html', 'data']
->Reconstructed Target:
Override this method to add html data
->Reconstructed Predication:
:data, data_target ):data, data_action ):data, data_target ):data, data_target ) unless. nil? end
->Raw Input:
summarize:def component_html_data data_target = html_options. try ( :[], :data ). try ( :[], :target ) || options. try ( :delete, :target ) add_html_data ( :target, data_target ) unless data_target. nil? data_controller = html_options. try ( :[], :data ). try ( :[], :controller ) || options. try ( :delete, :controller ) add_html_data ( :controller, data_controller ) unless data_controller. nil? data_action = html_options. try ( :[], :data ). try ( :[], :action ) || options. try ( :delete, :action ) add_html_data ( :action, data_action ) unless data_action. nil? data_turbolinks = html_options. try ( :[], :data ). try ( :[], :turbolinks ) || options. try ( :delete, :turbolinks ) add_html_data ( :turbolinks, data_turbolinks ) unless data_turbolinks. nil? end
->Raw Target:
Override this method to add html data
--

539=========
->Original Input:
['def', 'add_html_data', 'name', ',', 'value', '=', 'true', 'html_options', '[', ':data', ']', '=', '{', '}', 'if', 'html_options', '[', ':data', ']', '.', 'nil?', 'value', '=', 'value', '.', 'kind_of?', '(', 'String', ')', '?', 'value', '.', 'strip', ':', 'value', 'html_options', '[', ':data', ']', '.', 'update', '(', 'Hash', '[', 'name', ',', 'value', ']', ')', 'end']
->Original Target:
['Add', 'html', 'data', 'arguments']
->Reconstructed Target:
Add html data arguments
->Reconstructed Predication:
the html data to be added
->Raw Input:
summarize:def add_html_data name, value = true html_options [ :data ] = { } if html_options [ :data ]. nil? value = value. kind_of? ( String )? value. strip : value html_options [ :data ]. update ( Hash [ name, value ] ) end
->Raw Target:
Add html data arguments
--

540=========
->Original Input:
['def', 'header', 'column', ',', 'name', '=', 'nil', '@column', '=', 'column', 'defaults', '=', '[', 'translate_headers_by_defaults', ',', 'translate_headers_by_defaults_active_record', ',', 'translate_headers_by_active_record', ',', 'header_name', '(', 'name', ')', ']', '@name', '=', 'UiBibz', '::', 'Utils', '::', 'Internationalization', '.', 'new', '(', 'translate_headers_by_model', ',', 'default', ':', 'defaults', ')', '.', 'translate', 'sortable?', '?', 'sortable_link', ':', 'title', 'end']
->Original Target:
['header', 'use', 'i18n']
->Reconstructed Target:
header use i18n
->Reconstructed Predication:
: title : title
->Raw Input:
summarize:def header column, name = nil @column = column defaults = [ translate_headers_by_defaults, translate_headers_by_defaults_active_record, translate_headers_by_active_record, header_name ( name ) ] @name = UiBibz :: Utils :: Internationalization. new ( translate_headers_by_model, default : defaults ). translate sortable?? sortable_link : title end
->Raw Target:
header use i18n
--

541=========
->Original Input:
['def', 'column', 'data_index', '=', 'nil', ',', 'options', '=', 'nil', ',', 'html_options', '=', 'nil', ',', '&', 'block', '@columns', '<<', 'Column', '.', 'new', '(', 'data_index', ',', 'options', ',', 'html_options', ',', '&', 'block', ')', 'end']
->Original Target:
['Add', 'column', 'in', 'table']
->Reconstructed Target:
Add column in table
->Reconstructed Predication:
the column to be displayed
->Raw Input:
summarize:def column data_index = nil, options = nil, html_options = nil, & block @columns << Column. new ( data_index, options, html_options, & block ) end
->Raw Target:
Add column in table
--

542=========
->Original Input:
['def', 'link', 'content', '=', 'nil', ',', 'options', '=', 'nil', ',', 'html_options', '=', 'nil', ',', '&', 'block', '@actions', '<<', 'UiBibz', '::', 'Ui', '::', 'Core', '::', 'Forms', '::', 'Dropdowns', '::', 'Components', '::', 'DropdownLink', '.', 'new', '(', 'content', ',', 'options', ',', 'html_options', ',', '&', 'block', ')', '.', 'render', 'end']
->Original Target:
['Add', 'link', 'action', 'in', 'table']
->Reconstructed Target:
Add link action in table
->Reconstructed Predication:
the link to the Dropdown
->Raw Input:
summarize:def link content = nil, options = nil, html_options = nil, & block @actions << UiBibz :: Ui :: Core :: Forms :: Dropdowns :: Components :: DropdownLink. new ( content, options, html_options, & block ). render end
->Raw Target:
Add link action in table
--

543=========
->Original Input:
['def', 'engine_scaffold', 'FileUtils', '.', 'mkdir_p', '(', '@gem_temp', ')', 'Dir', '.', 'chdir', '(', '@gem_temp', ')', 'do', 'response', '=', 'Open3', '.', 'capture3', '(', '"rails plugin new #{gem} --mountable --dummy-path=site --skip-test-unit"', ')', 'if', '!', 'response', '[', '1', ']', '.', 'empty?', 'puts', 'response', '[', '1', ']', 'abort', '"FAILED: Please be sure you have the rails gem installed with `gem install rails`"', 'end', 'remove', '=', '%w(', 'mailers', 'models', 'assets', 'channels', 'jobs', 'views', ')', '.', 'map', '{', '|', 'f', '|', 'File', '.', 'join', '(', "'app'", ',', 'f', ')', '}', 'remove', '.', 'concat', '%w(', 'cable.yml', 'storage.yml', 'database.yml', ')', '.', 'map', '{', '|', 'f', '|', 'File', '.', 'join', '(', "'config'", ',', 'f', ')', '}', 'remove', '.', 'each', '{', '|', 'f', '|', 'FileUtils', '.', 'rm_rf', 'File', '.', 'join', '(', '@gem', ',', "'site'", ',', 'f', ')', ',', 'secure', ':', 'true', '}', 'end', 'engine_copy', 'end']
->Original Target:
['Create', 'an', 'Rails', 'plugin', 'engine', 'for', 'documentation', 'site']
->Reconstructed Target:
Create an Rails plugin engine for documentation site
->Reconstructed Predication:
. join ( @gem_temp,. join ( @gem_temp,. join ( @gem_temp,. join ( @gem_temp,. join ( @gem_temp,. join ( @gem_temp,. join ( @gem_temp,. join ( @gem_temp,. join ( @gem_temp,. join ( @gem_temp,. join ( @gem_temp
->Raw Input:
summarize:def engine_scaffold FileUtils. mkdir_p ( @gem_temp ) Dir. chdir ( @gem_temp ) do response = Open3. capture3 ( "rails plugin new #{gem} --mountable --dummy-path=site --skip-test-unit" ) if! response [ 1 ]. empty? puts response [ 1 ] abort "FAILED: Please be sure you have the rails gem installed with `gem install rails`" end remove = %w( mailers models assets channels jobs views ). map { | f | File. join ( 'app', f ) } remove. concat %w( cable.yml storage.yml database.yml ). map { | f | File. join ( 'config', f ) } remove. each { | f | FileUtils. rm_rf File. join ( @gem,'site', f ), secure : true } end engine_copy end
->Raw Target:
Create an Rails plugin engine for documentation site
--

544=========
->Original Input:
['def', 'engine_copy', 'site_path', '=', 'File', '.', 'join', 'path', ',', "'site'", 'FileUtils', '.', 'mkdir_p', 'site_path', 'Dir', '.', 'chdir', '"#{@gem_temp}/#{gem}/site"', 'do', '%w(', 'app', 'config', 'bin', 'config.ru', 'Rakefile', 'public', 'log', ')', '.', 'each', 'do', '|', 'item', '|', 'target', '=', 'File', '.', 'join', 'site_path', ',', 'item', 'FileUtils', '.', 'cp_r', 'item', ',', 'target', 'action_log', '"create"', ',', 'target', '.', 'sub', '(', '@cwd', '+', "'/'", ',', "''", ')', 'end', 'end', 'FileUtils', '.', 'rm_rf', '@gem_temp', 'end']
->Original Target:
['Copy', 'parts', 'of', 'the', 'engine', 'scaffold', 'into', 'site', 'directory']
->Reconstructed Target:
Copy parts of the engine scaffold into site directory
->Reconstructed Predication:
. mkdir_p @gem_temp
->Raw Input:
summarize:def engine_copy site_path = File. join path,'site' FileUtils. mkdir_p site_path Dir. chdir "#{@gem_temp}/#{gem}/site" do %w( app config bin config.ru Rakefile public log ). each do | item | target = File. join site_path, item FileUtils. cp_r item, target action_log "create", target. sub ( @cwd + '/', '' ) end end FileUtils. rm_rf @gem_temp end
->Raw Target:
Copy parts of the engine scaffold into site directory
--

545=========
->Original Input:
['def', 'make_map', '(', 'item', ')', "'('", '+', 'item', '.', 'map', '{', '|', 'key', ',', 'value', '|', 'key', '.', 'to_s', '+', "':'", '+', 'convert_to_sass_value', '(', 'value', ')', '}', '.', 'join', '(', "','", ')', '+', "')'", 'end']
->Original Target:
['Convert', 'hashes', 'to', 'Sass', 'map', 'syntax']
->Reconstructed Target:
Convert hashes to Sass map syntax
->Reconstructed Predication:
the map of the item
->Raw Input:
summarize:def make_map ( item ) '(' + item. map { | key, value | key. to_s + ':' + convert_to_sass_value ( value ) }. join ( ',' ) + ')' end
->Raw Target:
Convert hashes to Sass map syntax
--

546=========
->Original Input:
['def', 'add_files', '(', 'klass', ')', 'ext', '=', 'asset_ext', 'klass', 'find_files', '(', 'ext', ')', '.', 'map', 'do', '|', 'path', '|', 'klass', '.', 'new', '(', 'self', ',', 'path', ')', 'end', 'end']
->Original Target:
['Find', 'files', 'based', 'on', 'class', 'type', 'and', 'return', 'an', 'array', 'of', 'Classes', 'for', 'each', 'file']
->Reconstructed Target:
Find files based on class type and return an array of Classes for each file
->Reconstructed Predication:
the files to be added to
->Raw Input:
summarize:def add_files ( klass ) ext = asset_ext klass find_files ( ext ). map do | path | klass. new ( self, path ) end end
->Raw Target:
Find files based on class type and return an array of Classes for each file
--

547=========
->Original Input:
['def', 'find_files', '(', 'ext', ')', 'files', '=', 'Dir', '[', 'File', '.', 'join', '(', 'paths', '[', 'ext', '.', 'to_sym', ']', ',', 'asset_glob', '(', 'ext', ')', ')', ']', 'files', '.', 'reject', '{', '|', 'f', '|', 'File', '.', 'basename', '(', 'f', ')', '.', 'start_with?', '(', "'_'", ')', '}', 'end']
->Original Target:
['Find', 'files', 'by', 'class', 'type', 'and', 'extension']
->Reconstructed Target:
Find files by class type and extension
->Reconstructed Predication:
files to find files in
->Raw Input:
summarize:def find_files ( ext ) files = Dir [ File. join ( paths [ ext. to_sym ], asset_glob ( ext ) ) ] files. reject { | f | File. basename ( f ). start_with? ( '_' ) } end
->Raw Target:
Find files by class type and extension
--

548=========
->Original Input:
['def', 'dispatch', '(', 'command', ',', '*', 'args', ')', '@threads', '=', '[', ']', 'send', 'command', ',', '*', 'args', '@threads', '.', 'each', '{', '|', 'thr', '|', 'thr', '.', 'join', '}', 'end']
->Original Target:
['Handles', 'running', 'threaded', 'commands']
->Reconstructed Target:
Handles running threaded commands
->Reconstructed Predication:
threads  def dispatch
->Raw Input:
summarize:def dispatch ( command, * args ) @threads = [ ] send command, * args @threads. each { | thr | thr. join } end
->Raw Target:
Handles running threaded commands
--

549=========
->Original Input:
['def', 'watch', '(', 'options', '=', '{', '}', ')', 'build', '(', 'options', ')', 'require', "'listen'", 'trap', '(', '"SIGINT"', ')', '{', 'puts', '"\\nspark_engine watcher stopped. Have a nice day!"', 'exit!', '}', '@threads', '.', 'concat', 'SparkEngine', '.', 'load_plugin', '.', 'watch', '(', 'options', ')', 'end']
->Original Target:
['Watch', 'assets', 'for', 'changes', 'and', 'build']
->Reconstructed Target:
Watch assets for changes and build
->Reconstructed Predication:
watch the engine and watchthe engine to watch thethe engine to watch the
->Raw Input:
summarize:def watch ( options = { } ) build ( options ) require 'listen' trap ( "SIGINT" ) { puts "\nspark_engine watcher stopped. Have a nice day!" exit! } @threads. concat SparkEngine. load_plugin. watch ( options ) end
->Raw Target:
Watch assets for changes and build
--

550=========
->Original Input:
['def', 'load_setup', '(', 'name', ')', 'reader', '=', 'create_fixture_reader', '(', 'name', ')', 'reader', '.', 'each', 'do', '|', 'fixture_name', '|', 'load', '(', 'fixture_name', ')', 'end', 'end']
->Original Target:
['lets', 'us', 'use', 'match_teams_for_country', 'etc', '.']
->Reconstructed Target:
lets us use match_teams_for_country etc.
->Reconstructed Predication:
load the fixture
->Raw Input:
summarize:def load_setup ( name ) reader = create_fixture_reader ( name ) reader. each do | fixture_name | load ( fixture_name ) end end
->Raw Target:
lets us use match_teams_for_country etc.
--

551=========
->Original Input:
['def', 'avoid_duplicate_image_names', '(', 'content', ')', 'nodes', '=', 'content', '.', 'xpath', '(', '"//draw:frame[@draw:name]"', ')', 'nodes', '.', 'each_with_index', 'do', '|', 'node', ',', 'i', '|', 'node', '.', 'attribute', '(', "'name'", ')', '.', 'value', '=', '"pic_#{i}"', 'end', 'end']
->Original Target:
['replace_images', 'newer', 'versions', 'of', 'LibreOffice', 'can', 't', 'open', 'files', 'with', 'duplicates', 'image', 'names']
->Reconstructed Target:
replace_images newer versions of LibreOffice can t open files with duplicates image names
->Reconstructed Predication:
the image name of the
->Raw Input:
summarize:def avoid_duplicate_image_names ( content ) nodes = content. xpath ( "//draw:frame[@draw:name]" ) nodes. each_with_index do | node, i | node. attribute ( 'name' ). value = "pic_#{i}" end end
->Raw Target:
replace_images newer versions of LibreOffice can t open files with duplicates image names
--

552=========
->Original Input:
['def', 'scope_params', 'return', '{', '}', 'if', 'dynamic_scaffold', '.', 'scope', '.', 'nil?', 'case', 'dynamic_scaffold', '.', 'scope', 'when', 'Array', 'then', 'dynamic_scaffold', '.', 'scope', '.', 'each_with_object', '(', '{', '}', ')', 'do', '|', 'val', ',', 'res', '|', 'if', 'val', '.', 'is_a?', 'Hash', 'val', '.', 'each', '{', '|', 'k', ',', 'v', '|', 'res', '[', 'k', ']', '=', 'v', '}', 'else', 'res', '[', 'val', ']', '=', 'params', '[', 'val', ']', 'end', 'end', 'when', 'Hash', 'then', 'dynamic_scaffold', '.', 'scope', 'end', 'end']
->Original Target:
['Get', 'the', 'hash', 'of', 'the', 'key', 'and', 'value', 'specified', 'for', 'the', 'scope', '.']
->Reconstructed Target:
Get the hash of the key and value specified for the scope.
->Reconstructed Predication:
the scope of the scope to
->Raw Input:
summarize:def scope_params return { } if dynamic_scaffold. scope. nil? case dynamic_scaffold. scope when Array then dynamic_scaffold. scope. each_with_object ( { } ) do | val, res | if val. is_a? Hash val. each { | k, v | res [ k ] = v } else res [ val ] = params [ val ] end end when Hash then dynamic_scaffold. scope end end
->Raw Target:
Get the hash of the key and value specified for the scope.
--

553=========
->Original Input:
['def', 'pkey_string_to_hash', '(', 'pkey', ')', 'pkey', '.', 'split', '(', "','", ')', '.', 'map', '{', '|', 'v', '|', 'v', '.', 'split', '(', "':'", ')', '}', '.', 'each_with_object', '(', '{', '}', ')', '{', '|', 'v', ',', 'res', '|', 'res', '[', 'v', '.', 'first', ']', '=', 'v', '.', 'last', '}', 'end']
->Original Target:
['Convert', 'pkey_string', 'value', 'to', 'hash', '.']
->Reconstructed Target:
Convert pkey_string value to hash.
->Reconstructed Predication:
the key to hash
->Raw Input:
summarize:def pkey_string_to_hash ( pkey ) pkey. split ( ',' ). map { | v | v. split ( ':' ) }. each_with_object ( { } ) { | v, res | res [ v. first ] = v. last } end
->Raw Target:
Convert pkey_string value to hash.
--

554=========
->Original Input:
['def', 'update_values', 'permitting', '=', '[', ']', 'dynamic_scaffold', '.', 'form', '.', 'items', '.', 'reject', '{', '|', 'i', '|', 'i', '.', 'type?', '(', ':carrierwave_image', ')', '}', '.', 'each', 'do', '|', 'item', '|', 'item', '.', 'extract_parameters', '(', 'permitting', ')', 'end', 'permitting', '.', 'concat', '(', 'dynamic_scaffold', '.', 'form', '.', 'permit_params', ')', 'dynamic_scaffold', '.', 'form', '.', 'items', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'type?', '(', ':carrierwave_image', ')', '}', '.', 'each', 'do', '|', 'item', '|', 'item', '.', 'extract_parameters', '(', 'permitting', ')', 'end', 'values', '=', 'params', '.', 'require', '(', 'dynamic_scaffold', '.', 'model', '.', 'name', '.', 'underscore', ')', '.', 'permit', '(', '*', 'permitting', ')', 'if', 'dynamic_scaffold', '.', 'scope', '&&', '!', 'valid_for_scope?', '(', 'values', ')', 'raise', 'DynamicScaffold', '::', 'Error', '::', 'InvalidOperation', ',', '"You can update only to #{scope_params} on this scope"', 'end', 'values', 'end']
->Original Target:
['Get', 'paramters', 'for', 'update', 'record', '.']
->Reconstructed Target:
Get paramters for update record.
->Reconstructed Predication:
.. permit_params. flatten.
->Raw Input:
summarize:def update_values permitting = [ ] dynamic_scaffold. form. items. reject { | i | i. type? ( :carrierwave_image ) }. each do | item | item. extract_parameters ( permitting ) end permitting. concat ( dynamic_scaffold. form. permit_params ) dynamic_scaffold. form. items. select { | i | i. type? ( :carrierwave_image ) }. each do | item | item. extract_parameters ( permitting ) end values = params. require ( dynamic_scaffold. model. name. underscore ). permit ( * permitting ) if dynamic_scaffold. scope &&! valid_for_scope? ( values ) raise DynamicScaffold :: Error :: InvalidOperation, "You can update only to #{scope_params} on this scope" end values end
->Raw Target:
Get paramters for update record.
--

555=========
->Original Input:
['def', 'valid_for_scope?', '(', 'update_params', ')', 'return', 'true', 'if', 'dynamic_scaffold', '.', 'scope_options', '[', ':changeable', ']', 'result', '=', 'true', 'scope_params', '.', 'each', 'do', '|', 'key', ',', 'value', '|', 'if', 'update_params', '.', 'key?', '(', 'key', ')', '&&', 'update_params', '[', 'key', ']', '!=', 'value', 'result', '=', 'false', 'break', 'end', 'end', 'result', 'end']
->Original Target:
['Check', 'if', 'there', 'are', 'inconsistent', 'scopes', 'in', 'update', 'parameters']
->Reconstructed Target:
Check if there are inconsistent scopes in update parameters
->Reconstructed Predication:
the scope to update the scope
->Raw Input:
summarize:def valid_for_scope? ( update_params ) return true if dynamic_scaffold. scope_options [ :changeable ] result = true scope_params. each do | key, value | if update_params. key? ( key ) && update_params [ key ]!= value result = false break end end result end
->Raw Target:
Check if there are inconsistent scopes in update parameters
--

556=========
->Original Input:
['def', 'lock', '(', 'timeout', ':', 'nil', ',', '&', 'block', ')', 'ensure_exists_and_release_stale_locks!', 'success', '=', '@redis', '.', 'with', 'do', '|', 'conn', '|', 'if', 'timeout', '!', 'conn', '.', 'blpop', '(', 'available_key', ',', 'timeout', '.', 'to_i', ')', '.', 'nil?', 'else', '!', 'conn', '.', 'lpop', '(', 'available_key', ')', '.', 'nil?', 'end', 'end', 'return', 'false', 'unless', 'success', 'token', '=', 'SecureRandom', '.', 'hex', '(', '16', ')', '@tokens', '.', 'push', '(', 'token', ')', '@redis', '.', 'with', 'do', '|', 'conn', '|', 'conn', '.', 'zadd', '(', 'grabbed_key', ',', 'epoch_f', '(', 'conn', ')', ',', 'token', ')', 'end', 'return_or_yield', '(', 'token', ',', '&', 'block', ')', 'end']
->Original Target:
['Acquire', 'a', 'resource', 'from', 'the', 'semaphore', 'if', 'available', '.', 'Returns', 'false', 'if', 'no', 'resources', 'are', 'available', '.']
->Reconstructed Target:
Acquire a resource from the semaphore if available. Returns false if no resources are available.
->Reconstructed Predication:
the lock
->Raw Input:
summarize:def lock ( timeout : nil, & block ) ensure_exists_and_release_stale_locks! success = @redis. with do | conn | if timeout! conn. blpop ( available_key, timeout. to_i ). nil? else! conn. lpop ( available_key ). nil? end end return false unless success token = SecureRandom. hex ( 16 ) @tokens. push ( token ) @redis. with do | conn | conn. zadd ( grabbed_key, epoch_f ( conn ), token ) end return_or_yield ( token, & block ) end
->Raw Target:
Acquire a resource from the semaphore if available. Returns false if no resources are available.
--

557=========
->Original Input:
['def', 'unlock', '(', 'token', '=', '@tokens', '.', 'pop', ')', 'return', 'unless', 'token', 'removed', '=', 'false', '@redis', '.', 'with', 'do', '|', 'conn', '|', 'removed', '=', 'conn', '.', 'zrem', 'grabbed_key', ',', 'token', 'if', 'removed', 'conn', '.', 'lpush', 'available_key', ',', '1', 'end', 'end', 'removed', 'end']
->Original Target:
['Release', 'a', 'resource', 'back', 'to', 'the', 'semaphore', '.', 'Should', 'normally', 'be', 'called', 'with', 'an', 'explicit', 'token', '.']
->Reconstructed Target:
Release a resource back to the semaphore. Should normally be called with an explicit token.
->Reconstructed Predication:
the token to be unlocked
->Raw Input:
summarize:def unlock ( token = @tokens. pop ) return unless token removed = false @redis. with do | conn | removed = conn. zrem grabbed_key, token if removed conn. lpush available_key, 1 end end removed end
->Raw Target:
Release a resource back to the semaphore. Should normally be called with an explicit token.
--

558=========
->Original Input:
['def', 'apply_options', '(', 'options', '=', '{', '}', ')', 'options', '.', 'each', '{', '|', 'key', ',', 'value', '|', 'send', '(', '"#{key}="', ',', 'value', ')', 'if', 'respond_to?', '(', 'key', ')', '}', 'yield', '(', 'self', ')', 'if', 'block_given?', 'end']
->Original Target:
['Creates', 'a', 'notification', 'object', '.']
->Reconstructed Target:
Creates a notification object.
->Reconstructed Predication:
the options to be applied
->Raw Input:
summarize:def apply_options ( options = { } ) options. each { | key, value | send ( "#{key}=", value ) if respond_to? ( key ) } yield ( self ) if block_given? end
->Raw Target:
Creates a notification object.
--

559=========
->Original Input:
['def', 'show!', 'notify_init', '(', 'app_name', ')', 'or', 'raise', '"notify_init failed"', 'raw_ptr', '=', 'notify_notification_new', '(', 'summary', ',', 'body', ',', 'icon_path', ',', 'nil', ')', '@notification', '=', '::', 'FFI', '::', 'AutoPointer', '.', 'new', '(', 'raw_ptr', ',', 'method', '(', ':g_object_unref', ')', ')', 'show', 'end']
->Original Target:
['Shows', 'a', 'new', 'notification', '.']
->Reconstructed Target:
Shows a new notification.
->Reconstructed Predication:
the notification to be displayed
->Raw Input:
summarize:def show! notify_init ( app_name ) or raise "notify_init failed" raw_ptr = notify_notification_new ( summary, body, icon_path, nil ) @notification = :: FFI :: AutoPointer. new ( raw_ptr, method ( :g_object_unref ) ) show end
->Raw Target:
Shows a new notification.
--

560=========
->Original Input:
['def', 'update', '(', 'options', '=', '{', '}', ',', '&', 'block', ')', 'apply_options', '(', 'options', ',', '&', 'block', ')', 'if', '@notification', 'notify_notification_update', '(', '@notification', ',', 'summary', ',', 'body', ',', 'icon_path', ',', 'nil', ')', 'show', 'else', 'show!', 'end', 'end']
->Original Target:
['Updates', 'a', 'previously', 'shown', 'notification', 'or', 'creates', 'a', 'new', 'one', '.']
->Reconstructed Target:
Updates a previously shown notification or creates a new one.
->Reconstructed Predication:
the notification to be displayed
->Raw Input:
summarize:def update ( options = { }, & block ) apply_options ( options, & block ) if @notification notify_notification_update ( @notification, summary, body, icon_path, nil ) show else show! end end
->Raw Target:
Updates a previously shown notification or creates a new one.
--

561=========
->Original Input:
['def', 'download', 'raise', 'ArgumentError', '.', 'new', '(', "'url cannot be nil'", ')', 'if', '@url', '.', 'nil?', 'raise', 'ArgumentError', '.', 'new', '(', "'url cannot be empty'", ')', 'if', '@url', '.', 'empty?', 'set_information_from_json', '(', 'YoutubeDL', '::', 'Runner', '.', 'new', '(', 'url', ',', 'runner_options', ')', '.', 'run', ')', 'end']
->Original Target:
['Instantiate', 'new', 'model']
->Reconstructed Target:
Instantiate new model
->Reconstructed Predication:
the download of the videothe video to download the video
->Raw Input:
summarize:def download raise ArgumentError. new ( 'url cannot be nil' ) if @url. nil? raise ArgumentError. new ( 'url cannot be empty' ) if @url. empty? set_information_from_json ( YoutubeDL :: Runner. new ( url, runner_options ). run ) end
->Raw Target:
Instantiate new model
--

562=========
->Original Input:
['def', 'method_missing', '(', 'method', ',', '*', 'args', ',', '&', 'block', ')', 'value', '=', 'information', '[', 'method', ']', 'if', 'value', '.', 'nil?', 'super', 'else', 'value', 'end', 'end']
->Original Target:
['Redirect', 'methods', 'for', 'information', 'getting']
->Reconstructed Target:
Redirect methods for information getting
->Reconstructed Predication:
the method to be called
->Raw Input:
summarize:def method_missing ( method, * args, & block ) value = information [ method ] if value. nil? super else value end end
->Raw Target:
Redirect methods for information getting
--

563=========
->Original Input:
['def', 'options_to_commands', 'commands', '=', '[', ']', '@options', '.', 'sanitize_keys', '.', 'each_paramized_key', 'do', '|', 'key', ',', 'paramized_key', '|', 'if', '@options', '[', 'key', ']', '.', 'to_s', '==', "'true'", 'commands', '.', 'push', '"--#{paramized_key}"', 'elsif', '@options', '[', 'key', ']', '.', 'to_s', '==', "'false'", 'commands', '.', 'push', '"--no-#{paramized_key}"', 'else', 'commands', '.', 'push', '"--#{paramized_key} :#{key}"', 'end', 'end', 'commands', '.', 'push', 'quoted', '(', 'url', ')', 'commands', '.', 'join', '(', "' '", ')', 'end']
->Original Target:
['Parses', 'options', 'and', 'converts', 'them', 'to', 'Cocaine', 's', 'syntax']
->Reconstructed Target:
Parses options and converts them to Cocaine s syntax
->Reconstructed Predication:
url : url
->Raw Input:
summarize:def options_to_commands commands = [ ] @options. sanitize_keys. each_paramized_key do | key, paramized_key | if @options [ key ]. to_s == 'true' commands. push "--#{paramized_key}" elsif @options [ key ]. to_s == 'false' commands. push "--no-#{paramized_key}" else commands. push "--#{paramized_key} :#{key}" end end commands. push quoted ( url ) commands. join ('' ) end
->Raw Target:
Parses options and converts them to Cocaine s syntax
--

564=========
->Original Input:
['def', 'with', '(', 'hash', ')', 'merged', '=', 'Options', '.', 'new', '(', '@store', '.', 'merge', '(', 'hash', '.', 'to_h', ')', ')', 'merged', '.', 'banned_keys', '=', '@banned_keys', 'merged', '.', 'send', '(', ':remove_banned', ')', 'merged', 'end']
->Original Target:
['Merge', 'options', 'with', 'given', 'hash', 'removing', 'banned', 'keys', 'and', 'returning', 'a', 'new', 'instance', 'of', 'Options', '.']
->Reconstructed Target:
Merge options with given hash removing banned keys and returning a new instance of Options.
->Reconstructed Predication:
the hash to the hash
->Raw Input:
summarize:def with ( hash ) merged = Options. new ( @store. merge ( hash. to_h ) ) merged. banned_keys = @banned_keys merged. send ( :remove_banned ) merged end
->Raw Target:
Merge options with given hash removing banned keys and returning a new instance of Options.
--

565=========
->Original Input:
['def', 'method_missing', '(', 'method', ',', '*', 'args', ',', '&', '_block', ')', 'remove_banned', 'if', 'method', '.', 'to_s', '.', 'include?', "'='", 'method', '=', 'method', '.', 'to_s', '.', 'tr', '(', "'='", ',', "''", ')', '.', 'to_sym', 'return', 'nil', 'if', 'banned?', 'method', '@store', '[', 'method', ']', '=', 'args', '.', 'first', 'else', 'return', 'nil', 'if', 'banned?', 'method', '@store', '[', 'method', ']', 'end', 'end']
->Original Target:
['Option', 'getting', 'and', 'setting', 'using', 'ghost', 'methods']
->Reconstructed Target:
Option getting and setting using ghost methods
->Reconstructed Predication:
the method to be called
->Raw Input:
summarize:def method_missing ( method, * args, & _block ) remove_banned if method. to_s. include? '=' method = method. to_s. tr ( '=', '' ). to_sym return nil if banned? method @store [ method ] = args. first else return nil if banned? method @store [ method ] end end
->Raw Target:
Option getting and setting using ghost methods
--

566=========
->Original Input:
['def', 'manipulate_keys!', '(', '&', 'block', ')', '@store', '.', 'keys', '.', 'each', 'do', '|', 'old_name', '|', 'new_name', '=', 'block', '.', 'call', '(', 'old_name', ')', 'unless', 'new_name', '==', 'old_name', '@store', '[', 'new_name', ']', '=', '@store', '[', 'old_name', ']', '@store', '.', 'delete', '(', 'old_name', ')', 'end', 'end', 'end']
->Original Target:
['Calls', 'a', 'block', 'to', 'do', 'operations', 'on', 'keys', 'See', 'sanitize_keys!', 'for', 'examples']
->Reconstructed Target:
Calls a block to do operations on keys See sanitize_keys! for examples
->Reconstructed Predication:
the store of the keys
->Raw Input:
summarize:def manipulate_keys! ( & block ) @store. keys. each do | old_name | new_name = block. call ( old_name ) unless new_name == old_name @store [ new_name ] = @store [ old_name ] @store. delete ( old_name ) end end end
->Raw Target:
Calls a block to do operations on keys See sanitize_keys! for examples
--

567=========
->Original Input:
['def', 'sanitize_keys!', 'manipulate_keys!', '{', '|', 'key_name', '|', 'key_name', '.', 'is_a?', '(', 'Symbol', ')', '?', 'key_name', ':', 'key_name', '.', 'to_sym', '}', 'manipulate_keys!', '{', '|', 'key_name', '|', 'key_name', '.', 'to_s', '.', 'tr', '(', "'-'", ',', "'_'", ')', '.', 'to_sym', '}', 'end']
->Original Target:
['Symbolizes', 'and', 'sanitizes', 'keys', 'in', 'the', 'option', 'store']
->Reconstructed Target:
Symbolizes and sanitizes keys in the option store
->Reconstructed Predication:
the key to be used for
->Raw Input:
summarize:def sanitize_keys! manipulate_keys! { | key_name | key_name. is_a? ( Symbol )? key_name : key_name. to_sym } manipulate_keys! { | key_name | key_name. to_s. tr ( '-', '_' ). to_sym } end
->Raw Target:
Symbolizes and sanitizes keys in the option store
--

568=========
->Original Input:
['def', 'representer_for', '(', 'format', ',', 'model', ',', 'options', '=', '{', '}', ')', 'options', '.', 'delete', '(', ':represent_with', ')', '||', 'self', '.', 'class', '.', 'represents_options', '.', 'for', '(', 'format', ',', 'model', ',', 'controller_path', ')', 'end']
->Original Target:
['Central', 'entry', '-', 'point', 'for', 'finding', 'the', 'appropriate', 'representer', '.']
->Reconstructed Target:
Central entry - point for finding the appropriate representer.
->Reconstructed Predication:
represents a model with the givenrepresents a model with the given
->Raw Input:
summarize:def representer_for ( format, model, options = { } ) options. delete ( :represent_with ) || self. class. represents_options. for ( format, model, controller_path ) end
->Raw Target:
Central entry - point for finding the appropriate representer.
--

569=========
->Original Input:
['def', 'variable_text_field', '(', 'x', ',', 'y', ',', 'params', '=', '{', '}', ')', 'x', '=', '0', 'unless', 'numeric?', '(', 'x', ')', 'y', '=', '0', 'unless', 'numeric?', '(', 'y', ')', 'options', '=', '{', 'height', ':', '0.1', ',', 'width', ':', '0.1', '}', '.', 'merge!', '(', 'params', ')', 'self', '.', 'variable_fields_count', '+=', '1', 'label_data', '.', 'push', '(', "'^FO'", '+', 'Integer', '(', 'x', '*', 'printer_dpi', ')', '.', 'to_s', '+', "','", '+', 'Integer', '(', 'y', '*', 'printer_dpi', ')', '.', 'to_s', ')', 'if', 'params', '[', ':orientation', ']', '==', ':landscape', 'label_data', '.', 'push', '(', "'^A0N,'", ')', 'else', 'label_data', '.', 'push', '(', "'^A0B,'", ')', 'end', 'label_data', '.', 'push', '(', 'Integer', '(', 'options', '[', ':height', ']', '*', 'printer_dpi', ')', '.', 'to_s', '+', "','", '+', 'Integer', '(', 'options', '[', ':width', ']', '*', 'printer_dpi', ')', '.', 'to_s', '+', "'^FN'", '+', 'variable_fields_count', '.', 'to_s', '+', "'^FS'", ')', 'end']
->Original Target:
['Called', 'when', 'the', 'new', 'method', 'is', 'invoked', 'Sets', 'a', 'variable', 'field', 'that', 'can', 'be', 'recalled']
->Reconstructed Target:
Called when the new method is invoked Sets a variable field that can be recalled
->Reconstructed Predication:
+ x + ',' ++ y ++ options [ :orientation ]++ options [ :width ]+ options [ :height ]+ options [ :width ]+ options [ :height ]+ options [ :width ]+ options [ :height ]+ options [ :width ]+ options [ :orientation ]+ options [ :orientation ]+ options [ :orientation ]+ options [ :orientation ]+
->Raw Input:
summarize:def variable_text_field ( x, y, params = { } ) x = 0 unless numeric? ( x ) y = 0 unless numeric? ( y ) options = { height : 0.1, width : 0.1 }. merge! ( params ) self. variable_fields_count += 1 label_data. push ( '^FO' + Integer ( x * printer_dpi ). to_s + ',' + Integer ( y * printer_dpi ). to_s ) if params [ :orientation ] == :landscape label_data. push ( '^A0N,' ) else label_data. push ( '^A0B,' ) end label_data. push ( Integer ( options [ :height ] * printer_dpi ). to_s + ',' + Integer ( options [ :width ] * printer_dpi ). to_s + '^FN' + variable_fields_count. to_s + '^FS' ) end
->Raw Target:
Called when the new method is invoked Sets a variable field that can be recalled
--

570=========
->Original Input:
['def', 'home_position', '(', 'x', ',', 'y', ')', 'x', '=', '0', 'unless', 'numeric?', '(', 'x', ')', 'y', '=', '0', 'unless', 'numeric?', '(', 'y', ')', 'label_data', '.', 'push', '(', "'^LH'", '+', 'x', '.', 'to_s', '+', "','", '+', 'y', '.', 'to_s', ')', 'end']
->Original Target:
['Set', 'the', 'home', 'position', 'of', 'the', 'label', 'All', 'other', 'X', 'and', 'Y', 'coordinates', 'are', 'relative', 'to', 'this']
->Reconstructed Target:
Set the home position of the label All other X and Y coordinates are relative to this
->Reconstructed Predication:
the home position of the home
->Raw Input:
summarize:def home_position ( x, y ) x = 0 unless numeric? ( x ) y = 0 unless numeric? ( y ) label_data. push ( '^LH' + x. to_s + ',' + y. to_s ) end
->Raw Target:
Set the home position of the label All other X and Y coordinates are relative to this
--

571=========
->Original Input:
['def', 'draw_border', '(', 'x', ',', 'y', ',', 'height', ',', 'width', ')', 'return', 'unless', 'numeric?', '(', 'height', ')', '&&', 'numeric?', '(', 'width', ')', 'x', '=', '0', 'unless', 'numeric?', '(', 'x', ')', 'y', '=', '0', 'unless', 'numeric?', '(', 'y', ')', 'label_data', '.', 'push', '(', "'^FO'", '+', 'Integer', '(', 'x', '*', 'printer_dpi', ')', '.', 'to_s', '+', "','", '+', 'Integer', '(', 'y', '*', 'printer_dpi', ')', '.', 'to_s', '+', "'^GB'", '+', 'Integer', '(', 'height', '*', 'printer_dpi', ')', '.', 'to_s', '+', "','", '+', 'Integer', '(', 'width', '*', 'printer_dpi', ')', '.', 'to_s', '+', "',1^FS'", ')', 'end']
->Original Target:
['Draws', 'a', 'square', 'border', 'on', 'dot', 'in', 'width']
->Reconstructed Target:
Draws a square border on dot in width
->Reconstructed Predication:
y = 0y = 0y = 0 unless numeric?y = 0 unless numeric?y = 0 unless numeric?y = 0 unless numeric?y = 0 unless numeric?y = 0 unless numeric?y = 0 unless numeric?y = 0 unless numeric?
->Raw Input:
summarize:def draw_border ( x, y, height, width ) return unless numeric? ( height ) && numeric? ( width ) x = 0 unless numeric? ( x ) y = 0 unless numeric? ( y ) label_data. push ( '^FO' + Integer ( x * printer_dpi ). to_s + ',' + Integer ( y * printer_dpi ). to_s + '^GB' + Integer ( height * printer_dpi ). to_s + ',' + Integer ( width * printer_dpi ). to_s + ',1^FS' ) end
->Raw Target:
Draws a square border on dot in width
--

572=========
->Original Input:
['def', 'reset_barcode_fields_to_default', 'label_data', '.', 'push', '(', "'^BY'", '+', 'Integer', '(', 'self', '.', 'barcode_default_module_width', ')', '.', 'to_s', '+', "','", '+', 'Float', '(', 'self', '.', 'barcode_default_width_ratio', ')', '.', 'to_s', '+', "','", '+', 'Integer', '(', 'self', '.', 'barcode_default_height', ')', '.', 'to_s', ')', 'end']
->Original Target:
['Some', 'barcodes', 'such', 'as', 'QR', 'codes', 'may', 'change', 'document', 'defaults', '.', 'These', 'may', 'be', 'reset', 'to', 'the', 'document', 'defaults', '.']
->Reconstructed Target:
Some barcodes such as QR codes may change document defaults. These may be reset to the document defaults.
->Reconstructed Predication:
the barcode fields to default
->Raw Input:
summarize:def reset_barcode_fields_to_default label_data. push ( '^BY' + Integer ( self. barcode_default_module_width ). to_s + ',' + Float ( self. barcode_default_width_ratio ). to_s + ',' + Integer ( self. barcode_default_height ). to_s ) end
->Raw Target:
Some barcodes such as QR codes may change document defaults. These may be reset to the document defaults.
--

573=========
->Original Input:
['def', 'draw_bar_code_39', '(', 'bar_code_string', ',', 'x', ',', 'y', ',', 'height', ')', 'return', 'unless', 'label_height', '>', '0', '&&', 'label_width', '>', '0', 'pdf', '.', 'bounding_box', '[', 'x', ',', 'Integer', '(', 'label_width', ')', '-', 'y', '-', '(', 'height', '*', 'pdf_dpi', ')', ']', ',', 'width', ':', '(', 'height', '*', 'pdf_dpi', ')', 'do', 'barcode', '=', 'Barby', '::', 'Code39', '.', 'new', '(', 'bar_code_string', ')', 'barcode', '.', 'annotate_pdf', '(', 'pdf', ',', 'height', ':', '(', 'height', '*', 'pdf_dpi', ')', ')', 'end', 'end']
->Original Target:
['Draws', 'the', 'PDF', 'bar', 'code', '39']
->Reconstructed Target:
Draws the PDF bar code 39
->Reconstructed Predication:
barcode_string
->Raw Input:
summarize:def draw_bar_code_39 ( bar_code_string, x, y, height ) return unless label_height > 0 && label_width > 0 pdf. bounding_box [ x, Integer ( label_width ) - y - ( height * pdf_dpi ) ], width : ( height * pdf_dpi ) do barcode = Barby :: Code39. new ( bar_code_string ) barcode. annotate_pdf ( pdf, height : ( height * pdf_dpi ) ) end end
->Raw Target:
Draws the PDF bar code 39
--

574=========
->Original Input:
['def', 'add_field', '(', 'value', ')', 'return', 'if', 'value', '.', 'nil?', 'return', 'if', 'value', '.', 'strip', '.', 'empty?', 'self', '.', 'variable_fields_count', '+=', '1', 'label_data', '.', 'push', '(', "'^FN'", '+', 'variable_fields_count', '.', 'to_s', '+', "'^FD'", '+', 'value', '+', "'^FS'", ')', 'end']
->Original Target:
['Called', 'when', 'the', 'new', 'method', 'is', 'invoked', 'Adds', 'a', 'variable', 'that', 'is', 'to', 'be', 'applied', 'to', 'the', 'saved', 'template']
->Reconstructed Target:
Called when the new method is invoked Adds a variable that is to be applied to the saved template
->Reconstructed Predication:
the field to be added
->Raw Input:
summarize:def add_field ( value ) return if value. nil? return if value. strip. empty? self. variable_fields_count += 1 label_data. push ( '^FN' + variable_fields_count. to_s + '^FD' + value + '^FS' ) end
->Raw Target:
Called when the new method is invoked Adds a variable that is to be applied to the saved template
--

575=========
->Original Input:
['def', 'build_slug', 'if', 'localized?', 'begin', 'orig_locale', '=', 'I18n', '.', 'locale', 'all_locales', '.', 'each', 'do', '|', 'target_locale', '|', 'I18n', '.', 'locale', '=', 'target_locale', 'apply_slug', 'end', 'ensure', 'I18n', '.', 'locale', '=', 'orig_locale', 'end', 'else', 'apply_slug', 'end', 'true', 'end']
->Original Target:
['Builds', 'a', 'new', 'slug', '.']
->Reconstructed Target:
Builds a new slug.
->Reconstructed Predication:
the slug to the current locale
->Raw Input:
summarize:def build_slug if localized? begin orig_locale = I18n. locale all_locales. each do | target_locale | I18n. locale = target_locale apply_slug end ensure I18n. locale = orig_locale end else apply_slug end true end
->Raw Target:
Builds a new slug.
--

576=========
->Original Input:
['def', 'new_with_slugs?', 'if', 'localized?', 'new_record?', '&&', '_slugs_translations', '.', 'fetch', '(', 'I18n', '.', 'locale', '.', 'to_s', ',', '[', ']', ')', '.', 'any?', 'else', 'new_record?', '&&', '_slugs', '.', 'present?', 'end', 'end']
->Original Target:
['Returns', 'true', 'if', 'object', 'is', 'a', 'new', 'record', 'and', 'slugs', 'are', 'present']
->Reconstructed Target:
Returns true if object is a new record and slugs are present
->Reconstructed Predication:
return true if the record is
->Raw Input:
summarize:def new_with_slugs? if localized? new_record? && _slugs_translations. fetch ( I18n. locale. to_s, [ ] ). any? else new_record? && _slugs. present? end end
->Raw Target:
Returns true if object is a new record and slugs are present
--

577=========
->Original Input:
['def', 'persisted_with_slug_changes?', 'if', 'localized?', 'changes', '=', '_slugs_change', 'return', '(', 'persisted?', '&&', 'false', ')', 'if', 'changes', '.', 'nil?', 'original', '=', 'changes', '.', 'first', '.', 'try', '(', ':fetch', ',', 'I18n', '.', 'locale', '.', 'to_s', ',', 'nil', ')', 'compare', '=', 'changes', '.', 'last', '.', 'try', '(', ':fetch', ',', 'I18n', '.', 'locale', '.', 'to_s', ',', 'nil', ')', 'persisted?', '&&', 'original', '!=', 'compare', 'else', 'persisted?', '&&', '_slugs_changed?', 'end', 'end']
->Original Target:
['Returns', 'true', 'if', 'object', 'has', 'been', 'persisted', 'and', 'has', 'changes', 'in', 'the', 'slug']
->Reconstructed Target:
Returns true if object has been persisted and has changes in the slug
->Reconstructed Predication:
the slug changes
->Raw Input:
summarize:def persisted_with_slug_changes? if localized? changes = _slugs_change return ( persisted? && false ) if changes. nil? original = changes. first. try ( :fetch, I18n. locale. to_s, nil ) compare = changes. last. try ( :fetch, I18n. locale. to_s, nil ) persisted? && original!= compare else persisted? && _slugs_changed? end end
->Raw Target:
Returns true if object has been persisted and has changes in the slug
--

578=========
->Original Input:
['def', 'distance_of_time_in_words', '(', 'from_time', ',', 'to_time', '=', 'Time', '.', 'now', ')', 'from_time', '=', 'from_time', '.', 'to_time', 'if', 'from_time', '.', 'respond_to?', '(', ':to_time', ')', 'to_time', '=', 'to_time', '.', 'to_time', 'if', 'to_time', '.', 'respond_to?', '(', ':to_time', ')', 'seconds', '=', '(', 'to_time', '-', 'from_time', ')', '.', 'round', 'distance_in_days', '=', '(', 'seconds', '/', '(', '60', '*', '60', '*', '24', ')', ')', '.', 'round', 'seconds', '=', 'seconds', '%', '(', '60', '*', '60', '*', '24', ')', 'distance_in_hours', '=', '(', 'seconds', '/', '(', '60', '*', '60', ')', ')', '.', 'round', 'seconds', '=', 'seconds', '%', '(', '60', '*', '60', ')', 'distance_in_minutes', '=', '(', 'seconds', '/', '60', ')', '.', 'round', 'seconds', '=', 'seconds', '%', '60', 'distance_in_seconds', '=', 'seconds', 's', '=', "''", 's', '<<', '"#{distance_in_days} days,"', 'if', 'distance_in_days', '>', '0', 's', '<<', '"#{distance_in_hours} hours, "', 'if', 'distance_in_hours', '>', '0', 's', '<<', '"#{distance_in_minutes} minutes, "', 'if', 'distance_in_minutes', '>', '0', 's', '<<', '"#{distance_in_seconds} seconds"', 's', 'end']
->Original Target:
['Return', 'the', 'distance', 'of', 'time', 'in', 'words', 'from', 'the', 'given', 'from_time', 'to', 'the', 'specified', 'to_time', '.', 'If', 'to_time', 'is', 'not', 'specified', 'then', 'Time', '.', 'now', 'is', 'used', '.', 'By', 'default', 'seconds', 'are', 'included', '...', 'set', 'the', 'include_seconds', 'argument', 'to', 'false', 'to', 'disable', 'the', 'seconds', '.']
->Reconstructed Target:
Return the distance of time in words from the given from_time to the specified to_time. If to_time is not specified then Time. now is used. By default seconds are included... set the include_seconds argument to false to disable the seconds.
->Reconstructed Predication:
the distance of the timethe time the distance of thethe timethe distance of the timethe time the distance of thethe time the distancethe time thethe time the distancethe time the timethe time the distance of thethe time the timethe time the distance of thethe time the timethe time the timethe time the distance of thethe time the time isthe time the time thethe
->Raw Input:
summarize:def distance_of_time_in_words ( from_time, to_time = Time. now ) from_time = from_time. to_time if from_time. respond_to? ( :to_time ) to_time = to_time. to_time if to_time. respond_to? ( :to_time ) seconds = ( to_time - from_time ). round distance_in_days = ( seconds / ( 60 * 60 * 24 ) ). round seconds = seconds % ( 60 * 60 * 24 ) distance_in_hours = ( seconds / ( 60 * 60 ) ). round seconds = seconds % ( 60 * 60 ) distance_in_minutes = ( seconds / 60 ). round seconds = seconds % 60 distance_in_seconds = seconds s = '' s << "#{distance_in_days} days," if distance_in_days > 0 s << "#{distance_in_hours} hours, " if distance_in_hours > 0 s << "#{distance_in_minutes} minutes, " if distance_in_minutes > 0 s << "#{distance_in_seconds} seconds" s end
->Raw Target:
Return the distance of time in words from the given from_time to the specified to_time. If to_time is not specified then Time. now is used. By default seconds are included... set the include_seconds argument to false to disable the seconds.
--

579=========
->Original Input:
['def', 'approximate_distance_of_time_in_words', '(', 'from_time', ',', 'to_time', '=', 'Time', '.', 'now', ',', 'include_seconds', '=', 'true', ')', 'from_time', '=', 'from_time', '.', 'to_time', 'if', 'from_time', '.', 'respond_to?', '(', ':to_time', ')', 'to_time', '=', 'to_time', '.', 'to_time', 'if', 'to_time', '.', 'respond_to?', '(', ':to_time', ')', 'distance_in_minutes', '=', '(', '(', '(', 'to_time', '-', 'from_time', ')', '.', 'abs', ')', '/', '60', ')', '.', 'round', 'distance_in_seconds', '=', '(', '(', 'to_time', '-', 'from_time', ')', '.', 'abs', ')', '.', 'round', 'case', 'distance_in_minutes', 'when', '0', '..', '1', 'return', '(', 'distance_in_minutes', '==', '0', ')', '?', "'less than a minute'", ':', "'1 minute'", 'unless', 'include_seconds', 'case', 'distance_in_seconds', 'when', '0', '..', '4', 'then', "'less than 5 seconds'", 'when', '5', '..', '9', 'then', "'less than 10 seconds'", 'when', '10', '..', '19', 'then', "'less than 20 seconds'", 'when', '20', '..', '39', 'then', "'half a minute'", 'when', '40', '..', '59', 'then', "'less than a minute'", 'else', "'1 minute'", 'end', 'when', '2', '..', '44', 'then', '"#{distance_in_minutes} minutes"', 'when', '45', '..', '89', 'then', "'about 1 hour'", 'when', '90', '..', '1439', 'then', '"about #{(distance_in_minutes.to_f / 60.0).round} hours"', 'when', '1440', '..', '2879', 'then', "'1 day'", 'when', '2880', '..', '43199', 'then', '"#{(distance_in_minutes / 1440).round} days"', 'when', '43200', '..', '86399', 'then', "'about 1 month'", 'when', '86400', '..', '525959', 'then', '"#{(distance_in_minutes / 43200).round} months"', 'when', '525960', '..', '1051919', 'then', "'about 1 year'", 'else', '"over #{(distance_in_minutes / 525960).round} years"', 'end', 'end']
->Original Target:
['Get', 'the', 'approximate', 'disntance', 'of', 'time', 'in', 'words', 'from', 'the', 'given', 'from_time', 'to', 'the', 'the', 'given', 'to_time', '.', 'If', 'to_time', 'is', 'not', 'specified', 'then', 'it', 'is', 'set', 'to', 'Time', '.', 'now', '.', 'By', 'default', 'seconds', 'are', 'included', '...', 'set', 'the', 'include_seconds', 'argument', 'to', 'false', 'to', 'disable', 'the', 'seconds', '.']
->Reconstructed Target:
Get the approximate disntance of time in words from the given from_time to the the given to_time. If to_time is not specified then it is set to Time. now. By default seconds are included... set the include_seconds argument to false to disable the seconds.
->Reconstructed Predication:
::::: 'less than a minute': 'less than a minute': 'less than a minute': 'less than a minute': 'less than a minute': 'less than a minute': 'less than a minute': 'less than a minute': 'less than a minute': 'less than a minute': 'less than a minute':
->Raw Input:
summarize:def approximate_distance_of_time_in_words ( from_time, to_time = Time. now, include_seconds = true ) from_time = from_time. to_time if from_time. respond_to? ( :to_time ) to_time = to_time. to_time if to_time. respond_to? ( :to_time ) distance_in_minutes = ( ( ( to_time - from_time ). abs ) / 60 ). round distance_in_seconds = ( ( to_time - from_time ). abs ). round case distance_in_minutes when 0.. 1 return ( distance_in_minutes == 0 )? 'less than a minute' : '1 minute' unless include_seconds case distance_in_seconds when 0.. 4 then 'less than 5 seconds' when 5.. 9 then 'less than 10 seconds' when 10.. 19 then 'less than 20 seconds' when 20.. 39 then 'half a minute' when 40.. 59 then 'less than a minute' else '1 minute' end when 2.. 44 then "#{distance_in_minutes} minutes" when 45.. 89 then 'about 1 hour' when 90.. 1439 then "about #{(distance_in_minutes.to_f / 60.0).round} hours" when 1440.. 2879 then '1 day' when 2880.. 43199 then "#{(distance_in_minutes / 1440).round} days" when 43200.. 86399 then 'about 1 month' when 86400.. 525959 then "#{(distance_in_minutes / 43200).round} months" when 525960.. 1051919 then 'about 1 year' else "over #{(distance_in_minutes / 525960).round} years" end end
->Raw Target:
Get the approximate disntance of time in words from the given from_time to the the given to_time. If to_time is not specified then it is set to Time. now. By default seconds are included... set the include_seconds argument to false to disable the seconds.
--

580=========
->Original Input:
['def', 'track_error', '(', 'control', ',', 'msg', ')', 'errors', '<<', 'msg', 'control', '.', 'error_handlers', '.', 'each', 'do', '|', 'handler', '|', 'handler', '.', 'call', '(', 'msg', ')', 'end', 'end']
->Original Target:
['First', 'attempt', 'at', 'centralizing', 'error', 'notifications']
->Reconstructed Target:
First attempt at centralizing error notifications
->Reconstructed Predication:
the error message to the
->Raw Input:
summarize:def track_error ( control, msg ) errors << msg control. error_handlers. each do | handler | handler. call ( msg ) end end
->Raw Target:
First attempt at centralizing error notifications
--

581=========
->Original Input:
['def', 'process_batch', '(', 'batch', ')', 'batch', '=', 'ETL', '::', 'Batch', '::', 'Batch', '.', 'resolve', '(', 'batch', ',', 'self', ')', 'say', '"Processing batch #{batch.file}"', 'ETL', '::', 'Engine', '.', 'batch', '=', 'ETL', '::', 'Execution', '::', 'Batch', '.', 'create!', '(', ':batch_file', '=>', 'batch', '.', 'file', ',', ':status', '=>', "'executing'", ')', 'batch', '.', 'execute', 'ETL', '::', 'Engine', '.', 'batch', '.', 'completed_at', '=', 'Time', '.', 'now', 'ETL', '::', 'Engine', '.', 'batch', '.', 'status', '=', '(', 'errors', '.', 'length', '>', '0', '?', "'completed with errors'", ':', "'completed'", ')', 'ETL', '::', 'Engine', '.', 'batch', '.', 'save!', 'end']
->Original Target:
['Process', 'the', 'specified', 'batch', 'file']
->Reconstructed Target:
Process the specified batch file
->Reconstructed Predication:
the batch to be processed
->Raw Input:
summarize:def process_batch ( batch ) batch = ETL :: Batch :: Batch. resolve ( batch, self ) say "Processing batch #{batch.file}" ETL :: Engine. batch = ETL :: Execution :: Batch. create! ( :batch_file => batch. file, :status => 'executing' ) batch. execute ETL :: Engine. batch. completed_at = Time. now ETL :: Engine. batch. status = ( errors. length > 0? 'completed with errors' : 'completed' ) ETL :: Engine. batch. save! end
->Raw Target:
Process the specified batch file
--

582=========
->Original Input:
['def', 'pre_process', '(', 'control', ')', 'Engine', '.', 'logger', '.', 'debug', '"Pre-processing #{control.file}"', 'control', '.', 'pre_processors', '.', 'each', 'do', '|', 'processor', '|', 'processor', '.', 'process', 'end', 'Engine', '.', 'logger', '.', 'debug', '"Pre-processing complete"', 'end']
->Original Target:
['Execute', 'all', 'preprocessors']
->Reconstructed Target:
Execute all preprocessors
->Reconstructed Predication:
pre - processing
->Raw Input:
summarize:def pre_process ( control ) Engine. logger. debug "Pre-processing #{control.file}" control. pre_processors. each do | processor | processor. process end Engine. logger. debug "Pre-processing complete" end
->Raw Target:
Execute all preprocessors
--

583=========
->Original Input:
['def', 'post_process', '(', 'control', ')', 'say_on_own_line', '"Executing post processes"', 'Engine', '.', 'logger', '.', 'debug', '"Post-processing #{control.file}"', 'control', '.', 'post_processors', '.', 'each', 'do', '|', 'processor', '|', 'processor', '.', 'process', 'end', 'Engine', '.', 'logger', '.', 'debug', '"Post-processing complete"', 'say', '"Post-processing complete"', 'end']
->Original Target:
['Execute', 'all', 'postprocessors']
->Reconstructed Target:
Execute all postprocessors
->Reconstructed Predication:
post processing complete" end  def
->Raw Input:
summarize:def post_process ( control ) say_on_own_line "Executing post processes" Engine. logger. debug "Post-processing #{control.file}" control. post_processors. each do | processor | processor. process end Engine. logger. debug "Post-processing complete" say "Post-processing complete" end
->Raw Target:
Execute all postprocessors
--

584=========
->Original Input:
['def', 'execute_dependencies', '(', 'control', ')', 'Engine', '.', 'logger', '.', 'debug', '"Executing dependencies"', 'control', '.', 'dependencies', '.', 'flatten', '.', 'each', 'do', '|', 'dependency', '|', 'case', 'dependency', 'when', 'Symbol', 'f', '=', 'dependency', '.', 'to_s', '+', "'.ctl'", 'Engine', '.', 'logger', '.', 'debug', '"Executing dependency: #{f}"', 'say', '"Executing dependency: #{f}"', 'process', '(', 'f', ')', 'when', 'String', 'Engine', '.', 'logger', '.', 'debug', '"Executing dependency: #{f}"', 'say', '"Executing dependency: #{f}"', 'process', '(', 'dependency', ')', 'else', 'raise', '"Invalid dependency type: #{dependency.class}"', 'end', 'end', 'end']
->Original Target:
['Execute', 'all', 'dependencies']
->Reconstructed Target:
Execute all dependencies
->Reconstructed Predication:
the dependencies of the control
->Raw Input:
summarize:def execute_dependencies ( control ) Engine. logger. debug "Executing dependencies" control. dependencies. flatten. each do | dependency | case dependency when Symbol f = dependency. to_s + '.ctl' Engine. logger. debug "Executing dependency: #{f}" say "Executing dependency: #{f}" process ( f ) when String Engine. logger. debug "Executing dependency: #{f}" say "Executing dependency: #{f}" process ( dependency ) else raise "Invalid dependency type: #{dependency.class}" end end end
->Raw Target:
Execute all dependencies
--

585=========
->Original Input:
['def', 'execute_screens', '(', 'control', ',', 'timing', '=', ':before_post_process', ')', 'screens', '=', 'case', 'timing', 'when', ':after_post_process', 'control', '.', 'after_post_process_screens', 'else', 'control', '.', 'screens', 'end', '[', ':fatal', ',', ':error', ',', ':warn', ']', '.', 'each', 'do', '|', 'type', '|', 'screens', '[', 'type', ']', '.', 'each', 'do', '|', 'block', '|', 'begin', 'block', '.', 'call', 'rescue', '=>', 'e', 'case', 'type', 'when', ':fatal', 'raise', 'FatalScreenError', ',', 'e', 'when', ':error', 'raise', 'ScreenError', ',', 'e', 'when', ':warn', 'say', '"Screen warning: #{e}"', 'end', 'end', 'end', 'end', 'end']
->Original Target:
['Execute', 'all', 'screens']
->Reconstructed Target:
Execute all screens
->Reconstructed Predication:
the screens to be executed
->Raw Input:
summarize:def execute_screens ( control, timing = :before_post_process ) screens = case timing when :after_post_process control. after_post_process_screens else control. screens end [ :fatal, :error, :warn ]. each do | type | screens [ type ]. each do | block | begin block. call rescue => e case type when :fatal raise FatalScreenError, e when :error raise ScreenError, e when :warn say "Screen warning: #{e}" end end end end end
->Raw Target:
Execute all screens
--

586=========
->Original Input:
['def', 'redis_key', '*', 'fields', '@redis_key_config', '=', 'fields', '.', 'flatten', 'validate_redis_key', 'remove_redis_autoincrement_key', 'unless', 'redis_user_field_config', '.', 'include?', '(', ':id', ')', '||', '@redis_key_config', '.', 'include?', '(', ':id', ')', '@redis_key_config', '.', 'each', 'do', '|', 'field', '|', 'validates', 'field', ',', ':presence', '=>', ':true', 'if', 'field', '!=', ':id', 'end', 'end']
->Original Target:
['set', 'redis', 'key', 'which', 'will', 'be', 'used', 'for', 'storing', 'model']
->Reconstructed Target:
set redis key which will be used for storing model
->Reconstructed Predication:
the redis key to use
->Raw Input:
summarize:def redis_key * fields @redis_key_config = fields. flatten validate_redis_key remove_redis_autoincrement_key unless redis_user_field_config. include? ( :id ) || @redis_key_config. include? ( :id ) @redis_key_config. each do | field | validates field, :presence => :true if field!= :id end end
->Raw Target:
set redis key which will be used for storing model
--

587=========
->Original Input:
['def', 'redis_key_normalize', '*', 'metrics', '@redis_key_normalize_conf', '||=', '[', ']', 'metrics', '.', 'each', 'do', '|', 'metric', '|', 'raise', 'ArgumentError', ',', '"Please provide valid normalization: #{VALID_NORMALIZATIONS.join(", ")}"', 'unless', 'VALID_NORMALIZATIONS', '.', 'include?', '(', 'metric', ')', '@redis_key_normalize_conf', '<<', 'metric', 'end', 'end']
->Original Target:
['set', 'redis', 'model', 'to', 'normalize', 'redis', 'keys']
->Reconstructed Target:
set redis model to normalize redis keys
->Reconstructed Predication:
the key to be normalized
->Raw Input:
summarize:def redis_key_normalize * metrics @redis_key_normalize_conf ||= [ ] metrics. each do | metric | raise ArgumentError, "Please provide valid normalization: #{VALID_NORMALIZATIONS.join(", ")}" unless VALID_NORMALIZATIONS. include? ( metric ) @redis_key_normalize_conf << metric end end
->Raw Target:
set redis model to normalize redis keys
--

588=========
->Original Input:
['def', 'redis_alias', 'name', ',', 'main_fields', ',', 'name_of_field_for_order', '=', 'nil', ',', 'name_of_field_for_args', '=', 'nil', 'if', 'name_of_field_for_order', '&&', 'name_of_field_for_args', 'redis_field', 'name_of_field_for_order', ',', ':array', ',', '[', ']', 'unless', 'redis_fields_config', '.', 'has_key?', '(', 'name_of_field_for_order', ')', 'redis_field', 'name_of_field_for_args', ',', ':hash', ',', '{', '}', 'unless', 'redis_fields_config', '.', 'has_key?', '(', 'name_of_field_for_args', ')', 'end', '@redis_alias_config', '||=', '{', '}', '@redis_alias_config', '[', 'name', ']', '=', '{', 'main_fields', ':', 'main_fields', ',', 'order_field', ':', 'name_of_field_for_order', ',', 'args_field', ':', 'name_of_field_for_args', ',', '}', 'create_class_alias_method', '(', 'name', ')', 'end']
->Original Target:
['store', 'informations', 'about', 'redis', 'aliases']
->Reconstructed Target:
store informations about redis aliases
->Reconstructed Predication:
thethe main_fieldsthe main_fieldsthe main_fieldsthe main_fields
->Raw Input:
summarize:def redis_alias name, main_fields, name_of_field_for_order = nil, name_of_field_for_args = nil if name_of_field_for_order && name_of_field_for_args redis_field name_of_field_for_order, :array, [ ] unless redis_fields_config. has_key? ( name_of_field_for_order ) redis_field name_of_field_for_args, :hash, { } unless redis_fields_config. has_key? ( name_of_field_for_args ) end @redis_alias_config ||= { } @redis_alias_config [ name ] = { main_fields : main_fields, order_field : name_of_field_for_order, args_field : name_of_field_for_args, } create_class_alias_method ( name ) end
->Raw Target:
store informations about redis aliases
--

589=========
->Original Input:
['def', 'store_redis_keys', 'args', '=', 'to_arg', 'redis_old_keys', '[', ':key', ']', '=', 'self', '.', 'class', '.', 'generate_key', '(', 'args', ')', 'redis_old_keys', '[', ':aliases', ']', '=', '[', ']', 'redis_alias_config', '.', 'each', 'do', '|', 'alias_name', ',', 'fields', '|', 'redis_old_keys', '[', ':aliases', ']', '<<', 'redis_alias_key', '(', 'alias_name', ')', 'if', 'valid_alias_key?', 'alias_name', 'end', 'end']
->Original Target:
['set', 'old', 'arguments']
->Reconstructed Target:
set old arguments
->Reconstructed Predication:
the key to store
->Raw Input:
summarize:def store_redis_keys args = to_arg redis_old_keys [ :key ] = self. class. generate_key ( args ) redis_old_keys [ :aliases ] = [ ] redis_alias_config. each do | alias_name, fields | redis_old_keys [ :aliases ] << redis_alias_key ( alias_name ) if valid_alias_key? alias_name end end
->Raw Target:
set old arguments
--

590=========
->Original Input:
['def', 'conf', 'fields', '=', '{', '}', 'redis_fields_config', '.', 'each', 'do', '|', 'key', ',', 'type', '|', 'fields', '[', 'key', ']', '=', 'TYPE_TRANSLATIONS', '[', 'type', ']', 'if', 'TYPE_TRANSLATIONS', '.', 'has_key?', '(', 'type', ')', 'end', '{', 'fields', ':', 'fields', ',', 'required', ':', '@required_config', '.', 'sort', ',', 'redis_key', ':', 'redis_key_config', ',', 'redis_aliases', ':', 'redis_alias_config', '.', 'inject', '(', '{', '}', ')', '{', '|', 'o', ',', '(', 'k', ',', 'v', ')', '|', 'o', '[', 'k', ']', '=', 'v', '[', ':main_fields', ']', ';', 'o', '}', ',', 'reject_nil_values', ':', '!', 'redis_save_fields_with_nil_conf', ',', '}', 'end']
->Original Target:
['get', 'config', 'hash']
->Reconstructed Target:
get config hash
->Reconstructed Predication:
::
->Raw Input:
summarize:def conf fields = { } redis_fields_config. each do | key, type | fields [ key ] = TYPE_TRANSLATIONS [ type ] if TYPE_TRANSLATIONS. has_key? ( type ) end { fields : fields, required : @required_config. sort, redis_key : redis_key_config, redis_aliases : redis_alias_config. inject ( { } ) { | o, ( k, v ) | o [ k ] = v [ :main_fields ] ; o }, reject_nil_values :! redis_save_fields_with_nil_conf, } end
->Raw Target:
get config hash
--

591=========
->Original Input:
['def', 'exists?', 'args', '=', '{', '}', 'RedisModelExtension', '::', 'Database', '.', 'redis', '.', 'exists', '(', 'self', '.', 'name', '.', 'constantize', '.', 'generate_key', '(', 'args', ')', ')', 'end']
->Original Target:
['Check', 'if', 'key', 'by', 'arguments', 'exists', 'in', 'db']
->Reconstructed Target:
Check if key by arguments exists in db
->Reconstructed Predication:
return true if the key exists
->Raw Input:
summarize:def exists? args = { } RedisModelExtension :: Database. redis. exists ( self. name. constantize. generate_key ( args ) ) end
->Raw Target:
Check if key by arguments exists in db
--

592=========
->Original Input:
['def', 'alias_exists?', 'alias_name', ',', 'args', '=', '{', '}', 'RedisModelExtension', '::', 'Database', '.', 'redis', '.', 'exists', '(', 'self', '.', 'name', '.', 'constantize', '.', 'generate_alias_key', '(', 'alias_name', ',', 'args', ')', ')', 'end']
->Original Target:
['Check', 'if', 'key', 'by', 'alias', 'name', 'and', 'arguments', 'exists', 'in', 'db']
->Reconstructed Target:
Check if key by alias name and arguments exists in db
->Reconstructed Predication:
return true if the alias exists
->Raw Input:
summarize:def alias_exists? alias_name, args = { } RedisModelExtension :: Database. redis. exists ( self. name. constantize. generate_alias_key ( alias_name, args ) ) end
->Raw Target:
Check if key by alias name and arguments exists in db
--

593=========
->Original Input:
['def', 'valid_item_for_redis_key?', 'args', ',', 'key', '(', 'args', '.', 'has_key?', '(', 'key', ')', '&&', '!', 'args', '[', 'key', ']', '.', 'nil?', ')', '||', 'redis_fields_config', '[', 'key', ']', '==', ':autoincrement', 'end']
->Original Target:
['validate', 'one', 'item', 'of', 'redis', 'key']
->Reconstructed Target:
validate one item of redis key
->Reconstructed Predication:
the item for the given redis_key
->Raw Input:
summarize:def valid_item_for_redis_key? args, key ( args. has_key? ( key ) &&! args [ key ]. nil? ) || redis_fields_config [ key ] == :autoincrement end
->Raw Target:
validate one item of redis key
--

594=========
->Original Input:
['def', 'validate_redis_key', 'valid_fields', '=', 'redis_fields_config', '.', 'select', '{', '|', 'k', ',', 'v', '|', 'v', '!=', ':array', '&&', 'v', '!=', ':hash', '}', '.', 'keys', 'bad_fields', '=', 'redis_key_config', '-', 'valid_fields', 'raise', 'ArgumentError', ',', '"Sorry, but you cannot use as redis key [nonexisting | array | hash] fields: [#{bad_fields.join(",")}], availible are: #{valid_fields.join(", ")}"', 'unless', 'bad_fields', '.', 'size', '==', '0', 'end']
->Original Target:
['look', 'for', 'bad', 'cofiguration', 'in', 'redis', 'key', 'and', 'raise', 'argument', 'error']
->Reconstructed Target:
look for bad cofiguration in redis key and raise argument error
->Reconstructed Predication:
the redis key to use
->Raw Input:
summarize:def validate_redis_key valid_fields = redis_fields_config. select { | k, v | v!= :array && v!= :hash }. keys bad_fields = redis_key_config - valid_fields raise ArgumentError, "Sorry, but you cannot use as redis key [nonexisting | array | hash] fields: [#{bad_fields.join(",")}], availible are: #{valid_fields.join(", ")}" unless bad_fields. size == 0 end
->Raw Target:
look for bad cofiguration in redis key and raise argument error
--

595=========
->Original Input:
['def', 'to_arg', 'redis_fields_config', '.', 'inject', '(', '{', '}', ')', 'do', '|', 'args', ',', '(', 'key', ',', 'type', ')', '|', 'args', '[', 'key', ']', '=', 'self', '.', 'send', '(', 'key', ')', 'args', 'end', 'end']
->Original Target:
['take', 'all', 'arguments', 'and', 'send', 'them', 'out']
->Reconstructed Target:
take all arguments and send them out
->Reconstructed Predication:
the redis_fields_config to a hash
->Raw Input:
summarize:def to_arg redis_fields_config. inject ( { } ) do | args, ( key, type ) | args [ key ] = self. send ( key ) args end end
->Raw Target:
take all arguments and send them out
--

596=========
->Original Input:
['def', 'find_by_alias', '(', 'alias_name', ',', 'args', '=', '{', '}', ')', 'raise', 'ArgumentError', ',', '"Unknown dynamic alias: \'#{alias_name}\', use: #{redis_alias_config.keys.join(", ")} "', 'unless', 'redis_alias_config', '.', 'has_key?', '(', 'alias_name', '.', 'to_sym', ')', 'args', '=', 'HashWithIndifferentAccess', '.', 'new', '(', 'args', ')', 'out', '=', '[', ']', 'klass', '=', 'self', '.', 'name', '.', 'constantize', 'search_key', '=', 'klass', '.', 'generate_alias_key', '(', 'alias_name', ',', 'args', ')', 'unless', 'search_key', '=~', '/', '\\*', '/', 'out', '=', 'klass', '.', 'get_by_alias', '(', 'alias_name', ',', 'args', ')', 'if', 'klass', '.', 'alias_exists?', '(', 'alias_name', ',', 'args', ')', 'else', 'RedisModelExtension', '::', 'Database', '.', 'redis', '.', 'keys', '(', 'search_key', ')', '.', 'each', 'do', '|', 'key', '|', 'out', '<<', 'klass', '.', 'get_by_alias_key', '(', 'key', ')', 'end', 'end', 'out', '.', 'flatten', 'end']
->Original Target:
['Find', 'method', 'for', 'searching', 'in', 'redis']
->Reconstructed Target:
Find method for searching in redis
->Reconstructed Predication:
the dynamic aliasthe dynamic aliasthe dynamic aliasthe dynamic aliasthe dynamic aliasthe dynamic aliasthe dynamic aliasthe dynamic aliasthe dynamic aliasthe dynamic alias
->Raw Input:
summarize:def find_by_alias ( alias_name, args = { } ) raise ArgumentError, "Unknown dynamic alias: '#{alias_name}', use: #{redis_alias_config.keys.join(", ")} " unless redis_alias_config. has_key? ( alias_name. to_sym ) args = HashWithIndifferentAccess. new ( args ) out = [ ] klass = self. name. constantize search_key = klass. generate_alias_key ( alias_name, args ) unless search_key =~ / \* / out = klass. get_by_alias ( alias_name, args ) if klass. alias_exists? ( alias_name, args ) else RedisModelExtension :: Database. redis. keys ( search_key ). each do | key | out << klass. get_by_alias_key ( key ) end end out. flatten end
->Raw Target:
Find method for searching in redis
--

597=========
->Original Input:
['def', 'get', '(', 'args', '=', '{', '}', ')', 'args', '=', '{', 'id', ':', 'args', '}', 'if', 'args', '.', 'is_a?', '(', 'Integer', ')', 'args', '=', 'HashWithIndifferentAccess', '.', 'new', '(', 'args', ')', 'klass', '=', 'self', '.', 'name', '.', 'constantize', 'if', 'klass', '.', 'valid_key?', '(', 'args', ')', '&&', 'klass', '.', 'exists?', '(', 'args', ')', 'klass', '.', 'new_by_key', '(', 'klass', '.', 'generate_key', '(', 'args', ')', ')', 'else', 'nil', 'end', 'end']
->Original Target:
['GET', 'BY', 'ARGUMENTS']
->Reconstructed Target:
GET BY ARGUMENTS
->Reconstructed Predication:
a summary of a specificthe summary of a specific
->Raw Input:
summarize:def get ( args = { } ) args = { id : args } if args. is_a? ( Integer ) args = HashWithIndifferentAccess. new ( args ) klass = self. name. constantize if klass. valid_key? ( args ) && klass. exists? ( args ) klass. new_by_key ( klass. generate_key ( args ) ) else nil end end
->Raw Target:
GET BY ARGUMENTS
--

598=========
->Original Input:
['def', 'get_by_alias_key', '(', 'alias_key', ')', 'klass', '=', 'self', '.', 'name', '.', 'constantize', 'if', 'RedisModelExtension', '::', 'Database', '.', 'redis', '.', 'exists', '(', 'alias_key', ')', 'out', '=', '[', ']', 'RedisModelExtension', '::', 'Database', '.', 'redis', '.', 'smembers', '(', 'alias_key', ')', '.', 'each', 'do', '|', 'key', '|', 'item', '=', 'klass', '.', 'new_by_key', '(', 'key', ')', 'out', '<<', 'item', 'if', 'item', 'end', 'return', 'out', 'end', 'nil', 'end']
->Original Target:
['fastest', 'method', 'to', 'get', 'object', 'from', 'redis', 'by', 'getting', 'it', 'by', 'alias', 'and', 'arguments']
->Reconstructed Target:
fastest method to get object from redis by getting it by alias and arguments
->Reconstructed Predication:
the item with the given alias_key
->Raw Input:
summarize:def get_by_alias_key ( alias_key ) klass = self. name. constantize if RedisModelExtension :: Database. redis. exists ( alias_key ) out = [ ] RedisModelExtension :: Database. redis. smembers ( alias_key ). each do | key | item = klass. new_by_key ( key ) out << item if item end return out end nil end
->Raw Target:
fastest method to get object from redis by getting it by alias and arguments
--

599=========
->Original Input:
['def', 'new_by_key', '(', 'key', ')', 'args', '=', 'RedisModelExtension', '::', 'Database', '.', 'redis', '.', 'hgetall', '(', 'key', ')', 'return', 'nil', 'unless', 'args', '&&', 'args', '.', 'any?', 'args', '.', 'symbolize_keys!', 'new_instance', '=', 'new', '(', 'args', ')', 'new_instance', '.', 'store_keys', 'return', 'new_instance', 'end']
->Original Target:
['CREATE', 'NEW', 'OBJECT', 'BY', 'HASH', 'VALUES']
->Reconstructed Target:
CREATE NEW OBJECT BY HASH VALUES
->Reconstructed Predication:
the value of a key
->Raw Input:
summarize:def new_by_key ( key ) args = RedisModelExtension :: Database. redis. hgetall ( key ) return nil unless args && args. any? args. symbolize_keys! new_instance = new ( args ) new_instance. store_keys return new_instance end
->Raw Target:
CREATE NEW OBJECT BY HASH VALUES
--

600=========
->Original Input:
['def', 'value_to_redis', 'name', ',', 'value', 'if', 'redis_fields_config', '.', 'has_key?', '(', 'name', ')', 'value_transform', 'value', ',', 'redis_fields_config', '[', 'name', ']', 'else', 'value', 'end', 'end']
->Original Target:
['choose', 'right', 'type', 'of', 'value', 'and', 'then', 'transform', 'it', 'for', 'redis']
->Reconstructed Target:
choose right type of value and then transform it for redis
->Reconstructed Predication:
the value to redis
->Raw Input:
summarize:def value_to_redis name, value if redis_fields_config. has_key? ( name ) value_transform value, redis_fields_config [ name ] else value end end
->Raw Target:
choose right type of value and then transform it for redis
--

601=========
->Original Input:
['def', 'value_transform', 'value', ',', 'type', 'return', 'nil', 'if', 'value', '.', 'nil?', '||', 'value', '.', 'to_s', '.', 'size', '==', '0', 'case', 'type', 'when', ':integer', 'then', 'value', '.', 'to_i', 'when', ':autoincrement', 'then', 'value', '.', 'to_i', 'when', ':string', 'then', 'value', '.', 'to_s', 'when', ':float', 'then', 'value', '.', 'to_f', 'when', ':bool', 'then', 'value', '.', 'to_s', 'when', ':symbol', 'then', 'value', '.', 'to_s', 'when', ':marshal', 'then', 'Marshal', '.', 'dump', '(', 'value', ')', 'when', ':array', 'then', 'Yajl', '::', 'Encoder', '.', 'encode', '(', 'value', ')', 'when', ':hash', 'then', 'Yajl', '::', 'Encoder', '.', 'encode', '(', 'value', ')', 'when', ':time', 'then', 'Time', '.', 'parse', '(', 'value', '.', 'to_s', ')', '.', 'strftime', '(', '"%Y.%m.%d %H:%M:%S"', ')', 'when', ':date', 'then', 'Date', '.', 'parse', '(', 'value', '.', 'to_s', ')', '.', 'strftime', '(', '"%Y-%m-%d"', ')', 'else', 'value', 'end', 'end']
->Original Target:
['convert', 'value', 'for', 'valid', 'format', 'which', 'can', 'be', 'saved', 'in', 'redis']
->Reconstructed Target:
convert value for valid format which can be saved in redis
->Reconstructed Predication:
:type :string:type :boolean:string:boolean:boolean:boolean :boolean :boolean :boolean:boolean :boolean :boolean :boolean:boolean :boolean :boolean:boolean :boolean :boolean:boolean :boolean :boolean :boolean:boolean :boolean :boolean:boolean :boolean :boolean:boolean :boolean :boolean :boolean:boolean :boolean :boolean:boolean :boolean :boolean :
->Raw Input:
summarize:def value_transform value, type return nil if value. nil? || value. to_s. size == 0 case type when :integer then value. to_i when :autoincrement then value. to_i when :string then value. to_s when :float then value. to_f when :bool then value. to_s when :symbol then value. to_s when :marshal then Marshal. dump ( value ) when :array then Yajl :: Encoder. encode ( value ) when :hash then Yajl :: Encoder. encode ( value ) when :time then Time. parse ( value. to_s ). strftime ( "%Y.%m.%d %H:%M:%S" ) when :date then Date. parse ( value. to_s ). strftime ( "%Y-%m-%d" ) else value end end
->Raw Target:
convert value for valid format which can be saved in redis
--

602=========
->Original Input:
['def', 'value_parse', 'value', ',', 'type', 'return', 'nil', 'if', 'value', '.', 'nil?', '||', 'value', '.', 'to_s', '.', 'size', '==', '0', 'case', 'type', 'when', ':integer', 'then', 'value', '.', 'to_i', 'when', ':autoincrement', 'then', 'value', '.', 'to_i', 'when', ':string', 'then', 'value', '.', 'to_s', 'when', ':float', 'then', 'value', '.', 'to_f', 'when', ':bool', 'then', 'value', '.', 'to_s', '.', 'to_bool', 'when', ':symbol', 'then', 'value', '.', 'to_s', '.', 'to_sym', 'when', ':marshal', 'then', 'value', '.', 'is_a?', '(', 'String', ')', '?', 'Marshal', '.', 'load', '(', 'value', ')', ':', 'value', 'when', ':array', 'then', 'value', '.', 'is_a?', '(', 'String', ')', '?', 'Yajl', '::', 'Parser', '.', 'parse', '(', 'value', ')', ':', 'value', 'when', ':hash', 'then', 'value', '.', 'is_a?', '(', 'String', ')', '?', 'Hashr', '.', 'new', '(', 'Yajl', '::', 'Parser', '.', 'parse', '(', 'value', ')', ')', ':', 'Hashr', '.', 'new', '(', 'value', ')', 'when', ':time', 'then', 'value', '.', 'is_a?', '(', 'String', ')', '?', 'Time', '.', 'parse', '(', 'value', ')', ':', 'value', 'when', ':date', 'then', 'value', '.', 'is_a?', '(', 'String', ')', '?', 'Date', '.', 'parse', '(', 'value', ')', ':', 'value', 'else', 'value', 'end', 'end']
->Original Target:
['convert', 'value', 'from', 'redis', 'into', 'valid', 'format', 'in', 'ruby']
->Reconstructed Target:
convert value from redis into valid format in ruby
->Reconstructed Predication:
value_parsevalue_parsevalue_parsevalue_parsevalue_parse value_parse value_parse value_parse value_parse
->Raw Input:
summarize:def value_parse value, type return nil if value. nil? || value. to_s. size == 0 case type when :integer then value. to_i when :autoincrement then value. to_i when :string then value. to_s when :float then value. to_f when :bool then value. to_s. to_bool when :symbol then value. to_s. to_sym when :marshal then value. is_a? ( String )? Marshal. load ( value ) : value when :array then value. is_a? ( String )? Yajl :: Parser. parse ( value ) : value when :hash then value. is_a? ( String )? Hashr. new ( Yajl :: Parser. parse ( value ) ) : Hashr. new ( value ) when :time then value. is_a? ( String )? Time. parse ( value ) : value when :date then value. is_a? ( String )? Date. parse ( value ) : value else value end end
->Raw Target:
convert value from redis into valid format in ruby
--

603=========
->Original Input:
['def', 'update', 'args', 'args', '.', 'each', 'do', '|', 'key', ',', 'value', '|', 'method', '=', '"#{key}="', '.', 'to_sym', 'if', 'self', '.', 'respond_to?', 'method', 'self', '.', 'send', '(', 'method', ',', 'value', ')', 'end', 'end', 'end']
->Original Target:
['update', 'multiple', 'attrubutes', 'at', 'once']
->Reconstructed Target:
update multiple attrubutes at once
->Reconstructed Predication:
the object to update the object
->Raw Input:
summarize:def update args args. each do | key, value | method = "#{key}=". to_sym if self. respond_to? method self. send ( method, value ) end end end
->Raw Target:
update multiple attrubutes at once
--

604=========
->Original Input:
['def', 'destroy_aliases!', 'if', 'redis_old_keys', '[', ':aliases', ']', '.', 'size', '>', '0', 'redis_old_keys', '[', ':aliases', ']', '.', 'each', 'do', '|', 'alias_key', '|', 'RedisModelExtension', '::', 'Database', '.', 'redis', '.', 'srem', 'alias_key', ',', 'redis_old_keys', '[', ':key', ']', 'RedisModelExtension', '::', 'Database', '.', 'redis', '.', 'del', '(', 'alias_key', ')', 'if', 'RedisModelExtension', '::', 'Database', '.', 'redis', '.', 'scard', '(', 'alias_key', ')', '.', 'to_i', '==', '0', 'end', 'end', 'end']
->Original Target:
['remove', 'all', 'aliases']
->Reconstructed Target:
remove all aliases
->Reconstructed Predication:
the aliases to be destroyed
->Raw Input:
summarize:def destroy_aliases! if redis_old_keys [ :aliases ]. size > 0 redis_old_keys [ :aliases ]. each do | alias_key | RedisModelExtension :: Database. redis. srem alias_key, redis_old_keys [ :key ] RedisModelExtension :: Database. redis. del ( alias_key ) if RedisModelExtension :: Database. redis. scard ( alias_key ). to_i == 0 end end end
->Raw Target:
remove all aliases
--

605=========
->Original Input:
['def', 'add', '(', 'username', ',', 'token', ')', 'Firim', '::', 'AccountManager', '.', 'new', '(', 'user', ':', 'username', ',', 'token', ':', 'token', ')', '.', 'add_to_keychain', 'end']
->Original Target:
['Add', 'entry', 'to', 'Apple', 'Keychain']
->Reconstructed Target:
Add entry to Apple Keychain
->Reconstructed Predication:
account account_id and account_token
->Raw Input:
summarize:def add ( username, token ) Firim :: AccountManager. new ( user : username, token : token ). add_to_keychain end
->Raw Target:
Add entry to Apple Keychain
--

606=========
->Original Input:
['def', 'get_nsqds', '(', 'lookupd', ',', 'topic', '=', 'nil', ')', 'uri_scheme', '=', "'http://'", 'unless', 'lookupd', '.', 'match', '(', '%r(', ')', ')', 'uri', '=', 'URI', '.', 'parse', '(', '"#{uri_scheme}#{lookupd}"', ')', 'uri', '.', 'query', '=', '"ts=#{Time.now.to_i}"', 'if', 'topic', 'uri', '.', 'path', '=', "'/lookup'", 'uri', '.', 'query', '+=', '"&topic=#{URI.escape(topic)}"', 'else', 'uri', '.', 'path', '=', "'/nodes'", 'end', 'begin', 'body', '=', 'Net', '::', 'HTTP', '.', 'get', '(', 'uri', ')', 'data', '=', 'JSON', '.', 'parse', '(', 'body', ')', 'producers', '=', 'data', '[', "'producers'", ']', '||', '(', 'data', '[', "'data'", ']', '&&', 'data', '[', "'data'", ']', '[', "'producers'", ']', ')', 'if', 'producers', 'producers', '.', 'map', 'do', '|', 'producer', '|', '"#{producer[\'broadcast_address\']}:#{producer[\'tcp_port\']}"', 'end', 'else', '[', ']', 'end', 'rescue', 'Exception', '=>', 'e', 'error', '"Error during discovery for #{lookupd}: #{e}"', 'nil', 'end', 'end']
->Original Target:
['Returns', 'an', 'array', 'of', 'nsqd', 'addresses', 'If', 'there', 's', 'an', 'error', 'return', 'nil']
->Reconstructed Target:
Returns an array of nsqd addresses If there s an error return nil
->Reconstructed Predication:
the nsqds for the givenlookupd ) return nsqds
->Raw Input:
summarize:def get_nsqds ( lookupd, topic = nil ) uri_scheme = 'http://' unless lookupd. match ( %r( ) ) uri = URI. parse ( "#{uri_scheme}#{lookupd}" ) uri. query = "ts=#{Time.now.to_i}" if topic uri. path = '/lookup' uri. query += "&topic=#{URI.escape(topic)}" else uri. path = '/nodes' end begin body = Net :: HTTP. get ( uri ) data = JSON. parse ( body ) producers = data [ 'producers' ] || ( data [ 'data' ] && data [ 'data' ] [ 'producers' ] ) if producers producers. map do | producer | "#{producer['broadcast_address']}:#{producer['tcp_port']}" end else [ ] end rescue Exception => e error "Error during discovery for #{lookupd}: #{e}" nil end end
->Raw Target:
Returns an array of nsqd addresses If there s an error return nil
--

607=========
->Original Input:
['def', 'discover_repeatedly', '(', 'opts', '=', '{', '}', ')', '@discovery_thread', '=', 'Thread', '.', 'new', 'do', '@discovery', '=', 'Discovery', '.', 'new', '(', 'opts', '[', ':nsqlookupds', ']', ')', 'loop', 'do', 'begin', 'nsqds', '=', 'nsqds_from_lookupd', '(', 'opts', '[', ':topic', ']', ')', 'drop_and_add_connections', '(', 'nsqds', ')', 'rescue', 'DiscoveryException', 'warn', "'Could not connect to any nsqlookupd instances in discovery loop'", 'end', 'sleep', 'opts', '[', ':interval', ']', 'end', 'end', '@discovery_thread', '.', 'abort_on_exception', '=', 'true', 'end']
->Original Target:
['discovers', 'nsqds', 'from', 'an', 'nsqlookupd', 'repeatedly']
->Reconstructed Target:
discovers nsqds from an nsqlookupd repeatedly
->Reconstructed Predication:
the discovery thread to startthe discovery thread to start
->Raw Input:
summarize:def discover_repeatedly ( opts = { } ) @discovery_thread = Thread. new do @discovery = Discovery. new ( opts [ :nsqlookupds ] ) loop do begin nsqds = nsqds_from_lookupd ( opts [ :topic ] ) drop_and_add_connections ( nsqds ) rescue DiscoveryException warn 'Could not connect to any nsqlookupd instances in discovery loop' end sleep opts [ :interval ] end end @discovery_thread. abort_on_exception = true end
->Raw Target:
discovers nsqds from an nsqlookupd repeatedly
--

608=========
->Original Input:
['def', 'with_retries', '(', '&', 'block', ')', 'base_sleep_seconds', '=', '0.5', 'max_sleep_seconds', '=', '300', 'attempts', '=', '0', 'begin', 'attempts', '+=', '1', 'return', 'block', '.', 'call', '(', 'attempts', ')', 'rescue', 'Errno', '::', 'ECONNREFUSED', ',', 'Errno', '::', 'ECONNRESET', ',', 'Errno', '::', 'EHOSTUNREACH', ',', 'Errno', '::', 'ENETDOWN', ',', 'Errno', '::', 'ENETUNREACH', ',', 'Errno', '::', 'ETIMEDOUT', ',', 'Timeout', '::', 'Error', '=>', 'ex', 'raise', 'ex', 'if', 'attempts', '>=', '100', 'sleep_seconds', '=', '[', 'base_sleep_seconds', '*', '(', '2', '**', '(', 'attempts', '-', '1', ')', ')', ',', 'max_sleep_seconds', ']', '.', 'min', 'sleep_seconds', '=', 'sleep_seconds', '*', '(', '0.5', '*', '(', '1', '+', 'rand', '(', ')', ')', ')', 'sleep_seconds', '=', '[', 'base_sleep_seconds', ',', 'sleep_seconds', ']', '.', 'max', 'warn', '"Failed to connect: #{ex}. Retrying in #{sleep_seconds.round(1)} seconds."', 'snooze', '(', 'sleep_seconds', ')', 'retry', 'end', 'end']
->Original Target:
['Retry', 'the', 'supplied', 'block', 'with', 'exponential', 'backoff', '.']
->Reconstructed Target:
Retry the supplied block with exponential backoff.
->Reconstructed Predication:
the connection to the server.
->Raw Input:
summarize:def with_retries ( & block ) base_sleep_seconds = 0.5 max_sleep_seconds = 300 attempts = 0 begin attempts += 1 return block. call ( attempts ) rescue Errno :: ECONNREFUSED, Errno :: ECONNRESET, Errno :: EHOSTUNREACH, Errno :: ENETDOWN, Errno :: ENETUNREACH, Errno :: ETIMEDOUT, Timeout :: Error => ex raise ex if attempts >= 100 sleep_seconds = [ base_sleep_seconds * ( 2 ** ( attempts - 1 ) ), max_sleep_seconds ]. min sleep_seconds = sleep_seconds * ( 0.5 * ( 1 + rand ( ) ) ) sleep_seconds = [ base_sleep_seconds, sleep_seconds ]. max warn "Failed to connect: #{ex}. Retrying in #{sleep_seconds.round(1)} seconds." snooze ( sleep_seconds ) retry end end
->Raw Target:
Retry the supplied block with exponential backoff.
--

609=========
->Original Input:
['def', 'show', '(', 'ind', '=', "''", ')', 'count', '=', '0', 'self', '.', 'to_a', '.', 'each', '{', '|', 'i', '|', 'puts', '"#{ind}#{i.name} [#{count}]: #{i.to_s.sub(/^(.{30})(.*?)(.{30})$/, \'\\1...\\3\')}"', 'if', 'i', '.', 'kind_of?', '(', 'X12', '::', 'Segment', ')', '&&', 'i', '.', 'nodes', '[', '0', ']', 'i', '.', 'find_field', '(', 'i', '.', 'nodes', '[', '0', ']', '.', 'name', ')', 'end', 'i', '.', 'nodes', '.', 'each', '{', '|', 'j', '|', 'case', 'when', 'j', '.', 'kind_of?', '(', 'X12', '::', 'Base', ')', 'then', 'j', '.', 'show', '(', 'ind', '+', "'  '", ')', 'when', 'j', '.', 'kind_of?', '(', 'X12', '::', 'Field', ')', 'then', 'puts', '"#{ind+\'  \'}#{j.name} -> \'#{j.to_s}\'"', 'end', '}', 'count', '+=', '1', '}', 'end']
->Original Target:
['Prints', 'a', 'tree', '-', 'like', 'representation', 'of', 'the', 'element']
->Reconstructed Target:
Prints a tree - like representation of the element
->Reconstructed Predication:
thethethethe fieldthe fieldthe fieldthe fieldthe fieldthe fieldthe field to the
->Raw Input:
summarize:def show ( ind = '' ) count = 0 self. to_a. each { | i | puts "#{ind}#{i.name} [#{count}]: #{i.to_s.sub(/^(.{30})(.*?)(.{30})$/, '\1...\3')}" if i. kind_of? ( X12 :: Segment ) && i. nodes [ 0 ] i. find_field ( i. nodes [ 0 ]. name ) end i. nodes. each { | j | case when j. kind_of? ( X12 :: Base ) then j. show ( ind +'') when j. kind_of? ( X12 :: Field ) then puts "#{ind+'  '}#{j.name} -> '#{j.to_s}'" end } count += 1 } end
->Raw Target:
Prints a tree - like representation of the element
--

610=========
->Original Input:
['def', 'do_repeats', '(', 's', ')', 'if', 'self', '.', 'repeats', '.', 'end', '>', '1', 'possible_repeat', '=', 'self', '.', 'dup', 'p_s', '=', 'possible_repeat', '.', 'parse', '(', 's', ')', 'if', 'p_s', 's', '=', 'p_s', 'self', '.', 'next_repeat', '=', 'possible_repeat', 'end', 'end', 's', 'end']
->Original Target:
['Try', 'to', 'parse', 'the', 'current', 'element', 'one', 'more', 'time', 'if', 'required', '.', 'Returns', 'the', 'rest', 'of', 'the', 'string', 'or', 'the', 'same', 'string', 'if', 'no', 'more', 'repeats', 'are', 'found', 'or', 'required', '.']
->Reconstructed Target:
Try to parse the current element one more time if required. Returns the rest of the string or the same string if no more repeats are found or required.
->Reconstructed Predication:
s ) s end  def
->Raw Input:
summarize:def do_repeats ( s ) if self. repeats. end > 1 possible_repeat = self. dup p_s = possible_repeat. parse ( s ) if p_s s = p_s self. next_repeat = possible_repeat end end s end
->Raw Target:
Try to parse the current element one more time if required. Returns the rest of the string or the same string if no more repeats are found or required.
--

611=========
->Original Input:
['def', 'find', '(', 'e', ')', 'case', 'self', 'when', 'X12', '::', 'Loop', 'res', '=', 'nodes', '.', 'find', '{', '|', 'i', '|', 'e', '==', 'i', '.', 'name', '}', 'return', 'res', 'if', 'res', 'nodes', '.', 'each', '{', '|', 'i', '|', 'res', '=', 'i', '.', 'find', '(', 'e', ')', 'if', 'i', '.', 'kind_of?', '(', 'X12', '::', 'Loop', ')', 'return', 'res', 'unless', 'res', '.', 'nil?', 'or', 'EMPTY', '==', 'res', '}', 'when', 'X12', '::', 'Segment', 'return', 'find_field', '(', 'e', ')', '.', 'to_s', 'end', 'return', 'EMPTY', 'end']
->Original Target:
['Make', 'a', 'deep', 'copy', 'of', 'the', 'element', 'dup', 'Recursively', 'find', 'a', 'sub', '-', 'element', 'which', 'also', 'has', 'to', 'be', 'of', 'type', 'Base', '.']
->Reconstructed Target:
Make a deep copy of the element dup Recursively find a sub - element which also has to be of type Base.
->Reconstructed Predication:
the node or the nodethe node or the node
->Raw Input:
summarize:def find ( e ) case self when X12 :: Loop res = nodes. find { | i | e == i. name } return res if res nodes. each { | i | res = i. find ( e ) if i. kind_of? ( X12 :: Loop ) return res unless res. nil? or EMPTY == res } when X12 :: Segment return find_field ( e ). to_s end return EMPTY end
->Raw Target:
Make a deep copy of the element dup Recursively find a sub - element which also has to be of type Base.
--

612=========
->Original Input:
['def', 'method_missing', '(', 'meth', ',', '*', 'args', ',', '&', 'block', ')', 'str', '=', 'meth', '.', 'id2name', 'str', '=', 'str', '[', '1', '..', 'str', '.', 'length', ']', 'if', 'str', '=~', '/', '\\d', '/', 'if', 'str', '=~', '/', '/', 'str', '.', 'chop!', 'case', 'self', 'when', 'X12', '::', 'Segment', 'res', '=', 'find_field', '(', 'str', ')', 'throw', 'Exception', '.', 'new', '(', '"No field \'#{str}\' in segment \'#{self.name}\'"', ')', 'if', 'EMPTY', '==', 'res', 'res', '.', 'content', '=', 'args', '[', '0', ']', '.', 'to_s', 'else', 'throw', 'Exception', '.', 'new', '(', '"Illegal assignment to #{meth} of #{self.class}"', ')', 'end', 'else', 'res', '=', 'find', '(', 'str', ')', 'yield', 'res', 'if', 'block_given?', 'res', 'end', 'end']
->Original Target:
['The', 'main', 'method', 'implementing', 'Ruby', '-', 'like', 'access', 'methods', 'for', 'nested', 'elements']
->Reconstructed Target:
The main method implementing Ruby - like access methods for nested elements
->Reconstructed Predication:
thethethethethethethethe field '#{meth}' in the segment
->Raw Input:
summarize:def method_missing ( meth, * args, & block ) str = meth. id2name str = str [ 1.. str. length ] if str =~ / \d / if str =~ / / str. chop! case self when X12 :: Segment res = find_field ( str ) throw Exception. new ( "No field '#{str}' in segment '#{self.name}'" ) if EMPTY == res res. content = args [ 0 ]. to_s else throw Exception. new ( "Illegal assignment to #{meth} of #{self.class}" ) end else res = find ( str ) yield res if block_given? res end end
->Raw Target:
The main method implementing Ruby - like access methods for nested elements
--

613=========
->Original Input:
['def', 'parse', '(', 'str', ')', 's', '=', 'str', 'm', '=', 'regexp', '.', 'match', '(', 's', ')', 'return', 'nil', 'unless', 'm', 's', '=', 'm', '.', 'post_match', 'self', '.', 'parsed_str', '=', 'm', '[', '0', ']', 's', '=', 'do_repeats', '(', 's', ')', 'return', 's', 'end']
->Original Target:
['Parses', 'this', 'segment', 'out', 'of', 'a', 'string', 'puts', 'the', 'match', 'into', 'value', 'returns', 'the', 'rest', 'of', 'the', 'string', '-', 'nil', 'if', 'cannot', 'parse']
->Reconstructed Target:
Parses this segment out of a string puts the match into value returns the rest of the string - nil if cannot parse
->Reconstructed Predication:
 def parse ( regexp
->Raw Input:
summarize:def parse ( str ) s = str m = regexp. match ( s ) return nil unless m s = m. post_match self. parsed_str = m [ 0 ] s = do_repeats ( s ) return s end
->Raw Target:
Parses this segment out of a string puts the match into value returns the rest of the string - nil if cannot parse
--

614=========
->Original Input:
['def', 'render', 'self', '.', 'to_a', '.', 'inject', '(', "''", ')', '{', '|', 'repeat_str', ',', 'i', '|', 'if', 'i', '.', 'repeats', '.', 'begin', '<', '1', 'and', '!', 'i', '.', 'has_content?', 'repeat_str', 'else', 'repeat_str', '+=', 'i', '.', 'name', '+', 'i', '.', 'nodes', '.', 'reverse', '.', 'inject', '(', "''", ')', '{', '|', 'nodes_str', ',', 'j', '|', 'field', '=', 'j', '.', 'render', '(', 'j', '.', 'required', 'or', 'nodes_str', '!=', "''", 'or', 'field', '!=', "''", ')', '?', 'field_separator', '+', 'field', '+', 'nodes_str', ':', 'nodes_str', '}', '+', 'segment_separator', 'end', '}', 'end']
->Original Target:
['parse', 'Render', 'all', 'components', 'of', 'this', 'segment', 'as', 'string', 'suitable', 'for', 'EDI']
->Reconstructed Target:
parse Render all components of this segment as string suitable for EDI
->Reconstructed Predication:
thethe content of the
->Raw Input:
summarize:def render self. to_a. inject ( '' ) { | repeat_str, i | if i. repeats. begin < 1 and! i. has_content? repeat_str else repeat_str += i. name + i. nodes. reverse. inject ( '' ) { | nodes_str, j | field = j. render ( j. required or nodes_str!= '' or field!= '' )? field_separator + field + nodes_str : nodes_str } + segment_separator end } end
->Raw Target:
parse Render all components of this segment as string suitable for EDI
--

615=========
->Original Input:
['def', 'regexp', 'unless', '@regexp', 'if', 'self', '.', 'nodes', '.', 'find', '{', '|', 'i', '|', 'i', '.', 'type', '=~', '/', '/', '}', 're_str', '=', 'self', '.', 'nodes', '.', 'inject', '(', '"^#{name}#{Regexp.escape(field_separator)}"', ')', '{', '|', 's', ',', 'i', '|', 'field_re', '=', 'i', '.', 'simple_regexp', '(', 'field_separator', ',', 'segment_separator', ')', '+', 'Regexp', '.', 'escape', '(', 'field_separator', ')', '+', "'?'", 'field_re', '=', '"(#{field_re})?"', 'unless', 'i', '.', 'required', 's', '+', 'field_re', '}', '+', 'Regexp', '.', 'escape', '(', 'segment_separator', ')', '@regexp', '=', 'Regexp', '.', 'new', '(', 're_str', ')', 'else', '@regexp', '=', 'Regexp', '.', 'new', '(', '"^#{name}#{Regexp.escape(field_separator)}[^#{Regexp.escape(segment_separator)}]*#{Regexp.escape(segment_separator)}"', ')', 'end', 'end', '@regexp', 'end']
->Original Target:
['render', 'Returns', 'a', 'regexp', 'that', 'matches', 'this', 'particular', 'segment']
->Reconstructed Target:
render Returns a regexp that matches this particular segment
->Reconstructed Predication:
@regexp = Regexp. new
->Raw Input:
summarize:def regexp unless @regexp if self. nodes. find { | i | i. type =~ / / } re_str = self. nodes. inject ( "^#{name}#{Regexp.escape(field_separator)}" ) { | s, i | field_re = i. simple_regexp ( field_separator, segment_separator ) + Regexp. escape ( field_separator ) + '?' field_re = "(#{field_re})?" unless i. required s + field_re } + Regexp. escape ( segment_separator ) @regexp = Regexp. new ( re_str ) else @regexp = Regexp. new ( "^#{name}#{Regexp.escape(field_separator)}[^#{Regexp.escape(segment_separator)}]*#{Regexp.escape(segment_separator)}" ) end end @regexp end
->Raw Target:
render Returns a regexp that matches this particular segment
--

616=========
->Original Input:
['def', 'find_field', '(', 'str', ')', 'field_num', '=', 'nil', 'self', '.', 'nodes', '.', 'each_index', '{', '|', 'i', '|', 'field_num', '=', 'i', 'if', 'str', '==', 'self', '.', 'nodes', '[', 'i', ']', '.', 'name', '}', 'return', 'EMPTY', 'if', 'field_num', '.', 'nil?', 'unless', '@fields', '@fields', '=', 'self', '.', 'to_s', '.', 'chop', '.', 'split', '(', 'Regexp', '.', 'new', '(', 'Regexp', '.', 'escape', '(', 'field_separator', ')', ')', ')', 'self', '.', 'nodes', '.', 'each_index', '{', '|', 'i', '|', 'self', '.', 'nodes', '[', 'i', ']', '.', 'content', '=', '@fields', '[', 'i', '+', '1', ']', '}', 'end', 'return', 'self', '.', 'nodes', '[', 'field_num', ']', 'end']
->Original Target:
['Finds', 'a', 'field', 'in', 'the', 'segment', '.', 'Returns', 'EMPTY', 'if', 'not', 'found', '.']
->Reconstructed Target:
Finds a field in the segment. Returns EMPTY if not found.
->Reconstructed Predication:
the field to findthe field to find the field
->Raw Input:
summarize:def find_field ( str ) field_num = nil self. nodes. each_index { | i | field_num = i if str == self. nodes [ i ]. name } return EMPTY if field_num. nil? unless @fields @fields = self. to_s. chop. split ( Regexp. new ( Regexp. escape ( field_separator ) ) ) self. nodes. each_index { | i | self. nodes [ i ]. content = @fields [ i + 1 ] } end return self. nodes [ field_num ] end
->Raw Target:
Finds a field in the segment. Returns EMPTY if not found.
--

617=========
->Original Input:
['def', 'parse', '(', 'loop_name', ',', 'str', ')', 'loop', '=', '@x12_definition', '[', 'X12', '::', 'Loop', ']', '[', 'loop_name', ']', 'throw', 'Exception', '.', 'new', '(', '"Cannot find a definition for loop #{loop_name}"', ')', 'unless', 'loop', 'loop', '=', 'loop', '.', 'dup', 'loop', '.', 'parse', '(', 'str', ')', 'return', 'loop', 'end']
->Original Target:
['Creates', 'a', 'parser', 'out', 'of', 'a', 'definition', 'initialize', 'Parse', 'a', 'loop', 'of', 'a', 'given', 'name', 'out', 'of', 'a', 'string', '.', 'Throws', 'an', 'exception', 'if', 'the', 'loop', 'name', 'is', 'not', 'defined', '.']
->Reconstructed Target:
Creates a parser out of a definition initialize Parse a loop of a given name out of a string. Throws an exception if the loop name is not defined.
->Reconstructed Predication:
 def parse_loop ( loop_name
->Raw Input:
summarize:def parse ( loop_name, str ) loop = @x12_definition [ X12 :: Loop ] [ loop_name ] throw Exception. new ( "Cannot find a definition for loop #{loop_name}" ) unless loop loop = loop. dup loop. parse ( str ) return loop end
->Raw Target:
Creates a parser out of a definition initialize Parse a loop of a given name out of a string. Throws an exception if the loop name is not defined.
--

618=========
->Original Input:
['def', 'factory', '(', 'loop_name', ')', 'loop', '=', '@x12_definition', '[', 'X12', '::', 'Loop', ']', '[', 'loop_name', ']', 'throw', 'Exception', '.', 'new', '(', '"Cannot find a definition for loop #{loop_name}"', ')', 'unless', 'loop', 'loop', '=', 'loop', '.', 'dup', 'return', 'loop', 'end']
->Original Target:
['parse', 'Make', 'an', 'empty', 'loop', 'to', 'be', 'filled', 'out', 'with', 'information']
->Reconstructed Target:
parse Make an empty loop to be filled out with information
->Reconstructed Predication:
the loop definition for the
->Raw Input:
summarize:def factory ( loop_name ) loop = @x12_definition [ X12 :: Loop ] [ loop_name ] throw Exception. new ( "Cannot find a definition for loop #{loop_name}" ) unless loop loop = loop. dup return loop end
->Raw Target:
parse Make an empty loop to be filled out with information
--

619=========
->Original Input:
['def', 'process_loop', '(', 'loop', ')', 'loop', '.', 'nodes', '.', 'each', '{', '|', 'i', '|', 'case', 'i', 'when', 'X12', '::', 'Loop', 'then', 'process_loop', '(', 'i', ')', 'when', 'X12', '::', 'Segment', 'then', 'process_segment', '(', 'i', ')', 'unless', 'i', '.', 'nodes', '.', 'size', '>', '0', 'else', 'return', 'end', '}', 'end']
->Original Target:
['Recursively', 'scan', 'the', 'loop', 'and', 'instantiate', 'fields', 'definitions', 'for', 'all', 'its', 'segments']
->Reconstructed Target:
Recursively scan the loop and instantiate fields definitions for all its segments
->Reconstructed Predication:
the loop nodes.
->Raw Input:
summarize:def process_loop ( loop ) loop. nodes. each { | i | case i when X12 :: Loop then process_loop ( i ) when X12 :: Segment then process_segment ( i ) unless i. nodes. size > 0 else return end } end
->Raw Target:
Recursively scan the loop and instantiate fields definitions for all its segments
--

620=========
->Original Input:
['def', 'process_segment', '(', 'segment', ')', 'unless', '@x12_definition', '[', 'X12', '::', 'Segment', ']', '&&', '@x12_definition', '[', 'X12', '::', 'Segment', ']', '[', 'segment', '.', 'name', ']', 'initialize', '(', 'segment', '.', 'name', '+', "'.xml'", ')', 'segment_definition', '=', '@x12_definition', '[', 'X12', '::', 'Segment', ']', '[', 'segment', '.', 'name', ']', 'throw', 'Exception', '.', 'new', '(', '"Cannot find a definition for segment #{segment.name}"', ')', 'unless', 'segment_definition', 'else', 'segment_definition', '=', '@x12_definition', '[', 'X12', '::', 'Segment', ']', '[', 'segment', '.', 'name', ']', 'end', 'segment_definition', '.', 'nodes', '.', 'each_index', '{', '|', 'i', '|', 'segment', '.', 'nodes', '[', 'i', ']', '=', 'segment_definition', '.', 'nodes', '[', 'i', ']', 'table', '=', 'segment', '.', 'nodes', '[', 'i', ']', '.', 'validation', 'if', 'table', 'unless', '@x12_definition', '[', 'X12', '::', 'Table', ']', '&&', '@x12_definition', '[', 'X12', '::', 'Table', ']', '[', 'table', ']', 'initialize', '(', 'table', '+', "'.xml'", ')', 'throw', 'Exception', '.', 'new', '(', '"Cannot find a definition for table #{table}"', ')', 'unless', '@x12_definition', '[', 'X12', '::', 'Table', ']', '&&', '@x12_definition', '[', 'X12', '::', 'Table', ']', '[', 'table', ']', 'end', 'end', '}', 'end']
->Original Target:
['Instantiate', 'segment', 's', 'fields', 'as', 'previously', 'defined']
->Reconstructed Target:
Instantiate segment s fields as previously defined
->Reconstructed Predication:
segment. nodes ). nodes ) segment.. nodes ) segment.. nodes ) segment.. nodes ) segment.. nodes ) segment.
->Raw Input:
summarize:def process_segment ( segment ) unless @x12_definition [ X12 :: Segment ] && @x12_definition [ X12 :: Segment ] [ segment. name ] initialize ( segment. name + '.xml' ) segment_definition = @x12_definition [ X12 :: Segment ] [ segment. name ] throw Exception. new ( "Cannot find a definition for segment #{segment.name}" ) unless segment_definition else segment_definition = @x12_definition [ X12 :: Segment ] [ segment. name ] end segment_definition. nodes. each_index { | i | segment. nodes [ i ] = segment_definition. nodes [ i ] table = segment. nodes [ i ]. validation if table unless @x12_definition [ X12 :: Table ] && @x12_definition [ X12 :: Table ] [ table ] initialize ( table + '.xml' ) throw Exception. new ( "Cannot find a definition for table #{table}" ) unless @x12_definition [ X12 :: Table ] && @x12_definition [ X12 :: Table ] [ table ] end end } end
->Raw Target:
Instantiate segment s fields as previously defined
--

621=========
->Original Input:
['def', 'render', 'if', 'self', '.', 'has_content?', 'self', '.', 'to_a', '.', 'inject', '(', "''", ')', '{', '|', 'loop_str', ',', 'i', '|', 'loop_str', '+=', 'i', '.', 'nodes', '.', 'inject', '(', "''", ')', '{', '|', 'nodes_str', ',', 'j', '|', 'nodes_str', '+=', 'j', '.', 'render', '}', '}', 'else', "''", 'end', 'end']
->Original Target:
['parse', 'Render', 'all', 'components', 'of', 'this', 'loop', 'as', 'string', 'suitable', 'for', 'EDI']
->Reconstructed Target:
parse Render all components of this loop as string suitable for EDI
->Reconstructed Predication:
the nodes of the node
->Raw Input:
summarize:def render if self. has_content? self. to_a. inject ( '' ) { | loop_str, i | loop_str += i. nodes. inject ( '' ) { | nodes_str, j | nodes_str += j. render } } else '' end end
->Raw Target:
parse Render all components of this loop as string suitable for EDI
--

622=========
->Original Input:
['def', 'calculate_sortable_values', 'response_fieldable', '.', 'input_fields', '.', 'each', 'do', '|', 'response_field', '|', 'if', '(', 'x', '=', 'response_value', '(', 'response_field', ')', ')', '.', 'present?', 'get_responses', '[', '"#{response_field.id}_sortable_value"', ']', '=', 'response_field', '.', 'sortable_value', '(', 'x', ')', 'end', 'end', 'mark_responses_as_changed!', 'end']
->Original Target:
['for', 'manual', 'use', 'maybe', 'when', 'migrating']
->Reconstructed Target:
for manual use maybe when migrating
->Reconstructed Predication:
the response field sortable values
->Raw Input:
summarize:def calculate_sortable_values response_fieldable. input_fields. each do | response_field | if ( x = response_value ( response_field ) ). present? get_responses [ "#{response_field.id}_sortable_value" ] = response_field. sortable_value ( x ) end end mark_responses_as_changed! end
->Raw Target:
for manual use maybe when migrating
--

623=========
->Original Input:
['def', 'normalize_responses', 'return', 'if', 'form', '.', 'blank?', 'form', '.', 'response_fields', '.', 'each', 'do', '|', 'response_field', '|', 'if', '(', 'x', '=', 'self', '.', 'response_value', '(', 'response_field', ')', ')', 'response_field', '.', 'normalize_response', '(', 'x', ',', 'get_responses', ')', 'end', 'end', 'mark_responses_as_changed!', 'end']
->Original Target:
['Normalizations', 'get', 'run', 'before', 'validation', '.']
->Reconstructed Target:
Normalizations get run before validation.
->Reconstructed Predication:
the form and the responses
->Raw Input:
summarize:def normalize_responses return if form. blank? form. response_fields. each do | response_field | if ( x = self. response_value ( response_field ) ) response_field. normalize_response ( x, get_responses ) end end mark_responses_as_changed! end
->Raw Target:
Normalizations get run before validation.
--

624=========
->Original Input:
['def', 'audit_responses', 'form', '.', 'response_fields', '.', 'each', 'do', '|', 'response_field', '|', 'response_field', '.', 'audit_response', '(', 'self', '.', 'response_value', '(', 'response_field', ')', ',', 'get_responses', ')', 'end', 'mark_responses_as_changed!', 'end']
->Original Target:
['Audits', 'get', 'run', 'explicitly', '.']
->Reconstructed Target:
Audits get run explicitly.
->Reconstructed Predication:
the form and the responses
->Raw Input:
summarize:def audit_responses form. response_fields. each do | response_field | response_field. audit_response ( self. response_value ( response_field ), get_responses ) end mark_responses_as_changed! end
->Raw Target:
Audits get run explicitly.
--

625=========
->Original Input:
['def', 'tag!', '(', 'tag', ',', '*', 'args', ',', '&', 'block', ')', 'text', ',', 'attributes', '=', 'nil', ',', '{', '}', 'args', '.', 'each', 'do', '|', 'arg', '|', 'case', 'arg', 'when', '::', 'Hash', 'attributes', '.', 'merge!', '(', 'arg', ')', 'when', '::', 'String', 'text', '||=', "''", 'text', '<<', 'arg', 'end', 'end', '@stack', '<<', '[', 'tag', ',', 'attributes', ',', 'text', '?', '[', 'text', ']', ':', '[', ']', ']', 'if', 'block', '_process', '(', '&', 'block', ')', 'end', 'if', '@stack', '.', 'length', '>', '1', 'node', '=', '@stack', '.', 'pop', '@stack', '.', 'last', '[', '2', ']', '<<', 'node', 'NodeBuilder', '.', 'new', '(', 'node', ',', 'self', ')', 'else', 'NodeBuilder', '.', 'new', '(', '@stack', '.', 'last', ',', 'self', ')', 'end', 'end']
->Original Target:
['Construct', 'a', 'new', 'builder', 'and', 'start', 'building']
->Reconstructed Target:
Construct a new builder and start building
->Reconstructed Predication:
the tag with the attributesthe tag with the attributesthe tag with the attributesthe tag with the attributesthe tag with the attributesthe tag with thethethe tag with the attributesthe tag with the attributesthe tag with the attributesthe tag with the attributes
->Raw Input:
summarize:def tag! ( tag, * args, & block ) text, attributes = nil, { } args. each do | arg | case arg when :: Hash attributes. merge! ( arg ) when :: String text ||= '' text << arg end end @stack << [ tag, attributes, text? [ text ] : [ ] ] if block _process ( & block ) end if @stack. length > 1 node = @stack. pop @stack. last [ 2 ] << node NodeBuilder. new ( node, self ) else NodeBuilder. new ( @stack. last, self ) end end
->Raw Target:
Construct a new builder and start building
--

626=========
->Original Input:
['def', '<<', '(', '*', 'args', ')', 'args', '.', 'each', 'do', '|', 'arg', '|', 'if', 'arg', '.', 'respond_to?', '(', ':to_hexp', ')', '@stack', '.', 'last', '[', '2', ']', '<<', 'arg', 'self', 'else', '::', 'Kernel', '.', 'raise', '::', 'Hexp', '::', 'FormatError', ',', '"Inserting literal HTML into a builder with << is deliberately not supported by Hexp"', 'end', 'end', 'end']
->Original Target:
['Add', 'Hexp', 'objects', 'to', 'the', 'current', 'tag']
->Reconstructed Target:
Add Hexp objects to the current tag
->Reconstructed Predication:
the builder to be appended tothe builder to be appended to
->Raw Input:
summarize:def << ( * args ) args. each do | arg | if arg. respond_to? ( :to_hexp ) @stack. last [ 2 ] << arg self else :: Kernel. raise :: Hexp :: FormatError, "Inserting literal HTML into a builder with << is deliberately not supported by Hexp" end end end
->Raw Target:
Add Hexp objects to the current tag
--

627=========
->Original Input:
['def', 'rewrite', '(', 'css_selector', '=', 'nil', ',', '&', 'block', ')', 'return', 'Rewriter', '.', 'new', '(', 'self', ',', 'block', ')', 'if', 'css_selector', '.', 'nil?', 'CssSelection', '.', 'new', '(', 'self', ',', 'css_selector', ')', '.', 'rewrite', '(', '&', 'block', ')', 'end']
->Original Target:
['Replace', 'nodes', 'in', 'a', 'tree']
->Reconstructed Target:
Replace nodes in a tree
->Reconstructed Predication:
the css selector to be used
->Raw Input:
summarize:def rewrite ( css_selector = nil, & block ) return Rewriter. new ( self, block ) if css_selector. nil? CssSelection. new ( self, css_selector ). rewrite ( & block ) end
->Raw Target:
Replace nodes in a tree
--

628=========
->Original Input:
['def', 'select', '(', 'css_selector', '=', 'nil', ',', '&', 'block', ')', 'if', 'css_selector', 'CssSelection', '.', 'new', '(', 'self', ',', 'css_selector', ')', '.', 'each', '(', '&', 'block', ')', 'else', 'Selection', '.', 'new', '(', 'self', ',', 'block', ')', 'end', 'end']
->Original Target:
['Select', 'nodes', 'based', 'on', 'a', 'css', 'selector']
->Reconstructed Target:
Select nodes based on a css selector
->Reconstructed Predication:
the selector to select.
->Raw Input:
summarize:def select ( css_selector = nil, & block ) if css_selector CssSelection. new ( self, css_selector ). each ( & block ) else Selection. new ( self, block ) end end
->Raw Target:
Select nodes based on a css selector
--

629=========
->Original Input:
['def', 'add_configuration', '(', 'config_hash', ')', 'config_hash', '.', 'each', 'do', '|', 'key', ',', 'val', '|', 'instance_eval', '{', 'instance_variable_set', '(', '"@#{key}"', ',', 'val', ')', '}', 'self', '.', 'class', '.', 'instance_eval', '{', 'attr_accessor', 'key', '}', 'end', 'end']
->Original Target:
['Extend', 'configuration', 'variables']
->Reconstructed Target:
Extend configuration variables
->Reconstructed Predication:
the configuration to the configuration
->Raw Input:
summarize:def add_configuration ( config_hash ) config_hash. each do | key, val | instance_eval { instance_variable_set ( "@#{key}", val ) } self. class. instance_eval { attr_accessor key } end end
->Raw Target:
Extend configuration variables
--

630=========
->Original Input:
['def', 'pid_exists', '(', 'pid', ')', 'return', 'false', 'if', 'pid', '<', '0', 'return', 'true', 'if', 'pid', '==', '0', '::', 'Process', '.', 'kill', '(', '0', ',', 'pid', ')', 'return', 'true', 'rescue', 'Errno', '::', 'ESRCH', 'return', 'false', 'rescue', 'Errno', '::', 'EPERM', 'return', 'true', 'rescue', 'RangeError', 'return', 'false', 'end']
->Original Target:
['Check', 'whether', 'pid', 'exists', 'in', 'the', 'current', 'process', 'table', '.']
->Reconstructed Target:
Check whether pid exists in the current process table.
->Reconstructed Predication:
return true if pid exists
->Raw Input:
summarize:def pid_exists ( pid ) return false if pid < 0 return true if pid == 0 :: Process. kill ( 0, pid ) return true rescue Errno :: ESRCH return false rescue Errno :: EPERM return true rescue RangeError return false end
->Raw Target:
Check whether pid exists in the current process table.
--

631=========
->Original Input:
['def', 'wait_pid', '(', 'pid', ',', 'timeout', '=', 'nil', ')', 'def', 'check_timeout', '(', 'delay', ',', 'stop_at', ',', 'timeout', ')', 'if', 'timeout', 'raise', 'Timeout', '::', 'Error', '.', 'new', '(', '"when waiting for (pid=#{pid})"', ')', 'if', 'Time', '.', 'now', '>=', 'stop_at', 'end', 'sleep', '(', 'delay', ')', 'delay', '*', '2', '<', '0.04', '?', 'delay', '*', '2', ':', '0.04', 'end', 'if', 'timeout', 'waitcall', '=', 'proc', '{', '::', 'Process', '.', 'wait', '(', 'pid', ',', '::', 'Process', '::', 'WNOHANG', ')', '}', 'stop_at', '=', 'Time', '.', 'now', '+', 'timeout', 'else', 'waitcall', '=', 'proc', '{', '::', 'Process', '.', 'wait', '(', 'pid', ')', '}', 'end', 'delay', '=', '0.0001', 'loop', 'do', 'begin', 'retpid', '=', 'waitcall', '.', 'call', '(', ')', 'rescue', 'Errno', '::', 'EINTR', 'delay', '=', 'check_timeout', '(', 'delay', ',', 'stop_at', ',', 'timeout', ')', 'next', 'rescue', 'Errno', '::', 'ECHILD', 'loop', 'do', 'return', 'nil', 'unless', 'pid_exists', '(', 'pid', ')', 'delay', '=', 'check_timeout', '(', 'delay', ',', 'stop_at', ',', 'timeout', ')', 'end', 'end', 'unless', 'retpid', 'delay', '=', 'check_timeout', '(', 'delay', ',', 'stop_at', ',', 'timeout', ')', 'next', 'end', 'if', '$?', '.', 'signaled?', 'return', '$?', '.', 'termsig', 'elsif', '$?', '.', 'exited?', 'return', '$?', '.', 'exitstatus', 'else', 'raise', 'RuntimeError', '.', 'new', '(', '"unknown process exit status"', ')', 'end', 'end', 'end']
->Original Target:
['Wait', 'for', 'process', 'with', 'pid', 'pid', 'to', 'terminate', 'and', 'return', 'its', 'exit', 'status', 'code', 'as', 'an', 'integer', '.']
->Reconstructed Target:
Wait for process with pid pid to terminate and return its exit status code as an integer.
->Reconstructed Predication:
pid=#{pid} is waiting for (timeout=#{timeout})"( pid=#{pid})" ) if timeout( pid )( pid )( pid )( pid ) if pid_existspid ) return nil end
->Raw Input:
summarize:def wait_pid ( pid, timeout = nil ) def check_timeout ( delay, stop_at, timeout ) if timeout raise Timeout :: Error. new ( "when waiting for (pid=#{pid})" ) if Time. now >= stop_at end sleep ( delay ) delay * 2 < 0.04? delay * 2 : 0.04 end if timeout waitcall = proc { :: Process. wait ( pid, :: Process :: WNOHANG ) } stop_at = Time. now + timeout else waitcall = proc { :: Process. wait ( pid ) } end delay = 0.0001 loop do begin retpid = waitcall. call ( ) rescue Errno :: EINTR delay = check_timeout ( delay, stop_at, timeout ) next rescue Errno :: ECHILD loop do return nil unless pid_exists ( pid ) delay = check_timeout ( delay, stop_at, timeout ) end end unless retpid delay = check_timeout ( delay, stop_at, timeout ) next end if $?. signaled? return $?. termsig elsif $?. exited? return $?. exitstatus else raise RuntimeError. new ( "unknown process exit status" ) end end end
->Raw Target:
Wait for process with pid pid to terminate and return its exit status code as an integer.
--

632=========
->Original Input:
['def', 'upload_module_changes', '(', 'parent_sha1', ',', 'sha1s', ')', 'remote_path', '=', 'fetch_module', 'tmp_git_path', '=', 'clone_or_fetch_repository', '(', 'remote_path', ',', 'module_tmp_git_path', '(', '@remote_path', ')', ')', 'RIM', '::', 'git_session', '(', 'tmp_git_path', ')', 'do', '|', 'dest', '|', 'local_branch', '=', 'nil', 'remote_branch', '=', 'nil', 'infos', '=', 'nil', 'if', '@module_info', '.', 'subdir', 'dest_path', '=', 'File', '.', 'join', '(', '[', 'tmp_git_path', ']', '+', '@module_info', '.', 'subdir', '.', 'split', '(', '"/"', ')', ')', 'else', 'dest_path', '=', 'tmp_git_path', 'end', 'RIM', '::', 'git_session', '(', '@ws_root', ')', 'do', '|', 'src', '|', 'infos', '=', 'get_branches_and_revision_infos', '(', 'src', ',', 'dest', ',', 'parent_sha1', ',', 'sha1s', ')', 'if', 'infos', '.', 'branches', '.', 'size', '==', '1', 'remote_branch', '=', 'infos', '.', 'branches', '[', '0', ']', 'if', 'dest', '.', 'has_remote_branch?', '(', 'remote_branch', ')', 'infos', '.', 'rev_infos', '.', 'each', 'do', '|', 'rev_info', '|', 'local_branch', '=', 'create_update_branch', '(', 'dest', ',', 'infos', '.', 'parent_sha1', ',', 'rev_info', '.', 'src_sha1', ')', 'if', '!', 'local_branch', 'copy_revision_files', '(', 'src', ',', 'rev_info', '.', 'src_sha1', ',', 'dest_path', ',', 'rev_info', '.', 'rim_info', '.', 'ignores', ')', 'commit_changes', '(', 'dest', ',', 'local_branch', ',', 'rev_info', '.', 'src_sha1', ',', 'rev_info', '.', 'message', ')', 'end', 'else', 'raise', 'RimException', '.', 'new', '(', '"The target revision \'#{@module_info.target_revision}\' of module #{@module_info.local_path} is not a branch. No push can be performed."', ')', 'end', 'elsif', 'infos', '.', 'branches', '.', 'size', '>', '1', 'raise', 'RimException', '.', 'new', '(', '"There are commits for module #{@module_info.local_path} on multiple target revisions (#{infos.branches.join(", ")})."', ')', 'end', 'end', 'if', 'local_branch', '&&', 'dest', '.', 'rev_sha1', '(', 'local_branch', ')', '!=', 'infos', '.', 'parent_sha1', 'push_branch', '=', '@review', '&&', '@module_info', '.', 'remote_branch_format', '&&', '!', '@module_info', '.', 'remote_branch_format', '.', 'empty?', '?', '@module_info', '.', 'remote_branch_format', '%', 'remote_branch', ':', 'remote_branch', 'dest', '.', 'execute', '(', '"git push #{@remote_url} #{local_branch}:#{push_branch}"', ')', 'dest', '.', 'execute', '(', '"git checkout --detach #{local_branch}"', ')', 'dest', '.', 'execute', '(', '"git branch -D #{local_branch}"', ')', '@logger', '.', 'info', '(', '"Commited changes for module #{@module_info.local_path} to remote branch #{push_branch}."', ')', 'else', '@logger', '.', 'info', '(', '"No changes to module #{@module_info.local_path}."', ')', 'end', 'end', 'end']
->Original Target:
['upload', 'the', 'content', 'of', 'the', 'module']
->Reconstructed Target:
upload the content of the module
->Reconstructed Predication:
().( "git checkoutremote_branch ) dest. execute( "git checkoutremote_branch ) dest. execute( "git checkoutremote_branch ) dest. execute( "git checkout --forceremote_branch ) dest. execute"git checkout --forceremote_branch ) dest. execute"git push #{@remote_url} #{local_branch}:#{remote_branch}" ) end end(
->Raw Input:
summarize:def upload_module_changes ( parent_sha1, sha1s ) remote_path = fetch_module tmp_git_path = clone_or_fetch_repository ( remote_path, module_tmp_git_path ( @remote_path ) ) RIM :: git_session ( tmp_git_path ) do | dest | local_branch = nil remote_branch = nil infos = nil if @module_info. subdir dest_path = File. join ( [ tmp_git_path ] + @module_info. subdir. split ( "/" ) ) else dest_path = tmp_git_path end RIM :: git_session ( @ws_root ) do | src | infos = get_branches_and_revision_infos ( src, dest, parent_sha1, sha1s ) if infos. branches. size == 1 remote_branch = infos. branches [ 0 ] if dest. has_remote_branch? ( remote_branch ) infos. rev_infos. each do | rev_info | local_branch = create_update_branch ( dest, infos. parent_sha1, rev_info. src_sha1 ) if! local_branch copy_revision_files ( src, rev_info. src_sha1, dest_path, rev_info. rim_info. ignores ) commit_changes ( dest, local_branch, rev_info. src_sha1, rev_info. message ) end else raise RimException. new ( "The target revision '#{@module_info.target_revision}' of module #{@module_info.local_path} is not a branch. No push can be performed." ) end elsif infos. branches. size > 1 raise RimException. new ( "There are commits for module #{@module_info.local_path} on multiple target revisions (#{infos.branches.join(", ")})." ) end end if local_branch && dest. rev_sha1 ( local_branch )!= infos. parent_sha1 push_branch = @review && @module_info. remote_branch_format &&! @module_info. remote_branch_format. empty?? @module_info. remote_branch_format % remote_branch : remote_branch dest. execute ( "git push #{@remote_url} #{local_branch}:#{push_branch}" ) dest. execute ( "git checkout --
->Raw Target:
upload the content of the module
--

633=========
->Original Input:
['def', 'get_branches_and_revision_infos', '(', 'src_session', ',', 'dest_session', ',', 'parent_sha1', ',', 'sha1s', ')', 'infos', '=', '[', ']', 'branches', '=', '[', ']', 'dest_parent_sha1', '=', 'nil', '(', 'sha1s', '.', 'size', '(', ')', '-', '1', ')', '.', 'step', '(', '0', ',', '-', '1', ')', 'do', '|', 'i', '|', 'info', '=', 'get_revision_info', '(', 'src_session', ',', 'dest_session', ',', 'sha1s', '[', 'i', ']', ')', 'if', '!', 'info', '.', 'dest_sha1', '&&', 'info', '.', 'rim_info', '.', 'target_revision', 'infos', '.', 'unshift', '(', 'info', ')', 'branches', '.', 'push', '(', 'info', '.', 'rim_info', '.', 'target_revision', ')', 'if', '!', 'branches', '.', 'include?', '(', 'info', '.', 'rim_info', '.', 'target_revision', ')', 'else', 'dest_parent_sha1', '=', 'info', '.', 'dest_sha1', 'break', 'end', 'end', 'dest_parent_sha1', '=', 'get_riminfo_for_revision', '(', 'src_session', ',', 'parent_sha1', ')', '.', 'revision_sha1', 'if', '!', 'dest_parent_sha1', 'dest_parent_sha1', '=', 'infos', '.', 'first', '.', 'rim_info', '.', 'revision_sha1', 'if', '!', 'dest_parent_sha1', '&&', '!', 'infos', '.', 'empty?', 'return', 'Struct', '.', 'new', '(', ':branches', ',', ':parent_sha1', ',', ':rev_infos', ')', '.', 'new', '(', 'branches', ',', 'dest_parent_sha1', ',', 'infos', ')', 'end']
->Original Target:
['search', 'backwards', 'for', 'all', 'revision', 'infos']
->Reconstructed Target:
search backwards for all revision infos
->Reconstructed Predication:
( branches, :parent_sha1,:rev_infos ). new (branches, :parent_sha1, :rev_infos). new ( branches, :rev_infos ). newbranches, :parent_sha1, :rev_infos). new ( branches, :parent_sha1, :rev_infos )( branches, :parent_sha1,). new ( branches, :
->Raw Input:
summarize:def get_branches_and_revision_infos ( src_session, dest_session, parent_sha1, sha1s ) infos = [ ] branches = [ ] dest_parent_sha1 = nil ( sha1s. size ( ) - 1 ). step ( 0, - 1 ) do | i | info = get_revision_info ( src_session, dest_session, sha1s [ i ] ) if! info. dest_sha1 && info. rim_info. target_revision infos. unshift ( info ) branches. push ( info. rim_info. target_revision ) if! branches. include? ( info. rim_info. target_revision ) else dest_parent_sha1 = info. dest_sha1 break end end dest_parent_sha1 = get_riminfo_for_revision ( src_session, parent_sha1 ). revision_sha1 if! dest_parent_sha1 dest_parent_sha1 = infos. first. rim_info. revision_sha1 if! dest_parent_sha1 &&! infos. empty? return Struct. new ( :branches, :parent_sha1, :rev_infos ). new ( branches, dest_parent_sha1, infos ) end
->Raw Target:
search backwards for all revision infos
--

634=========
->Original Input:
['def', 'get_revision_info', '(', 'src_session', ',', 'dest_session', ',', 'src_sha1', ')', 'module_status', '=', 'StatusBuilder', '.', 'new', '.', 'rev_module_status', '(', 'src_session', ',', 'src_sha1', ',', '@module_info', '.', 'local_path', ')', 'rim_info', '=', 'get_riminfo_for_revision', '(', 'src_session', ',', 'src_sha1', ')', 'dest_sha1', '=', 'dest_session', '.', 'rev_sha1', '(', '"rim-#{src_sha1}"', ')', 'msg', '=', 'src_session', '.', 'execute', '(', '"git show -s --format=%B #{src_sha1}"', ')', 'RevisionInfo', '.', 'new', '(', 'module_status', '&&', 'module_status', '.', 'dirty?', '?', 'dest_sha1', ':', 'rim_info', '.', 'revision_sha1', ',', 'src_sha1', ',', 'rim_info', ',', 'msg', ')', 'end']
->Original Target:
['collect', 'infos', 'for', 'a', 'revision']
->Reconstructed Target:
collect infos for a revision
->Reconstructed Predication:
revision_sha1 : dest_sha1revision_sha1 : dest_sha1
->Raw Input:
summarize:def get_revision_info ( src_session, dest_session, src_sha1 ) module_status = StatusBuilder. new. rev_module_status ( src_session, src_sha1, @module_info. local_path ) rim_info = get_riminfo_for_revision ( src_session, src_sha1 ) dest_sha1 = dest_session. rev_sha1 ( "rim-#{src_sha1}" ) msg = src_session. execute ( "git show -s --format=%B #{src_sha1}" ) RevisionInfo. new ( module_status && module_status. dirty?? dest_sha1 : rim_info. revision_sha1, src_sha1, rim_info, msg ) end
->Raw Target:
collect infos for a revision
--

635=========
->Original Input:
['def', 'commit_changes', '(', 'session', ',', 'branch', ',', 'sha1', ',', 'msg', ')', 'if', 'session', '.', 'status', '.', 'lines', '.', 'any?', 'session', '.', 'execute', '(', '"git add --all"', ')', 'msg_file', '=', 'Tempfile', '.', 'new', '(', "'message'", ')', 'begin', 'msg_file', '<<', 'msg', 'msg_file', '.', 'close', 'session', '.', 'execute', '(', '"git commit -F #{msg_file.path}"', ')', 'ensure', 'msg_file', '.', 'close', '(', 'true', ')', 'end', 'session', '.', 'execute', '(', '"git tag rim-#{sha1} refs/heads/#{branch}"', ')', 'end', 'end']
->Original Target:
['commit', 'changes', 'to', 'session']
->Reconstructed Target:
commit changes to session
->Reconstructed Predication:
commit changes to the branchcommit changes to the branch
->Raw Input:
summarize:def commit_changes ( session, branch, sha1, msg ) if session. status. lines. any? session. execute ( "git add --all" ) msg_file = Tempfile. new ('message' ) begin msg_file << msg msg_file. close session. execute ( "git commit -F #{msg_file.path}" ) ensure msg_file. close ( true ) end session. execute ( "git tag rim-#{sha1} refs/heads/#{branch}" ) end end
->Raw Target:
commit changes to session
--

636=========
->Original Input:
['def', 'get_riminfo_for_revision', '(', 'session', ',', 'sha1', ')', 'session', '.', 'execute', '(', '"git show #{sha1}:#{File.join(@module_info.local_path, RimInfo::InfoFileName)}"', ')', 'do', '|', 'out', ',', 'e', '|', 'return', 'RimInfo', '.', 'from_s', '(', '!', 'e', '?', 'out', ':', '""', ')', 'end', 'end']
->Original Target:
['get', 'target', 'revision', 'for', 'this', 'module', 'for', 'workspace', 'revision']
->Reconstructed Target:
get target revision for this module for workspace revision
->Reconstructed Predication:
the revision of the revision
->Raw Input:
summarize:def get_riminfo_for_revision ( session, sha1 ) session. execute ( "git show #{sha1}:#{File.join(@module_info.local_path, RimInfo::InfoFileName)}" ) do | out, e | return RimInfo. from_s (! e? out : "" ) end end
->Raw Target:
get target revision for this module for workspace revision
--

637=========
->Original Input:
['def', 'copy_revision_files', '(', 'src_session', ',', 'src_sha1', ',', 'dest_dir', ',', 'ignores', ')', 'Dir', '.', 'mktmpdir', 'do', '|', 'tmp_dir', '|', 'tmp_dir', '=', 'Dir', '.', 'glob', '(', 'tmp_dir', ')', '[', '0', ']', 'src_session', '.', 'execute', '(', '"git archive --format tar #{src_sha1} #{@module_info.local_path} | tar -C #{tmp_dir} -xf -"', ')', 'tmp_module_dir', '=', 'File', '.', 'join', '(', 'tmp_dir', ',', '@module_info', '.', 'local_path', ')', 'files', '=', 'FileHelper', '.', 'find_matching_files', '(', 'tmp_module_dir', ',', 'false', ',', '"/**/*"', ',', 'File', '::', 'FNM_DOTMATCH', ')', 'files', '.', 'delete', '(', '"."', ')', 'files', '.', 'delete', '(', '".."', ')', 'files', '.', 'delete', '(', 'RimInfo', '::', 'InfoFileName', ')', 'files', '-=', 'FileHelper', '.', 'find_matching_files', '(', 'tmp_module_dir', ',', 'false', ',', 'ignores', ')', 'prepare_empty_folder', '(', 'dest_dir', ',', '".git/**/*"', ')', 'files', '.', 'each', 'do', '|', 'f', '|', 'src_path', '=', 'File', '.', 'join', '(', 'tmp_module_dir', ',', 'f', ')', 'if', 'File', '.', 'file?', '(', 'src_path', ')', 'path', '=', 'File', '.', 'join', '(', 'dest_dir', ',', 'f', ')', 'FileUtils', '.', 'mkdir_p', '(', 'File', '.', 'dirname', '(', 'path', ')', ')', 'FileUtils', '.', 'cp', '(', 'src_path', ',', 'path', ')', 'end', 'end', 'end', 'end']
->Original Target:
['copy', 'files', 'from', 'given', 'source', 'revision', 'into', 'destination', 'dir']
->Reconstructed Target:
copy files from given source revision into destination dir
->Reconstructed Predication:
()( tmp_dir ))( tmp_dir )( tmp_dir )
->Raw Input:
summarize:def copy_revision_files ( src_session, src_sha1, dest_dir, ignores ) Dir. mktmpdir do | tmp_dir | tmp_dir = Dir. glob ( tmp_dir ) [ 0 ] src_session. execute ( "git archive --format tar #{src_sha1} #{@module_info.local_path} | tar -C #{tmp_dir} -xf -" ) tmp_module_dir = File. join ( tmp_dir, @module_info. local_path ) files = FileHelper. find_matching_files ( tmp_module_dir, false, "/**/*", File :: FNM_DOTMATCH ) files. delete ( "." ) files. delete ( ".." ) files. delete ( RimInfo :: InfoFileName ) files -= FileHelper. find_matching_files ( tmp_module_dir, false, ignores ) prepare_empty_folder ( dest_dir, ".git/**/*" ) files. each do | f | src_path = File. join ( tmp_module_dir, f ) if File. file? ( src_path ) path = File. join ( dest_dir, f ) FileUtils. mkdir_p ( File. dirname ( path ) ) FileUtils. cp ( src_path, path ) end end end end
->Raw Target:
copy files from given source revision into destination dir
--

638=========
->Original Input:
['def', 'rev_history_status', '(', 'git_session', ',', 'rev', ',', 'options', '=', '{', '}', ')', 'stop_rev', '=', 'options', '[', ':stop_rev', ']', 'relevant_revs', '=', '{', '}', 'if', 'stop_rev', 'git_session', '.', 'execute', '(', '"git rev-list #{rev} \\"^#{stop_rev}\\""', ')', '.', 'split', '(', '"\\n"', ')', '.', 'each', 'do', '|', 'r', '|', 'relevant_revs', '[', 'r', ']', '=', 'true', 'end', 'elsif', 'options', '[', ':gerrit', ']', 'git_session', '.', 'execute', '(', '"git rev-list #{rev} --not --all --"', ')', '.', 'split', '(', '"\\n"', ')', '.', 'each', 'do', '|', 'r', '|', 'relevant_revs', '[', 'r', ']', '=', 'true', 'end', 'else', 'git_session', '.', 'all_reachable_non_remote_revs', '(', 'rev', ')', '.', 'each', 'do', '|', 'r', '|', 'relevant_revs', '[', 'r', ']', '=', 'true', 'end', 'end', 'rev', '=', 'git_session', '.', 'rev_sha1', '(', 'rev', ')', 'build_rev_history_status', '(', 'git_session', ',', 'rev', ',', 'relevant_revs', ',', '{', '}', ',', ':fast', '=>', 'options', '[', ':fast', ']', ')', 'end']
->Original Target:
['status', 'object', 'tree', 'for', 'revision', 'rev', 'returns', 'the', 'root', 'status', 'object', 'which', 'points', 'to', 'any', 'parent', 'status', 'objects', 'note', 'that', 'merge', 'commits', 'mean', 'that', 'the', 'status', 'tree', 'branches', 'at', 'the', 'point', 'were', 'the', 'merged', 'branch', 'branched', 'off', 'the', 'status', 'tree', 'joins', 'i', '.', 'e', '.', 'the', 'parent', 'status', 'objects', 'are', 'the', 'same', 'at', 'this', 'point']
->Reconstructed Target:
status object tree for revision rev returns the root status object which points to any parent status objects note that merge commits mean that the status tree branches at the point were the merged branch branched off the status tree joins i. e. the parent status objects are the same at this point
->Reconstructed Predication:
the history of thethe history of thethe history of thethe history of thethe history of thethe history of the
->Raw Input:
summarize:def rev_history_status ( git_session, rev, options = { } ) stop_rev = options [ :stop_rev ] relevant_revs = { } if stop_rev git_session. execute ( "git rev-list #{rev} \"^#{stop_rev}\"" ). split ( "\n" ). each do | r | relevant_revs [ r ] = true end elsif options [ :gerrit ] git_session. execute ( "git rev-list #{rev} --not --all --" ). split ( "\n" ). each do | r | relevant_revs [ r ] = true end else git_session. all_reachable_non_remote_revs ( rev ). each do | r | relevant_revs [ r ] = true end end rev = git_session. rev_sha1 ( rev ) build_rev_history_status ( git_session, rev, relevant_revs, { }, :fast => options [ :fast ] ) end
->Raw Target:
status object tree for revision rev returns the root status object which points to any parent status objects note that merge commits mean that the status tree branches at the point were the merged branch branched off the status tree joins i. e. the parent status objects are the same at this point
--

639=========
->Original Input:
['def', 'rev_status', '(', 'git_session', ',', 'rev', ')', 'mod_dirs', '=', 'module_dirs', '(', 'git_session', ',', 'rev', ')', 'mod_stats', '=', '[', ']', 'git_session', '.', 'within_exported_rev', '(', 'rev', ',', 'mod_dirs', ')', 'do', '|', 'd', '|', 'mod_dirs', '.', 'each', 'do', '|', 'rel_path', '|', 'mod_stats', '<<', 'build_module_status', '(', 'd', ',', 'd', '+', '"/"', '+', 'rel_path', ')', 'end', 'end', 'stat', '=', 'RevStatus', '.', 'new', '(', 'mod_stats', ')', 'stat', '.', 'git_rev', '=', 'git_session', '.', 'rev_sha1', '(', 'rev', ')', 'stat', 'end']
->Original Target:
['status', 'object', 'for', 'single', 'revision', '+', 'rev', '+', 'without', 'status', 'of', 'ancestors']
->Reconstructed Target:
status object for single revision + rev + without status of ancestors
->Reconstructed Predication:
the status of a module
->Raw Input:
summarize:def rev_status ( git_session, rev ) mod_dirs = module_dirs ( git_session, rev ) mod_stats = [ ] git_session. within_exported_rev ( rev, mod_dirs ) do | d | mod_dirs. each do | rel_path | mod_stats << build_module_status ( d, d + "/" + rel_path ) end end stat = RevStatus. new ( mod_stats ) stat. git_rev = git_session. rev_sha1 ( rev ) stat end
->Raw Target:
status object for single revision + rev + without status of ancestors
--

640=========
->Original Input:
['def', 'rev_module_status', '(', 'git_session', ',', 'rev', ',', 'local_path', ')', 'mod_stat', '=', 'nil', 'if', 'git_session', '.', 'execute', '(', '"git ls-tree -r --name-only #{rev}"', ')', '.', 'split', '(', '"\\n"', ')', '.', 'include?', '(', 'File', '.', 'join', '(', 'local_path', ',', '".riminfo"', ')', ')', 'git_session', '.', 'within_exported_rev', '(', 'rev', ',', '[', 'local_path', ']', ')', 'do', '|', 'd', '|', 'mod_stat', '=', 'build_module_status', '(', 'd', ',', 'File', '.', 'join', '(', 'd', ',', 'local_path', ')', ')', 'end', 'end', 'mod_stat', 'end']
->Original Target:
['status', 'object', 'for', 'a', 'single', 'module', 'at', '+', 'local_path', '+', 'in', 'revision', '+', 'rev', '+', 'returns', 'nil', 'if', 'there', 'is', 'no', 'such', 'module', 'in', 'this', 'revision']
->Reconstructed Target:
status object for a single module at + local_path + in revision + rev + returns nil if there is no such module in this revision
->Reconstructed Predication:
the module status for thethe module status for thethe module status for thethe module status for thethe module status for the
->Raw Input:
summarize:def rev_module_status ( git_session, rev, local_path ) mod_stat = nil if git_session. execute ( "git ls-tree -r --name-only #{rev}" ). split ( "\n" ). include? ( File. join ( local_path, ".riminfo" ) ) git_session. within_exported_rev ( rev, [ local_path ] ) do | d | mod_stat = build_module_status ( d, File. join ( d, local_path ) ) end end mod_stat end
->Raw Target:
status object for a single module at + local_path + in revision + rev + returns nil if there is no such module in this revision
--

641=========
->Original Input:
['def', 'fs_status', '(', 'dir', ')', 'RevStatus', '.', 'new', '(', 'fs_rim_dirs', '(', 'dir', ')', '.', 'collect', '{', '|', 'd', '|', 'build_module_status', '(', 'dir', ',', 'd', ')', '}', ')', 'end']
->Original Target:
['status', 'object', 'for', 'the', 'current', 'file', 'system', 'content', 'of', 'dir', 'this', 'can', 'by', 'any', 'directory', 'even', 'outside', 'of', 'any', 'git', 'working', 'copy']
->Reconstructed Target:
status object for the current file system content of dir this can by any directory even outside of any git working copy
->Reconstructed Predication:
the status of a module
->Raw Input:
summarize:def fs_status ( dir ) RevStatus. new ( fs_rim_dirs ( dir ). collect { | d | build_module_status ( dir, d ) } ) end
->Raw Target:
status object for the current file system content of dir this can by any directory even outside of any git working copy
--

642=========
->Original Input:
['def', 'build_rev_history_status', '(', 'gs', ',', 'rev', ',', 'relevant_revs', ',', 'status_cache', '=', '{', '}', ',', 'options', '=', '{', '}', ')', 'return', 'status_cache', '[', 'rev', ']', 'if', 'status_cache', '[', 'rev', ']', 'stat', '=', 'nil', 'if', 'relevant_revs', '[', 'rev', ']', 'parent_revs', '=', 'gs', '.', 'parent_revs', '(', 'rev', ')', 'if', 'parent_revs', '.', 'size', '>', '0', 'parent_stats', '=', 'parent_revs', '.', 'collect', 'do', '|', 'p', '|', 'build_rev_history_status', '(', 'gs', ',', 'p', ',', 'relevant_revs', ',', 'status_cache', ',', 'options', ')', 'end', 'base_stat', '=', 'parent_stats', '.', 'first', 'changed_files', '=', 'gs', '.', 'changed_files', '(', 'rev', ',', 'parent_revs', '.', 'first', ')', 'module_dirs', '=', 'base_stat', '.', 'modules', '.', 'collect', '{', '|', 'm', '|', 'm', '.', 'dir', '}', 'changed_files', '.', 'each', 'do', '|', 'f', '|', 'if', 'File', '.', 'basename', '(', 'f', '.', 'path', ')', '==', 'RimInfo', '::', 'InfoFileName', 'if', 'f', '.', 'kind', '==', ':added', 'module_dirs', '<<', 'File', '.', 'dirname', '(', 'f', '.', 'path', ')', 'elsif', 'f', '.', 'kind', '==', ':deleted', 'module_dirs', '.', 'delete', '(', 'File', '.', 'dirname', '(', 'f', '.', 'path', ')', ')', 'end', 'end', 'end', 'check_dirs', '=', 'module_dirs', '.', 'select', '{', '|', 'd', '|', 'changed_files', '.', 'any?', '{', '|', 'f', '|', 'f', '.', 'path', '.', 'start_with?', '(', 'd', ')', '}', '}', 'module_stats', '=', '[', ']', 'if', 'check_dirs', '.', 'size', '>', '0', 'gs', '.', 'within_exported_rev', '(', 'rev', ',', 'check_dirs', ')', 'do', '|', 'ws', '|', 'check_dirs', '.', 'each', 'do', '|', 'd', '|', 'module_stats', '<<', 'build_module_status', '(', 'ws', ',', 'File', '.', 'join', '(', 'ws', ',', 'd', ')', ')', 'end', 'end', 'end', '(', 'module_dirs', '-', 'check_dirs', ')', '.', 'each', 'do', '|', 'd', '|', 'base_mod', '=', 'base_stat', '.', 'modules', '.', 'find', '{', '|', 'm', '|', 'm', '.', 'dir', '==', 'd', '}', 'module_stats', '<<', 'RevStatus', '::', 'ModuleStatus', '.', 'new', '(', 'd', ',', 'base_mod', '.', 'rim_info', ',', 'base_mod', '.', 'dirty?', ')', 'end', 'stat', '=', 'RevStatus', '.', 'new', '(', 'module_stats', ')', 'stat', '.', 'git_rev', '=', 'gs', '.', 'rev_sha1', '(', 'rev', ')', 'stat', '.', 'parents', '.', 'concat', '(', 'parent_stats', ')', 'else', 'if', 'options', '[', ':fast', ']', 'stat', '=', 'rev_status_fast', '(', 'gs', ',', 'rev', ')', 'else', 'stat', '=', 'rev_status', '(', 'gs', ',', 'rev', ')', 'end', 'end', 'else', 'if', 'options', '[', ':fast', ']', 'stat', '=', 'rev_status_fast', '(', 'gs', ',', 'rev', ')', 'else', 'stat', '=', 'rev_status', '(', 'gs', ',', 'rev', ')', 'end', 'end', 'status_cache', '[', 'rev', ']', '=', 'stat', 'end']
->Original Target:
['building', 'of', 'the', 'status', 'of', 'an', 'ancestor', 'chain', 'works', 'by', 'checking', 'the', 'dirty', 'state', 'of', 'modules', 'only', 'when', 'any', 'files', 'affecting', 'some', 'module', 'were', 'changed', ';', 'otherwise', 'the', 'status', 'of', 'the', 'module', 'in', 'the', 'ancestor', 'is', 'assumed']
->Reconstructed Target:
building of the status of an ancestor chain works by checking the dirty state of modules only when any files affecting some module were changed ; otherwise the status of the module in the ancestor is assumed
->Reconstructed Predication:
.(.......... last.
->Raw Input:
summarize:def build_rev_history_status ( gs, rev, relevant_revs, status_cache = { }, options = { } ) return status_cache [ rev ] if status_cache [ rev ] stat = nil if relevant_revs [ rev ] parent_revs = gs. parent_revs ( rev ) if parent_revs. size > 0 parent_stats = parent_revs. collect do | p | build_rev_history_status ( gs, p, relevant_revs, status_cache, options ) end base_stat = parent_stats. first changed_files = gs. changed_files ( rev, parent_revs. first ) module_dirs = base_stat. modules. collect { | m | m. dir } changed_files. each do | f | if File. basename ( f. path ) == RimInfo :: InfoFileName if f. kind == :added module_dirs << File. dirname ( f. path ) elsif f. kind == :deleted module_dirs. delete ( File. dirname ( f. path ) ) end end end check_dirs = module_dirs. select { | d | changed_files. any? { | f | f. path. start_with? ( d ) } } module_stats = [ ] if check_dirs. size > 0 gs. within_exported_rev ( rev, check_dirs ) do | ws | check_dirs. each do | d | module_stats << build_module_status ( ws, File. join ( ws, d ) ) end end end ( module_dirs - check_dirs ). each do | d | base_mod = base_stat. modules. find { | m | m. dir == d } module_stats << RevStatus :: ModuleStatus. new ( d, base_mod. rim_info, base_mod. dirty? ) end stat = RevStatus. new ( module_stats ) stat. git_rev = gs. rev_sha1 ( rev ) stat. parents. concat ( parent_stats ) else if options [ :fast ] stat = rev_status_fast ( gs, rev ) else stat = rev_status ( gs, rev ) end end else if options [ :fast ] stat = rev_status_fast ( gs, rev ) else stat = rev_status ( gs, rev ) end end status_cache [ rev ]
->Raw Target:
building of the status of an ancestor chain works by checking the dirty state of modules only when any files affecting some module were changed ; otherwise the status of the module in the ancestor is assumed
--

643=========
->Original Input:
['def', 'rev_status_fast', '(', 'git_session', ',', 'rev', ')', 'mod_dirs', '=', 'module_dirs', '(', 'git_session', ',', 'rev', ')', 'mod_stats', '=', '[', ']', 'git_session', '.', 'within_exported_rev', '(', 'rev', ',', 'mod_dirs', '.', 'collect', '{', '|', 'd', '|', '"#{d}/#{RimInfo::InfoFileName}"', '}', ')', 'do', '|', 'temp_dir', '|', 'mod_dirs', '.', 'each', 'do', '|', 'rel_path', '|', 'mod_stats', '<<', 'RevStatus', '::', 'ModuleStatus', '.', 'new', '(', 'rel_path', ',', 'RimInfo', '.', 'from_dir', '(', '"#{temp_dir}/#{rel_path}"', ')', ',', 'false', ')', 'end', 'end', 'stat', '=', 'RevStatus', '.', 'new', '(', 'mod_stats', ')', 'stat', '.', 'git_rev', '=', 'git_session', '.', 'rev_sha1', '(', 'rev', ')', 'stat', 'end']
->Original Target:
['creates', 'a', 'RevStatus', 'object', 'for', '+', 'rev', '+', 'with', 'all', 'modules', 'assumend', 'to', 'be', 'clean']
->Reconstructed Target:
creates a RevStatus object for + rev + with all modules assumend to be clean
->Reconstructed Predication:
the module status for thethe module status for the
->Raw Input:
summarize:def rev_status_fast ( git_session, rev ) mod_dirs = module_dirs ( git_session, rev ) mod_stats = [ ] git_session. within_exported_rev ( rev, mod_dirs. collect { | d | "#{d}/#{RimInfo::InfoFileName}" } ) do | temp_dir | mod_dirs. each do | rel_path | mod_stats << RevStatus :: ModuleStatus. new ( rel_path, RimInfo. from_dir ( "#{temp_dir}/#{rel_path}" ), false ) end end stat = RevStatus. new ( mod_stats ) stat. git_rev = git_session. rev_sha1 ( rev ) stat end
->Raw Target:
creates a RevStatus object for + rev + with all modules assumend to be clean
--

644=========
->Original Input:
['def', 'sync', '(', 'message', '=', 'nil', ',', 'rebase', '=', 'nil', ',', 'split', '=', 'true', ')', 'RIM', '::', 'git_session', '(', '@ws_root', ')', 'do', '|', 's', '|', 'branch', '=', 's', '.', 'current_branch', '||', "''", 'rim_branch', '=', '"rim/"', '+', 'branch', 'branch_sha1', '=', 'nil', 'changed_modules', '=', 'nil', 'if', 'branch', '.', 'empty?', 'raise', 'RimException', '.', 'new', '(', '"Not on a git branch."', ')', 'elsif', 'branch', '.', 'start_with?', '(', '"rim/"', ')', 'raise', 'RimException', '.', 'new', '(', '"The current git branch \'#{branch}\' is a rim integration branch. Please switch to a non rim branch to proceed."', ')', 'else', 'branch', '=', '"refs/heads/#{branch}"', 'branch_sha1', '=', 's', '.', 'rev_sha1', '(', 'rim_branch', ')', 'remote_rev', '=', 'get_latest_remote_revision', '(', 's', ',', 'branch', ')', 'rev', '=', 'get_latest_clean_path_revision', '(', 's', ',', 'branch', ',', 'remote_rev', ')', 'if', '!', 's', '.', 'has_branch?', '(', 'rim_branch', ')', '||', 'has_ancestor?', '(', 's', ',', 'branch', ',', 's', '.', 'rev_sha1', '(', 'rim_branch', ')', ')', '||', '!', 'has_ancestor?', '(', 's', ',', 'rim_branch', ',', 'remote_rev', ')', 's', '.', 'execute', '(', '"git branch -f #{rim_branch} #{rev}"', ')', 'branch_sha1', '=', 's', '.', 'rev_sha1', '(', 'rim_branch', ')', 'end', 'remote_url', '=', '"file://"', '+', '@ws_root', '@logger', '.', 'debug', '(', '"Folder for temporary git repositories: #{@rim_path}"', ')', 'tmpdir', '=', 'clone_or_fetch_repository', '(', 'remote_url', ',', 'module_tmp_git_path', '(', '".ws"', ')', ',', '"Cloning workspace git..."', ')', 'RIM', '::', 'git_session', '(', 'tmpdir', ')', 'do', '|', 'tmp_session', '|', 'tmp_session', '.', 'execute', '(', '"git reset --hard"', ')', 'tmp_session', '.', 'execute', '(', '"git clean -xdf"', ')', 'tmp_session', '.', 'execute', '(', '"git checkout -B #{rim_branch} -f remotes/origin/#{rim_branch}"', ')', 'changed_modules', '=', 'sync_modules', '(', 'tmp_session', ',', 'message', ')', 'if', '!', 'split', 'tmp_session', '.', 'execute', '(', '"git reset --soft #{branch_sha1}"', ')', 'commit', '(', 'tmp_session', ',', 'message', '?', 'message', ':', 'get_commit_message', '(', 'changed_modules', ')', ')', 'if', 'tmp_session', '.', 'uncommited_changes?', 'end', 'tmp_session', '.', 'execute', '(', '"git push #{remote_url} #{rim_branch}:#{rim_branch}"', ')', 'end', 'end', 'if', '!', 'changed_modules', '.', 'empty?', 'if', 'rebase', 's', '.', 'execute', '(', '"git rebase #{rim_branch}"', ')', '@logger', '.', 'info', '(', '"Changes have been commited to branch #{rim_branch} and workspace has been rebased successfully."', ')', 'else', '@logger', '.', 'info', '(', '"Changes have been commited to branch #{rim_branch}. Rebase to apply changes to workspace."', ')', 'end', 'else', '@logger', '.', 'info', '(', '"No changes."', ')', 'end', 'end', 'end']
->Original Target:
['sync', 'all', 'module', 'changes', 'into', 'rim', 'branch']
->Reconstructed Target:
sync all module changes into rim branch
->Reconstructed Predication:
..... execute ( "git"git push #{remote_url} #{rim_path} #{branch_sha1}" )( "git push #{remote_url} #{rim_path}"git push #{remote_url} #{rim_path} #{branch_sha1}" )( "git push #{remote_url} #{rim_path}"git push #{remote_url
->Raw Input:
summarize:def sync ( message = nil, rebase = nil, split = true ) RIM :: git_session ( @ws_root ) do | s | branch = s. current_branch || '' rim_branch = "rim/" + branch branch_sha1 = nil changed_modules = nil if branch. empty? raise RimException. new ( "Not on a git branch." ) elsif branch. start_with? ( "rim/" ) raise RimException. new ( "The current git branch '#{branch}' is a rim integration branch. Please switch to a non rim branch to proceed." ) else branch = "refs/heads/#{branch}" branch_sha1 = s. rev_sha1 ( rim_branch ) remote_rev = get_latest_remote_revision ( s, branch ) rev = get_latest_clean_path_revision ( s, branch, remote_rev ) if! s. has_branch? ( rim_branch ) || has_ancestor? ( s, branch, s. rev_sha1 ( rim_branch ) ) ||! has_ancestor? ( s, rim_branch, remote_rev ) s. execute ( "git branch -f #{rim_branch} #{rev}" ) branch_sha1 = s. rev_sha1 ( rim_branch ) end remote_url = "file://" + @ws_root @logger. debug ( "Folder for temporary git repositories: #{@rim_path}" ) tmpdir = clone_or_fetch_repository ( remote_url, module_tmp_git_path ( ".ws" ), "Cloning workspace git..." ) RIM :: git_session ( tmpdir ) do | tmp_session | tmp_session. execute ( "git reset --hard" ) tmp_session. execute ( "git clean -xdf" ) tmp_session. execute ( "git checkout -B #{rim_branch} -f remotes/origin/#{rim_branch}" ) changed_modules = sync_modules ( tmp_session, message ) if! split tmp_session. execute ( "git reset --soft #{branch_sha1}" ) commit ( tmp_session, message? message : get_commit_message ( changed_modules ) ) if tmp_session. uncommited_changes? end tmp_session. execute ( "git push #{remote_url} #{rim_
->Raw Target:
sync all module changes into rim branch
--

645=========
->Original Input:
['def', 'sync_modules', '(', 'session', ',', 'message', ')', 'module_helpers', '=', '[', ']', '@module_infos', '.', 'each', 'do', '|', 'module_info', '|', 'module_helpers', '.', 'push', '(', 'SyncModuleHelper', '.', 'new', '(', 'session', '.', 'execute_dir', ',', '@ws_root', ',', 'module_info', ',', '@logger', ')', ')', 'end', 'changed_modules', '=', '[', ']', 'module_helpers', '.', 'each', 'do', '|', 'm', '|', '@logger', '.', 'info', '(', '"Synchronizing #{m.module_info.local_path}..."', ')', 'if', 'm', '.', 'sync', '(', 'message', ')', 'changed_modules', '<<', 'm', '.', 'module_info', 'end', 'end', 'changed_modules', 'end']
->Original Target:
['sync', 'all', 'modules']
->Reconstructed Target:
sync all modules
->Reconstructed Predication:
the modules that have been
->Raw Input:
summarize:def sync_modules ( session, message ) module_helpers = [ ] @module_infos. each do | module_info | module_helpers. push ( SyncModuleHelper. new ( session. execute_dir, @ws_root, module_info, @logger ) ) end changed_modules = [ ] module_helpers. each do | m | @logger. info ( "Synchronizing #{m.module_info.local_path}..." ) if m. sync ( message ) changed_modules << m. module_info end end changed_modules end
->Raw Target:
sync all modules
--

646=========
->Original Input:
['def', 'has_ancestor?', '(', 'session', ',', 'rev', ',', 'ancestor', ')', 'rev', '=', 'session', '.', 'rev_sha1', '(', 'rev', ')', 'return', 'rev', '==', 'ancestor', '||', 'session', '.', 'is_ancestor?', '(', 'ancestor', ',', 'rev', ')', 'end']
->Original Target:
['check', 'whether', 'revision', 'has', 'a', 'given', 'ancestor']
->Reconstructed Target:
check whether revision has a given ancestor
->Reconstructed Predication:
 def has_ancestor? ( session
->Raw Input:
summarize:def has_ancestor? ( session, rev, ancestor ) rev = session. rev_sha1 ( rev ) return rev == ancestor || session. is_ancestor? ( ancestor, rev ) end
->Raw Target:
check whether revision has a given ancestor
--

647=========
->Original Input:
['def', 'get_parent', '(', 'session', ',', 'rev', ')', 'parents', '=', 'session', '.', 'parent_revs', '(', 'rev', ')', '!', 'parents', '.', 'empty?', '?', 'parents', '.', 'first', ':', 'nil', 'end']
->Original Target:
['get', 'first', 'parent', 'node']
->Reconstructed Target:
get first parent node
->Reconstructed Predication:
the parent of the given rev
->Raw Input:
summarize:def get_parent ( session, rev ) parents = session. parent_revs ( rev )! parents. empty?? parents. first : nil end
->Raw Target:
get first parent node
--

648=========
->Original Input:
['def', 'get_commit_message', '(', 'changed_modules', ')', 'StringIO', '.', 'open', 'do', '|', 's', '|', 's', '.', 'puts', '"rim sync."', 's', '.', 'puts', 'changed_modules', '.', 'each', 'do', '|', 'm', '|', 's', '.', 'puts', 'm', '.', 'local_path', 'end', 's', '.', 'string', 'end', 'end']
->Original Target:
['create', 'default', 'commit', 'message', 'from', 'array', 'of', 'changed', 'modules']
->Reconstructed Target:
create default commit message from array of changed modules
->Reconstructed Predication:
 def get_commit_message
->Raw Input:
summarize:def get_commit_message ( changed_modules ) StringIO. open do | s | s. puts "rim sync." s. puts changed_modules. each do | m | s. puts m. local_path end s. string end end
->Raw Target:
create default commit message from array of changed modules
--

649=========
->Original Input:
['def', 'pmmap_ext', '(', 'data', ')', 'pmmap_ext', '=', '[', "'addr'", ',', "'perms'", ',', "'path'", ',', "'rss'", ',', "'size'", ',', "'pss'", ',', "'shared_clean'", ',', "'shared_dirty'", ',', "'private_clean'", ',', "'private_dirty'", ',', "'referenced'", ',', "'anonymous'", ',', "'swap'", ']', 'os_list', '=', '[', ']', 'data', '.', 'each', 'do', '|', 'datum', '|', 'os', '=', 'OpenStruct', '.', 'new', 'pmmap_ext', '.', 'each_index', '{', '|', 'i', '|', 'os', '[', 'pmmap_ext', '[', 'i', ']', ']', '=', 'datum', '[', 'i', ']', '}', 'os_list', '.', 'push', '(', 'os', ')', 'end', 'os_list', 'end']
->Original Target:
['data', 'in', 'pmmap_ext', 'is', 'an', 'Array']
->Reconstructed Target:
data in pmmap_ext is an Array
->Reconstructed Predication:
the file system to thethe file system to the file
->Raw Input:
summarize:def pmmap_ext ( data ) pmmap_ext = [ 'addr', 'perms', 'path', 'rss','size', 'pss','shared_clean','shared_dirty', 'private_clean', 'private_dirty','referenced', 'anonymous','swap' ] os_list = [ ] data. each do | datum | os = OpenStruct. new pmmap_ext. each_index { | i | os [ pmmap_ext [ i ] ] = datum [ i ] } os_list. push ( os ) end os_list end
->Raw Target:
data in pmmap_ext is an Array
--

650=========
->Original Input:
['def', 'pmmap_grouped', '(', 'data', ')', 'pmmap_grouped', '=', '[', "'rss'", ',', "'size'", ',', "'pss'", ',', "'shared_clean'", ',', "'shared_dirty'", ',', "'private_clean'", ',', "'private_dirty'", ',', "'referenced'", ',', "'anonymous'", ',', "'swap'", ']', 'os_list', '=', '[', ']', 'data', '.', 'each', 'do', '|', 'k', ',', 'v', '|', 'os', '=', 'OpenStruct', '.', 'new', 'os', '.', 'path', '=', 'k', 'pmmap_grouped', '.', 'each_index', '{', '|', 'i', '|', 'os', '[', 'pmmap_grouped', '[', 'i', ']', ']', '=', 'v', '[', 'i', ']', '}', 'os_list', '.', 'push', '(', 'os', ')', 'end', 'os_list', 'end']
->Original Target:
['data', 'in', 'pmmap_grouped', 'is', 'a', 'Hash']
->Reconstructed Target:
data in pmmap_grouped is a Hash
->Reconstructed Predication:
the data to be grouped
->Raw Input:
summarize:def pmmap_grouped ( data ) pmmap_grouped = [ 'rss','size', 'pss','shared_clean','shared_dirty', 'private_clean', 'private_dirty','referenced', 'anonymous','swap' ] os_list = [ ] data. each do | k, v | os = OpenStruct. new os. path = k pmmap_grouped. each_index { | i | os [ pmmap_grouped [ i ] ] = v [ i ] } os_list. push ( os ) end os_list end
->Raw Target:
data in pmmap_grouped is a Hash
--

651=========
->Original Input:
['def', 'calc_checksum', '(', 'mi', ',', 'dir', ')', 'if', 'check_required_attributes', '(', 'mi', ')', 'sha1', '=', 'Digest', '::', 'SHA1', '.', 'new', 'files', '=', 'FileHelper', '.', 'find_matching_files', '(', 'dir', ',', 'false', ',', '"/**/*"', ',', 'File', '::', 'FNM_DOTMATCH', ')', 'files', '.', 'delete', '(', '"."', ')', 'files', '.', 'delete', '(', '".."', ')', 'files', '.', 'delete', '(', 'RimInfo', '::', 'InfoFileName', ')', 'files', '-=', 'FileHelper', '.', 'find_matching_files', '(', 'dir', ',', 'false', ',', 'mi', '.', 'ignores', ')', 'files', '.', 'sort!', 'files', '.', 'each', 'do', '|', 'fn', '|', 'update_file', '(', 'sha1', ',', 'dir', ',', 'fn', ')', 'end', 'ChecksumAttributes', '.', 'each', 'do', '|', 'a', '|', 'sha1', '.', 'update', '(', 'mi', '.', 'send', '(', 'a', ')', ')', 'end', 'sha1', '.', 'hexdigest', 'else', 'nil', 'end', 'end']
->Original Target:
['returns', 'nil', 'if', 'checksum', 'can', 't', 'be', 'calculated', 'due', 'to', 'missing', 'info']
->Reconstructed Target:
returns nil if checksum can t be calculated due to missing info
->Reconstructed Predication:
the file to be checksumed.
->Raw Input:
summarize:def calc_checksum ( mi, dir ) if check_required_attributes ( mi ) sha1 = Digest :: SHA1. new files = FileHelper. find_matching_files ( dir, false, "/**/*", File :: FNM_DOTMATCH ) files. delete ( "." ) files. delete ( ".." ) files. delete ( RimInfo :: InfoFileName ) files -= FileHelper. find_matching_files ( dir, false, mi. ignores ) files. sort! files. each do | fn | update_file ( sha1, dir, fn ) end ChecksumAttributes. each do | a | sha1. update ( mi. send ( a ) ) end sha1. hexdigest else nil end end
->Raw Target:
returns nil if checksum can t be calculated due to missing info
--

652=========
->Original Input:
['def', 'current_branch', 'out', '=', 'execute', '"git branch"', 'out', '.', 'split', '(', '"\\n"', ')', '.', 'each', 'do', '|', 'l', '|', 'if', '!', 'l', '.', 'include?', '(', "'('", ')', '&&', '(', 'l', '=~', '/', '\\*', '\\s', '\\S', '/', ')', 'return', '$1', 'end', 'end', 'nil', 'end']
->Original Target:
['returns', 'the', 'current', 'branch']
->Reconstructed Target:
returns the current branch
->Reconstructed Predication:
branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch branch
->Raw Input:
summarize:def current_branch out = execute "git branch" out. split ( "\n" ). each do | l | if! l. include? ( '(' ) && ( l =~ / \* \s \S / ) return $1 end end nil end
->Raw Target:
returns the current branch
--

653=========
->Original Input:
['def', 'has_remote_branch?', '(', 'branch', ')', 'out', '=', 'execute', '(', '"git ls-remote --heads"', ')', 'out', '.', 'split', '(', '"\\n"', ')', '.', 'each', 'do', '|', 'l', '|', 'return', 'true', 'if', 'l', '.', 'split', '(', '/', '\\s', '/', ')', '[', '1', ']', '==', '"refs/heads/#{branch}"', 'end', 'false', 'end']
->Original Target:
['check', 'whether', 'remote', 'branch', 'exists']
->Reconstructed Target:
check whether remote branch exists
->Reconstructed Predication:
branch is a remote branch
->Raw Input:
summarize:def has_remote_branch? ( branch ) out = execute ( "git ls-remote --heads" ) out. split ( "\n" ). each do | l | return true if l. split ( / \s / ) [ 1 ] == "refs/heads/#{branch}" end false end
->Raw Target:
check whether remote branch exists
--

654=========
->Original Input:
['def', 'rev_sha1', '(', 'rev', ')', 'sha1', '=', 'nil', 'execute', '"git rev-list -n 1 #{rev} --"', 'do', '|', 'out', ',', 'e', '|', 'sha1', '=', 'out', '.', 'strip', 'if', '!', 'e', 'end', 'sha1', 'end']
->Original Target:
['returns', 'the', 'SHA', '-', '1', 'representation', 'of', 'rev']
->Reconstructed Target:
returns the SHA - 1 representation of rev
->Reconstructed Predication:
the sha1 of the revision
->Raw Input:
summarize:def rev_sha1 ( rev ) sha1 = nil execute "git rev-list -n 1 #{rev} --" do | out, e | sha1 = out. strip if! e end sha1 end
->Raw Target:
returns the SHA - 1 representation of rev
--

655=========
->Original Input:
['def', 'rev_infos', '(', 'rev', ',', 'desired', ')', 'info', '=', '{', '}', 'desired', '.', 'each_pair', 'do', '|', 'key', ',', 'value', '|', 'execute', '"git log -1 --format=#{value} #{rev} --"', 'do', '|', 'out', ',', 'e', '|', 'info', '[', 'key', ']', '=', 'out', '.', 'strip', 'if', '!', 'e', 'end', 'end', 'info', 'end']
->Original Target:
['returns', 'some', 'informations', 'about', 'a', 'revision']
->Reconstructed Target:
returns some informations about a revision
->Reconstructed Predication:
the rev information for the
->Raw Input:
summarize:def rev_infos ( rev, desired ) info = { } desired. each_pair do | key, value | execute "git log -1 --format=#{value} #{rev} --" do | out, e | info [ key ] = out. strip if! e end end info end
->Raw Target:
returns some informations about a revision
--

656=========
->Original Input:
['def', 'remote_branch_revs', 'out', '=', 'execute', '"git show-ref"', 'out', '.', 'split', '(', '"\\n"', ')', '.', 'collect', '{', '|', 'l', '|', 'if', 'l', '=~', '/', '\\/', '\\/', '/', 'l', '.', 'split', '[', '0', ']', 'else', 'nil', 'end', '}', '.', 'compact', 'end']
->Original Target:
['returns', 'the', 'SHA', '-', '1', 'representations', 'of', 'the', 'heads', 'of', 'all', 'remote', 'branches']
->Reconstructed Target:
returns the SHA - 1 representations of the heads of all remote branches
->Reconstructed Predication:
remote branch ref to remote branch
->Raw Input:
summarize:def remote_branch_revs out = execute "git show-ref" out. split ( "\n" ). collect { | l | if l =~ / \/ \/ / l. split [ 0 ] else nil end }. compact end
->Raw Target:
returns the SHA - 1 representations of the heads of all remote branches
--

657=========
->Original Input:
['def', 'export_rev', '(', 'rev', ',', 'dir', ',', 'paths', '=', '[', ']', ')', 'paths', '=', 'paths', '.', 'dup', 'loop', 'do', 'path_args', '=', '""', 'while', '!', 'paths', '.', 'empty?', '&&', 'path_args', '.', 'size', '<', '6000', 'path_args', '<<', '" "', 'path_args', '<<', 'paths', '.', 'shift', 'end', 'execute', '"git archive --format tar #{rev} #{path_args} | tar -C #{dir} -xf -"', 'break', 'if', 'paths', '.', 'empty?', 'end', 'end']
->Original Target:
['export', 'file', 'contents', 'of', 'rev', 'to', 'dir', 'if', '+', 'paths', '+', 'is', 'given', 'and', 'non', '-', 'empty', 'checks', 'out', 'only', 'those', 'parts', 'of', 'the', 'filesystem', 'tree', 'does', 'not', 'remove', 'any', 'files', 'from', 'dir', 'which', 'existed', 'before']
->Reconstructed Target:
export file contents of rev to dir if + paths + is given and non - empty checks out only those parts of the filesystem tree does not remove any files from dir which existed before
->Reconstructed Predication:
the archive of a revision
->Raw Input:
summarize:def export_rev ( rev, dir, paths = [ ] ) paths = paths. dup loop do path_args = "" while! paths. empty? && path_args. size < 6000 path_args << " " path_args << paths. shift end execute "git archive --format tar #{rev} #{path_args} | tar -C #{dir} -xf -" break if paths. empty? end end
->Raw Target:
export file contents of rev to dir if + paths + is given and non - empty checks out only those parts of the filesystem tree does not remove any files from dir which existed before
--

658=========
->Original Input:
['def', 'within_exported_rev', '(', 'rev', ',', 'paths', '=', '[', ']', ')', 'Dir', '.', 'mktmpdir', '(', '"rim"', ')', 'do', '|', 'd', '|', 'd', '=', 'Dir', '.', 'glob', '(', 'd', ')', '[', '0', ']', 'c', '=', 'File', '.', 'join', '(', 'd', ',', '"content"', ')', 'FileUtils', '.', 'mkdir', '(', 'c', ')', 'export_rev', '(', 'rev', ',', 'c', ',', 'paths', ')', 'yield', 'c', 'FileUtils', '.', 'rm_rf', '(', 'c', ')', 'retries', '=', '600', 'while', 'File', '.', 'exist?', '(', 'c', ')', '&&', 'retries', '>', '0', 'sleep', '(', '0.1', ')', 'FileUtils', '.', 'rm_rf', '(', 'c', ')', 'retries', '-=', '1', 'end', 'if', 'File', '.', 'exist?', '(', 'c', ')', '@logger', '.', 'warn', '"could not delete temp dir: #{c}"', 'end', 'end', 'end']
->Original Target:
['checks', 'out', 'rev', 'to', 'a', 'temporary', 'directory', 'and', 'yields', 'this', 'directory', 'to', 'the', 'given', 'block', 'if', '+', 'paths', '+', 'is', 'given', 'and', 'non', '-', 'empty', 'checks', 'out', 'only', 'those', 'parts', 'of', 'the', 'filesystem', 'tree', 'returns', 'the', 'value', 'returned', 'by', 'the', 'block']
->Reconstructed Target:
checks out rev to a temporary directory and yields this directory to the given block if + paths + is given and non - empty checks out only those parts of the filesystem tree returns the value returned by the block
->Reconstructed Predication:
the content of thethe content of thethe content of thethe content of the revision
->Raw Input:
summarize:def within_exported_rev ( rev, paths = [ ] ) Dir. mktmpdir ( "rim" ) do | d | d = Dir. glob ( d ) [ 0 ] c = File. join ( d, "content" ) FileUtils. mkdir ( c ) export_rev ( rev, c, paths ) yield c FileUtils. rm_rf ( c ) retries = 600 while File. exist? ( c ) && retries > 0 sleep ( 0.1 ) FileUtils. rm_rf ( c ) retries -= 1 end if File. exist? ( c ) @logger. warn "could not delete temp dir: #{c}" end end end
->Raw Target:
checks out rev to a temporary directory and yields this directory to the given block if + paths + is given and non - empty checks out only those parts of the filesystem tree returns the value returned by the block
--

659=========
->Original Input:
['def', 'upload', 'RIM', '::', 'git_session', '(', '@ws_root', ')', 'do', '|', 's', '|', 'branch', '=', 's', '.', 'current_branch', 'if', 'branch', '.', 'nil?', 'raise', 'RimException', '.', 'new', '(', '"Not on a git branch."', ')', 'elsif', '!', 'branch', '.', 'start_with?', '(', '"rim/"', ')', 'begin', 'sha1', '=', 's', '.', 'rev_sha1', '(', 'branch', ')', '@logger', '.', 'info', '(', '"Uploading modules..."', ')', 'upload_modules', '(', 'get_upload_revisions', '(', 's', ',', 'sha1', ')', ')', 'ensure', 's', '.', 'execute', '(', '"git checkout -B #{branch}"', ')', 'end', 'else', 'raise', 'RimException', '.', 'new', '(', '"The current git branch \'#{branch}\' is a rim integration branch. Please switch to a non rim branch to proceed."', ')', 'end', 'end', 'end']
->Original Target:
['upload', 'all', 'module', 'changes', 'into', 'corresponding', 'remote', 'repositories']
->Reconstructed Target:
upload all module changes into corresponding remote repositories
->Reconstructed Predication:
the current repository to thethe current repository to thethe current repository to thethe current repository to thethe current repository to thethe current repository to thethe current repository to thethe current repository to thethe current repository to thethe current repository to the current
->Raw Input:
summarize:def upload RIM :: git_session ( @ws_root ) do | s | branch = s. current_branch if branch. nil? raise RimException. new ( "Not on a git branch." ) elsif! branch. start_with? ( "rim/" ) begin sha1 = s. rev_sha1 ( branch ) @logger. info ( "Uploading modules..." ) upload_modules ( get_upload_revisions ( s, sha1 ) ) ensure s. execute ( "git checkout -B #{branch}" ) end else raise RimException. new ( "The current git branch '#{branch}' is a rim integration branch. Please switch to a non rim branch to proceed." ) end end end
->Raw Target:
upload all module changes into corresponding remote repositories
--

660=========
->Original Input:
['def', 'upload_modules', '(', 'info', ')', 'each_module_parallel', '(', '"uploading"', ',', '@module_helpers', ')', 'do', '|', 'm', '|', 'm', '.', 'upload', '(', 'info', '.', 'parent', ',', 'info', '.', 'sha1s', ')', 'end', 'end']
->Original Target:
['upload', 'all', 'modules']
->Reconstructed Target:
upload all modules
->Reconstructed Predication:
module_helpers. upload_modules
->Raw Input:
summarize:def upload_modules ( info ) each_module_parallel ( "uploading", @module_helpers ) do | m | m. upload ( info. parent, info. sha1s ) end end
->Raw Target:
upload all modules
--

661=========
->Original Input:
['def', 'get_upload_revisions', '(', 'session', ',', 'rev', ')', 'non_remote_revs', '=', '{', '}', 'session', '.', 'all_reachable_non_remote_revs', '(', 'rev', ')', '.', 'each', 'do', '|', 'r', '|', 'non_remote_revs', '[', 'r', ']', '=', 'true', 'end', 'revisions', '=', '[', ']', 'rev', '=', 'session', '.', 'rev_sha1', '(', 'rev', ')', 'while', 'rev', '&&', 'non_remote_revs', '[', 'rev', ']', 'revisions', '.', 'push', '(', 'rev', ')', 'parents', '=', 'session', '.', 'parent_revs', '(', 'rev', ')', 'rev', '=', 'parents', '.', 'size', '>', '0', '?', 'parents', '.', 'first', ':', 'nil', 'end', 'Struct', '.', 'new', '(', ':parent', ',', ':sha1s', ')', '.', 'new', '(', 'rev', ',', 'revisions', '.', 'reverse!', ')', 'end']
->Original Target:
['get', 'revisions', 'to', 'upload', 'i', '.', 'e', '.', 'the', 'revisions', 'up', 'to', 'the', 'last', 'remote', 'revision', 'the', 'function', 'returns', 'the', 'revisions', 'in', 'order', 'of', 'appearal', 'i', '.', 'e', '.', 'the', 'oldest', 'first']
->Reconstructed Target:
get revisions to upload i. e. the revisions up to the last remote revision the function returns the revisions in order of appearal i. e. the oldest first
->Reconstructed Predication:
the revisions of thethe revisions of the
->Raw Input:
summarize:def get_upload_revisions ( session, rev ) non_remote_revs = { } session. all_reachable_non_remote_revs ( rev ). each do | r | non_remote_revs [ r ] = true end revisions = [ ] rev = session. rev_sha1 ( rev ) while rev && non_remote_revs [ rev ] revisions. push ( rev ) parents = session. parent_revs ( rev ) rev = parents. size > 0? parents. first : nil end Struct. new ( :parent, :sha1s ). new ( rev, revisions. reverse! ) end
->Raw Target:
get revisions to upload i. e. the revisions up to the last remote revision the function returns the revisions in order of appearal i. e. the oldest first
--

662=========
->Original Input:
['def', 'fetch_module', 'FileUtils', '.', 'mkdir_p', 'git_path', 'RIM', '::', 'git_session', '(', 'git_path', ')', 'do', '|', 's', '|', 'if', '!', 'File', '.', 'exist?', '(', 'git_path', '+', '"/config"', ')', 's', '.', 'execute', '(', '"git clone --mirror #{@remote_url} #{git_path}"', ')', 'do', '|', 'out', ',', 'e', '|', 'raise', 'RimException', '.', 'new', '(', '"Remote repository \'#{@remote_url}\' of module \'#{@module_info.local_path}\' not found."', ')', 'if', 'e', 'end', 'else', 's', '.', 'execute', '(', '"git remote update"', ')', 'end', 'end', 'git_path', 'end']
->Original Target:
['fetch', 'module', '+', 'mod', '+', 'into', 'the', '.', 'rim', 'folder', 'works', 'both', 'for', 'initial', 'fetch', 'and', 'updates']
->Reconstructed Target:
fetch module + mod + into the. rim folder works both for initial fetch and updates
->Reconstructed Predication:
the module to be fetched.the module to be fetched.the module to be fetched.the module to be fetched.
->Raw Input:
summarize:def fetch_module FileUtils. mkdir_p git_path RIM :: git_session ( git_path ) do | s | if! File. exist? ( git_path + "/config" ) s. execute ( "git clone --mirror #{@remote_url} #{git_path}" ) do | out, e | raise RimException. new ( "Remote repository '#{@remote_url}' of module '#{@module_info.local_path}' not found." ) if e end else s. execute ( "git remote update" ) end end git_path end
->Raw Target:
fetch module + mod + into the. rim folder works both for initial fetch and updates
--

663=========
->Original Input:
['def', 'assign', '(', 'attribute', ',', 'value', ')', 'unless', 'value', '==', ':skip', '||', 'attribute', '==', ':class', 'if', 'item', '.', 'respond_to?', '(', '"#{attribute}="', ')', 'item', '.', 'send', '(', '"#{attribute}="', ',', 'value', ')', 'elsif', 'item', '.', 'is_a?', '(', 'Hash', ')', 'item', '[', 'attribute', ']', '=', 'value', 'end', 'end', 'end']
->Original Target:
['Assign', 'the', 'value', 'to', 'the', 'given', 'attribute', 'of', 'the', 'item']
->Reconstructed Target:
Assign the value to the given attribute of the item
->Reconstructed Predication:
attribute to the item to be assigned
->Raw Input:
summarize:def assign ( attribute, value ) unless value == :skip || attribute == :class if item. respond_to? ( "#{attribute}=" ) item. send ( "#{attribute}=", value ) elsif item. is_a? ( Hash ) item [ attribute ] = value end end end
->Raw Target:
Assign the value to the given attribute of the item
--

664=========
->Original Input:
['def', 'debug', '(', '*', 'args', ')', 'item', '=', 'build', '(', '*', 'args', ')', 'invalid_item', '=', 'Array', '(', 'item', ')', '.', 'find', '(', '&', ':invalid?', ')', 'if', 'invalid_item', 'if', 'invalid_item', '.', 'errors', '.', 'respond_to?', '(', ':messages', ')', 'errors', '=', 'invalid_item', '.', 'errors', '.', 'messages', 'else', 'errors', '=', 'invalid_item', '.', 'errors', 'end', 'raise', '"Oops, the #{invalid_item.class} created by the Factory has the following errors: #{errors}"', 'end', 'item', 'end']
->Original Target:
['Can', 'be', 'left', 'in', 'your', 'tests', 'as', 'an', 'alternative', 'to', 'build', 'and', 'to', 'warn', 'if', 'your', 'factory', 'method', 'ever', 'starts', 'producing', 'invalid', 'instances']
->Reconstructed Target:
Can be left in your tests as an alternative to build and to warn if your factory method ever starts producing invalid instances
->Reconstructed Predication:
the item to be created by
->Raw Input:
summarize:def debug ( * args ) item = build ( * args ) invalid_item = Array ( item ). find ( & :invalid? ) if invalid_item if invalid_item. errors. respond_to? ( :messages ) errors = invalid_item. errors. messages else errors = invalid_item. errors end raise "Oops, the #{invalid_item.class} created by the Factory has the following errors: #{errors}" end item end
->Raw Target:
Can be left in your tests as an alternative to build and to warn if your factory method ever starts producing invalid instances
--

665=========
->Original Input:
['def', 'crank_it', '(', 'what', ',', 'overrides', ')', 'if', 'what', '.', 'to_s', '=~', '/', '/', 'what', '=', '$1', 'overrides', '=', 'overrides', '.', 'merge', '(', ':_return_attributes', '=>', 'true', ')', 'end', 'item', '=', '"TBD"', 'new_job', '(', 'what', ',', 'overrides', ')', 'do', 'item', '=', 'self', '.', 'send', '(', 'what', ')', 'item', '=', 'apply_traits', '(', 'what', ',', 'item', ')', 'end', 'item', 'end']
->Original Target:
['Execute', 'the', 'requested', 'factory', 'method', 'crank', 'out', 'the', 'target', 'object!']
->Reconstructed Target:
Execute the requested factory method crank out the target object!
->Reconstructed Predication:
the job to be run
->Raw Input:
summarize:def crank_it ( what, overrides ) if what. to_s =~ / / what = $1 overrides = overrides. merge ( :_return_attributes => true ) end item = "TBD" new_job ( what, overrides ) do item = self. send ( what ) item = apply_traits ( what, item ) end item end
->Raw Target:
Execute the requested factory method crank out the target object!
--

666=========
->Original Input:
['def', 'method_missing', '(', 'method', ',', '*', 'args', ',', '&', 'block', ')', 'if', 'view_context', '.', 'respond_to?', '(', 'method', ',', 'true', ')', 'view_context', '.', 'send', '(', 'method', ',', '*', 'args', ',', '&', 'block', ')', 'else', 'super', 'end', 'end']
->Original Target:
['Send', 'missing', 'methods', 'to', 'view_context', 'first']
->Reconstructed Target:
Send missing methods to view_context first
->Reconstructed Predication:
the view context to the view
->Raw Input:
summarize:def method_missing ( method, * args, & block ) if view_context. respond_to? ( method, true ) view_context. send ( method, * args, & block ) else super end end
->Raw Target:
Send missing methods to view_context first
--

667=========
->Original Input:
['def', 'present', '(', 'object', ',', 'presenter', ':', 'nil', ',', '**', 'args', ')', 'if', 'object', '.', 'respond_to?', '(', ':to_ary', ')', 'object', '.', 'map', '{', '|', 'item', '|', 'present', '(', 'item', ',', 'presenter', ':', 'presenter', ',', '**', 'args', ')', '}', 'else', 'presenter', '||=', 'presenter_klass', '(', 'object', ')', 'wrapper', '=', 'presenter', '.', 'new', '(', 'object', ',', 'view_context', ',', '**', 'args', ')', 'block_given?', '?', 'yield', '(', 'wrapper', ')', ':', 'wrapper', 'end', 'end']
->Original Target:
['Wrap', 'an', 'object', 'or', 'collection', 'of', 'objects', 'with', 'a', 'presenter', 'class', '.']
->Reconstructed Target:
Wrap an object or collection of objects with a presenter class.
->Reconstructed Predication:
the object to be displayed
->Raw Input:
summarize:def present ( object, presenter : nil, ** args ) if object. respond_to? ( :to_ary ) object. map { | item | present ( item, presenter : presenter, ** args ) } else presenter ||= presenter_klass ( object ) wrapper = presenter. new ( object, view_context, ** args ) block_given?? yield ( wrapper ) : wrapper end end
->Raw Target:
Wrap an object or collection of objects with a presenter class.
--

668=========
->Original Input:
['def', 'push', '(', 'gem', ',', 'method', ',', 'options', '=', '{', '}', ')', 'push_command', '=', 'PUSH_METHODS', '[', 'method', '.', 'to_s', ']', 'or', 'raise', '"Unknown Gem push method #{method.inspect}."', 'push_command', '+=', '[', 'gem', ']', 'push_command', '+=', '[', '"--as"', ',', 'options', '[', ':as', ']', ']', 'if', 'options', '[', ':as', ']', '@cli_facade', '.', 'execute', '(', '*', 'push_command', ')', 'end']
->Original Target:
['Publish', 'the', 'gem', '.']
->Reconstructed Target:
Publish the gem.
->Reconstructed Predication:
push a gem to apush a gem to a gem
->Raw Input:
summarize:def push ( gem, method, options = { } ) push_command = PUSH_METHODS [ method. to_s ] or raise "Unknown Gem push method #{method.inspect}." push_command += [ gem ] push_command += [ "--as", options [ :as ] ] if options [ :as ] @cli_facade. execute ( * push_command ) end
->Raw Target:
Publish the gem.
--

669=========
->Original Input:
['def', 'interpolate', 'interpolant', 'case', '@opts', '[', ':type', ']', 'when', ':linear', 'for_each', '(', 'interpolant', ')', '{', '|', 'x', '|', 'linear_interpolation', '(', 'x', ')', '}', 'when', ':cubic', 'cubic_spline_interpolation', 'interpolant', 'else', 'raise', 'ArgumentError', ',', '"1 D interpolation of type #{@opts[:type]} not supported"', 'end', 'end']
->Original Target:
['Constructor', 'for', 'all', 'One', 'Dimensional', 'interpolation', 'operations', '.']
->Reconstructed Target:
Constructor for all One Dimensional interpolation operations.
->Reconstructed Predication:
interpolation of a linear spline
->Raw Input:
summarize:def interpolate interpolant case @opts [ :type ] when :linear for_each ( interpolant ) { | x | linear_interpolation ( x ) } when :cubic cubic_spline_interpolation interpolant else raise ArgumentError, "1 D interpolation of type #{@opts[:type]} not supported" end end
->Raw Target:
Constructor for all One Dimensional interpolation operations.
--

670=========
->Original Input:
['def', 'lines_selector_for', '(', 'target', ',', 'attributes', ')', 'if', '(', 'klass', '=', '@selectors', '.', 'find', '{', '|', 's', '|', 's', '.', 'handles?', 'target', ',', 'attributes', '}', ')', 'klass', '.', 'new', '(', 'target', ',', 'attributes', ',', 'logger', ':', 'logger', ')', 'end', 'end']
->Original Target:
['Finds', 'and', 'initializes', 'a', 'lines', 'selector', 'that', 'can', 'handle', 'the', 'specified', 'include', '.']
->Reconstructed Target:
Finds and initializes a lines selector that can handle the specified include.
->Reconstructed Predication:
the lines selector for the given
->Raw Input:
summarize:def lines_selector_for ( target, attributes ) if ( klass = @selectors. find { | s | s. handles? target, attributes } ) klass. new ( target, attributes, logger : logger ) end end
->Raw Target:
Finds and initializes a lines selector that can handle the specified include.
--

671=========
->Original Input:
['def', 'run', 'client_ip', '=', '@ip', 'key', '=', '"request_count:#{client_ip}"', 'result', '=', '{', 'status', ':', 'Constants', '::', 'SUCCESS_STATUS', ',', 'message', ':', 'Constants', '::', 'OK_MESSAGE', '}', 'requests_count', '=', '@storage', '.', 'get', '(', 'key', ')', 'unless', 'requests_count', '@storage', '.', 'set', '(', 'key', ',', '0', ')', '@storage', '.', 'expire', '(', 'key', ',', '@limits', '[', '"time_period_seconds"', ']', ')', 'end', 'if', 'requests_count', '.', 'to_i', '>=', '@limits', '[', '"max_requests_count"', ']', 'result', '[', ':status', ']', '=', 'Constants', '::', 'EXPIRED_STATUS', 'result', '[', ':message', ']', '=', 'message', '(', 'period', '(', 'key', ')', ')', 'else', '@storage', '.', 'incr', '(', 'key', ')', 'end', 'result', 'end']
->Original Target:
['Create', 'a', 'Core', 'object', '.']
->Reconstructed Target:
Create a Core object.
->Reconstructed Predication:
:status : success message :
->Raw Input:
summarize:def run client_ip = @ip key = "request_count:#{client_ip}" result = { status : Constants :: SUCCESS_STATUS, message : Constants :: OK_MESSAGE } requests_count = @storage. get ( key ) unless requests_count @storage. set ( key, 0 ) @storage. expire ( key, @limits [ "time_period_seconds" ] ) end if requests_count. to_i >= @limits [ "max_requests_count" ] result [ :status ] = Constants :: EXPIRED_STATUS result [ :message ] = message ( period ( key ) ) else @storage. incr ( key ) end result end
->Raw Target:
Create a Core object.
--

672=========
->Original Input:
['def', 'date_select', '(', 'method', ',', 'options', '=', '{', '}', ')', 'options', '[', ':include_blank', ']', '||=', 'false', 'options', '[', ':start_year', ']', '||=', '1801', 'options', '[', ':end_year', ']', '||=', 'Time', '.', 'now', '.', 'year', 'options', '[', ':label_for', ']', '=', '"#{object_name}_#{method}_1i"', 'build_shell', '(', 'method', ',', 'options', ')', '{', 'super', '}', 'end']
->Original Target:
['Standard', 'Rails', 'date', 'selector', '.']
->Reconstructed Target:
Standard Rails date selector.
->Reconstructed Predication:
the date selectthe date select
->Raw Input:
summarize:def date_select ( method, options = { } ) options [ :include_blank ] ||= false options [ :start_year ] ||= 1801 options [ :end_year ] ||= Time. now. year options [ :label_for ] = "#{object_name}_#{method}_1i" build_shell ( method, options ) { super } end
->Raw Target:
Standard Rails date selector.
--

673=========
->Original Input:
['def', 'label', '(', 'method', ',', 'text', '=', 'nil', ',', 'options', '=', '{', '}', ')', 'colon', '=', 'false', 'if', 'options', '[', ':colon', ']', '.', 'nil?', 'options', '[', ':for', ']', '=', 'options', '[', ':label_for', ']', 'required', '=', 'options', '[', ':required', ']', 'options', '.', 'delete', ':colon', 'options', '.', 'delete', ':label_for', 'options', '.', 'delete', ':required', 'text', '=', '@template', '.', 'send', '(', ':h', ',', 'text', '.', 'blank?', '?', 'method', '.', 'to_s', '.', 'humanize', ':', 'text', '.', 'to_s', ')', 'text', '<<', "':'", '.', 'html_safe', 'if', 'colon', 'text', '<<', '@template', '.', 'content_tag', '(', ':span', ',', '"*"', ',', ':class', '=>', '"required"', ')', 'if', 'required', 'super', 'end']
->Original Target:
['Render', 'a', 'field', 'label', '.']
->Reconstructed Target:
Render a field label.
->Reconstructed Predication:
:colon ]. nil? colonoptions [ :colon ]options [ :for ]. html_safe end. html_safe end
->Raw Input:
summarize:def label ( method, text = nil, options = { } ) colon = false if options [ :colon ]. nil? options [ :for ] = options [ :label_for ] required = options [ :required ] options. delete :colon options. delete :label_for options. delete :required text = @template. send ( :h, text. blank?? method. to_s. humanize : text. to_s ) text << ':'. html_safe if colon text << @template. content_tag ( :span, "*", :class => "required" ) if required super end
->Raw Target:
Render a field label.
--

674=========
->Original Input:
['def', 'read', '(', 'raw', ',', 'predecessors', '=', 'nil', ')', 'if', 'raw', '.', 'respond_to?', '(', ':read', ')', 'raw', '=', 'raw', '.', 'read', '(', 'self', '.', 'sizeof', '(', ')', ')', 'end', 'if', 'raw', '.', 'size', '<', 'self', '.', 'sizeof', '(', ')', 'raise', '(', 'ReadError', ',', '"Expected #{self.sizeof} bytes, but only got #{raw.size} bytes"', ')', 'end', 'vals', '=', 'if', '@unpack_cb', '@unpack_cb', '.', 'call', '(', 'raw', ',', 'predecessors', ')', 'else', 'raw', '.', 'unpack', '(', 'self', '.', 'format', ')', 'end', 'return', '(', 'self', '.', 'claim_value', '(', 'vals', ',', 'predecessors', ')', ')', 'end']
->Original Target:
['Called', 'when', 'parsing', '.', 'While', 'you', 'can', 'override', 'this', 'in', 'subclasses', 'in', 'general', 'it', 'is', 'probably', 'better', 'to', 'use', 'the', 'on_unpack', 'method', 'to', 'define', 'a', 'proc', 'to', 'handle', 'unpacking', 'for', 'special', 'cases', '.']
->Reconstructed Target:
Called when parsing. While you can override this in subclasses in general it is probably better to use the on_unpack method to define a proc to handle unpacking for special cases.
->Reconstructed Predication:
the raw datathe raw data to return.
->Raw Input:
summarize:def read ( raw, predecessors = nil ) if raw. respond_to? ( :read ) raw = raw. read ( self. sizeof ( ) ) end if raw. size < self. sizeof ( ) raise ( ReadError, "Expected #{self.sizeof} bytes, but only got #{raw.size} bytes" ) end vals = if @unpack_cb @unpack_cb. call ( raw, predecessors ) else raw. unpack ( self. format ) end return ( self. claim_value ( vals, predecessors ) ) end
->Raw Target:
Called when parsing. While you can override this in subclasses in general it is probably better to use the on_unpack method to define a proc to handle unpacking for special cases.
--

675=========
->Original Input:
['def', 'pack_value', '(', 'val', ',', 'obj', '=', 'nil', ')', 'begin', 'if', '@pack_cb', '@pack_cb', '.', 'call', '(', 'val', ',', 'obj', ')', 'else', 'varray', '=', 'val', '.', 'is_a?', '(', 'Array', ')', '?', 'val', ':', '[', 'val', ']', 'varray', '.', 'pack', '(', 'self', '.', 'format', ')', 'end', 'rescue', '=>', 'e', 'raise', '(', 'PackError', ',', '"Error packing #{val.inspect} as type #{self.name.inspect} -- #{e.class} -> #{e}"', ')', 'end', 'end']
->Original Target:
['Called', 'when', 'composing', 'raw', 'data', '.', 'While', 'you', 'can', 'override', 'this', 'in', 'subclasses', 'in', 'general', 'it', 'is', 'probably', 'better', 'to', 'use', 'the', 'on_pack', 'method', 'to', 'define', 'a', 'proc', 'to', 'handle', 'packing', 'for', 'special', 'cases', '.']
->Reconstructed Target:
Called when composing raw data. While you can override this in subclasses in general it is probably better to use the on_pack method to define a proc to handle packing for special cases.
->Reconstructed Predication:
the value to be packed into
->Raw Input:
summarize:def pack_value ( val, obj = nil ) begin if @pack_cb @pack_cb. call ( val, obj ) else varray = val. is_a? ( Array )? val : [ val ] varray. pack ( self. format ) end rescue => e raise ( PackError, "Error packing #{val.inspect} as type #{self.name.inspect} -- #{e.class} -> #{e}" ) end end
->Raw Target:
Called when composing raw data. While you can override this in subclasses in general it is probably better to use the on_pack method to define a proc to handle packing for special cases.
--

676=========
->Original Input:
['def', 'method_missing', '(', 'sym', ',', '*', 'args', ',', '&', 'block', ')', 'return', 'Lebowski', '::', 'RSpec', '::', 'Matchers', '::', 'Be', '.', 'new', '(', 'sym', ',', '*', 'args', ')', 'if', 'sym', '.', 'to_s', '=~', '/', '/', 'return', 'Lebowski', '::', 'RSpec', '::', 'Matchers', '::', 'Has', '.', 'new', '(', 'sym', ',', '*', 'args', ')', 'if', 'sym', '.', 'to_s', '=~', '/', '/', 'return', 'Lebowski', '::', 'RSpec', '::', 'Operators', '::', 'That', '.', 'new', '(', 'sym', ',', '*', 'args', ')', 'if', 'sym', '.', 'to_s', '=~', '/', '/', 'super', 'end']
->Original Target:
['Replacing', 'RSpec', 's', 'default', 'method_missing', 'implementation', 'so', 'that', 'we', 'can', 'include', 'our', 'own', 'special', 'default', 'hooks', 'that', 'allows', 'spec', 'tests', 'to', 'look', 'more', 'readable', '.']
->Reconstructed Target:
Replacing RSpec s default method_missing implementation so that we can include our own special default hooks that allows spec tests to look more readable.
->Reconstructed Predication:
the method to be called
->Raw Input:
summarize:def method_missing ( sym, * args, & block ) return Lebowski :: RSpec :: Matchers :: Be. new ( sym, * args ) if sym. to_s =~ / / return Lebowski :: RSpec :: Matchers :: Has. new ( sym, * args ) if sym. to_s =~ / / return Lebowski :: RSpec :: Operators :: That. new ( sym, * args ) if sym. to_s =~ / / super end
->Raw Target:
Replacing RSpec s default method_missing implementation so that we can include our own special default hooks that allows spec tests to look more readable.
--

677=========
->Original Input:
['def', 'static_files', 'source', '=', 'File', '.', 'dirname', '(', 'ENGINE', '.', 'assets_path', ')', 'asset_files', '.', 'map', 'do', '|', 'file', '|', 'dir', '=', 'File', '.', 'dirname', '(', 'file', ')', 'file_name', '=', 'File', '.', 'basename', '(', 'file', ')', 'Jekyll', '::', 'StaticFile', '.', 'new', '@site', ',', 'source', ',', 'dir', ',', 'file_name', 'end', 'end']
->Original Target:
['This', 'method', 'searches', 'for', 'folders', 'and', 'files', 'in', 'the', 'assets', 'root', 'directory', '.', 'After', 'searching', 'all', 'files', 'stores', 'in', 'an', 'array', 'and', 'then', 'copying', 'to', 'the', 'folder', '_site', '.']
->Reconstructed Target:
This method searches for folders and files in the assets root directory. After searching all files stores in an array and then copying to the folder _site.
->Reconstructed Predication:
the files to be processed
->Raw Input:
summarize:def static_files source = File. dirname ( ENGINE. assets_path ) asset_files. map do | file | dir = File. dirname ( file ) file_name = File. basename ( file ) Jekyll :: StaticFile. new @site, source, dir, file_name end end
->Raw Target:
This method searches for folders and files in the assets root directory. After searching all files stores in an array and then copying to the folder _site.
--

678=========
->Original Input:
['def', 'asset_files', 'asset_files', '=', '[', ']', 'Find', '.', 'find', '(', 'ENGINE', '.', 'assets_path', ')', '.', 'each', 'do', '|', 'path', '|', 'next', 'if', 'File', '.', 'directory?', '(', 'path', ')', 'next', 'if', 'path', '.', 'include?', '(', 'ENGINE', '.', 'stylesheets_sass_path', ')', 'asset_files', '<<', 'path', '.', 'sub', '(', 'ENGINE', '.', 'assets_path', ',', "'assets'", ')', 'end', 'asset_files', 'end']
->Original Target:
['Get', 'paths', 'and', 'fils', 'directory', 'assets']
->Reconstructed Target:
Get paths and fils directory assets
->Reconstructed Predication:
the asset files to be
->Raw Input:
summarize:def asset_files asset_files = [ ] Find. find ( ENGINE. assets_path ). each do | path | next if File. directory? ( path ) next if path. include? ( ENGINE. stylesheets_sass_path ) asset_files << path. sub ( ENGINE. assets_path, 'assets' ) end asset_files end
->Raw Target:
Get paths and fils directory assets
--

679=========
->Original Input:
['def', 'daily', '(', 'time', '=', 'Date', '.', 'today', ',', 'page_size', '=', '50', ')', 'time', '=', 'time', '.', 'strftime', '(', '"%Y-%m-%d"', ')', 'unless', 'time', '.', 'is_a?', '(', 'String', ')', 'report_id', '=', 'run_report_request', '(', "'DailyActivityReport'", ',', '{', "'report_date'", '=>', 'time', '}', ',', 'page_size', ')', 'meta_data', '=', 'get_meta_data_request', '(', 'report_id', ')', 'data', '=', '[', ']', 'meta_data', '[', '"numberOfPages"', ']', '.', 'to_i', '.', 'times', 'do', '|', 'page_num', '|', 'data', '+=', 'get_data_request', '(', 'report_id', ',', 'page_num', '+', '1', ')', 'end', 'data', 'end']
->Original Target:
['high', 'level', 'functions']
->Reconstructed Target:
high level functions
->Reconstructed Predication:
the daily activity report.the daily activity reportthe daily activity reportthe daily activity reportthe daily activity reportthe daily activity report
->Raw Input:
summarize:def daily ( time = Date. today, page_size = 50 ) time = time. strftime ( "%Y-%m-%d" ) unless time. is_a? ( String ) report_id = run_report_request ( 'DailyActivityReport', {'report_date' => time }, page_size ) meta_data = get_meta_data_request ( report_id ) data = [ ] meta_data [ "numberOfPages" ]. to_i. times do | page_num | data += get_data_request ( report_id, page_num + 1 ) end data end
->Raw Target:
high level functions
--

680=========
->Original Input:
['def', 'run_report_request', '(', 'report_name', ',', 'report_params', '=', '{', '}', ',', 'page_size', '=', '50', ')', 'response', '=', 'request', "'runReportRequest'", 'do', '|', 'xml', '|', 'xml', '.', 'reportName', 'report_name', 'report_params', '.', 'each', 'do', '|', 'name', ',', 'value', '|', 'xml', '.', 'reportParam', 'do', 'xml', '.', 'paramName', 'name', 'xml', '.', 'paramValue', 'value', 'end', 'end', 'xml', '.', 'pageSize', 'page_size', 'end', 'response', '.', 'elements', '[', '"runReportResponse/reportId"', ']', '.', 'get_text', '.', 'value', 'end']
->Original Target:
['low', 'level', 'functions']
->Reconstructed Target:
low level functions
->Reconstructed Predication:
the report to runthe report to run the reportthe report to run the reportthe report to run the reportthe report to run the reportthe report to run the reportthe report to runthe report to runthe report to runthe report to run
->Raw Input:
summarize:def run_report_request ( report_name, report_params = { }, page_size = 50 ) response = request 'runReportRequest' do | xml | xml. reportName report_name report_params. each do | name, value | xml. reportParam do xml. paramName name xml. paramValue value end end xml. pageSize page_size end response. elements [ "runReportResponse/reportId" ]. get_text. value end
->Raw Target:
low level functions
--

681=========
->Original Input:
['def', 'generate_unique', '(', 'length', '=', '32', ',', '&', 'blk', ')', 'unique', '=', 'generate_random', '(', 'length', ')', 'unique', '=', 'generate_random', '(', 'length', ')', 'until', 'blk', '.', 'call', '(', 'unique', ')', 'unique', 'end']
->Original Target:
['Generate', 'a', 'unique', 'field']
->Reconstructed Target:
Generate a unique field
->Reconstructed Predication:
the unique string. 
->Raw Input:
summarize:def generate_unique ( length = 32, & blk ) unique = generate_random ( length ) unique = generate_random ( length ) until blk. call ( unique ) unique end
->Raw Target:
Generate a unique field
--

682=========
->Original Input:
['def', 'draw_paperback', '(', 'qr_code', ':', ',', 'sixword_lines', ':', ',', 'sixword_bytes', ':', ',', 'labels', ':', ',', 'passphrase_sha', ':', 'nil', ',', 'passphrase_len', ':', 'nil', ',', 'sixword_font_size', ':', 'nil', ',', 'base64_content', ':', 'nil', ',', 'base64_bytes', ':', 'nil', ')', 'unless', 'qr_code', '.', 'is_a?', '(', 'RQRCode', '::', 'QRCode', ')', 'raise', 'ArgumentError', '.', 'new', '(', "'qr_code must be RQRCode::QRCode'", ')', 'end', 'pdf', '.', 'font', '(', "'Times-Roman'", ')', 'debug_draw_axes', 'draw_header', '(', 'labels', ':', 'labels', ',', 'passphrase_sha', ':', 'passphrase_sha', ',', 'passphrase_len', ':', 'passphrase_len', ')', 'add_newline', 'draw_qr_code', '(', 'qr_modules', ':', 'qr_code', '.', 'modules', ')', 'pdf', '.', 'stroke_color', "'000000'", 'pdf', '.', 'fill_color', "'000000'", 'pdf', '.', 'start_new_page', 'draw_sixword', '(', 'lines', ':', 'sixword_lines', ',', 'sixword_bytes', ':', 'sixword_bytes', ',', 'font_size', ':', 'sixword_font_size', ',', 'is_encrypted', ':', 'passphrase_len', ')', 'if', 'base64_content', 'draw_base64', '(', 'b64_content', ':', 'base64_content', ',', 'b64_bytes', ':', 'base64_bytes', ',', 'is_encrypted', ':', 'passphrase_len', ')', 'end', 'pdf', '.', 'number_pages', '(', "'<page> of <total>'", ',', 'align', ':', ':right', ',', 'at', ':', '[', 'pdf', '.', 'bounds', '.', 'right', '-', '100', ',', '-', '2', ']', ')', 'end']
->Original Target:
['High', 'level', 'method', 'to', 'draw', 'the', 'paperback', 'content', 'on', 'the', 'pdf', 'document']
->Reconstructed Target:
High level method to draw the paperback content on the pdf document
->Reconstructed Predication:
:: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,: passphrase_len,
->Raw Input:
summarize:def draw_paperback ( qr_code :, sixword_lines :, sixword_bytes :, labels :, passphrase_sha : nil, passphrase_len : nil, sixword_font_size : nil, base64_content : nil, base64_bytes : nil ) unless qr_code. is_a? ( RQRCode :: QRCode ) raise ArgumentError. new ( 'qr_code must be RQRCode::QRCode' ) end pdf. font ( 'Times-Roman' ) debug_draw_axes draw_header ( labels : labels, passphrase_sha : passphrase_sha, passphrase_len : passphrase_len ) add_newline draw_qr_code ( qr_modules : qr_code. modules ) pdf. stroke_color '000000' pdf. fill_color '000000' pdf. start_new_page draw_sixword ( lines : sixword_lines, sixword_bytes : sixword_bytes, font_size : sixword_font_size, is_encrypted : passphrase_len ) if base64_content draw_base64 ( b64_content : base64_content, b64_bytes : base64_bytes, is_encrypted : passphrase_len ) end pdf. number_pages ( '<page> of <total>', align : :right, at : [ pdf. bounds. right - 100, - 2 ] ) end
->Raw Target:
High level method to draw the paperback content on the pdf document
--

683=========
->Original Input:
['def', 'produce_report', '(', '*', 'args', ')', '`', '`', 'unless', 'xcov_available?', 'unless', 'xcov_available?', 'puts', '"xcov is not available on this machine"', 'return', 'end', 'require', '"xcov"', 'require', '"fastlane_core"', 'config', '=', 'FastlaneCore', '::', 'Configuration', '.', 'create', '(', 'Xcov', '::', 'Options', '.', 'available_options', ',', 'convert_options', '(', 'args', '.', 'first', ')', ')', 'Xcov', '.', 'config', '=', 'config', 'Xcov', '.', 'ignore_handler', '=', 'Xcov', '::', 'IgnoreHandler', '.', 'new', 'manager', '=', 'Xcov', '::', 'Manager', '.', 'new', '(', 'config', ')', 'report_json', '=', 'manager', '.', 'parse_xccoverage', 'process_report', '(', 'Xcov', '::', 'Report', '.', 'map', '(', 'report_json', ')', ')', 'end']
->Original Target:
['Produces', 'and', 'processes', 'a', 'report', 'for', 'use', 'in', 'the', 'report', 'method', 'It', 'takes', 'the', 'same', 'arguments', 'as', 'report', 'and', 'returns', 'the', 'same', 'object', 'as', 'process_report']
->Reconstructed Target:
Produces and processes a report for use in the report method It takes the same arguments as report and returns the same object as process_report
->Reconstructed Predication:
the report to produce.. map () ) end end  def
->Raw Input:
summarize:def produce_report ( * args ) ` ` unless xcov_available? unless xcov_available? puts "xcov is not available on this machine" return end require "xcov" require "fastlane_core" config = FastlaneCore :: Configuration. create ( Xcov :: Options. available_options, convert_options ( args. first ) ) Xcov. config = config Xcov. ignore_handler = Xcov :: IgnoreHandler. new manager = Xcov :: Manager. new ( config ) report_json = manager. parse_xccoverage process_report ( Xcov :: Report. map ( report_json ) ) end
->Raw Target:
Produces and processes a report for use in the report method It takes the same arguments as report and returns the same object as process_report
--

684=========
->Original Input:
['def', 'output_report', '(', 'report', ')', 'report_markdown', '=', 'report', '.', 'markdown_value', 'markdown', '(', 'report_markdown', ')', 'threshold', '=', 'Xcov', '.', 'config', '[', ':minimum_coverage_percentage', ']', '.', 'to_i', 'if', '!', 'threshold', '.', 'nil?', '&&', '(', 'report', '.', 'coverage', '*', '100', ')', '<', 'threshold', 'fail', '(', '"Code coverage under minimum of #{threshold}%"', ')', 'end', 'end']
->Original Target:
['Outputs', 'a', 'processed', 'report', 'with', 'Danger']
->Reconstructed Target:
Outputs a processed report with Danger
->Reconstructed Predication:
the report report. 
->Raw Input:
summarize:def output_report ( report ) report_markdown = report. markdown_value markdown ( report_markdown ) threshold = Xcov. config [ :minimum_coverage_percentage ]. to_i if! threshold. nil? && ( report. coverage * 100 ) < threshold fail ( "Code coverage under minimum of #{threshold}%" ) end end
->Raw Target:
Outputs a processed report with Danger
--

685=========
->Original Input:
['def', 'process_report', '(', 'report', ')', 'file_names', '=', '@dangerfile', '.', 'git', '.', 'modified_files', '.', 'map', '{', '|', 'file', '|', 'File', '.', 'basename', '(', 'file', ')', '}', 'file_names', '+=', '@dangerfile', '.', 'git', '.', 'added_files', '.', 'map', '{', '|', 'file', '|', 'File', '.', 'basename', '(', 'file', ')', '}', 'report', '.', 'targets', '.', 'each', 'do', '|', 'target', '|', 'target', '.', 'files', '=', 'target', '.', 'files', '.', 'select', '{', '|', 'file', '|', 'file_names', '.', 'include?', '(', 'file', '.', 'name', ')', '}', 'end', 'report', 'end']
->Original Target:
['Filters', 'the', 'files', 'that', 'haven', 't', 'been', 'modified', 'in', 'the', 'current', 'PR']
->Reconstructed Target:
Filters the files that haven t been modified in the current PR
->Reconstructed Predication:
the files to be processedthe files to be processed
->Raw Input:
summarize:def process_report ( report ) file_names = @dangerfile. git. modified_files. map { | file | File. basename ( file ) } file_names += @dangerfile. git. added_files. map { | file | File. basename ( file ) } report. targets. each do | target | target. files = target. files. select { | file | file_names. include? ( file. name ) } end report end
->Raw Target:
Filters the files that haven t been modified in the current PR
--

686=========
->Original Input:
['def', 'update', '(', 'data', ')', 'data', '.', 'each_byte', 'do', '|', 'b', '|', 'b', '=', 'revert_byte', '(', 'b', ')', 'if', 'REVERSE_DATA', '@crc', '=', '(', '(', '@table', '[', '(', '(', '@crc', '>>', '8', ')', '^', 'b', ')', '&', '0xff', ']', '^', '(', '@crc', '<<', '8', ')', ')', '&', '0xffff', ')', 'end', 'return', 'self', 'end']
->Original Target:
['Updates', 'the', 'CRC16', 'checksum', '.']
->Reconstructed Target:
Updates the CRC16 checksum.
->Reconstructed Predication:
the data to be updated.
->Raw Input:
summarize:def update ( data ) data. each_byte do | b | b = revert_byte ( b ) if REVERSE_DATA @crc = ( ( @table [ ( ( @crc >> 8 ) ^ b ) & 0xff ] ^ ( @crc << 8 ) ) & 0xffff ) end return self end
->Raw Target:
Updates the CRC16 checksum.
--

687=========
->Original Input:
['def', 'request', '(', 'http_verb', ',', 'url', ',', 'options', '=', '{', '}', ')', 'full_url', '=', 'url', '+', 'hash_to_params', '(', 'options', ')', 'handle', '(', 'access_token', '.', 'request', '(', 'http_verb', ',', 'full_url', ')', ')', 'end']
->Original Target:
['class', '<<', 'self']
->Reconstructed Target:
class << self
->Reconstructed Predication:
the request to the specified url
->Raw Input:
summarize:def request ( http_verb, url, options = { } ) full_url = url + hash_to_params ( options ) handle ( access_token. request ( http_verb, full_url ) ) end
->Raw Target:
class << self
--

688=========
->Original Input:
['def', 'string', '(', 'opts', '=', '{', '}', ')', 'length', ',', 'any', ',', 'value', '=', '(', 'opts', '[', ':length', ']', '||', '8', ')', ',', 'opts', '[', ':any', ']', ',', 'opts', '[', ':value', ']', 'if', 'value', 'string', '=', 'value', '.', 'to_s', 'Proc', '.', 'new', '{', 'string', '}', 'elsif', 'any', 'Proc', '.', 'new', '{', 'self', '.', 'any', '(', 'any', ')', '}', 'else', 'Proc', '.', 'new', '{', 'Array', '.', 'new', '(', 'length', ')', '{', '@chars', '[', 'rand', '(', '@chars', '.', 'size', '-', '1', ')', ']', '}', '.', 'join', '}', 'end', 'end']
->Original Target:
['belows', 'are', 'data', 'types']
->Reconstructed Target:
belows are data types
->Reconstructed Predication:
the string to be formatted
->Raw Input:
summarize:def string ( opts = { } ) length, any, value = ( opts [ :length ] || 8 ), opts [ :any ], opts [ :value ] if value string = value. to_s Proc. new { string } elsif any Proc. new { self. any ( any ) } else Proc. new { Array. new ( length ) { @chars [ rand ( @chars. size - 1 ) ] }. join } end end
->Raw Target:
belows are data types
--

689=========
->Original Input:
['def', 'convert', 'tag', ',', 'val', 'return', 'val', 'unless', 'val', '.', 'kind_of?', '(', 'String', ')', 'case', 'tag', 'when', "'partofset'", ',', "'track'", 'return', 'val', 'end', 'case', 'val', 'when', 'REGEXP_TIMESTAMP', 'year', ',', 'month', ',', 'day', ',', 'hour', ',', 'minute', '=', '$~', '.', 'captures', '[', '0', ',', '5', ']', '.', 'map', '{', '|', 'cap', '|', 'cap', '.', 'to_i', '}', 'if', 'month', '==', '0', '||', 'day', '==', '0', 'return', 'nil', 'end', 'second', '=', '$6', '.', 'to_f', 'zone', '=', '$7', 'zone', '=', "'+00:00'", 'if', 'zone', '==', "'Z'", 'Time', '.', 'new', '(', 'year', ',', 'month', ',', 'day', ',', 'hour', ',', 'minute', ',', 'second', ',', 'zone', ')', 'when', 'REGEXP_RATIONAL', 'return', 'val', 'if', '$2', '.', 'to_i', '==', '0', 'Rational', '(', '$1', ',', '$2', ')', 'else', 'val', 'end', 'end']
->Original Target:
['Converts', 'values', 'on', 'the', 'basis', 'of', 'unified', 'tag', 'name', 'and', 'value', '.', 'It', 'is', 'called', 'each', 'time', 'a', 'value', 'is', 'fethed', 'from', 'a', 'Values', 'instance', '.']
->Reconstructed Target:
Converts values on the basis of unified tag name and value. It is called each time a value is fethed from a Values instance.
->Reconstructed Predication:
, val ), val ) end
->Raw Input:
summarize:def convert tag, val return val unless val. kind_of? ( String ) case tag when 'partofset', 'track' return val end case val when REGEXP_TIMESTAMP year, month, day, hour, minute = $~. captures [ 0, 5 ]. map { | cap | cap. to_i } if month == 0 || day == 0 return nil end second = $6. to_f zone = $7 zone = '+00:00' if zone == 'Z' Time. new ( year, month, day, hour, minute, second, zone ) when REGEXP_RATIONAL return val if $2. to_i == 0 Rational ( $1, $2 ) else val end end
->Raw Target:
Converts values on the basis of unified tag name and value. It is called each time a value is fethed from a Values instance.
--

690=========
->Original Input:
['def', 'to_h', '@values', '.', 'inject', '(', 'Hash', '.', 'new', ')', 'do', '|', 'h', ',', 'a', '|', 'tag', ',', 'val', '=', 'a', 'h', '[', 'Values', '.', 'tag_map', '[', 'tag', ']', ']', '=', 'convert', '(', 'Values', '.', 'unify_tag', '(', 'tag', ')', ',', 'val', ')', 'h', 'end', 'end']
->Original Target:
['Generates', 'a', 'hash', 'representation', 'of', 'this', 'instance', 'with', 'original', 'tag', 'names', 'es', 'keys', 'and', 'converted', 'values', 'as', 'values']
->Reconstructed Target:
Generates a hash representation of this instance with original tag names es keys and converted values as values
->Reconstructed Predication:
the values to a hash
->Raw Input:
summarize:def to_h @values. inject ( Hash. new ) do | h, a | tag, val = a h [ Values. tag_map [ tag ] ] = convert ( Values. unify_tag ( tag ), val ) h end end
->Raw Target:
Generates a hash representation of this instance with original tag names es keys and converted values as values
--

691=========
->Original Input:
['def', 'n', '(', 'msg', ',', 'title', '=', "''", ',', 'image', '=', 'nil', ')', 'Compat', '::', 'UI', '.', 'notify', '(', 'msg', ',', ':title', '=>', 'title', ',', ':image', '=>', 'image', ')', 'end']
->Original Target:
['Easy', 'method', 'to', 'display', 'a', 'notification']
->Reconstructed Target:
Easy method to display a notification
->Reconstructed Predication:
the message to the user.
->Raw Input:
summarize:def n ( msg, title = '', image = nil ) Compat :: UI. notify ( msg, :title => title, :image => image ) end
->Raw Target:
Easy method to display a notification
--

692=========
->Original Input:
['def', 'eager', '(', 'command', ')', 'require', "'pty'", 'begin', 'PTY', '.', 'spawn', 'command', 'do', '|', 'r', ',', 'w', ',', 'pid', '|', 'begin', '$stdout', '.', 'puts', 'r', '.', 'each', '{', '|', 'line', '|', 'print', 'line', '}', 'rescue', 'Errno', '::', 'EIO', 'end', 'end', 'rescue', 'PTY', '::', 'ChildExited', '$stdout', '.', 'puts', '"The child process exited!"', 'end', 'end']
->Original Target:
['Eager', 'prints', 'the', 'result', 'for', 'stdout', 'and', 'stderr', 'as', 'it', 'would', 'be', 'written', 'when', 'running', 'the', 'command', 'from', 'the', 'terminal', '.', 'This', 'is', 'useful', 'for', 'long', 'running', 'tasks', '.']
->Reconstructed Target:
Eager prints the result for stdout and stderr as it would be written when running the command from the terminal. This is useful for long running tasks.
->Reconstructed Predication:
the child process to run the
->Raw Input:
summarize:def eager ( command ) require 'pty' begin PTY. spawn command do | r, w, pid | begin $stdout. puts r. each { | line | print line } rescue Errno :: EIO end end rescue PTY :: ChildExited $stdout. puts "The child process exited!" end end
->Raw Target:
Eager prints the result for stdout and stderr as it would be written when running the command from the terminal. This is useful for long running tasks.
--

693=========
->Original Input:
['def', 'wrap_list', '(', 'list', ',', 'width', ')', 'list', '.', 'map', 'do', '|', 'text', '|', 'wrap_text', '(', 'text', ',', 'width', ')', 'end', '.', 'flatten', 'end']
->Original Target:
['an', 'array', 'of', 'text']
->Reconstructed Target:
an array of text
->Reconstructed Predication:
the list of text to wrap
->Raw Input:
summarize:def wrap_list ( list, width ) list. map do | text | wrap_text ( text, width ) end. flatten end
->Raw Target:
an array of text
--

694=========
->Original Input:
['def', 'save', 'return', 'if', '@data', '.', 'empty?', 'output', '=', '{', '}', 'output', '[', ':data', ']', '=', '@data', 'output', '[', ':generated_at', ']', '=', 'Time', '.', 'now', '.', 'to_s', 'output', '[', ':started_at', ']', '=', '@started_at', 'output', '[', ':format_version', ']', '=', "'1.0'", 'output', '[', ':rails_version', ']', '=', 'Rails', '.', 'version', 'output', '[', ':rails_path', ']', '=', 'Rails', '.', 'root', '.', 'to_s', 'FileUtils', '.', 'mkdir_p', '(', '@config', '.', 'output_path', ')', 'filename', '=', '"sql_tracker-#{Process.pid}-#{Time.now.to_i}.json"', 'File', '.', 'open', '(', 'File', '.', 'join', '(', '@config', '.', 'output_path', ',', 'filename', ')', ',', "'w'", ')', 'do', '|', 'f', '|', 'f', '.', 'write', 'JSON', '.', 'dump', '(', 'output', ')', 'end', 'end']
->Original Target:
['save', 'the', 'data', 'to', 'file']
->Reconstructed Target:
save the data to file
->Reconstructed Predication:
. join ( @config..
->Raw Input:
summarize:def save return if @data. empty? output = { } output [ :data ] = @data output [ :generated_at ] = Time. now. to_s output [ :started_at ] = @started_at output [ :format_version ] = '1.0' output [ :rails_version ] = Rails. version output [ :rails_path ] = Rails. root. to_s FileUtils. mkdir_p ( @config. output_path ) filename = "sql_tracker-#{Process.pid}-#{Time.now.to_i}.json" File. open ( File. join ( @config. output_path, filename ), 'w' ) do | f | f. write JSON. dump ( output ) end end
->Raw Target:
save the data to file
--

695=========
->Original Input:
['def', 'delete', '(', 'key', ')', 'ref', '=', '@references', '.', 'delete', '(', 'key', ')', 'if', 'ref', 'keys_to_id', '=', '@references_to_keys_map', '[', 'ref', '.', 'referenced_object_id', ']', 'if', 'keys_to_id', 'keys_to_id', '.', 'delete', '(', 'key', ')', '@references_to_keys_map', '.', 'delete', '(', 'ref', '.', 'referenced_object_id', ')', 'if', 'keys_to_id', '.', 'empty?', 'end', 'ref', '.', 'object', 'else', 'nil', 'end', 'end']
->Original Target:
['Remove', 'the', 'entry', 'associated', 'with', 'the', 'key', 'from', 'the', 'map', '.']
->Reconstructed Target:
Remove the entry associated with the key from the map.
->Reconstructed Predication:
the object for the given
->Raw Input:
summarize:def delete ( key ) ref = @references. delete ( key ) if ref keys_to_id = @references_to_keys_map [ ref. referenced_object_id ] if keys_to_id keys_to_id. delete ( key ) @references_to_keys_map. delete ( ref. referenced_object_id ) if keys_to_id. empty? end ref. object else nil end end
->Raw Target:
Remove the entry associated with the key from the map.
--

696=========
->Original Input:
['def', 'merge', '(', 'other_hash', ',', '&', 'block', ')', 'to_h', '.', 'merge', '(', 'other_hash', ',', '&', 'block', ')', '.', 'reduce', '(', 'self', '.', 'class', '.', 'new', ')', 'do', '|', 'map', ',', 'pair', '|', 'map', '[', 'pair', '.', 'first', ']', '=', 'pair', '.', 'last', 'map', 'end', 'end']
->Original Target:
['Returns', 'a', 'new', 'struct', 'containing', 'the', 'contents', 'of', 'other', 'and', 'the', 'contents', 'of', 'self', '.', 'If', 'no', 'block', 'is', 'specified', 'the', 'value', 'for', 'entries', 'with', 'duplicate', 'keys', 'will', 'be', 'that', 'of', 'other', '.', 'Otherwise', 'the', 'value', 'for', 'each', 'duplicate', 'key', 'is', 'determined', 'by', 'calling', 'the', 'block', 'with', 'the', 'key', 'its', 'value', 'in', 'self', 'and', 'its', 'value', 'in', 'other', '.']
->Reconstructed Target:
Returns a new struct containing the contents of other and the contents of self. If no block is specified the value for entries with duplicate keys will be that of other. Otherwise the value for each duplicate key is determined by calling the block with the key its value in self and its value in other.
->Reconstructed Predication:
the hash to the hash.
->Raw Input:
summarize:def merge ( other_hash, & block ) to_h. merge ( other_hash, & block ). reduce ( self. class. new ) do | map, pair | map [ pair. first ] = pair. last map end end
->Raw Target:
Returns a new struct containing the contents of other and the contents of self. If no block is specified the value for entries with duplicate keys will be that of other. Otherwise the value for each duplicate key is determined by calling the block with the key its value in self and its value in other.
--

697=========
->Original Input:
['def', 'add_strong_reference', '(', 'obj', ')', '@@lock', '.', 'synchronize', 'do', '@@strong_references', '.', 'last', '[', 'obj', ']', '=', 'true', 'unless', '@@gc_flag_set', '@@gc_flag_set', '=', 'true', 'ObjectSpace', '.', 'define_finalizer', '(', 'Object', '.', 'new', ',', '@@finalizer', ')', 'end', 'end', 'end']
->Original Target:
['Create', 'a', 'strong', 'reference', 'to', 'the', 'object', '.', 'This', 'reference', 'will', 'live', 'for', 'three', 'passes', 'of', 'the', 'garbage', 'collector', '.']
->Reconstructed Target:
Create a strong reference to the object. This reference will live for three passes of the garbage collector.
->Reconstructed Predication:
the object to be added to
->Raw Input:
summarize:def add_strong_reference ( obj ) @@lock. synchronize do @@strong_references. last [ obj ] = true unless @@gc_flag_set @@gc_flag_set = true ObjectSpace. define_finalizer ( Object. new, @@finalizer ) end end end
->Raw Target:
Create a strong reference to the object. This reference will live for three passes of the garbage collector.
--

698=========
->Original Input:
['def', 'object', '@ref', '.', '__getobj__', 'rescue', '=>', 'e', 'if', '(', 'defined?', '(', 'RefError', ')', '&&', 'e', '.', 'is_a?', '(', 'RefError', ')', ')', '||', '(', 'defined?', '(', '::', 'WeakRef', '::', 'RefError', ')', '&&', 'e', '.', 'is_a?', '(', '::', 'WeakRef', '::', 'RefError', ')', ')', 'nil', 'else', 'raise', 'e', 'end', 'end']
->Original Target:
['This', 'implementation', 'of', 'a', 'weak', 'reference', 'simply', 'wraps', 'the', 'standard', 'WeakRef', 'implementation', 'that', 'comes', 'with', 'the', 'Ruby', 'standard', 'library', '.']
->Reconstructed Target:
This implementation of a weak reference simply wraps the standard WeakRef implementation that comes with the Ruby standard library.
->Reconstructed Predication:
ref : ref
->Raw Input:
summarize:def object @ref. __getobj__ rescue => e if ( defined? ( RefError ) && e. is_a? ( RefError ) ) || ( defined? ( :: WeakRef :: RefError ) && e. is_a? ( :: WeakRef :: RefError ) ) nil else raise e end end
->Raw Target:
This implementation of a weak reference simply wraps the standard WeakRef implementation that comes with the Ruby standard library.
--

699=========
->Original Input:
['def', 'delete', '(', 'key', ')', '@lock', '.', 'synchronize', 'do', 'rkey', '=', 'ref_key', '(', 'key', ')', 'if', 'rkey', '@references_to_keys_map', '.', 'delete', '(', 'rkey', ')', '@values', '.', 'delete', '(', 'rkey', ')', 'else', 'nil', 'end', 'end', 'end']
->Original Target:
['Remove', 'the', 'value', 'associated', 'with', 'the', 'key', 'from', 'the', 'map', '.']
->Reconstructed Target:
Remove the value associated with the key from the map.
->Reconstructed Predication:
the value for the key
->Raw Input:
summarize:def delete ( key ) @lock. synchronize do rkey = ref_key ( key ) if rkey @references_to_keys_map. delete ( rkey ) @values. delete ( rkey ) else nil end end end
->Raw Target:
Remove the value associated with the key from the map.
--

700=========
->Original Input:
['def', 'monitor', '(', 'reference', ')', 'obj', '=', 'reference', '.', 'object', 'if', 'obj', '@lock', '.', 'synchronize', 'do', '@references', '[', 'reference', '.', 'referenced_object_id', ']', '=', 'reference', 'end', 'ObjectSpace', '.', 'define_finalizer', '(', 'obj', ',', '@finalizer', ')', 'else', 'push', '(', 'reference', ')', 'end', 'end']
->Original Target:
['Monitor', 'a', 'reference', '.', 'When', 'the', 'object', 'the', 'reference', 'points', 'to', 'is', 'garbage', 'collected', 'the', 'reference', 'will', 'be', 'added', 'to', 'the', 'queue', '.']
->Reconstructed Target:
Monitor a reference. When the object the reference points to is garbage collected the reference will be added to the queue.
->Reconstructed Predication:
the object to be processed
->Raw Input:
summarize:def monitor ( reference ) obj = reference. object if obj @lock. synchronize do @references [ reference. referenced_object_id ] = reference end ObjectSpace. define_finalizer ( obj, @finalizer ) else push ( reference ) end end
->Raw Target:
Monitor a reference. When the object the reference points to is garbage collected the reference will be added to the queue.
--

701=========
->Original Input:
['def', 'client', '(', 'options', '=', '{', '}', ')', '@client', '||=', '::', 'OAuth2', '::', 'Client', '.', 'new', '(', 'client_id', ',', 'client_secret', ',', '{', ':site', '=>', 'options', '.', 'fetch', '(', ':site', ')', '{', 'Nimbu', '.', 'site', '}', ',', ':authorize_url', '=>', "'login/oauth/authorize'", ',', ':token_url', '=>', "'login/oauth/access_token'", ',', ':ssl', '=>', '{', ':verify', '=>', 'false', '}', '}', ')', 'end']
->Original Target:
['Setup', 'OAuth2', 'instance']
->Reconstructed Target:
Setup OAuth2 instance
->Reconstructed Predication:
the client to authenticate withthe client.  def client
->Raw Input:
summarize:def client ( options = { } ) @client ||= :: OAuth2 :: Client. new ( client_id, client_secret, { :site => options. fetch ( :site ) { Nimbu. site }, :authorize_url => 'login/oauth/authorize', :token_url => 'login/oauth/access_token', :ssl => { :verify => false } } ) end
->Raw Target:
Setup OAuth2 instance
--

702=========
->Original Input:
['def', 'default_middleware', '(', 'options', '=', '{', '}', ')', 'Proc', '.', 'new', 'do', '|', 'builder', '|', 'unless', 'options', '[', ':with_attachments', ']', 'builder', '.', 'use', 'Nimbu', '::', 'Request', '::', 'Json', 'end', 'builder', '.', 'use', 'Faraday', '::', 'Request', '::', 'Multipart', 'builder', '.', 'use', 'Faraday', '::', 'Request', '::', 'UrlEncoded', 'builder', '.', 'use', 'Nimbu', '::', 'Request', '::', 'OAuth2', ',', 'oauth_token', 'if', 'oauth_token?', 'builder', '.', 'use', 'Nimbu', '::', 'Request', '::', 'BasicAuth', ',', 'authentication', 'if', 'basic_authed?', 'builder', '.', 'use', 'Nimbu', '::', 'Request', '::', 'UserAgent', 'builder', '.', 'use', 'Nimbu', '::', 'Request', '::', 'SiteHeader', ',', 'subdomain', 'builder', '.', 'use', 'Nimbu', '::', 'Request', '::', 'ContentLocale', ',', 'content_locale', 'builder', '.', 'use', 'Faraday', '::', 'Response', '::', 'Logger', 'if', 'ENV', '[', "'DEBUG'", ']', 'builder', '.', 'use', 'Nimbu', '::', 'Response', '::', 'RaiseError', 'unless', 'options', '[', ':raw', ']', 'builder', '.', 'use', 'Nimbu', '::', 'Response', '::', 'Mashify', 'builder', '.', 'use', 'Nimbu', '::', 'Response', '::', 'Json', 'end', 'builder', '.', 'adapter', 'adapter', 'end', 'end']
->Original Target:
['Default', 'middleware', 'stack', 'that', 'uses', 'default', 'adapter', 'as', 'specified', 'at', 'configuration', 'stage', '.']
->Reconstructed Target:
Default middleware stack that uses default adapter as specified at configuration stage.
->Reconstructed Predication:
: raw : false: raw : true: raw : true: raw : true
->Raw Input:
summarize:def default_middleware ( options = { } ) Proc. new do | builder | unless options [ :with_attachments ] builder. use Nimbu :: Request :: Json end builder. use Faraday :: Request :: Multipart builder. use Faraday :: Request :: UrlEncoded builder. use Nimbu :: Request :: OAuth2, oauth_token if oauth_token? builder. use Nimbu :: Request :: BasicAuth, authentication if basic_authed? builder. use Nimbu :: Request :: UserAgent builder. use Nimbu :: Request :: SiteHeader, subdomain builder. use Nimbu :: Request :: ContentLocale, content_locale builder. use Faraday :: Response :: Logger if ENV [ 'DEBUG' ] builder. use Nimbu :: Response :: RaiseError unless options [ :raw ] builder. use Nimbu :: Response :: Mashify builder. use Nimbu :: Response :: Json end builder. adapter adapter end end
->Raw Target:
Default middleware stack that uses default adapter as specified at configuration stage.
--

703=========
->Original Input:
['def', 'load', 'unless', 'valid_params?', 'raise', 'SmartAdapters', '::', 'Exceptions', '::', 'InvalidRequestParamsException', 'end', 'unless', 'valid_format?', 'raise', 'SmartAdapters', '::', 'Exceptions', '::', 'InvalidRequestFormatException', 'end', 'adapter_finder', '.', 'new', '(', 'request_manager', ')', 'end']
->Original Target:
['Initialise', 'SmartAdapters', 'delegator']
->Reconstructed Target:
Initialise SmartAdapters delegator
->Reconstructed Predication:
the request to the adapterthe adapter to the adapter tothe adapter to the adapter tothe adapter to the adapter to
->Raw Input:
summarize:def load unless valid_params? raise SmartAdapters :: Exceptions :: InvalidRequestParamsException end unless valid_format? raise SmartAdapters :: Exceptions :: InvalidRequestFormatException end adapter_finder. new ( request_manager ) end
->Raw Target:
Initialise SmartAdapters delegator
--

704=========
->Original Input:
['def', 'error', '{', 'error', ':', '{', 'model', ':', 'self', '.', 'object', '[', '"model"', ']', ',', 'model_human', ':', 'self', '.', 'object', '[', '"model_human"', ']', ',', 'attribute', ':', 'self', '.', 'object', '[', '"attribute"', ']', ',', 'attribute_human', ':', 'self', '.', 'object', '[', '"attribute_human"', ']', ',', 'field', ':', 'self', '.', 'object', '[', '"field"', ']', ',', 'message', ':', 'self', '.', 'object', '[', '"message"', ']', ',', 'full_message', ':', '"#{self.object["full_message"]}"', '}', '}', 'end']
->Original Target:
['for', 'standard', 'errors', 'this', 'method', 'build', 'a', 'hash']
->Reconstructed Target:
for standard errors this method build a hash
->Reconstructed Predication:
the error message for thethe error message for thethe error messagethe error messagethe error message for thethe error message for the errorthe error messagethe error message for thethe error message for the error
->Raw Input:
summarize:def error { error : { model : self. object [ "model" ], model_human : self. object [ "model_human" ], attribute : self. object [ "attribute" ], attribute_human : self. object [ "attribute_human" ], field : self. object [ "field" ], message : self. object [ "message" ], full_message : "#{self.object["full_message"]}" } } end
->Raw Target:
for standard errors this method build a hash
--

705=========
->Original Input:
['def', 'setup', '(', 'options', '=', '{', '}', ')', 'options', '.', 'each', 'do', '|', 'k', ',', 'v', '|', 'self', '.', 'set', '(', 'k', ',', 'v', ',', 'true', ')', 'end', 'options', '=', 'Nimbu', '.', 'options', '.', 'merge', '(', 'options', ')', 'self', '.', 'current_options', '=', 'options', 'Configuration', '.', 'keys', '.', 'each', 'do', '|', 'key', '|', 'send', '(', '"#{key}="', ',', 'options', '[', 'key', ']', ')', 'end', 'process_basic_auth', '(', 'options', '[', ':basic_auth', ']', ')', 'end']
->Original Target:
['Configure', 'options', 'and', 'process', 'basic', 'authorization']
->Reconstructed Target:
Configure options and process basic authorization
->Reconstructed Predication:
the configuration to use for thethe configuration to use for thethe configuration to use for thethe configuration to use for thethe configuration to use for thethe configuration to use for the
->Raw Input:
summarize:def setup ( options = { } ) options. each do | k, v | self. set ( k, v, true ) end options = Nimbu. options. merge ( options ) self. current_options = options Configuration. keys. each do | key | send ( "#{key}=", options [ key ] ) end process_basic_auth ( options [ :basic_auth ] ) end
->Raw Target:
Configure options and process basic authorization
--

706=========
->Original Input:
['def', 'arguments', '(', 'args', '=', '(', 'not_set', '=', 'true', ')', ',', 'options', '=', '{', '}', ',', '&', 'block', ')', 'if', 'not_set', '@arguments', 'else', '@arguments', '=', 'Arguments', '.', 'new', '(', 'self', ',', 'options', ')', '.', 'parse', '(', '*', 'args', ',', '&', 'block', ')', 'end', 'end']
->Original Target:
['Acts', 'as', 'setter', 'and', 'getter', 'for', 'api', 'requests', 'arguments', 'parsing', '.']
->Reconstructed Target:
Acts as setter and getter for api requests arguments parsing.
->Reconstructed Predication:
the arguments to be parsed
->Raw Input:
summarize:def arguments ( args = ( not_set = true ), options = { }, & block ) if not_set @arguments else @arguments = Arguments. new ( self, options ). parse ( * args, & block ) end end
->Raw Target:
Acts as setter and getter for api requests arguments parsing.
--

707=========
->Original Input:
['def', 'reset!', 'self', '.', 'client_id', '=', 'DEFAULT_CLIENT_ID', 'self', '.', 'client_secret', '=', 'DEFAULT_CLIENT_SECRET', 'self', '.', 'oauth_token', '=', 'DEFAULT_OAUTH_TOKEN', 'self', '.', 'endpoint', '=', 'DEFAULT_ENDPOINT', 'self', '.', 'site', '=', 'DEFAULT_SITE', 'self', '.', 'ssl', '=', 'DEFAULT_SSL', 'self', '.', 'user_agent', '=', 'DEFAULT_USER_AGENT', 'self', '.', 'connection_options', '=', 'DEFAULT_CONNECTION_OPTIONS', 'self', '.', 'mime_type', '=', 'DEFAULT_MIME_TYPE', 'self', '.', 'login', '=', 'DEFAULT_LOGIN', 'self', '.', 'password', '=', 'DEFAULT_PASSWORD', 'self', '.', 'basic_auth', '=', 'DEFAULT_BASIC_AUTH', 'self', '.', 'auto_pagination', '=', 'DEFAULT_AUTO_PAGINATION', 'self', '.', 'content_locale', '=', 'DEFAULT_CONTENT_LOCALE', 'self', '.', 'adapter', '=', 'DEFAULT_ADAPTER', 'self', '.', 'subdomain', '=', 'DEFAULT_SUBDOMAIN', 'self', 'end']
->Original Target:
['Reset', 'configuration', 'options', 'to', 'their', 'defaults']
->Reconstructed Target:
Reset configuration options to their defaults
->Reconstructed Predication:
the client and client secret.
->Raw Input:
summarize:def reset! self. client_id = DEFAULT_CLIENT_ID self. client_secret = DEFAULT_CLIENT_SECRET self. oauth_token = DEFAULT_OAUTH_TOKEN self. endpoint = DEFAULT_ENDPOINT self. site = DEFAULT_SITE self. ssl = DEFAULT_SSL self. user_agent = DEFAULT_USER_AGENT self. connection_options = DEFAULT_CONNECTION_OPTIONS self. mime_type = DEFAULT_MIME_TYPE self. login = DEFAULT_LOGIN self. password = DEFAULT_PASSWORD self. basic_auth = DEFAULT_BASIC_AUTH self. auto_pagination = DEFAULT_AUTO_PAGINATION self. content_locale = DEFAULT_CONTENT_LOCALE self. adapter = DEFAULT_ADAPTER self. subdomain = DEFAULT_SUBDOMAIN self end
->Raw Target:
Reset configuration options to their defaults
--

708=========
->Original Input:
['def', 'invalid_fts_filters', '(', 'filters', ')', 'filters', '.', 'select', '{', '|', 'filter', '|', 'category', ',', 'name', ',', 'value', '=', 'filter', '.', 'values_at', '(', "'category'", ',', "'name'", ',', "'value'", ')', 'category', '==', "'fts'", '&&', 'name', '==', "'search'", '&&', 'value', '.', 'to_s', '.', 'length', '<=', '1', '}', '.', 'map', '{', '|', 'invalid_fts_filter', '|', 'error', '=', '<<-MSG', '.', 'gsub', '(', '/', '\\s', '/', ',', "''", ')', '.', 'strip', 'MSG', 'invalid_fts_filter', '.', 'merge', '(', ':error', '=>', 'error', ')', '}', 'end']
->Original Target:
['Retrieve', 'the', 'filters', 'that', 'represent', 'invalid', 'full', '-', 'text', 'search', 'values', '.']
->Reconstructed Target:
Retrieve the filters that represent invalid full - text search values.
->Reconstructed Predication:
the filter to be filtered
->Raw Input:
summarize:def invalid_fts_filters ( filters ) filters. select { | filter | category, name, value = filter. values_at ( 'category', 'name', 'value' ) category == 'fts' && name =='search' && value. to_s. length <= 1 }. map { | invalid_fts_filter | error = <<-MSG. gsub ( / \s /, '' ). strip MSG invalid_fts_filter. merge ( :error => error ) } end
->Raw Target:
Retrieve the filters that represent invalid full - text search values.
--

709=========
->Original Input:
['def', 'extended', '(', 'object', ')', 'each_param', 'do', '|', 'param', '|', 'object', '.', 'params', '[', 'param', '.', 'name', ']', '=', 'param', '.', 'to_instance', '(', 'object', ')', 'end', 'end']
->Original Target:
['Ensures', 'that', 'the', 'module', 'will', 'initialize', 'parameters', 'when', 'extended', 'into', 'an', 'Object', '.']
->Reconstructed Target:
Ensures that the module will initialize parameters when extended into an Object.
->Reconstructed Predication:
the object to be extended.
->Raw Input:
summarize:def extended ( object ) each_param do | param | object. params [ param. name ] = param. to_instance ( object ) end end
->Raw Target:
Ensures that the module will initialize parameters when extended into an Object.
--

710=========
->Original Input:
['def', 'params', '=', '(', 'values', ')', 'values', '.', 'each', 'do', '|', 'name', ',', 'value', '|', 'if', 'has_param?', '(', 'name', ')', 'get_param', '(', 'name', ')', '.', 'value', '=', 'case', 'value', 'when', 'Parameters', '::', 'ClassParam', ',', 'Parameters', '::', 'InstanceParam', 'value', '.', 'value', 'else', 'value', 'end', 'end', 'end', 'end']
->Original Target:
['Sets', 'the', 'values', 'of', 'the', 'class', 'parameters', '.']
->Reconstructed Target:
Sets the values of the class parameters.
->Reconstructed Predication:
the parameters to be used for
->Raw Input:
summarize:def params = ( values ) values. each do | name, value | if has_param? ( name ) get_param ( name ). value = case value when Parameters :: ClassParam, Parameters :: InstanceParam value. value else value end end end end
->Raw Target:
Sets the values of the class parameters.
--

711=========
->Original Input:
['def', 'parameter', '(', 'name', ',', 'options', '=', '{', '}', ')', 'name', '=', 'name', '.', 'to_sym', 'meta_def', '(', 'name', ')', 'do', 'get_param', '(', 'name', ')', '.', 'value', 'end', 'meta_def', '(', '"#{name}="', ')', 'do', '|', 'value', '|', 'get_param', '(', 'name', ')', '.', 'value', '=', 'value', 'end', 'meta_def', '(', '"#{name}?"', ')', 'do', '!', '!', 'get_param', '(', 'name', ')', '.', 'value', 'end', 'define_method', '(', 'name', ')', 'do', 'get_param', '(', 'name', ')', '.', 'value', 'end', 'define_method', '(', '"#{name}="', ')', 'do', '|', 'value', '|', 'get_param', '(', 'name', ')', '.', 'value', '=', 'value', 'end', 'define_method', '(', '"#{name}?"', ')', 'do', '!', '!', 'get_param', '(', 'name', ')', '.', 'value', 'end', 'new_param', '=', 'Parameters', '::', 'ClassParam', '.', 'new', '(', 'name', ',', 'options', '[', ':type', ']', ',', 'options', '[', ':description', ']', ',', 'options', '[', ':default', ']', ')', 'params', '[', 'name', ']', '=', 'new_param', 'return', 'new_param', 'end']
->Original Target:
['Adds', 'a', 'new', 'parameters', 'to', 'the', 'class', '.']
->Reconstructed Target:
Adds a new parameters to the class.
->Reconstructed Predication:
the parameterthe parameterthe parameterthe parameterthe parameterthe parameterthe parameterthe parameterthe parameterthe parameterthe parameterthe parameterthe parameterthe parameter isthe parameter is thethe parameter is thethe parameter is thethe parameter is thethe parameter is thethe parameter is thethe parameter is thethe parameter is thethe parameter is thethe parameter is thethe parameter is the
->Raw Input:
summarize:def parameter ( name, options = { } ) name = name. to_sym meta_def ( name ) do get_param ( name ). value end meta_def ( "#{name}=" ) do | value | get_param ( name ). value = value end meta_def ( "#{name}?" ) do!! get_param ( name ). value end define_method ( name ) do get_param ( name ). value end define_method ( "#{name}=" ) do | value | get_param ( name ). value = value end define_method ( "#{name}?" ) do!! get_param ( name ). value end new_param = Parameters :: ClassParam. new ( name, options [ :type ], options [ :description ], options [ :default ] ) params [ name ] = new_param return new_param end
->Raw Target:
Adds a new parameters to the class.
--

712=========
->Original Input:
['def', 'has_param?', '(', 'name', ')', 'name', '=', 'name', '.', 'to_sym', 'ancestors', '.', 'each', 'do', '|', 'ancestor', '|', 'if', 'ancestor', '.', 'included_modules', '.', 'include?', '(', 'Parameters', ')', 'return', 'true', 'if', 'ancestor', '.', 'params', '.', 'has_key?', '(', 'name', ')', 'end', 'end', 'return', 'false', 'end']
->Original Target:
['Determines', 'if', 'a', 'class', 'parameter', 'exists', 'with', 'the', 'given', 'name', '.']
->Reconstructed Target:
Determines if a class parameter exists with the given name.
->Reconstructed Predication:
the parameter with the given name
->Raw Input:
summarize:def has_param? ( name ) name = name. to_sym ancestors. each do | ancestor | if ancestor. included_modules. include? ( Parameters ) return true if ancestor. params. has_key? ( name ) end end return false end
->Raw Target:
Determines if a class parameter exists with the given name.
--

713=========
->Original Input:
['def', 'get_param', '(', 'name', ')', 'name', '=', 'name', '.', 'to_sym', 'ancestors', '.', 'each', 'do', '|', 'ancestor', '|', 'if', 'ancestor', '.', 'included_modules', '.', 'include?', '(', 'Parameters', ')', 'if', 'ancestor', '.', 'params', '.', 'has_key?', '(', 'name', ')', 'return', 'ancestor', '.', 'params', '[', 'name', ']', 'end', 'end', 'end', 'raise', '(', 'Parameters', '::', 'ParamNotFound', ',', '"parameter #{name.to_s.dump} was not found in class #{self}"', ')', 'end']
->Original Target:
['Searches', 'for', 'the', 'class', 'parameter', 'with', 'the', 'matching', 'name', '.']
->Reconstructed Target:
Searches for the class parameter with the matching name.
->Reconstructed Predication:
the parameter for the given
->Raw Input:
summarize:def get_param ( name ) name = name. to_sym ancestors. each do | ancestor | if ancestor. included_modules. include? ( Parameters ) if ancestor. params. has_key? ( name ) return ancestor. params [ name ] end end end raise ( Parameters :: ParamNotFound, "parameter #{name.to_s.dump} was not found in class #{self}" ) end
->Raw Target:
Searches for the class parameter with the matching name.
--

714=========
->Original Input:
['def', 'set_param', '(', 'name', ',', 'value', ')', 'name', '=', 'name', '.', 'to_sym', 'ancestors', '.', 'each', 'do', '|', 'ancestor', '|', 'if', 'ancestor', '.', 'included_modules', '.', 'include?', '(', 'Parameters', ')', 'if', 'ancestor', '.', 'params', '.', 'has_key?', '(', 'name', ')', 'return', 'ancestor', '.', 'params', '[', 'name', ']', '.', 'set', '(', 'value', ')', 'end', 'end', 'end', 'raise', '(', 'Parameters', '::', 'ParamNotFound', ',', '"parameter #{name.to_s.dump} was not found in class #{self}"', ')', 'end']
->Original Target:
['Sets', 'a', 'class', 'parameter', '.']
->Reconstructed Target:
Sets a class parameter.
->Reconstructed Predication:
the parameter value for the
->Raw Input:
summarize:def set_param ( name, value ) name = name. to_sym ancestors. each do | ancestor | if ancestor. included_modules. include? ( Parameters ) if ancestor. params. has_key? ( name ) return ancestor. params [ name ]. set ( value ) end end end raise ( Parameters :: ParamNotFound, "parameter #{name.to_s.dump} was not found in class #{self}" ) end
->Raw Target:
Sets a class parameter.
--

715=========
->Original Input:
['def', 'each_param', '(', '&', 'block', ')', 'ancestors', '.', 'reverse_each', 'do', '|', 'ancestor', '|', 'if', 'ancestor', '.', 'included_modules', '.', 'include?', '(', 'Parameters', ')', 'ancestor', '.', 'params', '.', 'each_value', '(', '&', 'block', ')', 'end', 'end', 'return', 'self', 'end']
->Original Target:
['Iterates', 'over', 'the', 'parameters', 'of', 'the', 'class', 'and', 'it', 's', 'ancestors', '.']
->Reconstructed Target:
Iterates over the parameters of the class and it s ancestors.
->Reconstructed Predication:
the parameters of each ancestor
->Raw Input:
summarize:def each_param ( & block ) ancestors. reverse_each do | ancestor | if ancestor. included_modules. include? ( Parameters ) ancestor. params. each_value ( & block ) end end return self end
->Raw Target:
Iterates over the parameters of the class and it s ancestors.
--

716=========
->Original Input:
['def', 'link', '(', '*', 'things', ')', 'unless', 'none?', 'raise', '"Illegal state for link: #{state}"', 'end', 'things', '.', 'each', 'do', '|', 'thing', '|', 'case', 'thing', 'when', 'DataMapper', '::', 'Adapters', '::', 'AbstractAdapter', '@adapters', '[', 'thing', ']', '=', ':none', 'when', 'DataMapper', '::', 'Repository', 'link', '(', 'thing', '.', 'adapter', ')', 'when', 'DataMapper', '::', 'Model', 'link', '(', '*', 'thing', '.', 'repositories', ')', 'when', 'DataMapper', '::', 'Resource', 'link', '(', 'thing', '.', 'model', ')', 'when', 'Array', 'link', '(', '*', 'thing', ')', 'else', 'raise', '"Unknown argument to #{self.class}#link: #{thing.inspect} (#{thing.class})"', 'end', 'end', 'if', 'block_given?', 'commit', '{', '|', '*', 'block_args', '|', 'yield', '(', '*', 'block_args', ')', '}', 'else', 'self', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'Transaction']
->Reconstructed Target:
Create a new Transaction
->Reconstructed Predication:
the given
->Raw Input:
summarize:def link ( * things ) unless none? raise "Illegal state for link: #{state}" end things. each do | thing | case thing when DataMapper :: Adapters :: AbstractAdapter @adapters [ thing ] = :none when DataMapper :: Repository link ( thing. adapter ) when DataMapper :: Model link ( * thing. repositories ) when DataMapper :: Resource link ( thing. model ) when Array link ( * thing ) else raise "Unknown argument to #{self.class}#link: #{thing.inspect} (#{thing.class})" end end if block_given? commit { | * block_args | yield ( * block_args ) } else self end end
->Raw Target:
Create a new Transaction
--

717=========
->Original Input:
['def', 'commit', 'if', 'block_given?', 'unless', 'none?', 'raise', '"Illegal state for commit with block: #{state}"', 'end', 'begin', 'self', '.', 'begin', 'rval', '=', 'within', '{', '|', '*', 'block_args', '|', 'yield', '(', '*', 'block_args', ')', '}', 'rescue', 'Exception', '=>', 'exception', 'if', 'begin?', 'rollback', 'end', 'raise', 'exception', 'ensure', 'unless', 'exception', 'if', 'begin?', 'commit', 'end', 'return', 'rval', 'end', 'end', 'else', 'unless', 'begin?', 'raise', '"Illegal state for commit without block: #{state}"', 'end', 'each_adapter', '(', ':commit_adapter', ',', '[', ':log_fatal_transaction_breakage', ']', ')', 'each_adapter', '(', ':close_adapter', ',', '[', ':log_fatal_transaction_breakage', ']', ')', 'self', '.', 'state', '=', ':commit', 'end', 'end']
->Original Target:
['Commit', 'the', 'transaction']
->Reconstructed Target:
Commit the transaction
->Reconstructed Predication:
the transaction with the given
->Raw Input:
summarize:def commit if block_given? unless none? raise "Illegal state for commit with block: #{state}" end begin self. begin rval = within { | * block_args | yield ( * block_args ) } rescue Exception => exception if begin? rollback end raise exception ensure unless exception if begin? commit end return rval end end else unless begin? raise "Illegal state for commit without block: #{state}" end each_adapter ( :commit_adapter, [ :log_fatal_transaction_breakage ] ) each_adapter ( :close_adapter, [ :log_fatal_transaction_breakage ] ) self. state = :commit end end
->Raw Target:
Commit the transaction
--

718=========
->Original Input:
['def', 'within', 'unless', 'block_given?', 'raise', "'No block provided'", 'end', 'unless', 'begin?', 'raise', '"Illegal state for within: #{state}"', 'end', 'adapters', '=', '@adapters', 'adapters', '.', 'each_key', 'do', '|', 'adapter', '|', 'adapter', '.', 'push_transaction', '(', 'self', ')', 'end', 'begin', 'yield', 'self', 'ensure', 'adapters', '.', 'each_key', 'do', '|', 'adapter', '|', 'adapter', '.', 'pop_transaction', 'end', 'end', 'end']
->Original Target:
['Execute', 'a', 'block', 'within', 'this', 'Transaction', '.']
->Reconstructed Target:
Execute a block within this Transaction.
->Reconstructed Predication:
block
->Raw Input:
summarize:def within unless block_given? raise 'No block provided' end unless begin? raise "Illegal state for within: #{state}" end adapters = @adapters adapters. each_key do | adapter | adapter. push_transaction ( self ) end begin yield self ensure adapters. each_key do | adapter | adapter. pop_transaction end end end
->Raw Target:
Execute a block within this Transaction.
--

719=========
->Original Input:
['def', 'next_message', 'read_header', 'if', '@state', '==', ':header', 'read_payload_length', 'if', '@state', '==', ':payload_length', 'read_mask_key', 'if', '@state', '==', ':mask', 'read_payload', 'if', '@state', '==', ':payload', '@state', '==', ':complete', '?', 'process_frame!', ':', 'nil', 'rescue', 'StandardError', '=>', 'ex', 'if', '@on_error', '@on_error', '.', 'call', '(', 'ex', '.', 'message', ')', 'else', 'raise', 'ex', 'end', 'end']
->Original Target:
['Parse', 'next', 'message', 'in', 'buffer']
->Reconstructed Target:
Parse next message in buffer
->Reconstructed Predication:
: header : header : payload
->Raw Input:
summarize:def next_message read_header if @state == :header read_payload_length if @state == :payload_length read_mask_key if @state == :mask read_payload if @state == :payload @state == :complete? process_frame! : nil rescue StandardError => ex if @on_error @on_error. call ( ex. message ) else raise ex end end
->Raw Target:
Parse next message in buffer
--

720=========
->Original Input:
['def', 'reporter', '(', 'query', ',', 'options', '=', '{', '}', ',', '&', 'block', ')', '@report', '||=', 'QueryReport', '::', 'Report', '.', 'new', '(', 'params', ',', 'view_context', ',', 'options', ')', '@report', '.', 'query', '=', 'query', '@report', '.', 'instance_eval', '&', 'block', 'render_report', '(', 'options', ')', 'unless', 'options', '[', ':skip_rendering', ']', '@report', 'end']
->Original Target:
['Generates', 'the', 'reports']
->Reconstructed Target:
Generates the reports
->Reconstructed Predication:
the report to render. 
->Raw Input:
summarize:def reporter ( query, options = { }, & block ) @report ||= QueryReport :: Report. new ( params, view_context, options ) @report. query = query @report. instance_eval & block render_report ( options ) unless options [ :skip_rendering ] @report end
->Raw Target:
Generates the reports
--

721=========
->Original Input:
['def', 'infer_type', '(', 'field_name', ')', 'case', 'field_name', 'when', ':email', ',', ':time_zone', 'field_name', 'when', '%r{', '\\b', '\\b', '}', ':password', 'else', 'type_mappings', '=', '{', 'text', ':', ':textarea', '}', 'db_type', '=', '@object', '.', 'column_for_attribute', '(', 'field_name', ')', '.', 'type', 'case', 'db_type', 'when', ':text', ':textarea', 'when', ':decimal', ',', ':integer', ',', ':float', ':numeric', 'else', 'db_type', 'end', 'end', 'end']
->Original Target:
['Infers', 'the', 'type', 'of', 'field', 'to', 'render', 'based', 'on', 'the', 'field', 'name', '.']
->Reconstructed Target:
Infers the type of field to render based on the field name.
->Reconstructed Predication:
the type of the field
->Raw Input:
summarize:def infer_type ( field_name ) case field_name when :email, :time_zone field_name when %r{ \b \b } :password else type_mappings = { text : :textarea } db_type = @object. column_for_attribute ( field_name ). type case db_type when :text :textarea when :decimal, :integer, :float :numeric else db_type end end end
->Raw Target:
Infers the type of field to render based on the field name.
--

722=========
->Original Input:
['def', 'validate_instance_node', '(', 'instance_node', ')', 'validations_passed', '=', '!', 'self', '.', 'node_validations', '.', 'collect', '{', '|', 'node_validation', '|', 'node_validation', '.', 'validate_instance_node', '(', 'instance_node', ',', 'self', ')', '}', '.', 'include?', '(', 'false', ')', 'parent_validations_passed', '=', '!', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'collect', '{', '|', 'node_map', '|', 'if', 'node_map', '.', 'parent', 'node_map', '.', 'parent', '.', 'node', '.', 'validate_parent_instance_node', '(', 'instance_node', ',', 'self', ')', 'else', 'true', 'end', '}', '.', 'include?', '(', 'false', ')', 'validations_passed', '&&', 'parent_validations_passed', 'end']
->Original Target:
['Run', 'all', 'validations', 'applied', 'to', 'this', 'node']
->Reconstructed Target:
Run all validations applied to this node
->Reconstructed Predication:
the node node.the node nodethe parent node nodethe parent node nodethe parent node nodethe parent node node
->Raw Input:
summarize:def validate_instance_node ( instance_node ) validations_passed =! self. node_validations. collect { | node_validation | node_validation. validate_instance_node ( instance_node, self ) }. include? ( false ) parent_validations_passed =! self. survey. node_maps. select { | i | i. node == self }. collect { | node_map | if node_map. parent node_map. parent. node. validate_parent_instance_node ( instance_node, self ) else true end }. include? ( false ) validations_passed && parent_validations_passed end
->Raw Target:
Run all validations applied to this node
--

723=========
->Original Input:
['def', 'instance_node_path_to_root?', '(', 'instance_node', ')', 'instance_nodes', '=', 'instance_node', '.', 'instance', '.', 'instance_nodes', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', 'if', 'self', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Answer', ')', '&&', '(', 'instance_nodes', '.', 'length', '===', '0', ')', 'return', 'false', 'end', 'if', 'self', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Question', ')', '&&', '(', 'self', '.', 'answers', '.', 'length', '===', '0', ')', '&&', '(', 'instance_nodes', '.', 'length', '===', '0', ')', 'return', 'false', 'end', 'paths', '=', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'collect', '{', '|', 'node_map', '|', 'if', 'node_map', '.', 'parent', 'node_map', '.', 'parent', '.', 'node', '.', 'instance_node_path_to_root?', '(', 'instance_node', ')', 'else', 'true', 'end', '}', 'paths', '.', 'include?', '(', 'true', ')', 'end']
->Original Target:
['Whether', 'there', 'is', 'a', 'valid', 'answer', 'path', 'from', 'this', 'node', 'to', 'the', 'root', 'node', 'for', 'the', 'instance']
->Reconstructed Target:
Whether there is a valid answer path from this node to the root node for the instance
->Reconstructed Predication:
node_path_to_root? ( instance_node )return true if instance_nodes. length. include? (true ) return false if. include? (true ) return false end
->Raw Input:
summarize:def instance_node_path_to_root? ( instance_node ) instance_nodes = instance_node. instance. instance_nodes. select { | i | i. node == self } if self. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Answer ) && ( instance_nodes. length === 0 ) return false end if self. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Question ) && ( self. answers. length === 0 ) && ( instance_nodes. length === 0 ) return false end paths = self. survey. node_maps. select { | i | i. node == self }. collect { | node_map | if node_map. parent node_map. parent. node. instance_node_path_to_root? ( instance_node ) else true end } paths. include? ( true ) end
->Raw Target:
Whether there is a valid answer path from this node to the root node for the instance
--

724=========
->Original Input:
['def', 'build_link', '(', 'to_node', ')', 'if', '!', 'to_node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Question', ')', 'raise', 'ArgumentError', '.', 'new', '"to_node must inherit from ::ActiveRecordSurvey::Node::Question"', 'end', 'if', 'self', '.', 'survey', '.', 'nil?', 'raise', 'ArgumentError', '.', 'new', '"A survey is required before calling #build_link"', 'end', 'from_node_maps', '=', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '&&', '!', 'i', '.', 'marked_for_destruction?', '}', 'if', 'from_node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'children', '.', 'length', '>', '0', '}', '.', 'length', '>', '0', 'raise', 'RuntimeError', '.', 'new', '"This node has already been linked"', 'end', 'to_node_maps', '=', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'to_node', '&&', '!', 'i', '.', 'marked_for_destruction?', '}', 'if', 'to_node_maps', '.', 'first', '.', 'nil?', 'to_node_maps', '<<', 'self', '.', 'survey', '.', 'node_maps', '.', 'build', '(', ':survey', '=>', 'self', '.', 'survey', ',', ':node', '=>', 'to_node', ')', 'end', 'to_node_map', '=', 'to_node_maps', '.', 'first', 'to_node_map', '.', 'survey', '=', 'self', '.', 'survey', 'to_node_maps', '=', 'to_node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'parent', '.', 'nil?', '}', 'while', 'to_node_maps', '.', 'length', '<', 'from_node_maps', '.', 'length', 'do', 'to_node_maps', '.', 'push', '(', 'to_node_map', '.', 'recursive_clone', ')', 'end', 'from_node_maps', '.', 'each_with_index', '{', '|', 'from_node_map', ',', 'index', '|', 'from_node_map', '.', 'children', '<<', 'to_node_maps', '[', 'index', ']', '}', 'from_node_maps', '.', 'each', '{', '|', 'node_map', '|', 'if', 'node_map', '.', 'has_infinite_loop?', 'raise', 'RuntimeError', '.', 'new', '"Infinite loop detected"', 'end', '}', 'end']
->Original Target:
['Build', 'a', 'link', 'from', 'this', 'node', 'to', 'another', 'node', 'Building', 'a', 'link', 'actually', 'needs', 'to', 'throw', 'off', 'a', 'whole', 'new', 'clone', 'of', 'all', 'children', 'nodes']
->Reconstructed Target:
Build a link from this node to another node Building a link actually needs to throw off a whole new clone of all children nodes
->Reconstructed Predication:
... children. length >.. children. length. children. length >. children. length. children. length >. children. length. children. length >. children. length. children. length. children. length >. children. length >. children. length. children. length. children. length >. children. length. children. length. children. length
->Raw Input:
summarize:def build_link ( to_node ) if! to_node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Question ) raise ArgumentError. new "to_node must inherit from ::ActiveRecordSurvey::Node::Question" end if self. survey. nil? raise ArgumentError. new "A survey is required before calling #build_link" end from_node_maps = self. survey. node_maps. select { | i | i. node == self &&! i. marked_for_destruction? } if from_node_maps. select { | i | i. children. length > 0 }. length > 0 raise RuntimeError. new "This node has already been linked" end to_node_maps = self. survey. node_maps. select { | i | i. node == to_node &&! i. marked_for_destruction? } if to_node_maps. first. nil? to_node_maps << self. survey. node_maps. build ( :survey => self. survey, :node => to_node ) end to_node_map = to_node_maps. first to_node_map. survey = self. survey to_node_maps = to_node_maps. select { | i | i. parent. nil? } while to_node_maps. length < from_node_maps. length do to_node_maps. push ( to_node_map. recursive_clone ) end from_node_maps. each_with_index { | from_node_map, index | from_node_map. children << to_node_maps [ index ] } from_node_maps. each { | node_map | if node_map. has_infinite_loop? raise RuntimeError. new "Infinite loop detected" end } end
->Raw Target:
Build a link from this node to another node Building a link actually needs to throw off a whole new clone of all children nodes
--

725=========
->Original Input:
['def', 'before_destroy_rebuild_node_map', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'each', '{', '|', 'node_map', '|', 'node_map', '.', 'children', '.', 'each', '{', '|', 'child', '|', 'node_map', '.', 'parent', '.', 'children', '<<', 'child', '}', '}', 'true', 'end']
->Original Target:
['Before', 'a', 'node', 'is', 'destroyed', 'will', 're', '-', 'build', 'the', 'node_map', 'links', 'from', 'parent', 'to', 'child', 'if', 'they', 'exist']
->Reconstructed Target:
Before a node is destroyed will re - build the node_map links from parent to child if they exist
->Reconstructed Predication:
the node map to be destroyed
->Raw Input:
summarize:def before_destroy_rebuild_node_map self. survey. node_maps. select { | i | i. node == self }. each { | node_map | node_map. children. each { | child | node_map. parent. children << child } } true end
->Raw Target:
Before a node is destroyed will re - build the node_map links from parent to child if they exist
--

726=========
->Original Input:
['def', 'validate_instance_node', '(', 'instance_node', ')', 'super', '&&', '(', 'instance_node', '.', 'value', '.', 'to_s', '.', 'empty?', '||', '!', 'instance_node', '.', 'value', '.', 'to_s', '.', 'match', '(', '/', '\\d', '\\.', '\\d', '/', ')', '.', 'nil?', ')', 'end']
->Original Target:
['Accept', 'integer', 'float', 'or', 'empty', 'values']
->Reconstructed Target:
Accept integer float or empty values
->Reconstructed Predication:
the instance node is valid
->Raw Input:
summarize:def validate_instance_node ( instance_node ) super && ( instance_node. value. to_s. empty? ||! instance_node. value. to_s. match ( / \d \. \d / ). nil? ) end
->Raw Target:
Accept integer float or empty values
--

727=========
->Original Input:
['def', 'is_answered_for_instance?', '(', 'instance', ')', 'if', 'instance_node', '=', 'self', '.', 'instance_node_for_instance', '(', 'instance', ')', '!', 'instance_node', '.', 'value', '.', 'to_s', '.', 'empty?', '&&', 'instance_node', '.', 'value', '.', 'to_i', '>=', '0', 'else', 'false', 'end', 'end']
->Original Target:
['Scale', 'answers', 'are', 'considered', 'answered', 'if', 'they', 'have', 'a', 'value', 'of', 'greater', 'than', '0']
->Reconstructed Target:
Scale answers are considered answered if they have a value of greater than 0
->Reconstructed Predication:
the answered for the given instance
->Raw Input:
summarize:def is_answered_for_instance? ( instance ) if instance_node = self. instance_node_for_instance ( instance )! instance_node. value. to_s. empty? && instance_node. value. to_i >= 0 else false end end
->Raw Target:
Scale answers are considered answered if they have a value of greater than 0
--

728=========
->Original Input:
['def', 'is_answered_for_instance?', '(', 'instance', ')', 'if', 'instance_node', '=', 'self', '.', 'instance_node_for_instance', '(', 'instance', ')', 'instance_node', '.', 'value', '.', 'to_s', '.', 'strip', '.', 'length', '>', '0', 'else', 'false', 'end', 'end']
->Original Target:
['Text', 'answers', 'are', 'considered', 'answered', 'if', 'they', 'have', 'text', 'entered']
->Reconstructed Target:
Text answers are considered answered if they have text entered
->Reconstructed Predication:
the answered for the given instance
->Raw Input:
summarize:def is_answered_for_instance? ( instance ) if instance_node = self. instance_node_for_instance ( instance ) instance_node. value. to_s. strip. length > 0 else false end end
->Raw Target:
Text answers are considered answered if they have text entered
--

729=========
->Original Input:
['def', 'recursive_clone', 'node_map', '=', 'self', '.', 'survey', '.', 'node_maps', '.', 'build', '(', ':survey', '=>', 'self', '.', 'survey', ',', ':node', '=>', 'self', '.', 'node', ')', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'parent', '==', 'self', '&&', '!', 'i', '.', 'marked_for_destruction?', '}', '.', 'each', '{', '|', 'child_node', '|', 'child_node', '.', 'survey', '=', 'self', '.', 'survey', 'node_map', '.', 'children', '<<', 'child_node', '.', 'recursive_clone', '}', 'node_map', 'end']
->Original Target:
['Recursively', 'creates', 'a', 'copy', 'of', 'this', 'entire', 'node_map']
->Reconstructed Target:
Recursively creates a copy of this entire node_map
->Reconstructed Predication:
the node. 
->Raw Input:
summarize:def recursive_clone node_map = self. survey. node_maps. build ( :survey => self. survey, :node => self. node ) self. survey. node_maps. select { | i | i. parent == self &&! i. marked_for_destruction? }. each { | child_node | child_node. survey = self. survey node_map. children << child_node. recursive_clone } node_map end
->Raw Target:
Recursively creates a copy of this entire node_map
--

730=========
->Original Input:
['def', 'ancestors_until_node_not_ancestor_of', '(', 'klass', ')', 'if', '!', 'self', '.', 'parent', '||', '!', 'self', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', 'klass', ')', 'return', '[', ']', 'end', '[', 'self', ']', '+', 'self', '.', 'parent', '.', 'ancestors_until_node_not_ancestor_of', '(', 'klass', ')', 'end']
->Original Target:
['Gets', 'all', 'the', 'ancestor', 'nodes', 'until', 'one', 'is', 'not', 'an', 'ancestor', 'of', 'klass']
->Reconstructed Target:
Gets all the ancestor nodes until one is not an ancestor of klass
->Reconstructed Predication:
the ancestors until the given node
->Raw Input:
summarize:def ancestors_until_node_not_ancestor_of ( klass ) if! self. parent ||! self. node. class. ancestors. include? ( klass ) return [ ] end [ self ] + self. parent. ancestors_until_node_not_ancestor_of ( klass ) end
->Raw Target:
Gets all the ancestor nodes until one is not an ancestor of klass
--

731=========
->Original Input:
['def', 'children_until_node_not_ancestor_of', '(', 'klass', ')', 'if', '!', 'self', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', 'klass', ')', 'return', '[', ']', 'end', '[', 'self', ']', '+', 'self', '.', 'children', '.', 'collect', '{', '|', 'i', '|', 'i', '.', 'children_until_node_not_ancestor_of', '(', 'klass', ')', '}', 'end']
->Original Target:
['Gets', 'all', 'the', 'child', 'nodes', 'until', 'one', 'is', 'not', 'an', 'ancestor', 'of', 'klass']
->Reconstructed Target:
Gets all the child nodes until one is not an ancestor of klass
->Reconstructed Predication:
children of the given class
->Raw Input:
summarize:def children_until_node_not_ancestor_of ( klass ) if! self. node. class. ancestors. include? ( klass ) return [ ] end [ self ] + self. children. collect { | i | i. children_until_node_not_ancestor_of ( klass ) } end
->Raw Target:
Gets all the child nodes until one is not an ancestor of klass
--

732=========
->Original Input:
['def', 'has_infinite_loop?', '(', 'path', '=', '[', ']', ')', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'parent', '==', 'self', '&&', '!', 'i', '.', 'marked_for_destruction?', '}', '.', 'each', '{', '|', 'i', '|', 'if', 'path', '.', 'include?', '(', 'self', '.', 'node', ')', '||', 'i', '.', 'has_infinite_loop?', '(', 'path', '.', 'clone', '.', 'push', '(', 'self', '.', 'node', ')', ')', 'return', 'true', 'end', '}', 'path', '.', 'include?', '(', 'self', '.', 'node', ')', 'end']
->Original Target:
['Check', 'to', 'see', 'whether', 'there', 'is', 'an', 'infinite', 'loop', 'from', 'this', 'node_map']
->Reconstructed Target:
Check to see whether there is an infinite loop from this node_map
->Reconstructed Predication:
node ) return true ifnode ) return false
->Raw Input:
summarize:def has_infinite_loop? ( path = [ ] ) self. survey. node_maps. select { | i | i. parent == self &&! i. marked_for_destruction? }. each { | i | if path. include? ( self. node ) || i. has_infinite_loop? ( path. clone. push ( self. node ) ) return true end } path. include? ( self. node ) end
->Raw Target:
Check to see whether there is an infinite loop from this node_map
--

733=========
->Original Input:
['def', 'validate_instance_node', '(', 'instance_node', ',', 'answer_node', '=', 'nil', ')', 'is_valid', '=', '(', '!', 'instance_node', '.', 'value', '.', 'to_s', '.', 'empty?', '&&', 'instance_node', '.', 'value', '.', 'to_f', '>=', 'self', '.', 'value', '.', 'to_f', ')', 'instance_node', '.', 'errors', '[', ':base', ']', '<<', '{', ':nodes', '=>', '{', 'answer_node', '.', 'id', '=>', '[', '"MINIMUM_VALUE"', ']', '}', '}', 'if', '!', 'is_valid', 'is_valid', 'end']
->Original Target:
['Validate', 'the', 'instance_node', 'value', 'is', 'greater', 'than', 'the', 'minimum']
->Reconstructed Target:
Validate the instance_node value is greater than the minimum
->Reconstructed Predication:
the instance node is valid
->Raw Input:
summarize:def validate_instance_node ( instance_node, answer_node = nil ) is_valid = (! instance_node. value. to_s. empty? && instance_node. value. to_f >= self. value. to_f ) instance_node. errors [ :base ] << { :nodes => { answer_node. id => [ "MINIMUM_VALUE" ] } } if! is_valid is_valid end
->Raw Target:
Validate the instance_node value is greater than the minimum
--

734=========
->Original Input:
['def', 'validate_instance_node', '(', 'instance_node', ',', 'question_node', '=', 'nil', ')', 'if', '!', 'question_node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Question', ')', 'return', 'false', 'end', 'instance', '=', 'instance_node', '.', 'instance', 'total_answered', '=', 'question_node', '.', 'node_maps', '.', 'collect', '{', '|', 'question_node_map', '|', 'question_node_map', '.', 'children', '.', 'collect', '{', '|', 'i', '|', 'i', '.', 'children_until_node_not_ancestor_of', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Answer', ')', '}', '.', 'flatten', '.', 'collect', '{', '|', 'i', '|', 'i', '.', 'node', '.', 'is_answered_for_instance?', '(', 'instance', ')', '}', '}', '.', 'flatten', '.', 'select', '{', '|', 'i', '|', 'i', '}', '.', 'count', 'is_valid', '=', '(', 'total_answered', '>=', 'self', '.', 'value', '.', 'to_i', ')', 'instance_node', '.', 'errors', '[', ':base', ']', '<<', '{', ':nodes', '=>', '{', 'question_node', '.', 'id', '=>', '[', '"MINIMUM_ANSWER"', ']', '}', '}', 'if', '!', 'is_valid', 'is_valid', 'end']
->Original Target:
['Validate', 'the', 'instance_node', 'to', 'ensure', 'a', 'minimum', 'number', 'of', 'answers', 'are', 'made']
->Reconstructed Target:
Validate the instance_node to ensure a minimum number of answers are made
->Reconstructed Predication:
:base => [ "MINIMUM_ANSWER" ]:base => [ "MINIMUM_ANSWER" ]:base => [ "MINIMUM_ANSWER" ]:base => [ "MINIMUM_ANSWER" ]:base => [ "MINIMUM_ANSWER" ]:base => [ "MINIMUM_ANSWER" ]
->Raw Input:
summarize:def validate_instance_node ( instance_node, question_node = nil ) if! question_node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Question ) return false end instance = instance_node. instance total_answered = question_node. node_maps. collect { | question_node_map | question_node_map. children. collect { | i | i. children_until_node_not_ancestor_of ( :: ActiveRecordSurvey :: Node :: Answer ) }. flatten. collect { | i | i. node. is_answered_for_instance? ( instance ) } }. flatten. select { | i | i }. count is_valid = ( total_answered >= self. value. to_i ) instance_node. errors [ :base ] << { :nodes => { question_node. id => [ "MINIMUM_ANSWER" ] } } if! is_valid is_valid end
->Raw Target:
Validate the instance_node to ensure a minimum number of answers are made
--

735=========
->Original Input:
['def', 'validate_node', '(', 'instance', ')', '!', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'collect', '{', '|', 'node_map', '|', 'node_map', '.', 'parent', '.', 'node', '.', 'validate_node', '(', 'instance', ')', '}', '.', 'include?', '(', 'false', ')', 'end']
->Original Target:
['Answer', 'nodes', 'are', 'valid', 'if', 'their', 'questions', 'are', 'valid!', 'Validate', 'this', 'node', 'against', 'an', 'instance']
->Reconstructed Target:
Answer nodes are valid if their questions are valid! Validate this node against an instance
->Reconstructed Predication:
the node.  def
->Raw Input:
summarize:def validate_node ( instance )! self. survey. node_maps. select { | i | i. node == self }. collect { | node_map | node_map. parent. node. validate_node ( instance ) }. include? ( false ) end
->Raw Target:
Answer nodes are valid if their questions are valid! Validate this node against an instance
--

736=========
->Original Input:
['def', 'question', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'collect', '{', '|', 'node_map', '|', 'if', 'node_map', '.', 'parent', '&&', 'node_map', '.', 'parent', '.', 'node', 'if', 'node_map', '.', 'parent', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Answer', ')', 'node_map', '.', 'parent', '.', 'node', '.', 'question', 'else', 'node_map', '.', 'parent', '.', 'node', 'end', 'else', 'nil', 'end', '}', '.', 'first', 'end']
->Original Target:
['Returns', 'the', 'question', 'that', 'preceeds', 'this', 'answer']
->Reconstructed Target:
Returns the question that preceeds this answer
->Reconstructed Predication:
the question of the questionthe question.
->Raw Input:
summarize:def question self. survey. node_maps. select { | i | i. node == self }. collect { | node_map | if node_map. parent && node_map. parent. node if node_map. parent. node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Answer ) node_map. parent. node. question else node_map. parent. node end else nil end }. first end
->Raw Target:
Returns the question that preceeds this answer
--

737=========
->Original Input:
['def', 'next_question', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '&&', '!', 'i', '.', 'marked_for_destruction?', '}', '.', 'each', '{', '|', 'answer_node_map', '|', 'answer_node_map', '.', 'children', '.', 'each', '{', '|', 'child', '|', 'if', '!', 'child', '.', 'node', '.', 'nil?', '&&', '!', 'child', '.', 'marked_for_destruction?', 'if', 'child', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Question', ')', 'return', 'child', '.', 'node', 'elsif', 'child', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Answer', ')', 'return', 'child', '.', 'node', '.', 'next_question', 'end', 'else', 'return', 'nil', 'end', '}', '}', 'return', 'nil', 'end']
->Original Target:
['Returns', 'the', 'question', 'that', 'follows', 'this', 'answer']
->Reconstructed Target:
Returns the question that follows this answer
->Reconstructed Predication:
the next questionthe next questionthe next questionthe next questionthe next question.
->Raw Input:
summarize:def next_question self. survey. node_maps. select { | i | i. node == self &&! i. marked_for_destruction? }. each { | answer_node_map | answer_node_map. children. each { | child | if! child. node. nil? &&! child. marked_for_destruction? if child. node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Question ) return child. node elsif child. node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Answer ) return child. node. next_question end else return nil end } } return nil end
->Raw Target:
Returns the question that follows this answer
--

738=========
->Original Input:
['def', 'remove_link', 'return', 'true', 'if', '(', 'question', '=', 'self', '.', 'next_question', ')', '.', 'nil?', 'count', '=', '0', 'to_remove', '=', '[', ']', 'self', '.', 'survey', '.', 'node_maps', '.', 'each', '{', '|', 'node_map', '|', 'if', 'node_map', '.', 'node', '==', 'question', 'if', 'count', '>', '0', 'to_remove', '.', 'concat', '(', 'node_map', '.', 'self_and_descendants', ')', 'else', 'node_map', '.', 'parent', '=', 'nil', 'node_map', '.', 'move_to_root', 'unless', 'node_map', '.', 'new_record?', 'end', 'count', '=', 'count', '+', '1', 'end', 'if', 'node_map', '.', 'node', '==', 'self', 'node_map', '.', 'children', '=', '[', ']', 'end', '}', 'self', '.', 'survey', '.', 'node_maps', '.', 'each', '{', '|', 'node_map', '|', 'if', 'to_remove', '.', 'include?', '(', 'node_map', ')', 'node_map', '.', 'parent', '=', 'nil', 'node_map', '.', 'mark_for_destruction', 'end', '}', 'end']
->Original Target:
['Removes', 'the', 'node_map', 'from', 'this', 'answer', 'to', 'its', 'next', 'question']
->Reconstructed Target:
Removes the node_map from this answer to its next question
->Reconstructed Predication:
the link to the questionthe link to the questionthe question to remove thethe link to the questionthe question to remove thethe link to the question to
->Raw Input:
summarize:def remove_link return true if ( question = self. next_question ). nil? count = 0 to_remove = [ ] self. survey. node_maps. each { | node_map | if node_map. node == question if count > 0 to_remove. concat ( node_map. self_and_descendants ) else node_map. parent = nil node_map. move_to_root unless node_map. new_record? end count = count + 1 end if node_map. node == self node_map. children = [ ] end } self. survey. node_maps. each { | node_map | if to_remove. include? ( node_map ) node_map. parent = nil node_map. mark_for_destruction end } end
->Raw Target:
Removes the node_map from this answer to its next question
--

739=========
->Original Input:
['def', 'sibling_index', 'node_maps', '=', 'self', '.', 'survey', '.', 'node_maps', 'if', 'node_map', '=', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'first', 'parent', '=', 'node_map', '.', 'parent', 'children', '=', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'parent', '&&', 'i', '.', 'parent', '.', 'node', '===', 'parent', '.', 'node', '}', 'children', '.', 'each_with_index', '{', '|', 'nm', ',', 'i', '|', 'if', 'nm', '==', 'node_map', 'return', 'i', 'end', '}', 'end', 'end']
->Original Target:
['Gets', 'index', 'in', 'sibling', 'relationship']
->Reconstructed Target:
Gets index in sibling relationship
->Reconstructed Predication:
the sibling index of the sibling
->Raw Input:
summarize:def sibling_index node_maps = self. survey. node_maps if node_map = node_maps. select { | i | i. node == self }. first parent = node_map. parent children = node_maps. select { | i | i. parent && i. parent. node === parent. node } children. each_with_index { | nm, i | if nm == node_map return i end } end end
->Raw Target:
Gets index in sibling relationship
--

740=========
->Original Input:
['def', 'move_up', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'collect', '{', '|', 'node_map', '|', 'begin', 'node_map', '.', 'move_left', 'rescue', 'end', '}', 'end']
->Original Target:
['Moves', 'answer', 'up', 'relative', 'to', 'other', 'answers']
->Reconstructed Target:
Moves answer up relative to other answers
->Reconstructed Predication:
 def move_up_all_node_maps
->Raw Input:
summarize:def move_up self. survey. node_maps. select { | i | i. node == self }. collect { | node_map | begin node_map. move_left rescue end } end
->Raw Target:
Moves answer up relative to other answers
--

741=========
->Original Input:
['def', 'move_down', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'collect', '{', '|', 'node_map', '|', 'begin', 'node_map', '.', 'move_right', 'rescue', 'end', '}', 'end']
->Original Target:
['Moves', 'answer', 'down', 'relative', 'to', 'other', 'answers']
->Reconstructed Target:
Moves answer down relative to other answers
->Reconstructed Predication:
 def move_down_from_right_to_left_to_right_to_right_to_right_to_right_to_right_to_right_to_right_to_right_to_right_to_right_to_right_to_right_to_right_to_left_to_right_to_right_to_right_to_right_to_right_to_left_to_right
->Raw Input:
summarize:def move_down self. survey. node_maps. select { | i | i. node == self }. collect { | node_map | begin node_map. move_right rescue end } end
->Raw Target:
Moves answer down relative to other answers
--

742=========
->Original Input:
['def', 'validate_instance_node', '(', 'instance_node', ')', 'super', '&&', '(', 'instance_node', '.', 'value', '.', 'to_s', '.', 'empty?', '||', '!', 'instance_node', '.', 'value', '.', 'to_s', '.', 'match', '(', '/', '\\d', '/', ')', '.', 'nil?', ')', '&&', '(', 'instance_node', '.', 'value', '.', 'to_s', '.', 'empty?', '||', 'instance_node', '.', 'value', '.', 'to_i', '>=', '1', ')', '&&', 'instance_node', '.', 'value', '.', 'to_i', '<=', 'self', '.', 'max_rank', 'end']
->Original Target:
['Accept', 'integer', 'or', 'empty', 'values', 'Must', 'be', 'within', 'range', 'of', 'the', 'number', 'of', 'ranking', 'nodes']
->Reconstructed Target:
Accept integer or empty values Must be within range of the number of ranking nodes
->Reconstructed Predication:
the node is valid for thethe node is valid for the
->Raw Input:
summarize:def validate_instance_node ( instance_node ) super && ( instance_node. value. to_s. empty? ||! instance_node. value. to_s. match ( / \d / ). nil? ) && ( instance_node. value. to_s. empty? || instance_node. value. to_i >= 1 ) && instance_node. value. to_i <= self. max_rank end
->Raw Target:
Accept integer or empty values Must be within range of the number of ranking nodes
--

743=========
->Original Input:
['def', 'num_above', 'count', '=', '0', 'self', '.', 'node_maps', '.', 'each', '{', '|', 'i', '|', 'if', 'i', '.', 'parent', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', 'self', '.', 'class', ')', 'count', '=', 'count', '+', '1', '+', 'i', '.', 'parent', '.', 'node', '.', 'num_above', 'end', '}', 'count', 'end']
->Original Target:
['Calculate', 'the', 'number', 'of', 'Rank', 'nodes', 'above', 'this', 'one']
->Reconstructed Target:
Calculate the number of Rank nodes above this one
->Reconstructed Predication:
the number of nodes above
->Raw Input:
summarize:def num_above count = 0 self. node_maps. each { | i | if i. parent. node. class. ancestors. include? ( self. class ) count = count + 1 + i. parent. node. num_above end } count end
->Raw Target:
Calculate the number of Rank nodes above this one
--

744=========
->Original Input:
['def', 'num_below', 'count', '=', '0', 'self', '.', 'node_maps', '.', 'each', '{', '|', 'node_map', '|', 'node_map', '.', 'children', '.', 'each', '{', '|', 'child', '|', 'if', 'child', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', 'self', '.', 'class', ')', 'count', '=', 'count', '+', '1', '+', 'child', '.', 'node', '.', 'num_below', 'end', '}', '}', 'count', 'end']
->Original Target:
['Calculate', 'the', 'number', 'of', 'Rank', 'nodes', 'below', 'this', 'one']
->Reconstructed Target:
Calculate the number of Rank nodes below this one
->Reconstructed Predication:
the number of ancestors below
->Raw Input:
summarize:def num_below count = 0 self. node_maps. each { | node_map | node_map. children. each { | child | if child. node. class. ancestors. include? ( self. class ) count = count + 1 + child. node. num_below end } } count end
->Raw Target:
Calculate the number of Rank nodes below this one
--

745=========
->Original Input:
['def', 'validate_instance_node', '(', 'instance_node', ',', 'answer_node', '=', 'nil', ')', 'is_valid', '=', '(', 'self', '.', 'value', '.', 'to_i', '>=', 'instance_node', '.', 'value', '.', 'to_s', '.', 'length', '.', 'to_i', ')', 'instance_node', '.', 'errors', '[', ':base', ']', '<<', '{', ':nodes', '=>', '{', 'answer_node', '.', 'id', '=>', '[', '"MAXIMUM_LENGTH"', ']', '}', '}', 'if', '!', 'is_valid', 'is_valid', 'end']
->Original Target:
['Validate', 'the', 'instance_node', 'value']
->Reconstructed Target:
Validate the instance_node value
->Reconstructed Predication:
the instance node is valid
->Raw Input:
summarize:def validate_instance_node ( instance_node, answer_node = nil ) is_valid = ( self. value. to_i >= instance_node. value. to_s. length. to_i ) instance_node. errors [ :base ] << { :nodes => { answer_node. id => [ "MAXIMUM_LENGTH" ] } } if! is_valid is_valid end
->Raw Target:
Validate the instance_node value
--

746=========
->Original Input:
['def', 'build_first_question', '(', 'question_node', ')', 'if', '!', 'question_node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Question', ')', 'raise', 'ArgumentError', '.', 'new', '"must inherit from ::ActiveRecordSurvey::Node::Question"', 'end', 'question_node_maps', '=', 'self', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'question_node', '&&', '!', 'i', '.', 'marked_for_destruction?', '}', 'if', 'question_node_maps', '.', 'length', '===', '0', 'question_node_maps', '<<', 'self', '.', 'node_maps', '.', 'build', '(', ':node', '=>', 'question_node', ',', ':survey', '=>', 'self', ')', 'end', 'end']
->Original Target:
['Builds', 'first', 'question']
->Reconstructed Target:
Builds first question
->Reconstructed Predication:
the first question that isthe first question that isthe first question that isthe first question that isthe first question that isthe first question that is
->Raw Input:
summarize:def build_first_question ( question_node ) if! question_node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Question ) raise ArgumentError. new "must inherit from ::ActiveRecordSurvey::Node::Question" end question_node_maps = self. node_maps. select { | i | i. node == question_node &&! i. marked_for_destruction? } if question_node_maps. length === 0 question_node_maps << self. node_maps. build ( :node => question_node, :survey => self ) end end
->Raw Target:
Builds first question
--

747=========
->Original Input:
['def', 'edges', 'self', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', '!', 'i', '.', 'marked_for_destruction?', '}', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '&&', 'i', '.', 'parent', '}', '.', 'collect', '{', '|', 'i', '|', '{', ':source', '=>', 'i', '.', 'parent', '.', 'node', '.', 'id', ',', ':target', '=>', 'i', '.', 'node', '.', 'id', ',', '}', '}', '.', 'uniq', 'end']
->Original Target:
['All', 'the', 'connective', 'edges']
->Reconstructed Target:
All the connective edges
->Reconstructed Predication:
the edges of the nodes
->Raw Input:
summarize:def edges self. node_maps. select { | i |! i. marked_for_destruction? }. select { | i | i. node && i. parent }. collect { | i | { :source => i. parent. node. id, :target => i. node. id, } }. uniq end
->Raw Target:
All the connective edges
--

748=========
->Original Input:
['def', 'validate_parent_instance_node', '(', 'instance_node', ',', 'child_node', ')', '!', 'self', '.', 'node_validations', '.', 'collect', '{', '|', 'node_validation', '|', 'node_validation', '.', 'validate_instance_node', '(', 'instance_node', ',', 'self', ')', '}', '.', 'include?', '(', 'false', ')', 'end']
->Original Target:
['Stop', 'validating', 'at', 'the', 'Question', 'node']
->Reconstructed Target:
Stop validating at the Question node
->Reconstructed Predication:
the child node that the child
->Raw Input:
summarize:def validate_parent_instance_node ( instance_node, child_node )! self. node_validations. collect { | node_validation | node_validation. validate_instance_node ( instance_node, self ) }. include? ( false ) end
->Raw Target:
Stop validating at the Question node
--

749=========
->Original Input:
['def', 'update_question_type', '(', 'klass', ')', 'if', 'self', '.', 'next_questions', '.', 'length', '>', '0', 'raise', 'RuntimeError', '.', 'new', '"No questions can follow when changing the question type"', 'end', 'nm', '=', 'self', '.', 'survey', '.', 'node_maps', 'answers', '=', 'self', '.', 'answers', '.', 'collect', '{', '|', 'answer', '|', 'nm', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'answer', '}', '}', '.', 'flatten', '.', 'uniq', '.', 'collect', '{', '|', 'answer_node_map', '|', 'node', '=', 'answer_node_map', '.', 'node', 'answer_node_map', '.', 'send', '(', '(', 'answer_node_map', '.', 'new_record?', ')', '?', ':destroy', ':', ':mark_for_destruction', ')', 'node', '}', '.', 'collect', '{', '|', 'answer', '|', 'answer', '.', 'type', '=', 'klass', '.', 'to_s', 'answer', '=', 'answer', '.', 'becomes', '(', 'klass', ')', 'answer', '.', 'save', 'if', '!', 'answer', '.', 'new_record?', 'answer', '}', '.', 'uniq', 'answers', '.', 'each', '{', '|', 'answer', '|', 'answer', '.', 'survey', '=', 'self', '.', 'survey', 'self', '.', 'build_answer', '(', 'answer', ')', '}', 'end']
->Original Target:
['Updates', 'the', 'answers', 'of', 'this', 'question', 'to', 'a', 'different', 'type']
->Reconstructed Target:
Updates the answers of this question to a different type
->Reconstructed Predication:
the question typethe question typethe question typethe question typethe question typethe question typethe questionthe question typethe question typethe question typethe question typethe question typethe question type is thethe question typethe question type is thethe question typethe question type is thethe question typethe question typethe question typethe question typethe question typethe question type
->Raw Input:
summarize:def update_question_type ( klass ) if self. next_questions. length > 0 raise RuntimeError. new "No questions can follow when changing the question type" end nm = self. survey. node_maps answers = self. answers. collect { | answer | nm. select { | i | i. node == answer } }. flatten. uniq. collect { | answer_node_map | node = answer_node_map. node answer_node_map. send ( ( answer_node_map. new_record? )? :destroy : :mark_for_destruction ) node }. collect { | answer | answer. type = klass. to_s answer = answer. becomes ( klass ) answer. save if! answer. new_record? answer }. uniq answers. each { | answer | answer. survey = self. survey self. build_answer ( answer ) } end
->Raw Target:
Updates the answers of this question to a different type
--

750=========
->Original Input:
['def', 'remove_answer', '(', 'answer_node', ')', 'if', 'self', '.', 'survey', '.', 'nil?', 'raise', 'ArgumentError', '.', 'new', '"A survey must be passed if ActiveRecordSurvey::Node::Question is not yet added to a survey"', 'end', 'if', '!', 'answer_node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Answer', ')', 'raise', 'ArgumentError', '.', 'new', '"::ActiveRecordSurvey::Node::Answer not passed"', 'end', 'if', '!', 'self', '.', 'answers', '.', 'include?', '(', 'answer_node', ')', 'raise', 'ArgumentError', '.', 'new', '"Answer not linked to question"', 'end', 'answer_node', '.', 'send', '(', ':remove_answer', ',', 'self', ')', 'end']
->Original Target:
['Removes', 'an', 'answer']
->Reconstructed Target:
Removes an answer
->Reconstructed Predication:
Answer to be removed fromthe answer to be removed"
->Raw Input:
summarize:def remove_answer ( answer_node ) if self. survey. nil? raise ArgumentError. new "A survey must be passed if ActiveRecordSurvey::Node::Question is not yet added to a survey" end if! answer_node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Answer ) raise ArgumentError. new "::ActiveRecordSurvey::Node::Answer not passed" end if! self. answers. include? ( answer_node ) raise ArgumentError. new "Answer not linked to question" end answer_node. send ( :remove_answer, self ) end
->Raw Target:
Removes an answer
--

751=========
->Original Input:
['def', 'build_answer', '(', 'answer_node', ')', 'if', 'self', '.', 'survey', '.', 'nil?', 'raise', 'ArgumentError', '.', 'new', '"A survey must be passed if ActiveRecordSurvey::Node::Question is not yet added to a survey"', 'end', 'if', '!', 'self', '.', 'answers', '.', 'select', '{', '|', 'answer', '|', 'answer', '.', 'class', '!=', 'answer_node', '.', 'class', '}', '.', 'empty?', 'raise', 'ArgumentError', '.', 'new', '"Cannot mix answer types on question"', 'end', 'if', 'answer_node', '.', 'send', '(', ':build_answer', ',', 'self', ')', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'answer_node', '&&', '!', 'i', '.', 'marked_for_destruction?', '}', '.', 'each', '{', '|', 'answer_node_map', '|', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'j', '|', '!', 'j', '.', 'marked_for_destruction?', '&&', 'j', '.', 'parent', '==', 'answer_node_map', '.', 'parent', '&&', 'j', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Question', ')', '}', '.', 'each', '{', '|', 'j', '|', 'answer_node_map', '.', 'survey', '=', 'self', '.', 'survey', 'j', '.', 'survey', '=', 'self', '.', 'survey', 'answer_node_map', '.', 'children', '<<', 'j', '}', '}', 'true', 'end', 'end']
->Original Target:
['Build', 'an', 'answer', 'off', 'this', 'node']
->Reconstructed Target:
Build an answer off this node
->Reconstructed Predication:
the answerthe answerthe answerthe answerthe answer nodethe answer nodethe answer nodethethe answer nodethe answer nodethe answer nodethe answer nodethe answer node. The answer nodethe answer node isthe answer node. The answer nodethe answer node isthe answer node isthethe answer node. Thethe answer node isthe answer node isthe answer node is the
->Raw Input:
summarize:def build_answer ( answer_node ) if self. survey. nil? raise ArgumentError. new "A survey must be passed if ActiveRecordSurvey::Node::Question is not yet added to a survey" end if! self. answers. select { | answer | answer. class!= answer_node. class }. empty? raise ArgumentError. new "Cannot mix answer types on question" end if answer_node. send ( :build_answer, self ) self. survey. node_maps. select { | i | i. node == answer_node &&! i. marked_for_destruction? }. each { | answer_node_map | self. survey. node_maps. select { | j |! j. marked_for_destruction? && j. parent == answer_node_map. parent && j. node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Question ) }. each { | j | answer_node_map. survey = self. survey j. survey = self. survey answer_node_map. children << j } } true end end
->Raw Target:
Build an answer off this node
--

752=========
->Original Input:
['def', 'remove_link', 'return', 'true', 'if', '(', 'questions', '=', 'self', '.', 'next_questions', ')', '.', 'length', '===', '0', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'each', '{', '|', 'node_map', '|', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'j', '|', 'node_map', '.', 'children', '.', 'include?', '(', 'j', ')', '}', '.', 'each', '{', '|', 'child', '|', 'if', 'child', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Question', ')', 'child', '.', 'parent', '=', 'nil', 'child', '.', 'send', '(', '(', 'child', '.', 'new_record?', ')', '?', ':destroy', ':', ':mark_for_destruction', ')', 'end', '}', '}', 'self', '.', 'answers', '.', 'collect', '{', '|', 'i', '|', 'i', '.', 'remove_link', '}', 'end']
->Original Target:
['Removes', 'the', 'node_map', 'link', 'from', 'this', 'question', 'all', 'of', 'its', 'next', 'questions']
->Reconstructed Target:
Removes the node_map link from this question all of its next questions
->Reconstructed Predication:
thethe link to thethe link to thethe link to thethe link to thethe link to the link to
->Raw Input:
summarize:def remove_link return true if ( questions = self. next_questions ). length === 0 self. survey. node_maps. select { | i | i. node == self }. each { | node_map | self. survey. node_maps. select { | j | node_map. children. include? ( j ) }. each { | child | if child. node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Question ) child. parent = nil child. send ( ( child. new_record? )? :destroy : :mark_for_destruction ) end } } self. answers. collect { | i | i. remove_link } end
->Raw Target:
Removes the node_map link from this question all of its next questions
--

753=========
->Original Input:
['def', 'before_destroy_rebuild_node_map', 'self', '.', 'survey', '.', 'node_maps', '.', 'select', '{', '|', 'i', '|', 'i', '.', 'node', '==', 'self', '}', '.', 'each', '{', '|', 'node_map', '|', 'node_map', '.', 'children', '.', 'each', '{', '|', 'child', '|', 'if', '!', 'child', '.', 'node', '.', 'class', '.', 'ancestors', '.', 'include?', '(', '::', 'ActiveRecordSurvey', '::', 'Node', '::', 'Answer', ')', 'node_map', '.', 'parent', '.', 'children', '<<', 'child', 'end', '}', '}', 'true', 'end']
->Original Target:
['Before', 'a', 'node', 'is', 'destroyed', 'will', 're', '-', 'build', 'the', 'node_map', 'links', 'from', 'parent', 'to', 'child', 'if', 'they', 'exist', 'If', 'a', 'question', 'is', 'being', 'destroyed', 'and', 'it', 'has', 'answers', '-', 'don', 't', 'link', 'its', 'answers', '-', 'only', 'parent', 'questions', 'that', 'follow', 'it']
->Reconstructed Target:
Before a node is destroyed will re - build the node_map links from parent to child if they exist If a question is being destroyed and it has answers - don t link its answers - only parent questions that follow it
->Reconstructed Predication:
the node map to be destroyed
->Raw Input:
summarize:def before_destroy_rebuild_node_map self. survey. node_maps. select { | i | i. node == self }. each { | node_map | node_map. children. each { | child | if! child. node. class. ancestors. include? ( :: ActiveRecordSurvey :: Node :: Answer ) node_map. parent. children << child end } } true end
->Raw Target:
Before a node is destroyed will re - build the node_map links from parent to child if they exist If a question is being destroyed and it has answers - don t link its answers - only parent questions that follow it
--

754=========
->Original Input:
['def', 'table_for', '(', 'collection', ',', '*', 'args', ',', '&', 'block', ')', 'block', '=', 'Tabletastic', '.', 'default_table_block', 'unless', 'block_given?', 'klass', '=', 'default_class_for', '(', 'collection', ')', 'options', '=', 'args', '.', 'extract_options!', 'initialize_html_options', '(', 'options', ',', 'klass', ')', 'result', '=', 'capture', '{', 'block', '.', 'call', '(', 'TableBuilder', '.', 'new', '(', 'collection', ',', 'klass', ',', 'self', ')', ')', '}', 'content_tag', '(', ':table', ',', 'result', ',', 'options', '[', ':html', ']', ')', 'end']
->Original Target:
['returns', 'and', 'outputs', 'a', 'table', 'for', 'the', 'given', 'active', 'record', 'collection']
->Reconstructed Target:
returns and outputs a table for the given active record collection
->Reconstructed Predication:
table for collection
->Raw Input:
summarize:def table_for ( collection, * args, & block ) block = Tabletastic. default_table_block unless block_given? klass = default_class_for ( collection ) options = args. extract_options! initialize_html_options ( options, klass ) result = capture { block. call ( TableBuilder. new ( collection, klass, self ) ) } content_tag ( :table, result, options [ :html ] ) end
->Raw Target:
returns and outputs a table for the given active record collection
--

755=========
->Original Input:
['def', 'default_class_for', '(', 'collection', ')', 'if', 'collection', '.', 'respond_to?', '(', ':klass', ')', 'collection', '.', 'klass', 'elsif', '!', 'collection', '.', 'empty?', 'collection', '.', 'first', '.', 'class', 'end', 'end']
->Original Target:
['Finds', 'the', 'class', 'representing', 'the', 'objects', 'within', 'the', 'collection']
->Reconstructed Target:
Finds the class representing the objects within the collection
->Reconstructed Predication:
the default class for the given
->Raw Input:
summarize:def default_class_for ( collection ) if collection. respond_to? ( :klass ) collection. klass elsif! collection. empty? collection. first. class end end
->Raw Target:
Finds the class representing the objects within the collection
--

756=========
->Original Input:
['def', 'events_for_targets', '(', '*', 'list', ')', 'found_events', '=', 'Array', '(', 'list', ')', '.', 'flatten', '.', 'compact', '.', 'map', '{', '|', 's', '|', 'events_for_target', '(', 's', ')', '}', '.', 'flatten', '.', 'compact', 'found_events', 'end']
->Original Target:
['Return', 'all', 'the', 'events', 'for', 'all', 'the', 'specified', 'targets', '.']
->Reconstructed Target:
Return all the events for all the specified targets.
->Reconstructed Predication:
the events for the given targets
->Raw Input:
summarize:def events_for_targets ( * list ) found_events = Array ( list ). flatten. compact. map { | s | events_for_target ( s ) }. flatten. compact found_events end
->Raw Target:
Return all the events for all the specified targets.
--

757=========
->Original Input:
['def', 'writer', '@writer', '||=', 'begin', 'writer_matching_existing_parser', '=', 'supported_writers', '.', 'find', '{', '|', 'writer', '|', 'writer', '.', 'format', '==', 'format', '}', 'writer_matching_existing_parser', '||', 'default_writer', 'end', 'end']
->Original Target:
['The', 'writer', 'for', 'this', 'view', '.', 'If', 'the', 'view', 'has', 'already', 'been', 'parsed', 'then', 'use']
->Reconstructed Target:
The writer for this view. If the view has already been parsed then use
->Reconstructed Predication:
writer.
->Raw Input:
summarize:def writer @writer ||= begin writer_matching_existing_parser = supported_writers. find { | writer | writer. format == format } writer_matching_existing_parser || default_writer end end
->Raw Target:
The writer for this view. If the view has already been parsed then use
--

758=========
->Original Input:
['def', 'animate', '(', 'actor_or_actor_name', ',', 'options', ',', '&', 'block', ')', 'options', '[', ':actor', ']', '=', 'actor', '(', 'actor_or_actor_name', ')', 'options', '[', ':context', ']', '=', 'self', 'animation_group', '=', 'SceneAnimation', '.', 'build', 'options', ',', '&', 'block', 'enqueue', 'animation_group', 'end']
->Original Target:
['Define', 'an', 'animation', 'from', 'within', 'another', 'animation', 'block', 'an', 'event', 'block', 'or', 'a', 'method', '.']
->Reconstructed Target:
Define an animation from within another animation block an event block or a method.
->Reconstructed Predication:
the animation group.
->Raw Input:
summarize:def animate ( actor_or_actor_name, options, & block ) options [ :actor ] = actor ( actor_or_actor_name ) options [ :context ] = self animation_group = SceneAnimation. build options, & block enqueue animation_group end
->Raw Target:
Define an animation from within another animation block an event block or a method.
--

759=========
->Original Input:
['def', 'on_mouse_movement', '(', '*', 'args', ',', '&', 'block', ')', 'options', '=', '(', 'args', '.', 'last', '.', 'is_a?', '(', 'Hash', ')', '?', 'args', '.', 'pop', ':', '{', '}', ')', '@mouse_movement_actions', '<<', '(', 'block', '||', 'lambda', '{', '|', 'instance', '|', 'send', '(', 'options', '[', ':do', ']', ')', '}', ')', 'end']
->Original Target:
['Register', 'for', 'mouse', 'movements', 'events', '.', 'These', 'events', 'are', 'fired', 'each', 'update', 'providing', 'an', 'event', 'which', 'contains', 'the', 'current', 'position', 'of', 'the', 'mouse', '.']
->Reconstructed Target:
Register for mouse movements events. These events are fired each update providing an event which contains the current position of the mouse.
->Reconstructed Predication:
the mouse movement action.
->Raw Input:
summarize:def on_mouse_movement ( * args, & block ) options = ( args. last. is_a? ( Hash )? args. pop : { } ) @mouse_movement_actions << ( block || lambda { | instance | send ( options [ :do ] ) } ) end
->Raw Target:
Register for mouse movements events. These events are fired each update providing an event which contains the current position of the mouse.
--

760=========
->Original Input:
['def', 'notification', '(', 'param', ',', '&', 'block', ')', 'custom_notifications', '[', 'param', '.', 'to_sym', ']', '=', 'custom_notifications', '[', 'param', '.', 'to_sym', ']', '+', '[', 'block', ']', 'end']
->Original Target:
['Register', 'for', 'a', 'custom', 'notification', 'event', '.', 'These', 'events', 'are', 'fired', 'when', 'another', 'object', 'within', 'the', 'game', 'posts', 'a', 'notification', 'with', 'matching', 'criteria', '.', 'If', 'there', 'has', 'indeed', 'been', 'a', 'match', 'then', 'the', 'stored', 'action', 'block', 'will', 'be', 'fired', '.']
->Reconstructed Target:
Register for a custom notification event. These events are fired when another object within the game posts a notification with matching criteria. If there has indeed been a match then the stored action block will be fired.
->Reconstructed Predication:
the notification to be displayed
->Raw Input:
summarize:def notification ( param, & block ) custom_notifications [ param. to_sym ] = custom_notifications [ param. to_sym ] + [ block ] end
->Raw Target:
Register for a custom notification event. These events are fired when another object within the game posts a notification with matching criteria. If there has indeed been a match then the stored action block will be fired.
--

761=========
->Original Input:
['def', 'fire_events_for_held_buttons', 'held_actions', '.', 'each', 'do', '|', 'key', ',', 'action', '|', 'execute_block_for_target', '(', '&', 'action', ')', 'if', 'window', 'and', 'window', '.', 'button_down?', '(', 'key', ')', 'end', 'end']
->Original Target:
['Fire', 'the', 'events', 'mapped', 'to', 'the', 'held', 'buttons', 'within', 'the', 'context', 'of', 'the', 'specified', 'target', '.', 'This', 'method', 'is', 'differently', 'formatted', 'because', 'held', 'buttons', 'are', 'not', 'events', 'but', 'polling', 'to', 'see', 'if', 'the', 'button', 'is', 'still', 'being', 'held', '.']
->Reconstructed Target:
Fire the events mapped to the held buttons within the context of the specified target. This method is differently formatted because held buttons are not events but polling to see if the button is still being held.
->Reconstructed Predication:
the event to fire for the
->Raw Input:
summarize:def fire_events_for_held_buttons held_actions. each do | key, action | execute_block_for_target ( & action ) if window and window. button_down? ( key ) end end
->Raw Target:
Fire the events mapped to the held buttons within the context of the specified target. This method is differently formatted because held buttons are not events but polling to see if the button is still being held.
--

762=========
->Original Input:
['def', 'fire_events_for_notification', '(', 'event', ',', 'sender', ')', 'notification_actions', '=', 'custom_notifications', '[', 'event', ']', 'notification_actions', '.', 'each', 'do', '|', 'action', '|', '_fire_event_for_notification', '(', 'event', ',', 'sender', ',', 'action', ')', 'end', 'end']
->Original Target:
['Fire', 'all', 'events', 'mapped', 'to', 'the', 'matching', 'notification', '.']
->Reconstructed Target:
Fire all events mapped to the matching notification.
->Reconstructed Predication:
the event to fire for the
->Raw Input:
summarize:def fire_events_for_notification ( event, sender ) notification_actions = custom_notifications [ event ] notification_actions. each do | action | _fire_event_for_notification ( event, sender, action ) end end
->Raw Target:
Fire all events mapped to the matching notification.
--

763=========
->Original Input:
['def', '_fire_event_for_notification', '(', 'event', ',', 'sender', ',', 'action', ')', 'if', 'action', '.', 'arity', '==', '2', 'target', '.', 'instance_exec', '(', 'sender', ',', 'event', ',', '&', 'action', ')', 'elsif', 'action', '.', 'arity', '==', '1', 'target', '.', 'instance_exec', '(', 'sender', ',', '&', 'action', ')', 'else', 'target', '.', 'instance_eval', '(', '&', 'action', ')', 'end', 'end']
->Original Target:
['Fire', 'a', 'single', 'event', 'based', 'on', 'the', 'matched', 'notification', '.']
->Reconstructed Target:
Fire a single event based on the matched notification.
->Reconstructed Predication:
the event to fire for the
->Raw Input:
summarize:def _fire_event_for_notification ( event, sender, action ) if action. arity == 2 target. instance_exec ( sender, event, & action ) elsif action. arity == 1 target. instance_exec ( sender, & action ) else target. instance_eval ( & action ) end end
->Raw Target:
Fire a single event based on the matched notification.
--

764=========
->Original Input:
['def', 'add', '(', 'model', ')', 'all_models_for', '(', 'model', ')', '.', 'each', 'do', '|', 'model', '|', 'models_hash', '[', 'model', '.', 'to_s', ']', '=', 'model', '.', 'to_s', 'name_with_slashes', '=', 'model', '.', 'model_name', 'models_hash', '[', 'name_with_slashes', ']', '=', 'model', '.', 'to_s', 'name_with_colons', '=', 'name_with_slashes', '.', 'gsub', '(', "'/'", ',', "'::'", ')', 'models_hash', '[', 'name_with_colons', ']', '=', 'model', '.', 'to_s', 'end', 'end']
->Original Target:
['Add', 'a', 'model', 'and', 'all', 'it', 's', 'subclasses', 'to', 'the', 'list', 'of', 'available', 'models', '.']
->Reconstructed Target:
Add a model and all it s subclasses to the list of available models.
->Reconstructed Predication:
the model to the collection
->Raw Input:
summarize:def add ( model ) all_models_for ( model ). each do | model | models_hash [ model. to_s ] = model. to_s name_with_slashes = model. model_name models_hash [ name_with_slashes ] = model. to_s name_with_colons = name_with_slashes. gsub ( '/', '::' ) models_hash [ name_with_colons ] = model. to_s end end
->Raw Target:
Add a model and all it s subclasses to the list of available models.
--

765=========
->Original Input:
['def', 'after_initialize', 'to', '.', 'each', 'do', '|', 'attribute', ',', 'final', '|', 'start', '=', 'actor', '.', 'send', '(', 'attribute', ')', 'animations', '.', 'push', 'build_animation_step', '(', 'attribute', ',', 'start', ',', 'final', ')', 'end', 'end']
->Original Target:
['Additional', 'initializion', 'is', 'required', 'to', 'calculate', 'the', 'attributes', 'that', 'are', 'going', 'to', 'be', 'animated', 'and', 'to', 'determine', 'each', 'of', 'their', 'deltas', '.']
->Reconstructed Target:
Additional initializion is required to calculate the attributes that are going to be animated and to determine each of their deltas.
->Reconstructed Predication:
the animation to be applied to
->Raw Input:
summarize:def after_initialize to. each do | attribute, final | start = actor. send ( attribute ) animations. push build_animation_step ( attribute, start, final ) end end
->Raw Target:
Additional initializion is required to calculate the attributes that are going to be animated and to determine each of their deltas.
--

766=========
->Original Input:
['def', 'fire_events_for_notification', '(', 'event', ',', 'sender', ')', 'current_state', '.', 'each', '{', '|', 'cs', '|', 'cs', '.', 'fire_events_for_notification', '(', 'event', ',', 'sender', ')', '}', 'end']
->Original Target:
['Fire', 'notification', 'events', 'within', 'the', 'current', 'game', 'state']
->Reconstructed Target:
Fire notification events within the current game state
->Reconstructed Predication:
 def fire_events_for_notification ( event
->Raw Input:
summarize:def fire_events_for_notification ( event, sender ) current_state. each { | cs | cs. fire_events_for_notification ( event, sender ) } end
->Raw Target:
Fire notification events within the current game state
--

767=========
->Original Input:
['def', 'add_events_for_target', '(', 'target', ',', 'events', ')', 'relay', '=', 'EventRelay', '.', 'new', '(', 'target', ',', 'window', ')', 'events', '.', 'each', 'do', '|', 'target_event', '|', 'relay', '.', 'send', 'target_event', '.', 'event', ',', '*', 'target_event', '.', 'buttons', ',', '&', 'target_event', '.', 'block', 'end', 'current_state', '.', 'push', 'relay', 'end']
->Original Target:
['An', 'an', 'event', 'relay', 'to', 'the', 'current', 'game', 'state']
->Reconstructed Target:
An an event relay to the current game state
->Reconstructed Predication:
the events to the target
->Raw Input:
summarize:def add_events_for_target ( target, events ) relay = EventRelay. new ( target, window ) events. each do | target_event | relay. send target_event. event, * target_event. buttons, & target_event. block end current_state. push relay end
->Raw Target:
An an event relay to the current game state
--

768=========
->Original Input:
['def', 'method_missing', '(', 'name', ',', '*', 'params', ',', '&', 'block', ')', 'options', '=', 'params', '.', 'find', '{', '|', 'param', '|', 'param', '.', 'is_a?', 'Hash', '}', 'define_control', '(', 'name', ',', 'options', ')', 'end']
->Original Target:
['Creation', 'through', 'controls', 'is', 'usually', 'done', 'with', 'an', 'instance_eval', 'of', 'a', 'block', 'and', 'this', 'allows', 'for', 'a', 'flexible', 'interface', '.']
->Reconstructed Target:
Creation through controls is usually done with an instance_eval of a block and this allows for a flexible interface.
->Reconstructed Predication:
the control to be used for
->Raw Input:
summarize:def method_missing ( name, * params, & block ) options = params. find { | param | param. is_a? Hash } define_control ( name, options ) end
->Raw Target:
Creation through controls is usually done with an instance_eval of a block and this allows for a flexible interface.
--

769=========
->Original Input:
['def', 'start!', '@window', '=', 'Window', '.', 'new', 'width', ',', 'height', ',', 'fullscreen?', 'window', '.', 'caption', '=', 'name', 'window', '.', 'scene', '=', 'Scenes', '.', 'generate', '(', 'first_scene', ')', 'window', '.', 'show', 'end']
->Original Target:
['Creates', 'a', 'window', 'and', 'starts', 'the', 'game', 'with', 'the', 'game', 'parameters', '.']
->Reconstructed Target:
Creates a window and starts the game with the game parameters.
->Reconstructed Predication:
 def show
->Raw Input:
summarize:def start! @window = Window. new width, height, fullscreen? window. caption = name window. scene = Scenes. generate ( first_scene ) window. show end
->Raw Target:
Creates a window and starts the game with the game parameters.
--

770=========
->Original Input:
['def', 'show', 'rectangle', '.', 'color', '=', 'starting_color', 'color', '=', 'final_color', 'animate', ':rectangle', ',', 'to', ':', '{', 'red', ':', 'color', '.', 'red', ',', 'green', ':', 'color', '.', 'green', ',', 'blue', ':', 'color', '.', 'blue', ',', 'alpha', ':', 'color', '.', 'alpha', '}', ',', 'interval', ':', 'interval', 'do', 'transition_to', 'next_scene', 'end', 'end']
->Original Target:
['When', 'the', 'scene', 'is', 'shown', 'set', 'up', 'the', 'starting', 'color', 'for', 'the', 'rectangle', 'and', 'queue', 'the', 'animation', 'to', 'transition', 'the', 'color', 'to', 'the', 'final', 'color', '.']
->Reconstructed Target:
When the scene is shown set up the starting color for the rectangle and queue the animation to transition the color to the final color.
->Reconstructed Predication:
show rectangle.  def show_rectangle
->Raw Input:
summarize:def show rectangle. color = starting_color color = final_color animate :rectangle, to : { red : color. red, green : color. green, blue : color. blue, alpha : color. alpha }, interval : interval do transition_to next_scene end end
->Raw Target:
When the scene is shown set up the starting color for the rectangle and queue the animation to transition the color to the final color.
--

771=========
->Original Input:
['def', 'data', '(', '*', 'args', ',', '&', 'block', ')', 'options', '=', 'args', '.', 'extract_options!', 'if', 'block_given?', 'yield', 'self', 'else', '@table_fields', '=', 'args', '.', 'empty?', '?', 'orm_fields', ':', 'args', '.', 'collect', '{', '|', 'f', '|', 'TableField', '.', 'new', '(', 'f', '.', 'to_sym', ')', '}', 'end', 'action_cells', '(', 'options', '[', ':actions', ']', ',', 'options', '[', ':action_prefix', ']', ')', '[', '"\\n"', ',', 'head', ',', '"\\n"', ',', 'body', ',', '"\\n"', ']', '.', 'join', '(', '""', ')', '.', 'html_safe', 'end']
->Original Target:
['builds', 'up', 'the', 'fields', 'that', 'the', 'table', 'will', 'include', 'returns', 'table', 'head', 'and', 'body', 'with', 'all', 'data']
->Reconstructed Target:
builds up the fields that the table will include returns table head and body with all data
->Reconstructed Predication:
table_fields = orm_fields. map
->Raw Input:
summarize:def data ( * args, & block ) options = args. extract_options! if block_given? yield self else @table_fields = args. empty?? orm_fields : args. collect { | f | TableField. new ( f. to_sym ) } end action_cells ( options [ :actions ], options [ :action_prefix ] ) [ "\n", head, "\n", body, "\n" ]. join ( "" ). html_safe end
->Raw Target:
builds up the fields that the table will include returns table head and body with all data
--

772=========
->Original Input:
['def', 'cell', '(', '*', 'args', ',', '&', 'proc', ')', 'options', '=', 'args', '.', 'extract_options!', 'options', '.', 'merge!', '(', ':klass', '=>', 'klass', ')', 'args', '<<', 'options', '@table_fields', '<<', 'TableField', '.', 'new', '(', '*', 'args', ',', '&', 'proc', ')', 'return', '""', 'end']
->Original Target:
['individually', 'specify', 'a', 'column', 'which', 'will', 'build', 'up', 'the', 'header', 'and', 'method', 'or', 'block', 'to', 'call', 'on', 'each', 'resource', 'in', 'the', 'array']
->Reconstructed Target:
individually specify a column which will build up the header and method or block to call on each resource in the array
->Reconstructed Predication:
the table for the given
->Raw Input:
summarize:def cell ( * args, & proc ) options = args. extract_options! options. merge! ( :klass => klass ) args << options @table_fields << TableField. new ( * args, & proc ) return "" end
->Raw Target:
individually specify a column which will build up the header and method or block to call on each resource in the array
--

773=========
->Original Input:
['def', 'action_cells', '(', 'actions', ',', 'prefix', '=', 'nil', ')', 'return', 'if', 'actions', '.', 'blank?', 'actions', '=', '[', 'actions', ']', 'if', '!', 'actions', '.', 'respond_to?', '(', ':each', ')', 'actions', '=', '[', ':show', ',', ':edit', ',', ':destroy', ']', 'if', 'actions', '==', '[', ':all', ']', 'actions', '.', 'each', 'do', '|', 'action', '|', 'action_link', '(', 'action', '.', 'to_sym', ',', 'prefix', ')', 'end', 'end']
->Original Target:
['Used', 'internally', 'to', 'build', 'up', 'cells', 'for', 'common', 'CRUD', 'actions']
->Reconstructed Target:
Used internally to build up cells for common CRUD actions
->Reconstructed Predication:
actions to render the action
->Raw Input:
summarize:def action_cells ( actions, prefix = nil ) return if actions. blank? actions = [ actions ] if! actions. respond_to? ( :each ) actions = [ :show, :edit, :destroy ] if actions == [ :all ] actions. each do | action | action_link ( action. to_sym, prefix ) end end
->Raw Target:
Used internally to build up cells for common CRUD actions
--

774=========
->Original Input:
['def', 'action_link', '(', 'action', ',', 'prefix', ')', 'html_class', '=', '"actions #{action.to_s}_link"', 'block', '=', 'lambda', 'do', '|', 'resource', '|', 'compound_resource', '=', '[', 'prefix', ',', 'resource', ']', '.', 'compact', 'compound_resource', '.', 'flatten!', 'if', 'prefix', '.', 'kind_of?', '(', 'Array', ')', 'case', 'action', 'when', ':show', '@template', '.', 'link_to', '(', 'link_title', '(', 'action', ')', ',', 'compound_resource', ')', 'when', ':destroy', '@template', '.', 'link_to', '(', 'link_title', '(', 'action', ')', ',', 'compound_resource', ',', ':method', '=>', ':delete', ',', ':data', '=>', '{', ':confirm', '=>', 'confirmation_message', '}', ')', 'else', '@template', '.', 'link_to', '(', 'link_title', '(', 'action', ')', ',', '@template', '.', 'polymorphic_path', '(', 'compound_resource', ',', ':action', '=>', 'action', ')', ')', 'end', 'end', 'self', '.', 'cell', '(', 'action', ',', ':heading', '=>', '""', ',', ':cell_html', '=>', '{', ':class', '=>', 'html_class', '}', ',', '&', 'block', ')', 'end']
->Original Target:
['Dynamically', 'builds', 'links', 'for', 'the', 'action']
->Reconstructed Target:
Dynamically builds links for the action
->Reconstructed Predication:
the action link to thethe action link to thethe action link to thethe action link to thethe action link to thethe action link to thethe action link to thethe action link to thethe action link to thethe action link to thethe action link to thethe action link to thethe action to the actionthe action to the actionthe action to the actionthe action to the actionthe
->Raw Input:
summarize:def action_link ( action, prefix ) html_class = "actions #{action.to_s}_link" block = lambda do | resource | compound_resource = [ prefix, resource ]. compact compound_resource. flatten! if prefix. kind_of? ( Array ) case action when :show @template. link_to ( link_title ( action ), compound_resource ) when :destroy @template. link_to ( link_title ( action ), compound_resource, :method => :delete, :data => { :confirm => confirmation_message } ) else @template. link_to ( link_title ( action ), @template. polymorphic_path ( compound_resource, :action => action ) ) end end self. cell ( action, :heading => "", :cell_html => { :class => html_class }, & block ) end
->Raw Target:
Dynamically builds links for the action
--

775=========
->Original Input:
['def', 'add', '(', 'scene', ')', 'all_scenes_for', '(', 'scene', ')', '.', 'each', '{', '|', 'scene', '|', 'scenes_hash', '[', 'scene', '.', 'scene_name', ']', '=', 'scene', '.', 'to_s', '}', 'end']
->Original Target:
['Add', 'a', 'scene', 'to', 'the', 'hash', 'of', 'scenes', 'with', 'the', 'scene', 'name', 'of', 'the', 'scene', 'as', 'the', 'key', 'to', 'retrieving', 'this', 'scene', '.']
->Reconstructed Target:
Add a scene to the hash of scenes with the scene name of the scene as the key to retrieving this scene.
->Reconstructed Predication:
the scene to be added to
->Raw Input:
summarize:def add ( scene ) all_scenes_for ( scene ). each { | scene | scenes_hash [ scene. scene_name ] = scene. to_s } end
->Raw Target:
Add a scene to the hash of scenes with the scene name of the scene as the key to retrieving this scene.
--

776=========
->Original Input:
['def', 'apply_post_filters', '(', 'new_scene', ',', 'options', ')', 'post_filters', '.', 'inject', '(', 'new_scene', ')', '{', '|', 'scene', ',', 'post', '|', 'post', '.', 'filter', '(', 'scene', ',', 'options', ')', '}', 'end']
->Original Target:
['Apply', 'all', 'the', 'post', 'filtering', 'to', 'the', 'specified', 'scene', 'with', 'the', 'given', 'options']
->Reconstructed Target:
Apply all the post filtering to the specified scene with the given options
->Reconstructed Predication:
the post to the scene.
->Raw Input:
summarize:def apply_post_filters ( new_scene, options ) post_filters. inject ( new_scene ) { | scene, post | post. filter ( scene, options ) } end
->Raw Target:
Apply all the post filtering to the specified scene with the given options
--

777=========
->Original Input:
['def', 'hash_with_missing_scene_default', 'hash', '=', 'HashWithIndifferentAccess', '.', 'new', 'do', '|', 'hash', ',', 'key', '|', 'missing_scene', '=', 'hash', '[', ':missing_scene', ']', '.', 'constantize', 'missing_scene', '.', 'missing_scene', '=', 'key', '.', 'to_sym', 'missing_scene', 'end', 'hash', '[', ':missing_scene', ']', '=', '"Metro::MissingScene"', 'hash', 'end']
->Original Target:
['Create', 'a', 'hash', 'that', 'will', 'return', 'a', 'setup', 'missing', 'scene', 'by', 'default', '.']
->Reconstructed Target:
Create a hash that will return a setup missing scene by default.
->Reconstructed Predication:
the missing scene to be used
->Raw Input:
summarize:def hash_with_missing_scene_default hash = HashWithIndifferentAccess. new do | hash, key | missing_scene = hash [ :missing_scene ]. constantize missing_scene. missing_scene = key. to_sym missing_scene end hash [ :missing_scene ] = "Metro::MissingScene" hash end
->Raw Target:
Create a hash that will return a setup missing scene by default.
--

778=========
->Original Input:
['def', 'all_scenes_for', '(', 'scenes', ')', 'Array', '(', 'scenes', ')', '.', 'map', 'do', '|', 'scene_class_name', '|', 'scene', '=', 'scene_class_name', '.', 'constantize', '[', 'scene', ']', '+', 'all_scenes_for', '(', 'scene', '.', 'scenes', ')', 'end', '.', 'flatten', '.', 'compact', 'end']
->Original Target:
['Returns', 'all', 'subclassed', 'scenes', 'of', 'the', 'scene', 'or', 'scenes', 'provided', '.', 'This', 'method', 'is', 'meant', 'to', 'be', 'called', 'recursively', 'to', 'generate', 'the', 'entire', 'list', 'of', 'all', 'the', 'scenes', '.']
->Reconstructed Target:
Returns all subclassed scenes of the scene or scenes provided. This method is meant to be called recursively to generate the entire list of all the scenes.
->Reconstructed Predication:
the scenes to be summarizeed
->Raw Input:
summarize:def all_scenes_for ( scenes ) Array ( scenes ). map do | scene_class_name | scene = scene_class_name. constantize [ scene ] + all_scenes_for ( scene. scenes ) end. flatten. compact end
->Raw Target:
Returns all subclassed scenes of the scene or scenes provided. This method is meant to be called recursively to generate the entire list of all the scenes.
--

779=========
->Original Input:
['def', 'actor', '(', 'actor_or_actor_name', ')', 'if', 'actor_or_actor_name', '.', 'is_a?', 'String', 'or', 'actor_or_actor_name', '.', 'is_a?', 'Symbol', 'send', '(', 'actor_or_actor_name', ')', 'else', 'actor_or_actor_name', 'end', 'end']
->Original Target:
['When', 'an', 'actor', 'is', 'defined', 'through', 'the', 'class', 'method', 'draw', 'a', 'getter', 'and', 'setter', 'method', 'is', 'defined', '.', 'However', 'it', 'is', 'a', 'better', 'interface', 'internally', 'not', 'to', 'rely', 'heavily', 'on', 'send', 'and', 'have', 'this', 'small', 'amount', 'of', 'obfuscation', 'in', 'the', 'event', 'that', 'this', 'needs', 'to', 'change', '.']
->Reconstructed Target:
When an actor is defined through the class method draw a getter and setter method is defined. However it is a better interface internally not to rely heavily on send and have this small amount of obfuscation in the event that this needs to change.
->Reconstructed Predication:
the actor to be sent
->Raw Input:
summarize:def actor ( actor_or_actor_name ) if actor_or_actor_name. is_a? String or actor_or_actor_name. is_a? Symbol send ( actor_or_actor_name ) else actor_or_actor_name end end
->Raw Target:
When an actor is defined through the class method draw a getter and setter method is defined. However it is a better interface internally not to rely heavily on send and have this small amount of obfuscation in the event that this needs to change.
--

780=========
->Original Input:
['def', 'notification', '(', 'event', ',', 'sender', '=', 'nil', ')', 'sender', '=', 'sender', '||', 'UnknownSender', 'state', '.', 'fire_events_for_notification', '(', 'event', ',', 'sender', ')', 'end']
->Original Target:
['Post', 'a', 'custom', 'notification', 'event', '.', 'This', 'will', 'trigger', 'an', 'event', 'for', 'all', 'the', 'objects', 'that', 'are', 'registered', 'for', 'notification', 'with', 'the', 'current', 'state', '.']
->Reconstructed Target:
Post a custom notification event. This will trigger an event for all the objects that are registered for notification with the current state.
->Reconstructed Predication:
the event to fire for the
->Raw Input:
summarize:def notification ( event, sender = nil ) sender = sender || UnknownSender state. fire_events_for_notification ( event, sender ) end
->Raw Target:
Post a custom notification event. This will trigger an event for all the objects that are registered for notification with the current state.
--

781=========
->Original Input:
['def', 'after', '(', 'ticks', ',', '&', 'block', ')', 'tick', '=', 'OnUpdateOperation', '.', 'new', 'interval', ':', 'ticks', ',', 'context', ':', 'self', 'tick', '.', 'on_complete', '(', '&', 'block', ')', 'enqueue', 'tick', 'end']
->Original Target:
['Perform', 'an', 'operation', 'after', 'the', 'specified', 'interval', '.']
->Reconstructed Target:
Perform an operation after the specified interval.
->Reconstructed Predication:
the operation to complete after the
->Raw Input:
summarize:def after ( ticks, & block ) tick = OnUpdateOperation. new interval : ticks, context : self tick. on_complete ( & block ) enqueue tick end
->Raw Target:
Perform an operation after the specified interval.
--

782=========
->Original Input:
['def', 'add_actors_to_scene', 'self', '.', 'class', '.', 'actors', '.', 'each', 'do', '|', 'scene_actor', '|', 'actor_instance', '=', 'scene_actor', '.', 'create', 'actor_instance', '.', 'scene', '=', 'self', 'send', '"#{scene_actor.name}="', ',', 'actor_instance', 'end', 'end']
->Original Target:
['Setups', 'up', 'the', 'Actors', 'for', 'the', 'Scene', 'based', 'on', 'the', 'ModelFactories', 'that', 'have', 'been', 'defined', '.']
->Reconstructed Target:
Setups up the Actors for the Scene based on the ModelFactories that have been defined.
->Reconstructed Predication:
the scene to the scene
->Raw Input:
summarize:def add_actors_to_scene self. class. actors. each do | scene_actor | actor_instance = scene_actor. create actor_instance. scene = self send "#{scene_actor.name}=", actor_instance end end
->Raw Target:
Setups up the Actors for the Scene based on the ModelFactories that have been defined.
--

783=========
->Original Input:
['def', 'register_animations!', 'self', '.', 'class', '.', 'animations', '.', 'each', 'do', '|', 'animation', '|', 'animate', 'animation', '.', 'actor', ',', 'animation', '.', 'options', ',', '&', 'animation', '.', 'on_complete_block', 'end', 'end']
->Original Target:
['Register', 'all', 'the', 'animations', 'that', 'were', 'defined', 'for', 'this', 'scene', '.']
->Reconstructed Target:
Register all the animations that were defined for this scene.
->Reconstructed Predication:
animations to be called when the animation
->Raw Input:
summarize:def register_animations! self. class. animations. each do | animation | animate animation. actor, animation. options, & animation. on_complete_block end end
->Raw Target:
Register all the animations that were defined for this scene.
--

784=========
->Original Input:
['def', 'register_actor', '(', 'actor_factory', ')', 'registering_actor', '=', 'actor', '(', 'actor_factory', '.', 'name', ')', 'registering_actor', '.', 'window', '=', 'window', 'registering_actor', '.', 'show', 'drawers', '.', 'push', '(', 'registering_actor', ')', 'updaters', '.', 'push', '(', 'registering_actor', ')', 'register_events_for_target', '(', 'registering_actor', ',', 'registering_actor', '.', 'class', '.', 'events', ')', 'end']
->Original Target:
['Registering', 'an', 'actor', 'involves', 'setting', 'up', 'the', 'actor', 'within', 'the', 'window', 'adding', 'them', 'to', 'the', 'list', 'of', 'things', 'that', 'need', 'to', 'be', 'drawn', 'and', 'then', 'registering', 'any', 'eventst', 'that', 'they', 'might', 'have', '.']
->Reconstructed Target:
Registering an actor involves setting up the actor within the window adding them to the list of things that need to be drawn and then registering any eventst that they might have.
->Reconstructed Predication:
the actor to be registered
->Raw Input:
summarize:def register_actor ( actor_factory ) registering_actor = actor ( actor_factory. name ) registering_actor. window = window registering_actor. show drawers. push ( registering_actor ) updaters. push ( registering_actor ) register_events_for_target ( registering_actor, registering_actor. class. events ) end
->Raw Target:
Registering an actor involves setting up the actor within the window adding them to the list of things that need to be drawn and then registering any eventst that they might have.
--

785=========
->Original Input:
['def', 'base_update', 'updaters', '.', 'each', '{', '|', 'updater', '|', 'updater', '.', 'update', '}', 'update', 'updaters', '.', 'reject!', '{', '|', 'updater', '|', 'updater', '.', 'update_completed?', '}', 'end']
->Original Target:
['The', 'base_update', 'method', 'is', 'called', 'by', 'the', 'Game', 'Window', '.', 'This', 'is', 'to', 'allow', 'for', 'any', 'special', 'update', 'needs', 'to', 'be', 'handled', 'before', 'calling', 'the', 'traditional', 'update', 'method', 'defined', 'in', 'the', 'subclassed', 'Scene', '.']
->Reconstructed Target:
The base_update method is called by the Game Window. This is to allow for any special update needs to be handled before calling the traditional update method defined in the subclassed Scene.
->Reconstructed Predication:
update the update
->Raw Input:
summarize:def base_update updaters. each { | updater | updater. update } update updaters. reject! { | updater | updater. update_completed? } end
->Raw Target:
The base_update method is called by the Game Window. This is to allow for any special update needs to be handled before calling the traditional update method defined in the subclassed Scene.
--

786=========
->Original Input:
['def', 'base_draw', 'drawers', '.', 'each', '{', '|', 'drawer', '|', 'drawer', '.', 'draw', '}', 'draw', 'drawers', '.', 'reject!', '{', '|', 'drawer', '|', 'drawer', '.', 'draw_completed?', '}', 'end']
->Original Target:
['The', 'base_draw', 'method', 'is', 'called', 'by', 'the', 'Game', 'Window', '.', 'This', 'is', 'to', 'allow', 'for', 'any', 'special', 'drawing', 'needs', 'to', 'be', 'handled', 'before', 'calling', 'the', 'traditional', 'draw', 'method', 'defined', 'in', 'the', 'subclassed', 'Scene', '.']
->Reconstructed Target:
The base_draw method is called by the Game Window. This is to allow for any special drawing needs to be handled before calling the traditional draw method defined in the subclassed Scene.
->Reconstructed Predication:
drawer. draw_completed? drawers.
->Raw Input:
summarize:def base_draw drawers. each { | drawer | drawer. draw } draw drawers. reject! { | drawer | drawer. draw_completed? } end
->Raw Target:
The base_draw method is called by the Game Window. This is to allow for any special drawing needs to be handled before calling the traditional draw method defined in the subclassed Scene.
--

787=========
->Original Input:
['def', 'transition_to', '(', 'scene_or_scene_name', ',', 'options', '=', '{', '}', ')', 'new_scene', '=', 'Scenes', '.', 'generate', '(', 'scene_or_scene_name', ',', 'options', ')', '_prepare_transition', '(', 'new_scene', ')', 'window', '.', 'scene', '=', 'new_scene', 'end']
->Original Target:
['transition_to', 'performs', 'the', 'work', 'of', 'transitioning', 'this', 'scene', 'to', 'another', 'scene', '.']
->Reconstructed Target:
transition_to performs the work of transitioning this scene to another scene.
->Reconstructed Predication:
the scene to the new scenethe new scene to the new
->Raw Input:
summarize:def transition_to ( scene_or_scene_name, options = { } ) new_scene = Scenes. generate ( scene_or_scene_name, options ) _prepare_transition ( new_scene ) window. scene = new_scene end
->Raw Target:
transition_to performs the work of transitioning this scene to another scene.
--

788=========
->Original Input:
['def', '_prepare_transition', '(', 'new_scene', ')', 'log', '.', 'debug', '"Preparing to transition from scene #{self} to #{new_scene}"', 'new_scene', '.', 'class', '.', 'actors', '.', 'find_all', '{', '|', 'actor_factory', '|', 'actor_factory', '.', 'load_from_previous_scene?', '}', '.', 'each', 'do', '|', 'actor_factory', '|', 'new_actor', '=', 'new_scene', '.', 'actor', '(', 'actor_factory', '.', 'name', ')', 'current_actor', '=', 'actor', '(', 'actor_factory', '.', 'name', ')', 'new_actor', '.', '_load', 'current_actor', '.', '_save', 'end', 'prepare_transition_to', '(', 'new_scene', ')', 'new_scene', '.', 'prepare_transition_from', '(', 'self', ')', 'end']
->Original Target:
['Before', 'a', 'scene', 'is', 'transitioned', 'away', 'from', 'to', 'a', 'new', 'scene', 'this', 'private', 'method', 'is', 'here', 'to', 'allow', 'for', 'any', 'housekeeping', 'or', 'other', 'work', 'that', 'needs', 'to', 'be', 'done', 'before', 'calling', 'the', 'subclasses', 'implementation', 'of', 'prepare_transition', '.']
->Reconstructed Target:
Before a scene is transitioned away from to a new scene this private method is here to allow for any housekeeping or other work that needs to be done before calling the subclasses implementation of prepare_transition.
->Reconstructed Predication:
the scene to the new scene
->Raw Input:
summarize:def _prepare_transition ( new_scene ) log. debug "Preparing to transition from scene #{self} to #{new_scene}" new_scene. class. actors. find_all { | actor_factory | actor_factory. load_from_previous_scene? }. each do | actor_factory | new_actor = new_scene. actor ( actor_factory. name ) current_actor = actor ( actor_factory. name ) new_actor. _load current_actor. _save end prepare_transition_to ( new_scene ) new_scene. prepare_transition_from ( self ) end
->Raw Target:
Before a scene is transitioned away from to a new scene this private method is here to allow for any housekeeping or other work that needs to be done before calling the subclasses implementation of prepare_transition.
--

789=========
->Original Input:
['def', 'to_hash', 'drawn', '=', 'drawers', '.', 'find_all', '{', '|', 'draw', '|', 'draw', '.', 'saveable_to_view', '}', '.', 'inject', '(', '{', '}', ')', 'do', '|', 'hash', ',', 'drawer', '|', 'drawer_hash', '=', 'drawer', '.', 'to_hash', 'hash', '.', 'merge', 'drawer_hash', 'end', 'drawn', 'end']
->Original Target:
['A', 'Scene', 'represented', 'as', 'a', 'hash', 'currently', 'only', 'contains', 'the', 'drawers']
->Reconstructed Target:
A Scene represented as a hash currently only contains the drawers
->Reconstructed Predication:
drawers : the drawers to return
->Raw Input:
summarize:def to_hash drawn = drawers. find_all { | draw | draw. saveable_to_view }. inject ( { } ) do | hash, drawer | drawer_hash = drawer. to_hash hash. merge drawer_hash end drawn end
->Raw Target:
A Scene represented as a hash currently only contains the drawers
--

790=========
->Original Input:
['def', 'create', '(', 'model_name', ',', 'options', '=', '{', '}', ')', 'model_class', '=', 'Metro', '::', 'Models', '.', 'find', '(', 'model_name', ')', 'mc', '=', 'model_class', '.', 'new', 'options', 'mc', '.', 'scene', '=', 'scene', 'mc', '.', 'window', '=', 'window', 'mc', 'end']
->Original Target:
['A', 'helper', 'method', 'that', 'allows', 'the', 'current', 'model', 'to', 'generate', 'another', 'model', '.', 'This', 'is', 'useful', 'as', 'it', 'allows', 'for', 'the', 'current', 'model', 'to', 'pass', 'window', 'and', 'scene', 'state', 'to', 'the', 'created', 'model', '.']
->Reconstructed Target:
A helper method that allows the current model to generate another model. This is useful as it allows for the current model to pass window and scene state to the created model.
->Reconstructed Predication:
a new model instance. 
->Raw Input:
summarize:def create ( model_name, options = { } ) model_class = Metro :: Models. find ( model_name ) mc = model_class. new options mc. scene = scene mc. window = window mc end
->Raw Target:
A helper method that allows the current model to generate another model. This is useful as it allows for the current model to pass window and scene state to the created model.
--

791=========
->Original Input:
['def', '_load', '(', 'options', '=', '{', '}', ')', 'options', '.', 'keys', '.', 'each', 'do', '|', 'key', '|', 'property_name', '=', 'key', '.', 'to_s', '.', 'underscore', '.', 'to_sym', 'if', 'respond_to?', '"#{property_name}="', 'send', '(', '"#{property_name}="', ',', 'options', '.', 'delete', '(', 'key', ')', ')', 'else', 'options', '[', 'property_name', ']', '=', 'options', '.', 'delete', '(', 'key', ')', 'end', 'end', 'properties', '.', 'merge!', 'options', 'end']
->Original Target:
['Create', 'an', 'instance', 'of', 'a', 'model', '.']
->Reconstructed Target:
Create an instance of a model.
->Reconstructed Predication:
the properties to be loaded.
->Raw Input:
summarize:def _load ( options = { } ) options. keys. each do | key | property_name = key. to_s. underscore. to_sym if respond_to? "#{property_name}=" send ( "#{property_name}=", options. delete ( key ) ) else options [ property_name ] = options. delete ( key ) end end properties. merge! options end
->Raw Target:
Create an instance of a model.
--

792=========
->Original Input:
['def', 'activities', '(', 'user_id', ',', 'options', '=', '{', '}', ')', 'perform_request', '(', ':get', ',', "'/v2/measure'", ',', 'WithingsSDK', '::', 'Activity', ',', "'activities'", ',', '{', 'action', ':', "'getactivity'", ',', 'userid', ':', 'user_id', '}', '.', 'merge', '(', 'options', ')', ')', 'end']
->Original Target:
['Get', 'a', 'list', 'of', 'activity', 'measures', 'for', 'the', 'specified', 'user']
->Reconstructed Target:
Get a list of activity measures for the specified user
->Reconstructed Predication:
the user s activitythe user s activity.
->Raw Input:
summarize:def activities ( user_id, options = { } ) perform_request ( :get, '/v2/measure', WithingsSDK :: Activity, 'activities', { action : 'getactivity', userid : user_id }. merge ( options ) ) end
->Raw Target:
Get a list of activity measures for the specified user
--

793=========
->Original Input:
['def', 'body_measurements', '(', 'user_id', ',', 'options', '=', '{', '}', ')', 'perform_request', '(', ':get', ',', "'/measure'", ',', 'WithingsSDK', '::', 'MeasurementGroup', ',', "'measuregrps'", ',', '{', 'action', ':', "'getmeas'", ',', 'userid', ':', 'user_id', '}', '.', 'merge', '(', 'options', ')', ')', 'end']
->Original Target:
['Get', 'a', 'list', 'of', 'body', 'measurements', 'taken', 'by', 'Withings', 'devices']
->Reconstructed Target:
Get a list of body measurements taken by Withings devices
->Reconstructed Predication:
the user s measurements for athe user s measurements.
->Raw Input:
summarize:def body_measurements ( user_id, options = { } ) perform_request ( :get, '/measure', WithingsSDK :: MeasurementGroup,'measuregrps', { action : 'getmeas', userid : user_id }. merge ( options ) ) end
->Raw Target:
Get a list of body measurements taken by Withings devices
--

794=========
->Original Input:
['def', 'weight', '(', 'user_id', ',', 'options', '=', '{', '}', ')', 'groups', '=', 'body_measurements', '(', 'user_id', ',', 'options', ')', 'groups', '.', 'map', 'do', '|', 'group', '|', 'group', '.', 'measures', '.', 'select', '{', '|', 'm', '|', 'm', '.', 'is_a?', 'WithingsSDK', '::', 'Measure', '::', 'Weight', '}', '.', 'map', 'do', '|', 'm', '|', 'WithingsSDK', '::', 'Measure', '::', 'Weight', '.', 'new', '(', 'm', '.', 'attrs', '.', 'merge', '(', "'weighed_at'", '=>', 'group', '.', 'date', ')', ')', 'end', 'end', '.', 'flatten', 'end']
->Original Target:
['Return', 'a', 'list', 'of', 'weight', 'body', 'measurements']
->Reconstructed Target:
Return a list of weight body measurements
->Reconstructed Predication:
a summary of a usera summary of a user
->Raw Input:
summarize:def weight ( user_id, options = { } ) groups = body_measurements ( user_id, options ) groups. map do | group | group. measures. select { | m | m. is_a? WithingsSDK :: Measure :: Weight }. map do | m | WithingsSDK :: Measure :: Weight. new ( m. attrs. merge ( 'weighed_at' => group. date ) ) end end. flatten end
->Raw Target:
Return a list of weight body measurements
--

795=========
->Original Input:
['def', 'sleep_series', '(', 'user_id', ',', 'options', '=', '{', '}', ')', 'perform_request', '(', ':get', ',', "'/v2/sleep'", ',', 'WithingsSDK', '::', 'SleepSeries', ',', "'series'", ',', '{', 'action', ':', "'get'", ',', 'userid', ':', 'user_id', '}', '.', 'merge', '(', 'options', ')', ')', 'end']
->Original Target:
['Get', 'details', 'about', 'a', 'user', 's', 'sleep']
->Reconstructed Target:
Get details about a user s sleep
->Reconstructed Predication:
sleep series for a user def sleep_series ( series
->Raw Input:
summarize:def sleep_series ( user_id, options = { } ) perform_request ( :get, '/v2/sleep', WithingsSDK :: SleepSeries,'series', { action : 'get', userid : user_id }. merge ( options ) ) end
->Raw Target:
Get details about a user s sleep
--

796=========
->Original Input:
['def', 'perform_request', '(', 'http_method', ',', 'path', ',', 'klass', ',', 'key', ',', 'options', '=', '{', '}', ')', 'if', '@consumer_key', '.', 'nil?', '||', '@consumer_secret', '.', 'nil?', 'raise', 'WithingsSDK', '::', 'Error', '::', 'ClientConfigurationError', ',', '"Missing consumer_key or consumer_secret"', 'end', 'options', '=', 'WithingsSDK', '::', 'Utils', '.', 'normalize_date_params', '(', 'options', ')', 'request', '=', 'WithingsSDK', '::', 'HTTP', '::', 'Request', '.', 'new', '(', '@access_token', ',', '{', "'User-Agent'", '=>', 'user_agent', '}', ')', 'response', '=', 'request', '.', 'send', '(', 'http_method', ',', 'path', ',', 'options', ')', 'if', 'key', '.', 'nil?', 'klass', '.', 'new', '(', 'response', ')', 'elsif', 'response', '.', 'has_key?', 'key', 'response', '[', 'key', ']', '.', 'collect', 'do', '|', 'element', '|', 'klass', '.', 'new', '(', 'element', ')', 'end', 'else', '[', 'klass', '.', 'new', '(', 'response', ')', ']', 'end', 'end']
->Original Target:
['Helper', 'function', 'that', 'handles', 'all', 'API', 'requests']
->Reconstructed Target:
Helper function that handles all API requests
->Reconstructed Predication:
the request to the APIthe request to the APIthethe request to the APIthethe response to the API.
->Raw Input:
summarize:def perform_request ( http_method, path, klass, key, options = { } ) if @consumer_key. nil? || @consumer_secret. nil? raise WithingsSDK :: Error :: ClientConfigurationError, "Missing consumer_key or consumer_secret" end options = WithingsSDK :: Utils. normalize_date_params ( options ) request = WithingsSDK :: HTTP :: Request. new ( @access_token, { 'User-Agent' => user_agent } ) response = request. send ( http_method, path, options ) if key. nil? klass. new ( response ) elsif response. has_key? key response [ key ]. collect do | element | klass. new ( element ) end else [ klass. new ( response ) ] end end
->Raw Target:
Helper function that handles all API requests
--

797=========
->Original Input:
['def', 'set_magic_content_type', '(', 'override', '=', 'false', ')', 'if', 'override', '||', 'file', '.', 'content_type', '.', 'blank?', '||', 'generic_content_type?', '(', 'file', '.', 'content_type', ')', 'new_content_type', '=', '::', 'FileMagic', '.', 'new', '(', '::', 'FileMagic', '::', 'MAGIC_MIME', ')', '.', 'file', '(', 'file', '.', 'path', ')', '.', 'split', '(', "';'", ')', '.', 'first', 'if', 'file', '.', 'respond_to?', '(', ':content_type=', ')', 'file', '.', 'content_type', '=', 'new_content_type', 'else', 'file', '.', 'instance_variable_set', '(', ':@content_type', ',', 'new_content_type', ')', 'end', 'end', 'rescue', '::', 'Exception', '=>', 'e', 'raise', 'CarrierWave', '::', 'ProcessingError', ',', 'I18n', '.', 'translate', '(', ':"', '"', ',', 'e', ':', 'e', ',', 'default', ':', "'Failed to process file with FileMagic, Original Error: %{e}'", ')', 'end']
->Original Target:
['Changes', 'the', 'file', 'content_type', 'using', 'the', 'ruby', '-', 'filemagic', 'gem']
->Reconstructed Target:
Changes the file content_type using the ruby - filemagic gem
->Reconstructed Predication:
file with FileMagic, Originalfile with FileMagic, Original Error:file with FileMagic, Original Error:file with FileMagic, Original Error:file with FileMagic, Original Error: %{e}'file with FileMagic, Original Error: %{e}'
->Raw Input:
summarize:def set_magic_content_type ( override = false ) if override || file. content_type. blank? || generic_content_type? ( file. content_type ) new_content_type = :: FileMagic. new ( :: FileMagic :: MAGIC_MIME ). file ( file. path ). split ( ';' ). first if file. respond_to? ( :content_type= ) file. content_type = new_content_type else file. instance_variable_set ( :@content_type, new_content_type ) end end rescue :: Exception => e raise CarrierWave :: ProcessingError, I18n. translate ( :" ", e : e, default : 'Failed to process file with FileMagic, Original Error: %{e}' ) end
->Raw Target:
Changes the file content_type using the ruby - filemagic gem
--

798=========
->Original Input:
['def', 'send_request', '(', 'channel_id', ',', 'method', ',', 'properties', '=', '{', '}', ')', 'Util', '.', 'error_check', ':"', '"', ',', '@conn', '.', 'send_method', '(', 'Integer', '(', 'channel_id', ')', ',', 'method', '.', 'to_sym', ',', 'properties', ')', 'nil', 'end']
->Original Target:
['Send', 'a', 'request', 'on', 'the', 'given', 'channel', 'with', 'the', 'given', 'type', 'and', 'properties', '.']
->Reconstructed Target:
Send a request on the given channel with the given type and properties.
->Reconstructed Predication:
 def send_request ( channel_id
->Raw Input:
summarize:def send_request ( channel_id, method, properties = { } ) Util. error_check :" ", @conn. send_method ( Integer ( channel_id ), method. to_sym, properties ) nil end
->Raw Target:
Send a request on the given channel with the given type and properties.
--

799=========
->Original Input:
['def', 'fetch_response', '(', 'channel_id', ',', 'method', ',', 'timeout', ':', 'protocol_timeout', ')', 'methods', '=', 'Array', '(', 'method', ')', '.', 'map', '(', '&', ':to_sym', ')', 'timeout', '=', 'Float', '(', 'timeout', ')', 'if', 'timeout', 'fetch_response_internal', '(', 'Integer', '(', 'channel_id', ')', ',', 'methods', ',', 'timeout', ')', 'end']
->Original Target:
['Wait', 'for', 'a', 'specific', 'response', 'on', 'the', 'given', 'channel', 'of', 'the', 'given', 'type', 'and', 'return', 'the', 'event', 'data', 'for', 'the', 'response', 'when', 'it', 'is', 'received', '.', 'Any', 'other', 'events', 'received', 'will', 'be', 'processed', 'or', 'stored', 'internally', '.']
->Reconstructed Target:
Wait for a specific response on the given channel of the given type and return the event data for the response when it is received. Any other events received will be processed or stored internally.
->Reconstructed Predication:
the response for the specified
->Raw Input:
summarize:def fetch_response ( channel_id, method, timeout : protocol_timeout ) methods = Array ( method ). map ( & :to_sym ) timeout = Float ( timeout ) if timeout fetch_response_internal ( Integer ( channel_id ), methods, timeout ) end
->Raw Target:
Wait for a specific response on the given channel of the given type and return the event data for the response when it is received. Any other events received will be processed or stored internally.
--

800=========
->Original Input:
['def', 'on_event', '(', 'channel_id', ',', 'method', ',', 'callable', '=', 'nil', ',', '&', 'block', ')', 'handler', '=', 'block', '||', 'callable', 'raise', 'ArgumentError', ',', '"expected block or callable as the event handler"', 'unless', 'handler', '.', 'respond_to?', '(', ':call', ')', '@event_handlers', '[', 'Integer', '(', 'channel_id', ')', ']', '[', 'method', '.', 'to_sym', ']', '=', 'handler', 'handler', 'end']
->Original Target:
['Register', 'a', 'handler', 'for', 'events', 'on', 'the', 'given', 'channel', 'of', 'the', 'given', 'type', '.', 'Only', 'one', 'handler', 'for', 'each', 'event', 'type', 'may', 'be', 'registered', 'at', 'a', 'time', '.', 'If', 'no', 'callable', 'or', 'block', 'is', 'given', 'the', 'handler', 'will', 'be', 'cleared', '.']
->Reconstructed Target:
Register a handler for events on the given channel of the given type. Only one handler for each event type may be registered at a time. If no callable or block is given the handler will be cleared.
->Reconstructed Predication:
the event handler to be called
->Raw Input:
summarize:def on_event ( channel_id, method, callable = nil, & block ) handler = block || callable raise ArgumentError, "expected block or callable as the event handler" unless handler. respond_to? ( :call ) @event_handlers [ Integer ( channel_id ) ] [ method. to_sym ] = handler handler end
->Raw Target:
Register a handler for events on the given channel of the given type. Only one handler for each event type may be registered at a time. If no callable or block is given the handler will be cleared.
--

801=========
->Original Input:
['def', 'download_source', 'Log', '.', 'debug', '{', '"         Reading #{@source.url.green}"', '}', 'zip', '=', 'Tempfile', '.', 'new', '(', "'gtfs'", ')', 'zip', '.', 'binmode', 'zip', '<<', 'open', '(', '@source', '.', 'url', ')', '.', 'read', 'zip', '.', 'rewind', 'extract_to_tempfiles', '(', 'zip', ')', 'Log', '.', 'debug', '{', '"Finished reading #{@source.url.green}"', '}', 'rescue', 'StandardException', '=>', 'e', 'Log', '.', 'error', '(', 'e', '.', 'message', ')', 'raise', 'e', 'ensure', 'zip', '.', 'try', '(', ':close', ')', 'end']
->Original Target:
['Download', 'the', 'data', 'from', 'the', 'remote', 'server']
->Reconstructed Target:
Download the data from the remote server
->Reconstructed Predication:
. debug { "Finished reading
->Raw Input:
summarize:def download_source Log. debug { "         Reading #{@source.url.green}" } zip = Tempfile. new ( 'gtfs' ) zip. binmode zip << open ( @source. url ). read zip. rewind extract_to_tempfiles ( zip ) Log. debug { "Finished reading #{@source.url.green}" } rescue StandardException => e Log. error ( e. message ) raise e ensure zip. try ( :close ) end
->Raw Target:
Download the data from the remote server
--

802=========
->Original Input:
['def', 'check_files', '@found_files', '=', '[', ']', 'check_required_files', 'check_optional_files', '@source', '.', 'feed_definition', '.', 'files', '.', 'each', 'do', '|', 'req', '|', '@found_files', '<<', 'req', 'if', 'filenames', '.', 'include?', '(', 'req', '.', 'filename', ')', 'end', 'end']
->Original Target:
['Parse', 'the', 'filenames', 'in', 'the', 'feed', 'and', 'check', 'which', 'required', 'and', 'optional', 'files', 'are', 'present', '.']
->Reconstructed Target:
Parse the filenames in the feed and check which required and optional files are present.
->Reconstructed Predication:
files to be processed
->Raw Input:
summarize:def check_files @found_files = [ ] check_required_files check_optional_files @source. feed_definition. files. each do | req | @found_files << req if filenames. include? ( req. filename ) end end
->Raw Target:
Parse the filenames in the feed and check which required and optional files are present.
--

803=========
->Original Input:
['def', 'check_columns', '@found_files', '.', 'each', 'do', '|', 'file', '|', '@temp_files', '[', 'file', '.', 'filename', ']', '.', 'open', 'do', '|', 'data', '|', 'FileReader', '.', 'new', '(', 'data', ',', 'file', ',', 'validate', ':', 'true', ')', 'end', 'end', 'end']
->Original Target:
['Check', 'that', 'every', 'file', 'has', 'its', 'required', 'columns']
->Reconstructed Target:
Check that every file has its required columns
->Reconstructed Predication:
the file to be checked
->Raw Input:
summarize:def check_columns @found_files. each do | file | @temp_files [ file. filename ]. open do | data | FileReader. new ( data, file, validate : true ) end end end
->Raw Target:
Check that every file has its required columns
--

804=========
->Original Input:
['def', 'fetch_http_fallback_identifier', '(', 'head_request', ')', 'if', 'head_request', '.', 'key?', '(', "'last-modified'", ')', 'head_request', '[', "'last-modified'", ']', 'elsif', 'head_request', '.', 'key?', '(', "'content-length'", ')', 'head_request', '[', "'content-length'", ']', 'else', 'Time', '.', 'now', '.', 'to_s', 'end', 'end']
->Original Target:
['Find', 'a', 'next', 'best', 'ID', 'when', 'the', 'HEAD', 'request', 'does', 'not', 'return', 'an', 'ETag', 'header', '.']
->Reconstructed Target:
Find a next best ID when the HEAD request does not return an ETag header.
->Reconstructed Predication:
the request to the fallback
->Raw Input:
summarize:def fetch_http_fallback_identifier ( head_request ) if head_request. key? ( 'last-modified' ) head_request [ 'last-modified' ] elsif head_request. key? ( 'content-length' ) head_request [ 'content-length' ] else Time. now. to_s end end
->Raw Target:
Find a next best ID when the HEAD request does not return an ETag header.
--

805=========
->Original Input:
['def', 'parameter', '(', '*', 'names', ')', 'names', '.', 'each', 'do', '|', 'name', '|', 'define_singleton_method', '(', 'name', ')', 'do', '|', '*', 'values', '|', 'if', '(', 'value', '=', 'values', '.', 'first', ')', 'instance_variable_set', '(', '"@#{name}"', ',', 'value', ')', 'else', 'instance_variable_get', '(', '"@#{name}"', ')', 'end', 'end', 'end', 'end']
->Original Target:
['Creates', 'simple', 'configuration', 'parameters', 'which', 'may', 'be', 'set', 'by', 'the', 'user']
->Reconstructed Target:
Creates simple configuration parameters which may be set by the user
->Reconstructed Predication:
the parameter values for the given
->Raw Input:
summarize:def parameter ( * names ) names. each do | name | define_singleton_method ( name ) do | * values | if ( value = values. first ) instance_variable_set ( "@#{name}", value ) else instance_variable_get ( "@#{name}" ) end end end end
->Raw Target:
Creates simple configuration parameters which may be set by the user
--

806=========
->Original Input:
['def', 'find_columns', '(', 'validate', ')', '@found_columns', '=', '[', ']', 'prefix', '=', '"#{filename.yellow}:"', 'required', '=', '@definition', '.', 'required_columns', 'unless', 'required', '.', 'empty?', 'Log', '.', 'info', '{', '"#{prefix} #{\'required columns\'.magenta}"', '}', 'if', 'validate', 'missing', '=', 'check_columns', '(', 'validate', ',', 'prefix', ',', 'required', ',', ':green', ',', ':red', ')', 'raise', 'RequiredColumnsMissing', ',', 'missing', 'if', 'validate', '&&', 'missing', '.', 'present?', 'end', 'optional', '=', '@definition', '.', 'optional_columns', 'unless', 'optional', '.', 'empty?', 'Log', '.', 'info', '{', '"#{prefix} #{\'optional columns\'.cyan}"', '}', 'if', 'validate', 'check_columns', '(', 'validate', ',', 'prefix', ',', 'optional', ',', ':cyan', ',', ':light_yellow', ')', 'end', 'cols', '=', '@definition', '.', 'columns', '.', 'collect', '(', '&', ':name', ')', 'headers', '=', '@csv_headers', '.', 'select', '{', '|', 'h', '|', 'cols', '.', 'include?', '(', 'h', ')', '}', '@col_names', '||=', '@found_columns', '.', 'map', '(', '&', ':name', ')', '::', 'Hash', '[', '*', 'headers', '.', 'inject', '(', '[', ']', ')', '{', '|', 'list', ',', 'c', '|', 'list', '<<', 'c', '<<', '@definition', '[', 'c', ']', '}', ']', 'end']
->Original Target:
['Check', 'the', 'list', 'of', 'headers', 'in', 'the', 'file', 'against', 'the', 'expected', 'columns', 'in', 'the', 'definition']
->Reconstructed Target:
Check the list of headers in the file against the expected columns in the definition
->Reconstructed Predication:
@definition. columns. collect@found_columns. collect ()@found_columns. collect ()@found_columns. collect ()@found_columns. collect ()@found_columns. collect () { | c |.. map (| c | list <<. map (| c | list <<.. map (... map (
->Raw Input:
summarize:def find_columns ( validate ) @found_columns = [ ] prefix = "#{filename.yellow}:" required = @definition. required_columns unless required. empty? Log. info { "#{prefix} #{'required columns'.magenta}" } if validate missing = check_columns ( validate, prefix, required, :green, :red ) raise RequiredColumnsMissing, missing if validate && missing. present? end optional = @definition. optional_columns unless optional. empty? Log. info { "#{prefix} #{'optional columns'.cyan}" } if validate check_columns ( validate, prefix, optional, :cyan, :light_yellow ) end cols = @definition. columns. collect ( & :name ) headers = @csv_headers. select { | h | cols. include? ( h ) } @col_names ||= @found_columns. map ( & :name ) :: Hash [ * headers. inject ( [ ] ) { | list, c | list << c << @definition [ c ] } ] end
->Raw Target:
Check the list of headers in the file against the expected columns in the definition
--

807=========
->Original Input:
['def', 'map', '(', 'models', ',', 'options', ')', 'models', '=', 'models', '.', 'values', 'case', 'options', '[', ':platform', ']', '.', 'downcase', 'when', '"objc"', ',', '"obj-c"', ',', '"objective-c"', 'Nidyx', '::', 'ObjCMapper', '.', 'map', '(', 'models', ',', 'options', ')', 'end', 'end']
->Original Target:
['Proxies', 'model', 'mapping', 'to', 'the', 'proper', 'platform', 'mapper']
->Reconstructed Target:
Proxies model mapping to the proper platform mapper
->Reconstructed Predication:
the object to be mapped to
->Raw Input:
summarize:def map ( models, options ) models = models. values case options [ :platform ]. downcase when "objc", "obj-c", "objective-c" Nidyx :: ObjCMapper. map ( models, options ) end end
->Raw Target:
Proxies model mapping to the proper platform mapper
--

808=========
->Original Input:
['def', 'generate', '(', 'path', ',', 'name', ')', 'object', '=', 'get_object', '(', 'path', ')', 'type', '=', 'object', '[', 'TYPE_KEY', ']', 'if', 'type', '==', 'OBJECT_TYPE', 'generate_object', '(', 'path', ',', 'name', ')', 'elsif', 'type', '==', 'ARRAY_TYPE', 'generate_top_level_array', '(', 'path', ')', 'elsif', 'type', '.', 'is_a?', '(', 'Array', ')', 'if', 'type', '.', 'include?', '(', 'OBJECT_TYPE', ')', 'raise', 'UnsupportedSchemaError', 'if', 'type', '.', 'include?', '(', 'ARRAY_TYPE', ')', 'generate_object', '(', 'path', ',', 'name', ')', 'elsif', 'type', '.', 'include?', '(', 'ARRAY_TYPE', ')', 'generate_top_leve_array', '(', 'path', ')', 'else', 'raise', 'UnsupportedSchemaError', ';', 'end', 'else', 'raise', 'UnsupportedSchemaError', ';', 'end', 'end']
->Original Target:
['Generates', 'a', 'Model', 'and', 'adds', 'it', 'to', 'the', 'models', 'array', '.']
->Reconstructed Target:
Generates a Model and adds it to the models array.
->Reconstructed Predication:
the schema for the given objectthe schema for the given objectthe schema for the given objectthe schema for the given objectthe schema for the given object
->Raw Input:
summarize:def generate ( path, name ) object = get_object ( path ) type = object [ TYPE_KEY ] if type == OBJECT_TYPE generate_object ( path, name ) elsif type == ARRAY_TYPE generate_top_level_array ( path ) elsif type. is_a? ( Array ) if type. include? ( OBJECT_TYPE ) raise UnsupportedSchemaError if type. include? ( ARRAY_TYPE ) generate_object ( path, name ) elsif type. include? ( ARRAY_TYPE ) generate_top_leve_array ( path ) else raise UnsupportedSchemaError ; end else raise UnsupportedSchemaError ; end end
->Raw Target:
Generates a Model and adds it to the models array.
--

809=========
->Original Input:
['def', 'resolve_array_refs', '(', 'obj', ')', 'items', '=', 'obj', '[', 'ITEMS_KEY', ']', 'case', 'items', 'when', 'Array', 'return', 'resolve_items_array', '(', 'items', ')', 'when', 'Hash', 'any_of', '=', 'items', '[', 'ANY_OF_KEY', ']', 'return', 'resolve_items_array', '(', 'any_of', ')', 'if', 'any_of', '.', 'is_a?', '(', 'Array', ')', 'resolve_reference_string', '(', 'items', '[', 'REF_KEY', ']', ')', 'return', '[', 'class_name_from_ref', '(', 'items', '[', 'REF_KEY', ']', ')', ']', '.', 'compact', 'else', 'return', '[', ']', 'end', 'end']
->Original Target:
['Resolves', 'any', 'references', 'buied', 'in', 'the', 'items', 'property', 'of', 'an', 'array', 'definition', '.', 'Returns', 'a', 'list', 'of', 'collection', 'types', 'in', 'the', 'array', '.']
->Reconstructed Target:
Resolves any references buied in the items property of an array definition. Returns a list of collection types in the array.
->Reconstructed Predication:
the array of objects
->Raw Input:
summarize:def resolve_array_refs ( obj ) items = obj [ ITEMS_KEY ] case items when Array return resolve_items_array ( items ) when Hash any_of = items [ ANY_OF_KEY ] return resolve_items_array ( any_of ) if any_of. is_a? ( Array ) resolve_reference_string ( items [ REF_KEY ] ) return [ class_name_from_ref ( items [ REF_KEY ] ) ]. compact else return [ ] end end
->Raw Target:
Resolves any references buied in the items property of an array definition. Returns a list of collection types in the array.
--

810=========
->Original Input:
['def', 'run', '(', 'schema_path', ',', 'options', ')', 'schema', '=', 'Nidyx', '::', 'Reader', '.', 'read', '(', 'schema_path', ')', 'raw_models', '=', 'Nidyx', '::', 'Parser', '.', 'parse', '(', 'schema', ',', 'options', ')', 'models', '=', 'Nidyx', '::', 'Mapper', '.', 'map', '(', 'raw_models', ',', 'options', ')', 'Nidyx', '::', 'Output', '.', 'write', '(', 'models', ',', 'options', '[', ':output_directory', ']', ')', 'end']
->Original Target:
['The', 'Nidyx', 'model', 'generator', '.', 'Called', 'by', 'the', 'Nidyx', 'CLI', '.', 'Parses', 'the', 'input', 'schema', 'creates', 'models', 'and', 'writes', 'them', 'to', 'the', 'output', 'directory', '.']
->Reconstructed Target:
The Nidyx model generator. Called by the Nidyx CLI. Parses the input schema creates models and writes them to the output directory.
->Reconstructed Predication:
 def run
->Raw Input:
summarize:def run ( schema_path, options ) schema = Nidyx :: Reader. read ( schema_path ) raw_models = Nidyx :: Parser. parse ( schema, options ) models = Nidyx :: Mapper. map ( raw_models, options ) Nidyx :: Output. write ( models, options [ :output_directory ] ) end
->Raw Target:
The Nidyx model generator. Called by the Nidyx CLI. Parses the input schema creates models and writes them to the output directory.
--

811=========
->Original Input:
['def', 'read', '(', 'path', ')', 'schema', '=', 'nil', 'begin', 'schema', '=', 'JSON', '.', 'parse', '(', 'IO', '.', 'read', '(', 'path', ')', ')', 'raise', 'EmptySchemaError', 'if', 'empty_schema?', '(', 'schema', ')', 'rescue', 'JSON', '::', 'JSONError', '=>', 'e', 'puts', '"Encountered an error reading JSON from #{path}"', 'puts', 'e', '.', 'message', 'exit', '1', 'rescue', 'EmptySchemaError', 'puts', '"Schema read from #{path} is empty"', 'exit', '1', 'rescue', 'StandardError', '=>', 'e', 'puts', 'e', '.', 'message', 'exit', '1', 'end', 'schema', 'end']
->Original Target:
['Reads', 'JSON', 'from', 'a', 'file']
->Reconstructed Target:
Reads JSON from a file
->Reconstructed Predication:
the schema from the giventhe schema from the given
->Raw Input:
summarize:def read ( path ) schema = nil begin schema = JSON. parse ( IO. read ( path ) ) raise EmptySchemaError if empty_schema? ( schema ) rescue JSON :: JSONError => e puts "Encountered an error reading JSON from #{path}" puts e. message exit 1 rescue EmptySchemaError puts "Schema read from #{path} is empty" exit 1 rescue StandardError => e puts e. message exit 1 end schema end
->Raw Target:
Reads JSON from a file
--

812=========
->Original Input:
['def', 'sign_package', 'params', 'params_str', '=', 'create_sign_str', 'params', 'if', 'params_str', '=~', '/', '/', 'key', '=', 'Wxpay', '.', 'app_api_key', 'else', 'key', '=', 'Wxpay', '.', 'api_key', 'end', 'Digest', '::', 'MD5', '.', 'hexdigest', '(', 'params_str', '+', '"&key=#{key}"', ')', '.', 'upcase', 'end']
->Original Target:
['used', 'in', 'wechat', 'pay', 'api']
->Reconstructed Target:
used in wechat pay api
->Reconstructed Predication:
sign_package params
->Raw Input:
summarize:def sign_package params params_str = create_sign_str params if params_str =~ / / key = Wxpay. app_api_key else key = Wxpay. api_key end Digest :: MD5. hexdigest ( params_str + "&key=#{key}" ). upcase end
->Raw Target:
used in wechat pay api
--

813=========
->Original Input:
['def', '_each_resource_file', '(', 'config', ')', 'folder', '=', 'config', '.', 'folder', 'folder', '.', 'glob', '(', '"**/*.yml"', ')', '.', 'select', '(', '&', 'to_filter_proc', '(', 'config', '.', 'file_filter', ')', ')', '.', 'each', 'do', '|', 'file', '|', 'yield', 'file', ',', 'folder', 'end', 'end']
->Original Target:
['Recursive', 'implementation', 'of', 'each_resource_file', 'for', 'each', 'folder', 'in', 'the', 'configuration', '.']
->Reconstructed Target:
Recursive implementation of each_resource_file for each folder in the configuration.
->Reconstructed Predication:
each resource file
->Raw Input:
summarize:def _each_resource_file ( config ) folder = config. folder folder. glob ( "**/*.yml" ). select ( & to_filter_proc ( config. file_filter ) ). each do | file | yield file, folder end end
->Raw Target:
Recursive implementation of each_resource_file for each folder in the configuration.
--

814=========
->Original Input:
['def', 'each_resource', '(', '&', 'bl', ')', 'return', 'enum_for', '(', ':each_resource', ')', 'unless', 'block_given?', 'each_resource_file', 'do', '|', 'file', ',', 'folder', '|', 'yield', 'Webspicy', '.', 'resource', '(', 'file', '.', 'load', ',', 'file', ',', 'self', ')', 'end', 'end']
->Original Target:
['Yields', 'each', 'resource', 'in', 'the', 'current', 'scope', 'in', 'turn', '.']
->Reconstructed Target:
Yields each resource in the current scope in turn.
->Reconstructed Predication:
the resource for a file
->Raw Input:
summarize:def each_resource ( & bl ) return enum_for ( :each_resource ) unless block_given? each_resource_file do | file, folder | yield Webspicy. resource ( file. load, file, self ) end end
->Raw Target:
Yields each resource in the current scope in turn.
--

815=========
->Original Input:
['def', 'to_real_url', '(', 'url', ',', 'test_case', '=', 'nil', ',', '&', 'bl', ')', 'case', 'config', '.', 'host', 'when', 'Proc', 'config', '.', 'host', '.', 'call', '(', 'url', ',', 'test_case', ')', 'when', 'String', 'url', '=~', '/', '/', '?', 'url', ':', '"#{config.host}#{url}"', 'else', 'return', 'url', 'if', 'url', '=~', '/', '/', 'return', 'yield', '(', 'url', ')', 'if', 'block_given?', 'raise', '"Unable to resolve `#{url}` : no host resolver provided\\nSee `Configuration#host="', 'end', 'end']
->Original Target:
['Convert', 'an', 'instantiated', 'URL', 'found', 'in', 'a', 'webservice', 'definition', 'to', 'a', 'real', 'URL', 'using', 'the', 'configuration', 'host', '.']
->Reconstructed Target:
Convert an instantiated URL found in a webservice definition to a real URL using the configuration host.
->Reconstructed Predication:
the url to the given
->Raw Input:
summarize:def to_real_url ( url, test_case = nil, & bl ) case config. host when Proc config. host. call ( url, test_case ) when String url =~ / /? url : "#{config.host}#{url}" else return url if url =~ / / return yield ( url ) if block_given? raise "Unable to resolve `#{url}` : no host resolver provided\nSee `Configuration#host=" end end
->Raw Target:
Convert an instantiated URL found in a webservice definition to a real URL using the configuration host.
--

816=========
->Original Input:
['def', 'to_filter_proc', '(', 'filter', ')', 'case', 'ff', '=', 'filter', 'when', 'NilClass', 'then', '->', '(', 'f', ')', '{', 'true', '}', 'when', 'Proc', 'then', 'ff', 'when', 'Regexp', 'then', '->', '(', 'f', ')', '{', 'ff', '=~', 'f', '.', 'to_s', '}', 'else', '->', '(', 'f', ')', '{', 'ff', '===', 'f', '}', 'end', 'end']
->Original Target:
['Returns', 'a', 'proc', 'that', 'implements', 'file_filter', 'strategy', 'according', 'to', 'the', 'type', 'of', 'filter', 'installed']
->Reconstructed Target:
Returns a proc that implements file_filter strategy according to the type of filter installed
->Reconstructed Predication:
the filter to be filtered
->Raw Input:
summarize:def to_filter_proc ( filter ) case ff = filter when NilClass then -> ( f ) { true } when Proc then ff when Regexp then -> ( f ) { ff =~ f. to_s } else -> ( f ) { ff === f } end end
->Raw Target:
Returns a proc that implements file_filter strategy according to the type of filter installed
--

817=========
->Original Input:
['def', 'folder', '(', 'folder', '=', 'nil', ',', '&', 'bl', ')', 'if', 'folder', '.', 'nil?', '@folder', 'else', 'folder', '=', 'folder', '.', 'is_a?', '(', 'String', ')', '?', '@folder', '/', 'folder', ':', 'Path', '(', 'folder', ')', 'raise', '"Folder `#{folder}` does not exists"', 'unless', 'folder', '.', 'exists?', '&&', 'folder', '.', 'directory?', 'raise', '"Folder must be a descendant"', 'unless', 'folder', '.', 'inside?', '(', '@folder', ')', 'child', '=', 'dup', 'do', '|', 'c', '|', 'c', '.', 'parent', '=', 'self', 'c', '.', 'folder', '=', 'folder', 'end', 'yield', '(', 'child', ')', 'if', 'block_given?', '@children', '<<', 'child', 'child', 'end', 'end']
->Original Target:
['Adds', 'a', 'folder', 'to', 'the', 'list', 'of', 'folders', 'where', 'test', 'case', 'definitions', 'are', 'to', 'be', 'found', '.']
->Reconstructed Target:
Adds a folder to the list of folders where test case definitions are to be found.
->Reconstructed Predication:
folderfolder to be created in the
->Raw Input:
summarize:def folder ( folder = nil, & bl ) if folder. nil? @folder else folder = folder. is_a? ( String )? @folder / folder : Path ( folder ) raise "Folder `#{folder}` does not exists" unless folder. exists? && folder. directory? raise "Folder must be a descendant" unless folder. inside? ( @folder ) child = dup do | c | c. parent = self c. folder = folder end yield ( child ) if block_given? @children << child child end end
->Raw Target:
Adds a folder to the list of folders where test case definitions are to be found.
--

818=========
->Original Input:
['def', 'data_system', 'schema', '=', 'self', '.', 'folder', '/', '"schema.fio"', 'if', 'schema', '.', 'file?', 'Finitio', '::', 'DEFAULT_SYSTEM', '.', 'parse', '(', 'schema', '.', 'read', ')', 'elsif', 'not', '(', 'self', '.', 'parent', '.', 'nil?', ')', 'self', '.', 'parent', '.', 'data_system', 'else', 'Finitio', '::', 'DEFAULT_SYSTEM', 'end', 'end']
->Original Target:
['Returns', 'the', 'Data', 'system', 'to', 'use', 'for', 'parsing', 'schemas']
->Reconstructed Target:
Returns the Data system to use for parsing schemas
->Reconstructed Predication:
the schema for the file
->Raw Input:
summarize:def data_system schema = self. folder / "schema.fio" if schema. file? Finitio :: DEFAULT_SYSTEM. parse ( schema. read ) elsif not ( self. parent. nil? ) self. parent. data_system else Finitio :: DEFAULT_SYSTEM end end
->Raw Target:
Returns the Data system to use for parsing schemas
--

819=========
->Original Input:
['def', 'run', '(', 'direction', ')', 'self', '.', 'status', '.', 'direction', '=', 'direction', 'self', '.', 'status', '.', 'reset!', 'if', 'self', '.', 'class', '.', 'rerunnable_safe?', '&&', 'completed?', '(', 'direction', ')', 'self', '.', 'status', '.', 'execution_time', '=', 'time_it', '{', 'self', '.', 'send', '(', 'direction', ')', '}', 'self', '.', 'status', '.', 'last_succesful_completion', '=', 'Time', '.', 'now', 'end']
->Original Target:
['Makes', 'sure', 'status', 'get', 'instanciated', 'on', 'migration', 's', 'instanciation', 'Runs', 'the', 'migration', 'following', 'the', 'direction', 'sets', 'the', 'status', 'the', 'execution', 'time', 'and', 'the', 'last', 'succesful_completion', 'date']
->Reconstructed Target:
Makes sure status get instanciated on migration s instanciation Runs the migration following the direction sets the status the execution time and the last succesful_completion date
->Reconstructed Predication:
the given direction. 
->Raw Input:
summarize:def run ( direction ) self. status. direction = direction self. status. reset! if self. class. rerunnable_safe? && completed? ( direction ) self. status. execution_time = time_it { self. send ( direction ) } self. status. last_succesful_completion = Time. now end
->Raw Target:
Makes sure status get instanciated on migration s instanciation Runs the migration following the direction sets the status the execution time and the last succesful_completion date
--

820=========
->Original Input:
['def', 'failure', '=', '(', 'exception', ')', 'self', '.', 'status', '.', 'error', '=', 'MigrationError', '.', 'new', '(', ':error_message', '=>', 'exception', '.', 'message', ',', ':error_class', '=>', 'exception', '.', 'class', ',', ':error_backtrace', '=>', 'exception', '.', 'backtrace', ')', 'end']
->Original Target:
['Sets', 'an', 'error', 'to', 'migration', 'status']
->Reconstructed Target:
Sets an error to migration status
->Reconstructed Predication:
the error message. 
->Raw Input:
summarize:def failure = ( exception ) self. status. error = MigrationError. new ( :error_message => exception. message, :error_class => exception. class, :error_backtrace => exception. backtrace ) end
->Raw Target:
Sets an error to migration status
--

821=========
->Original Input:
['def', 'is_runnable?', '(', 'direction', ')', 'self', '.', 'class', '.', 'rerunnable_safe?', '||', '(', 'direction', '==', 'UP', '&&', 'status', '.', 'current_status', '<', 'status_complete', ')', '||', '(', 'direction', '==', 'DOWN', '&&', 'status', '.', 'current_status', '>', '0', ')', 'end']
->Original Target:
['Checks', 'if', 'a', 'migration', 'can', 'be', 'run']
->Reconstructed Target:
Checks if a migration can be run
->Reconstructed Predication:
return true if the runnable
->Raw Input:
summarize:def is_runnable? ( direction ) self. class. rerunnable_safe? || ( direction == UP && status. current_status < status_complete ) || ( direction == DOWN && status. current_status > 0 ) end
->Raw Target:
Checks if a migration can be run
--

822=========
->Original Input:
['def', 'completed?', '(', 'direction', ')', 'return', 'false', 'if', 'self', '.', 'status', '.', 'execution_time', '==', '0', '(', 'direction', '==', 'UP', '&&', 'self', '.', 'status', '.', 'current_status', '==', 'self', '.', 'status_complete', ')', '||', '(', 'direction', '==', 'DOWN', '&&', 'self', '.', 'status', '.', 'current_status', '==', '0', ')', 'end']
->Original Target:
['Checks', 'if', 'a', 'migration', 'as', 'been', 'completed']
->Reconstructed Target:
Checks if a migration as been completed
->Reconstructed Predication:
status_complete is the status of the
->Raw Input:
summarize:def completed? ( direction ) return false if self. status. execution_time == 0 ( direction == UP && self. status. current_status == self. status_complete ) || ( direction == DOWN && self. status. current_status == 0 ) end
->Raw Target:
Checks if a migration as been completed
--

823=========
->Original Input:
['def', 'step', '(', 'step_message', '=', 'nil', ',', 'step_status', '=', '1', ')', 'unless', 'status', '.', 'status_processed?', '(', 'status', '.', 'direction', ',', 'step_status', ')', 'self', '.', 'status', '.', 'message', '=', 'step_message', 'puts', '"\\t #{step_message}"', 'yield', 'if', 'block_given?', 'self', '.', 'status', '.', 'current_status', '+=', 'status', '.', 'direction_to_i', 'end', 'end']
->Original Target:
['Executes', 'a', 'given', 'block', 'if', 'the', 'status', 'has', 'not', 'being', 'processed', 'Then', 'update', 'the', 'status']
->Reconstructed Target:
Executes a given block if the status has not being processed Then update the status
->Reconstructed Predication:
the step step step step step_status
->Raw Input:
summarize:def step ( step_message = nil, step_status = 1 ) unless status. status_processed? ( status. direction, step_status ) self. status. message = step_message puts "\t #{step_message}" yield if block_given? self. status. current_status += status. direction_to_i end end
->Raw Target:
Executes a given block if the status has not being processed Then update the status
--

824=========
->Original Input:
['def', 'time_it', 'puts', '"Running #{self.class}[#{self.status.arguments}](#{self.status.direction})"', 'start', '=', 'Time', '.', 'now', 'yield', 'if', 'block_given?', 'end_time', '=', 'Time', '.', 'now', '-', 'start', 'puts', '"Tasks #{self.class} executed in #{end_time} seconds. \\n\\n"', 'end_time', 'end']
->Original Target:
['Executes', 'a', 'block', 'and', 'returns', 'the', 'time', 'it', 'took', 'to', 'be', 'executed']
->Reconstructed Target:
Executes a block and returns the time it took to be executed
->Reconstructed Predication:
the tasks to run
->Raw Input:
summarize:def time_it puts "Running #{self.class}[#{self.status.arguments}](#{self.status.direction})" start = Time. now yield if block_given? end_time = Time. now - start puts "Tasks #{self.class} executed in #{end_time} seconds. \n\n" end_time end
->Raw Target:
Executes a block and returns the time it took to be executed
--

825=========
->Original Input:
['def', 'super_print', '(', 'paragraphes', ',', 'space_number', '=', '50', ',', 'title', '=', 'true', ')', 'puts', 'format_paragraph', '(', 'space_number', ',', 'title', ',', '*', 'paragraphes', ')', 'end']
->Original Target:
['Prints', 'a', 'paragraphes']
->Reconstructed Target:
Prints a paragraphes
->Reconstructed Predication:
print paragraphes
->Raw Input:
summarize:def super_print ( paragraphes, space_number = 50, title = true ) puts format_paragraph ( space_number, title, * paragraphes ) end
->Raw Target:
Prints a paragraphes
--

826=========
->Original Input:
['def', 'columns_hash', 'colModel', '.', 'inject', '(', '{', '}', ')', '{', '|', 'h', ',', 'col', '|', 'h', '[', 'col', '.', 'name', ']', '=', 'col', ';', 'h', '}', 'end']
->Original Target:
['normally', 'we', 'need', 'to', 'keep', 'columns', 'an', 'ordered', 'array', 'sometimes', 'its', 'convenient', 'to', 'have', 'a', 'hash']
->Reconstructed Target:
normally we need to keep columns an ordered array sometimes its convenient to have a hash
->Reconstructed Predication:
return a hash of columns
->Raw Input:
summarize:def columns_hash colModel. inject ( { } ) { | h, col | h [ col. name ] = col ; h } end
->Raw Target:
normally we need to keep columns an ordered array sometimes its convenient to have a hash
--

827=========
->Original Input:
['def', 'render', '@page_list', '.', 'each', 'do', '|', 'page', '|', 'page', '.', 'render_to_file', '(', '@config', '.', 'dest_dir', ')', 'putc', "'.'", ';', '$stdout', '.', 'flush', 'end', '@dir_list', '.', 'each', 'do', '|', 'directory', '|', 'src', '=', 'File', '.', 'join', '(', '@config', '.', 'pages_dir', ',', 'directory', ')', 'dst', '=', 'File', '.', 'join', '(', '@config', '.', 'dest_dir', ',', 'directory', ')', 'Render', '::', 'Asset', '.', 'render_dir', '(', 'src', ',', 'dst', ')', 'putc', "'.'", ';', '$stdout', '.', 'flush', 'end', 'if', '@config', '.', 'short_paths', 'render_short_path_symlinks', 'end', 'Render', '::', 'Apache', '.', 'write_htaccess', '(', '@config', ',', '@config', '.', 'pages_dir', ',', '@config', '.', 'dest_dir', ')', 'puts', 'end']
->Original Target:
['def', 'reload_pages_if_needed', 'if']
->Reconstructed Target:
def reload_pages_if_needed if
->Reconstructed Predication:
. pages_dir ) puts. dest_dir ) puts
->Raw Input:
summarize:def render @page_list. each do | page | page. render_to_file ( @config. dest_dir ) putc '.' ; $stdout. flush end @dir_list. each do | directory | src = File. join ( @config. pages_dir, directory ) dst = File. join ( @config. dest_dir, directory ) Render :: Asset. render_dir ( src, dst ) putc '.' ; $stdout. flush end if @config. short_paths render_short_path_symlinks end Render :: Apache. write_htaccess ( @config, @config. pages_dir, @config. dest_dir ) puts end
->Raw Target:
def reload_pages_if_needed if
--

828=========
->Original Input:
['def', 'add_page', '(', 'page', ')', '@pages_by_name', '[', 'page', '.', 'name', ']', '||=', 'page', '@pages_by_path', '[', 'page', '.', 'path', '.', 'join', '(', "'/'", ')', ']', '=', 'page', 'add_aliases', '(', 'I18n', '.', 'default_locale', ',', 'page', ',', '@pages_by_path', ')', 'page', '.', 'locales', '.', 'each', 'do', '|', 'locale', '|', 'next', 'if', 'locale', '==', 'I18n', '.', 'default_locale', 'add_aliases', '(', 'locale', ',', 'page', ',', '@pages_by_locale_path', '[', 'locale', ']', ')', 'end', '@page_list', '<<', 'page', 'end']
->Original Target:
['registers', 'a', 'page', 'with', 'the', 'site', 'indexing', 'the', 'page', 'path', 'in', 'our', 'various', 'hashes']
->Reconstructed Target:
registers a page with the site indexing the page path in our various hashes
->Reconstructed Predication:
page.
->Raw Input:
summarize:def add_page ( page ) @pages_by_name [ page. name ] ||= page @pages_by_path [ page. path. join ( '/' ) ] = page add_aliases ( I18n. default_locale, page, @pages_by_path ) page. locales. each do | locale | next if locale == I18n. default_locale add_aliases ( locale, page, @pages_by_locale_path [ locale ] ) end @page_list << page end
->Raw Target:
registers a page with the site indexing the page path in our various hashes
--

829=========
->Original Input:
['def', 'add_aliases', '(', 'locale', ',', 'page', ',', 'path_hash', ')', 'page', '.', 'aliases', '(', 'locale', ')', '.', 'each', 'do', '|', 'alias_path', '|', 'alias_path_str', '=', 'alias_path', '.', 'join', '(', "'/'", ')', 'if', 'path_hash', '[', 'alias_path_str', ']', 'Amber', '.', 'logger', '.', 'warn', '"WARNING: page `#{page.path.join(\'/\')}` has alias `#{alias_path_str}`, but this path is already taken by `#{path_hash[alias_path_str].path.join(\'/\')}` (locale = #{locale})."', 'else', 'path_hash', '[', 'alias_path_str', ']', '=', 'page', 'end', 'end', 'end']
->Original Target:
['registers', 'a', 'page', 's', 'aliases', 'with', 'the', 'site']
->Reconstructed Target:
registers a page s aliases with the site
->Reconstructed Predication:
page alias path for the page
->Raw Input:
summarize:def add_aliases ( locale, page, path_hash ) page. aliases ( locale ). each do | alias_path | alias_path_str = alias_path. join ( '/' ) if path_hash [ alias_path_str ] Amber. logger. warn "WARNING: page `#{page.path.join('/')}` has alias `#{alias_path_str}`, but this path is already taken by `#{path_hash[alias_path_str].path.join('/')}` (locale = #{locale})." else path_hash [ alias_path_str ] = page end end end
->Raw Target:
registers a page s aliases with the site
--

830=========
->Original Input:
['def', 'parse_headers', '(', 'content_file', ')', 'headers', '=', '[', ']', 'para1', '=', '[', ']', 'para2', '=', '[', ']', 'file_type', '=', 'type_from_path', '(', 'content_file', ')', 'File', '.', 'open', '(', 'content_file', ',', ':encoding', '=>', "'UTF-8'", ')', 'do', '|', 'f', '|', 'while', '(', 'line', '=', 'f', '.', 'gets', ')', '=~', '/', '\\w', '/', 'if', 'line', '!~', '/', '/', 'line', '=', "'- '", '+', 'line', 'end', 'headers', '<<', 'line', 'end', 'while', 'line', '=', 'f', '.', 'gets', 'break', 'unless', 'line', '=~', '/', '\\s', '/', 'end', 'para1', '<<', 'line', 'while', 'line', '=', 'f', '.', 'gets', 'break', 'if', 'line', '=~', '/', '\\s', '/', 'para1', '<<', 'line', 'end', 'while', 'line', '=', 'f', '.', 'gets', 'break', 'if', 'line', '=~', '/', '\\s', '/', 'para2', '<<', 'line', 'end', 'end', 'headers', '=', 'headers', '.', 'join', 'para1', '=', 'para1', '.', 'join', 'para2', '=', 'para2', '.', 'join', 'excerpt', '=', '""', 'if', 'file_type', '==', ':textile', 'if', 'para1', '=~', '/', '\\.', '/', 'excerpt', '=', 'para2', 'else', 'excerpt', '=', 'para1', 'end', 'elsif', 'file_type', '==', ':markdown', 'if', 'para1', '=~', '/', '/', '||', 'para1', '=~', '/', '\\s', '/m', 'excerpt', '=', 'para2', 'else', 'excerpt', '=', 'para1', 'end', 'end', 'return', '[', 'headers', ',', 'excerpt', ']', 'end']
->Original Target:
['parses', 'a', 'content_file', 's', 'property', 'headers', 'and', 'tries', 'to', 'extract', 'the', 'first', 'paragraph', '.']
->Reconstructed Target:
parses a content_file s property headers and tries to extract the first paragraph.
->Reconstructed Predication:
the content of athe content of a filefile_type == :textilefile_type == :markdownfile_type == :markdownfile_type == :textilefile_type == :markdownfile_type == :markdownfile_type == :textilefile_type == :markdownfile_type == :markdownfile_type == :textilefile_type == :markdownfile_type == :
->Raw Input:
summarize:def parse_headers ( content_file ) headers = [ ] para1 = [ ] para2 = [ ] file_type = type_from_path ( content_file ) File. open ( content_file, :encoding => 'UTF-8' ) do | f | while ( line = f. gets ) =~ / \w / if line!~ / / line = '-'+ line end headers << line end while line = f. gets break unless line =~ / \s / end para1 << line while line = f. gets break if line =~ / \s / para1 << line end while line = f. gets break if line =~ / \s / para2 << line end end headers = headers. join para1 = para1. join para2 = para2. join excerpt = "" if file_type == :textile if para1 =~ / \. / excerpt = para2 else excerpt = para1 end elsif file_type == :markdown if para1 =~ / / || para1 =~ / \s /m excerpt = para2 else excerpt = para1 end end return [ headers, excerpt ] end
->Raw Target:
parses a content_file s property headers and tries to extract the first paragraph.
--

831=========
->Original Input:
['def', 'variable_files', 'if', '@simple_page', 'directory', '=', 'File', '.', 'dirname', '(', '@file_path', ')', 'regexp', '=', 'SIMPLE_VAR_MATCH_RE', '.', 'call', '(', '@name', ')', 'else', 'directory', '=', '@file_path', 'regexp', '=', 'VAR_FILE_MATCH_RE', 'end', 'hsh', '=', '{', '}', 'Dir', '.', 'foreach', '(', 'directory', ')', 'do', '|', 'file', '|', 'if', 'file', '&&', 'match', '=', 'regexp', '.', 'match', '(', 'file', ')', 'locale', '=', 'match', '[', "'locale'", ']', '||', 'I18n', '.', 'default_locale', 'hsh', '[', 'locale', '.', 'to_sym', ']', '=', 'File', '.', 'join', '(', 'directory', ',', 'file', ')', 'end', 'end', 'hsh', 'end']
->Original Target:
['VARIABLES', 'Variables', 'are', 'associated', 'with', 'a', 'page', 'but', 'unlike', 'properties', 'they', 'are', 'not', 'inheritable', '.', 'Variables', 'are', 'defined', 'in', 'a', 'separate', 'file', '.']
->Reconstructed Target:
VARIABLES Variables are associated with a page but unlike properties they are not inheritable. Variables are defined in a separate file.
->Reconstructed Predication:
@name
->Raw Input:
summarize:def variable_files if @simple_page directory = File. dirname ( @file_path ) regexp = SIMPLE_VAR_MATCH_RE. call ( @name ) else directory = @file_path regexp = VAR_FILE_MATCH_RE end hsh = { } Dir. foreach ( directory ) do | file | if file && match = regexp. match ( file ) locale = match [ 'locale' ] || I18n. default_locale hsh [ locale. to_sym ] = File. join ( directory, file ) end end hsh end
->Raw Target:
VARIABLES Variables are associated with a page but unlike properties they are not inheritable. Variables are defined in a separate file.
--

832=========
->Original Input:
['def', 'last_menu_at_depth', '(', 'depth', ')', 'menu', '=', 'self', 'depth', '.', 'times', '{', 'menu', '=', 'menu', '.', 'children', '.', 'last', '}', 'menu', 'end']
->Original Target:
['returns', 'the', 'last', 'list', 'of', 'children', 'at', 'the', 'specified', 'depth']
->Reconstructed Target:
returns the last list of children at the specified depth
->Reconstructed Predication:
menu  def last_menu_at_depth
->Raw Input:
summarize:def last_menu_at_depth ( depth ) menu = self depth. times { menu = menu. children. last } menu end
->Raw Target:
returns the last list of children at the specified depth
--

833=========
->Original Input:
['def', 'nameize', '(', 'str', ')', 'str', '=', 'str', '.', 'dup', 'str', '.', 'gsub!', '(', '/', '\\w', '/', ',', "''", ')', 'str', '.', 'gsub!', '(', '/', '/u', ',', "''", ')', 'str', '.', 'strip!', 'str', '.', 'downcase!', 'str', '.', 'gsub!', '(', '/', '\\ ', '/u', ',', "'-'", ')', 'CGI', '.', 'escape', '(', 'str', ')', 'end']
->Original Target:
['convert', 'any', 'string', 'to', 'one', 'suitable', 'for', 'a', 'url', '.', 'resist', 'the', 'urge', 'to', 'translit', 'non', '-', 'ascii', 'slugs', 'to', 'ascii', '.', 'it', 'is', 'always', 'much', 'better', 'to', 'keep', 'strings', 'as', 'utf8', '.']
->Reconstructed Target:
convert any string to one suitable for a url. resist the urge to translit non - ascii slugs to ascii. it is always much better to keep strings as utf8.
->Reconstructed Predication:
the name of the giventhe name of the given
->Raw Input:
summarize:def nameize ( str ) str = str. dup str. gsub! ( / \w /, '' ) str. gsub! ( / /u, '' ) str. strip! str. downcase! str. gsub! ( / \  /u, '-' ) CGI. escape ( str ) end
->Raw Target:
convert any string to one suitable for a url. resist the urge to translit non - ascii slugs to ascii. it is always much better to keep strings as utf8.
--

834=========
->Original Input:
['def', 'strip_html_tags', '(', 'html', ')', 'Nokogiri', '::', 'HTML', '::', 'DocumentFragment', '.', 'parse', '(', 'html', ',', "'UTF-8'", ')', '.', 'children', '.', 'collect', '{', '|', 'child', '|', 'child', '.', 'inner_text', '}', '.', 'join', 'end']
->Original Target:
['removes', 'all', 'html', 'markup']
->Reconstructed Target:
removes all html markup
->Reconstructed Predication:
strip html tags
->Raw Input:
summarize:def strip_html_tags ( html ) Nokogiri :: HTML :: DocumentFragment. parse ( html, 'UTF-8' ). children. collect { | child | child. inner_text }. join end
->Raw Target:
removes all html markup
--

835=========
->Original Input:
['def', 'populate_node', '(', 'node', ',', 'options', ')', '@children', '.', 'each', 'do', '|', 'item', '|', 'li', '=', 'node', '.', 'document', '.', 'create_element', '(', '"li"', ')', 'li', '.', 'add_child', '(', 'li', '.', 'document', '.', 'create_element', '(', '"a"', ',', 'item', '.', 'text', ',', ':href', '=>', '"#{options[:href_base]}##{item.anchor}"', ')', ')', 'if', 'item', '.', 'children', '.', 'any?', 'ul', '=', 'li', '.', 'document', '.', 'create_element', '(', 'options', '[', ':tag', ']', ')', 'item', '.', 'populate_node', '(', 'ul', ',', 'options', ')', 'li', '.', 'add_child', '(', 'ul', ')', 'end', 'node', '.', 'add_child', '(', 'li', ')', 'end', 'end']
->Original Target:
['generates', 'nokogiri', 'html', 'node', 'tree', 'from', 'this', 'toc']
->Reconstructed Target:
generates nokogiri html node tree from this toc
->Reconstructed Predication:
the node.
->Raw Input:
summarize:def populate_node ( node, options ) @children. each do | item | li = node. document. create_element ( "li" ) li. add_child ( li. document. create_element ( "a", item. text, :href => "#{options[:href_base]}##{item.anchor}" ) ) if item. children. any? ul = li. document. create_element ( options [ :tag ] ) item. populate_node ( ul, options ) li. add_child ( ul ) end node. add_child ( li ) end end
->Raw Target:
generates nokogiri html node tree from this toc
--

836=========
->Original Input:
['def', 'to_html', '(', 'options', '=', '{', '}', ')', 'html', '=', '[', ']', 'tag', '=', 'options', '[', ':tag', ']', 'indent', '=', 'options', '[', ':indent', ']', '||', '0', 'str', '=', 'options', '[', ':indent_str', ']', '||', '"  "', 'html', '<<', "'%s<%s>'", '%', '[', '(', 'str', '*', 'indent', ')', ',', 'tag', ']', '@children', '.', 'each', 'do', '|', 'item', '|', 'html', '<<', "'%s<li>'", '%', '(', 'str', '*', '(', 'indent', '+', '1', ')', ')', 'html', '<<', '\'%s<a href="%s#%s">%s</a>\'', '%', '[', 'str', '*', '(', 'indent', '+', '2', ')', ',', 'options', '[', ':href_base', ']', ',', 'item', '.', 'anchor', ',', 'item', '.', 'text', ']', 'if', 'item', '.', 'children', '.', 'any?', 'html', '<<', 'item', '.', 'to_html', '(', '{', ':indent', '=>', 'indent', '+', '2', ',', ':indent_str', '=>', 'str', ',', ':tag', '=>', 'tag', ',', ':href_base', '=>', 'options', '[', ':href_base', ']', '}', ')', 'end', 'html', '<<', "'%s</li>'", '%', '(', 'str', '*', '(', 'indent', '+', '1', ')', ')', 'end', 'html', '<<', "'%s</%s>'", '%', '[', '(', 'str', '*', 'indent', ')', ',', 'tag', ']', 'html', '.', 'join', '(', '"\\n"', ')', 'end']
->Original Target:
['generates', 'html', 'string', 'from', 'this', 'toc']
->Reconstructed Target:
generates html string from this toc
->Reconstructed Predication:
:indent_str => indent + 2:href_base => options [ :href_base], :href_base => options[ :href_base ],],],],],],],],],],],],],],
->Raw Input:
summarize:def to_html ( options = { } ) html = [ ] tag = options [ :tag ] indent = options [ :indent ] || 0 str = options [ :indent_str ] || "  " html << '%s<%s>' % [ ( str * indent ), tag ] @children. each do | item | html << '%s<li>' % ( str * ( indent + 1 ) ) html << '%s<a href="%s#%s">%s</a>' % [ str * ( indent + 2 ), options [ :href_base ], item. anchor, item. text ] if item. children. any? html << item. to_html ( { :indent => indent + 2, :indent_str => str, :tag => tag, :href_base => options [ :href_base ] } ) end html << '%s</li>' % ( str * ( indent + 1 ) ) end html << '%s</%s>' % [ ( str * indent ), tag ] html. join ( "\n" ) end
->Raw Target:
generates html string from this toc
--

837=========
->Original Input:
['def', 'parent_for', '(', 'heading', ')', 'heading', '=', 'heading', '[', '1', ']', '.', 'to_i', 'if', 'heading', '.', 'is_a?', '(', 'String', ')', 'if', 'children', '.', 'any?', '&&', 'children', '.', 'last', '.', 'level', '<', 'heading', 'children', '.', 'last', '.', 'parent_for', '(', 'heading', ')', 'else', 'self', 'end', 'end']
->Original Target:
['Returns', 'the', 'appropriate', 'TocItem', 'for', 'appending', 'a', 'new', 'item', 'at', 'a', 'particular', 'heading', 'level', '.']
->Reconstructed Target:
Returns the appropriate TocItem for appending a new item at a particular heading level.
->Reconstructed Predication:
the parent of the given heading
->Raw Input:
summarize:def parent_for ( heading ) heading = heading [ 1 ]. to_i if heading. is_a? ( String ) if children. any? && children. last. level < heading children. last. parent_for ( heading ) else self end end
->Raw Target:
Returns the appropriate TocItem for appending a new item at a particular heading level.
--

838=========
->Original Input:
['def', 'type_id', '(', 'which', ')', 'which', '=', 'which', '.', 'to_s', '.', 'humanize', 'unless', 'which', '.', 'kind_of?', '(', 'String', ')', 'which', '.', 'downcase!', 'case', 'which', 'when', "'alliance'", 'then', '16159', 'when', "'character'", 'then', '1377', 'when', "'corporation'", 'then', '2', 'when', "'constellation'", 'then', '4', 'when', "'region'", 'then', '3', 'when', "'solar system'", ',', "'solarsystem'", 'then', '5', 'when', "'station'", 'then', '3867', 'else', 'raise', 'ArgumentError', ',', '"Unknown type: #{which}"', 'end', 'end']
->Original Target:
['Returns', 'the', 'numeric', 'type', 'ID', 'for', 'a', 'string', 'so', 'you', 'don', 't', 'have', 'to', 'manage', 'magic', 'numbers', 'in', 'your', 'application', '.', 'The', 'argument', 'can', 'be', 'a', 'string', 'or', 'a', 'symbol', 'and', 'is', 'case', 'insensitive', '.', 'Underscores', 'will', 'be', 'converted', 'to', 'spaces', '.']
->Reconstructed Target:
Returns the numeric type ID for a string so you don t have to manage magic numbers in your application. The argument can be a string or a symbol and is case insensitive. Underscores will be converted to spaces.
->Reconstructed Predication:
the type of the
->Raw Input:
summarize:def type_id ( which ) which = which. to_s. humanize unless which. kind_of? ( String ) which. downcase! case which when 'alliance' then 16159 when 'character' then 1377 when 'corporation' then 2 when 'constellation' then 4 when'region' then 3 when'solar system','solarsystem' then 5 when'station' then 3867 else raise ArgumentError, "Unknown type: #{which}" end end
->Raw Target:
Returns the numeric type ID for a string so you don t have to manage magic numbers in your application. The argument can be a string or a symbol and is case insensitive. Underscores will be converted to spaces.
--

839=========
->Original Input:
['def', 'link_to_info', '(', 'text', ',', 'type_id', ',', 'item_id', '=', 'nil', ',', '*', 'args', ')', 'function', '=', '"CCPEVE.showInfo(#{type_id.inspect}"', 'function', '.', 'concat', '", #{item_id.inspect}"', 'if', 'item_id', 'function', '.', 'concat', '")"', 'link_to_function', 'text', ',', 'function', ',', '*', 'args', 'end']
->Original Target:
['Creates', 'a', 'hyperlink', 'that', 'results', 'in', 'the', 'show', 'info', 'dialog', 'being', 'displayed', 'on', 'the', 'client', 's', 'screen', '.', 'If', 'item_id', 'is', 'given', 'the', 'show', 'info', 'window', 'will', 'open', 'for', 'that', 'item', '.']
->Reconstructed Target:
Creates a hyperlink that results in the show info dialog being displayed on the client s screen. If item_id is given the show info window will open for that item.
->Reconstructed Predication:
the link to the
->Raw Input:
summarize:def link_to_info ( text, type_id, item_id = nil, * args ) function = "CCPEVE.showInfo(#{type_id.inspect}" function. concat ", #{item_id.inspect}" if item_id function. concat ")" link_to_function text, function, * args end
->Raw Target:
Creates a hyperlink that results in the show info dialog being displayed on the client s screen. If item_id is given the show info window will open for that item.
--

840=========
->Original Input:
['def', 'link_to_route', '(', 'text', ',', 'destination_id', ',', 'source_id', '=', 'nil', ',', '*', 'args', ')', 'function', '=', '"CCPEVE.showRouteTo(#{destination_id.inspect}"', 'function', '.', 'concat', '", #{source_id.inspect}"', 'if', 'source_id', 'function', '.', 'concat', '")"', 'link_to_function', 'text', ',', 'function', ',', '*', 'args', 'end']
->Original Target:
['Creates', 'a', 'hyperlink', 'that', 'results', 'in', 'showing', 'the', 'route', 'to', 'the', 'destination_id', 'from', 'the', 'source_id', '.', 'If', 'source_id', 'is', 'not', 'given', 'the', 'source', 'system', 'is', 'taken', 'to', 'be', 'the', 'system', 'the', 'user', 'is', 'currently', 'in', '.']
->Reconstructed Target:
Creates a hyperlink that results in showing the route to the destination_id from the source_id. If source_id is not given the source system is taken to be the system the user is currently in.
->Reconstructed Predication:
the link to the specified
->Raw Input:
summarize:def link_to_route ( text, destination_id, source_id = nil, * args ) function = "CCPEVE.showRouteTo(#{destination_id.inspect}" function. concat ", #{source_id.inspect}" if source_id function. concat ")" link_to_function text, function, * args end
->Raw Target:
Creates a hyperlink that results in showing the route to the destination_id from the source_id. If source_id is not given the source system is taken to be the system the user is currently in.
--

841=========
->Original Input:
['def', 'link_to_trust_request', '(', 'text', ',', 'trust_url', '=', '"http://#{request.host}/"', ',', '*', 'args', ')', 'trust_url', '=', 'url_for', '(', 'trust_url', '.', 'merge', '(', ':only_path', '=>', 'false', ')', ')', 'if', 'trust_url', '.', 'kind_of?', '(', 'Hash', ')', 'link_to_function', 'text', ',', '"CCPEVE.requestTrust(#{trust_url.inspect})"', ',', '*', 'args', 'end']
->Original Target:
['Produces', 'a', 'hyperlink', 'that', 'will', 'result', 'in', 'a', 'pop', '-', 'up', 'a', 'trust', 'prompt', 'in', 'the', 'client', 'allowing', 'the', 'user', 'to', 'either', 'grant', 'the', 'trust', 'request', 'ignore', 'it', 'or', 'always', 'ignore', 'trust', 'requests', 'from', 'your', 'site', '.']
->Reconstructed Target:
Produces a hyperlink that will result in a pop - up a trust prompt in the client allowing the user to either grant the trust request ignore it or always ignore trust requests from your site.
->Reconstructed Predication:
the trust request
->Raw Input:
summarize:def link_to_trust_request ( text, trust_url = "http://#{request.host}/", * args ) trust_url = url_for ( trust_url. merge ( :only_path => false ) ) if trust_url. kind_of? ( Hash ) link_to_function text, "CCPEVE.requestTrust(#{trust_url.inspect})", * args end
->Raw Target:
Produces a hyperlink that will result in a pop - up a trust prompt in the client allowing the user to either grant the trust request ignore it or always ignore trust requests from your site.
--

842=========
->Original Input:
['def', 'request_trust', '(', 'trust_url', '=', '"http://#{request.host}/"', ',', '*', 'args', ')', 'trust_url', '=', 'url_for', '(', 'trust_url', '.', 'merge', '(', ':only_path', '=>', 'false', ')', ')', 'if', 'trust_url', '.', 'kind_of?', '(', 'Hash', ')', 'javascript_tag', '"CCPEVE.requestTrust(#{trust_url.inspect});"', ',', '*', 'args', 'end']
->Original Target:
['This', 'will', 'generate', 'a', 'method', 'call', 'that', 'produces', 'a', 'pop', '-', 'up', 'a', 'trust', 'prompt', 'in', 'the', 'client', 'allowing', 'the', 'user', 'to', 'either', 'grant', 'the', 'trust', 'request', 'ignore', 'it', 'or', 'always', 'ignore', 'trust', 'requests', 'from', 'your', 'site', '.']
->Reconstructed Target:
This will generate a method call that produces a pop - up a trust prompt in the client allowing the user to either grant the trust request ignore it or always ignore trust requests from your site.
->Reconstructed Predication:
the trust url to the server
->Raw Input:
summarize:def request_trust ( trust_url = "http://#{request.host}/", * args ) trust_url = url_for ( trust_url. merge ( :only_path => false ) ) if trust_url. kind_of? ( Hash ) javascript_tag "CCPEVE.requestTrust(#{trust_url.inspect});", * args end
->Raw Target:
This will generate a method call that produces a pop - up a trust prompt in the client allowing the user to either grant the trust request ignore it or always ignore trust requests from your site.
--

843=========
->Original Input:
['def', 'render_to_file', '(', 'dest_dir', ',', 'options', '=', '{', '}', ')', 'render_content_files', '(', 'dest_dir', ',', 'options', ')', 'render_assets', '(', 'dest_dir', ')', '@props', '.', 'locales', '.', 'each', 'do', '|', 'locale', '|', 'if', 'aliases', '(', 'locale', ')', '.', 'any?', 'link_page_aliases', '(', 'dest_dir', ',', 'aliases', '(', 'locale', ')', ',', 'locale', ')', 'end', 'end', 'end']
->Original Target:
['render', 'without', 'layout', 'possibly', 'with', 'via', 'a', 'rails', 'request']
->Reconstructed Target:
render without layout possibly with via a rails request
->Reconstructed Predication:
render_to_file dest_dir
->Raw Input:
summarize:def render_to_file ( dest_dir, options = { } ) render_content_files ( dest_dir, options ) render_assets ( dest_dir ) @props. locales. each do | locale | if aliases ( locale ). any? link_page_aliases ( dest_dir, aliases ( locale ), locale ) end end end
->Raw Target:
render without layout possibly with via a rails request
--

844=========
->Original Input:
['def', 'symlink', '(', 'from_path', ',', 'to_path', ')', 'to_path', '=', 'realpath', '(', 'to_path', ')', 'target', '=', 'from_path', '.', 'relative_path_from', '(', 'to_path', ')', '.', 'to_s', '.', 'sub', '(', '/', '\\.', '\\.', '\\/', '/', ',', "''", ')', 'if', '!', 'to_path', '.', 'dirname', '.', 'directory?', 'Amber', '.', 'logger', '.', 'warn', '{', '"On page `#{@file_path}`, the parent directories for alias name `#{to_path}` don\'t exist. Skipping alias."', '}', 'return', 'end', 'if', 'to_path', '.', 'exist?', '&&', 'to_path', '.', 'symlink?', 'File', '.', 'unlink', '(', 'to_path', ')', 'end', 'if', '!', 'to_path', '.', 'exist?', 'Amber', '.', 'logger', '.', 'debug', '{', '"Symlink #{to_path} => #{target}"', '}', 'FileUtils', '.', 'ln_s', '(', 'target', ',', 'to_path', ')', 'end', 'end']
->Original Target:
['create', 'a', 'symlink', '.', 'arguments', 'must', 'be', 'of', 'type', 'Pathname', '.']
->Reconstructed Target:
create a symlink. arguments must be of type Pathname.
->Reconstructed Predication:
. symlink ( from_path to_path )
->Raw Input:
summarize:def symlink ( from_path, to_path ) to_path = realpath ( to_path ) target = from_path. relative_path_from ( to_path ). to_s. sub ( / \. \. \/ /, '' ) if! to_path. dirname. directory? Amber. logger. warn { "On page `#{@file_path}`, the parent directories for alias name `#{to_path}` don't exist. Skipping alias." } return end if to_path. exist? && to_path. symlink? File. unlink ( to_path ) end if! to_path. exist? Amber. logger. debug { "Symlink #{to_path} => #{target}" } FileUtils. ln_s ( target, to_path ) end end
->Raw Target:
create a symlink. arguments must be of type Pathname.
--

845=========
->Original Input:
['def', 'render_content_files', '(', 'dest_dir', ',', 'options', ')', 'view', '=', 'Render', '::', 'View', '.', 'new', '(', 'self', ',', '@config', ')', '@config', '.', 'locales', '.', 'each', 'do', '|', 'file_locale', '|', 'content_file', '=', 'content_file', '(', 'file_locale', ')', 'next', 'unless', 'content_file', 'dest', '=', 'destination_file', '(', 'dest_dir', ',', 'file_locale', ')', 'unless', 'Dir', '.', 'exist?', '(', 'File', '.', 'dirname', '(', 'dest', ')', ')', 'FileUtils', '.', 'mkdir_p', '(', 'File', '.', 'dirname', '(', 'dest', ')', ')', 'end', 'if', 'options', '[', ':force', ']', '||', '!', 'File', '.', 'exist?', '(', 'dest', ')', '||', 'File', '.', 'mtime', '(', 'content_file', ')', '>', 'File', '.', 'mtime', '(', 'dest', ')', 'File', '.', 'open', '(', 'dest', ',', "'w'", ')', 'do', '|', 'f', '|', 'layout', '=', '@props', '.', 'layout', '||', "'default'", 'f', '.', 'write', 'view', '.', 'render', '(', '{', 'page', ':', 'self', ',', 'layout', ':', 'layout', '}', ',', '{', 'locale', ':', 'file_locale', '}', ')', 'end', 'end', 'end', 'end']
->Original Target:
['called', 'only', 'by', 'render_to_file']
->Reconstructed Target:
called only by render_to_file
->Reconstructed Predication:
the content files. render_content_files (content_file, options )content_file, options )content_file, options ) end
->Raw Input:
summarize:def render_content_files ( dest_dir, options ) view = Render :: View. new ( self, @config ) @config. locales. each do | file_locale | content_file = content_file ( file_locale ) next unless content_file dest = destination_file ( dest_dir, file_locale ) unless Dir. exist? ( File. dirname ( dest ) ) FileUtils. mkdir_p ( File. dirname ( dest ) ) end if options [ :force ] ||! File. exist? ( dest ) || File. mtime ( content_file ) > File. mtime ( dest ) File. open ( dest, 'w' ) do | f | layout = @props. layout || 'default' f. write view. render ( { page : self, layout : layout }, { locale : file_locale } ) end end end end
->Raw Target:
called only by render_to_file
--

846=========
->Original Input:
['def', 'friend', 'name', ',', 'friend_id', ',', 'note', '=', 'nil', 'friend_wrapper', '(', 'api_name', '=', 'name', ',', 'api_container', '=', '@userid', ',', 'api_note', '=', 'note', ',', 'api_type', '=', '"friend"', ')', 'end']
->Original Target:
['Friend', 'a', 'user']
->Reconstructed Target:
Friend a user
->Reconstructed Predication:
the friend with the given id
->Raw Input:
summarize:def friend name, friend_id, note = nil friend_wrapper ( api_name = name, api_container = @userid, api_note = note, api_type = "friend" ) end
->Raw Target:
Friend a user
--

847=========
->Original Input:
['def', 'get_user_listing', 'username', ',', 'opts', '=', '{', '}', 'opts', '[', ':type', ']', '=', "'overview'", 'if', 'opts', '[', ':type', ']', '.', 'nil?', 'url', '=', '"/user/%s%s.json"', '%', '[', 'username', ',', '(', "'/'", '+', 'opts', '[', ':type', ']', 'if', 'opts', '[', ':type', ']', '!=', "'overview'", ')', ']', 'opts', '.', 'delete', ':type', 'query', '=', 'opts', 'get', '(', 'url', ',', 'query', ':', 'query', ')', 'end']
->Original Target:
['Get', 'a', 'listing', 'of', 'user', 'posts', '.', 'Some', 'options', 'may', 'be', 'restricted']
->Reconstructed Target:
Get a listing of user posts. Some options may be restricted
->Reconstructed Predication:
the user listing for thethe user listing.
->Raw Input:
summarize:def get_user_listing username, opts = { } opts [ :type ] = 'overview' if opts [ :type ]. nil? url = "/user/%s%s.json" % [ username, ( '/' + opts [ :type ] if opts [ :type ]!= 'overview' ) ] opts. delete :type query = opts get ( url, query : query ) end
->Raw Target:
Get a listing of user posts. Some options may be restricted
--

848=========
->Original Input:
['def', 'comment', 'text', ',', 'id', 'logged_in?', 'post', '(', "'/api/comment'", ',', 'body', ':', '{', 'text', ':', 'text', ',', 'thing_id', ':', 'id', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Posts', 'a', 'comment', 'to', 'the', 'site']
->Reconstructed Target:
Posts a comment to the site
->Reconstructed Predication:
the user to thethe user to the user
->Raw Input:
summarize:def comment text, id logged_in? post ( '/api/comment', body : { text : text, thing_id : id, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Posts a comment to the site
--

849=========
->Original Input:
['def', 'submit', 'title', ',', 'subreddit', ',', 'opts', '=', '{', '}', 'logged_in?', 'post', '=', '{', 'title', ':', 'title', ',', 'sr', ':', 'subreddit', ',', 'uh', ':', '@modhash', ',', 'kind', ':', '(', 'opts', '[', ':url', ']', '?', '"link"', ':', '"self"', ')', ',', 'api_type', ':', "'json'", '}', 'post', '.', 'merge!', 'opts', 'post', '(', "'/api/submit'", ',', 'body', ':', 'post', ')', 'end']
->Original Target:
['Submit', 'a', 'link', 'or', 'self', 'post']
->Reconstructed Target:
Submit a link or self post
->Reconstructed Predication:
submit a subreddit to asubmit a subreddit to a subredditreturn
->Raw Input:
summarize:def submit title, subreddit, opts = { } logged_in? post = { title : title, sr : subreddit, uh : @modhash, kind : ( opts [ :url ]? "link" : "self" ), api_type : 'json' } post. merge! opts post ( '/api/submit', body : post ) end
->Raw Target:
Submit a link or self post
--

850=========
->Original Input:
['def', 'vote', 'direction', ',', 'id', 'logged_in?', 'post', '(', "'/api/vote'", ',', 'body', ':', '{', 'id', ':', 'id', ',', 'dir', ':', 'direction', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Vote', 'on', 'a', 'comment', 'or', 'link']
->Reconstructed Target:
Vote on a comment or link
->Reconstructed Predication:
 def vote ( direction)
->Raw Input:
summarize:def vote direction, id logged_in? post ( '/api/vote', body : { id : id, dir : direction, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Vote on a comment or link
--

851=========
->Original Input:
['def', 'correct?', '(', 'str', ')', 'str', '=', 'str', '.', 'is_a?', '(', 'String', ')', '?', 'str', ':', 'str', '.', 'to_s', 'str', '==', '(', '@answer', '.', 'is_a?', '(', 'String', ')', '?', '@answer', ':', '@answer', '.', 'to_s', ')', 'end']
->Original Target:
['Determine', 'whether', 'or', 'not', 'an', 'answer', 'is', 'correct']
->Reconstructed Target:
Determine whether or not an answer is correct
->Reconstructed Predication:
the answer of the answer
->Raw Input:
summarize:def correct? ( str ) str = str. is_a? ( String )? str : str. to_s str == ( @answer. is_a? ( String )? @answer : @answer. to_s ) end
->Raw Target:
Determine whether or not an answer is correct
--

852=========
->Original Input:
['def', 'gotcha', '(', 'options', '=', '{', '}', ')', 'options', '[', ':label_options', ']', '||=', '{', '}', 'options', '[', ':text_field_options', ']', '||=', '{', '}', 'if', 'gotcha', '=', 'Gotcha', '.', 'random', 'field', '=', '"gotcha_response[#{gotcha.class.name.to_s}-#{Digest::MD5.hexdigest(gotcha.class.down_transform(gotcha.answer))}]"', '(', 'label_tag', 'field', ',', 'gotcha', '.', 'question', ',', 'options', '[', ':label_options', ']', ')', '+', '"\\n"', '+', '(', 'text_field_tag', 'field', ',', 'nil', ',', 'options', '[', ':text_field_options', ']', ')', 'else', 'raise', '"No Gotchas Installed"', 'end', 'end']
->Original Target:
['Propose', 'a', 'gotcha', 'to', 'the', 'user', '-', 'question', 'and', 'answer', 'hash']
->Reconstructed Target:
Propose a gotcha to the user - question and answer hash
->Reconstructed Predication:
The gotchathe gotcha answer for the
->Raw Input:
summarize:def gotcha ( options = { } ) options [ :label_options ] ||= { } options [ :text_field_options ] ||= { } if gotcha = Gotcha. random field = "gotcha_response[#{gotcha.class.name.to_s}-#{Digest::MD5.hexdigest(gotcha.class.down_transform(gotcha.answer))}]" ( label_tag field, gotcha. question, options [ :label_options ] ) + "\n" + ( text_field_tag field, nil, options [ :text_field_options ] ) else raise "No Gotchas Installed" end end
->Raw Target:
Propose a gotcha to the user - question and answer hash
--

853=========
->Original Input:
['def', 'delete_image', 'subreddit', ',', 'image_name', 'logged_in?', 'post', '(', "'/api/delete_sr_image'", ',', 'body', ':', '{', 'r', ':', 'subreddit', ',', 'img_name', ':', 'image_name', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Deletes', 'an', 'image', 'from', 'a', 'subreddit', '.', 'This', 'is', 'for', 'css', 'not', 'removing', 'posts']
->Reconstructed Target:
Deletes an image from a subreddit. This is for css not removing posts
->Reconstructed Predication:
 def delete_image ( subreddit,
->Raw Input:
summarize:def delete_image subreddit, image_name logged_in? post ( '/api/delete_sr_image', body : { r : subreddit, img_name : image_name, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Deletes an image from a subreddit. This is for css not removing posts
--

854=========
->Original Input:
['def', 'set_stylesheet', 'stylesheet', ',', 'subreddit', 'logged_in?', 'post', '(', "'/api/subreddit_stylesheet'", ',', 'body', ':', '{', 'op', ':', "'save'", ',', 'r', ':', 'subreddit', ',', 'stylesheet_contents', ':', 'stylesheet', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Set', 'the', 'subreddit', 'stylesheet']
->Reconstructed Target:
Set the subreddit stylesheet
->Reconstructed Predication:
 def set_stylesheet stylesheet
->Raw Input:
summarize:def set_stylesheet stylesheet, subreddit logged_in? post ( '/api/subreddit_stylesheet', body : { op :'save', r : subreddit, stylesheet_contents : stylesheet, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Set the subreddit stylesheet
--

855=========
->Original Input:
['def', 'subscribe', 'subreddit', ',', 'action', '=', '"sub"', 'logged_in?', 'post', '(', "'/api/subscribe'", ',', 'body', ':', '{', 'action', ':', 'action', ',', 'sr', ':', 'subreddit', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Subscribe', 'to', 'a', 'subreddit']
->Reconstructed Target:
Subscribe to a subreddit
->Reconstructed Predication:
subreddit : subredditsubreddit : subredditsubreddit : subreddit
->Raw Input:
summarize:def subscribe subreddit, action = "sub" logged_in? post ( '/api/subscribe', body : { action : action, sr : subreddit, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Subscribe to a subreddit
--

856=========
->Original Input:
['def', 'my_reddits', 'opts', '=', '{', '}', 'logged_in?', 'url', '=', '"/reddits/mine/%s.json"', '%', '(', 'opts', '[', ':condition', ']', 'if', 'opts', '[', ':condition', ']', ')', 'opts', '.', 'delete', ':condition', 'query', '=', 'opts', 'get', '(', 'url', ',', 'query', ':', 'query', ')', 'end']
->Original Target:
['Get', 'subreddits', 'I', 'have']
->Reconstructed Target:
Get subreddits I have
->Reconstructed Predication:
the reddits.  def summarize
->Raw Input:
summarize:def my_reddits opts = { } logged_in? url = "/reddits/mine/%s.json" % ( opts [ :condition ] if opts [ :condition ] ) opts. delete :condition query = opts get ( url, query : query ) end
->Raw Target:
Get subreddits I have
--

857=========
->Original Input:
['def', 'get_reddits', 'opts', '=', '{', '}', 'url', '=', '"/reddits/%s.json"', '%', '(', 'opts', '[', ':condition', ']', 'if', 'opts', '[', ':condition', ']', ')', 'opts', '.', 'delete', ':condition', 'query', '=', 'opts', 'get', '(', 'url', ',', 'query', ':', 'query', ')', 'end']
->Original Target:
['Get', 'a', 'list', 'of', 'subreddits']
->Reconstructed Target:
Get a list of subreddits
->Reconstructed Predication:
return the reddits for the given
->Raw Input:
summarize:def get_reddits opts = { } url = "/reddits/%s.json" % ( opts [ :condition ] if opts [ :condition ] ) opts. delete :condition query = opts get ( url, query : query ) end
->Raw Target:
Get a list of subreddits
--

858=========
->Original Input:
['def', 'add_moderator', 'container', ',', 'user', ',', 'subreddit', 'friend_wrapper', 'container', ':', 'container', ',', 'name', ':', 'user', ',', 'r', ':', 'subreddit', ',', 'type', ':', '"moderator"', 'end']
->Original Target:
['Add', 'a', 'moderator', 'to', 'the', 'subreddit']
->Reconstructed Target:
Add a moderator to the subreddit
->Reconstructed Predication:
moderator  def add_moderator
->Raw Input:
summarize:def add_moderator container, user, subreddit friend_wrapper container : container, name : user, r : subreddit, type : "moderator" end
->Raw Target:
Add a moderator to the subreddit
--

859=========
->Original Input:
['def', 'add_contributor', 'container', ',', 'user', ',', 'subreddit', 'friend_wrapper', 'container', ':', 'container', ',', 'name', ':', 'user', ',', 'r', ':', 'subreddit', ',', 'type', ':', '"contributor"', 'end']
->Original Target:
['Add', 'a', 'contributor', 'to', 'the', 'subreddit']
->Reconstructed Target:
Add a contributor to the subreddit
->Reconstructed Predication:
add user to the user suser_id
->Raw Input:
summarize:def add_contributor container, user, subreddit friend_wrapper container : container, name : user, r : subreddit, type : "contributor" end
->Raw Target:
Add a contributor to the subreddit
--

860=========
->Original Input:
['def', 'ban_user', 'container', ',', 'user', ',', 'subreddit', 'friend_wrapper', 'container', ':', 'container', ',', 'name', ':', 'user', ',', 'r', ':', 'subreddit', ',', 'type', ':', '"banned"', 'end']
->Original Target:
['Ban', 'a', 'user', 'from', 'a', 'subreddit']
->Reconstructed Target:
Ban a user from a subreddit
->Reconstructed Predication:
banned user
->Raw Input:
summarize:def ban_user container, user, subreddit friend_wrapper container : container, name : user, r : subreddit, type : "banned" end
->Raw Target:
Ban a user from a subreddit
--

861=========
->Original Input:
['def', 'remove_moderator', 'container', ',', 'user', ',', 'subreddit', 'unfriend_wrapper', 'container', ':', 'container', ',', 'name', ':', 'user', ',', 'r', ':', 'subreddit', ',', 'type', ':', '"moderator"', 'end']
->Original Target:
['Remove', 'a', 'moderator', 'from', 'a', 'subreddit']
->Reconstructed Target:
Remove a moderator from a subreddit
->Reconstructed Predication:
remove a user from thethe user.
->Raw Input:
summarize:def remove_moderator container, user, subreddit unfriend_wrapper container : container, name : user, r : subreddit, type : "moderator" end
->Raw Target:
Remove a moderator from a subreddit
--

862=========
->Original Input:
['def', 'remove_contributor', 'container', ',', 'user', ',', 'subreddit', 'unfriend_wrapper', 'container', ':', 'container', ',', 'name', ':', 'user', ',', 'r', ':', 'subreddit', ',', 'type', ':', '"contributor"', 'end']
->Original Target:
['Remove', 'a', 'contributor', 'from', 'a', 'subreddit']
->Reconstructed Target:
Remove a contributor from a subreddit
->Reconstructed Predication:
remove a user from thethe user to the subreddit
->Raw Input:
summarize:def remove_contributor container, user, subreddit unfriend_wrapper container : container, name : user, r : subreddit, type : "contributor" end
->Raw Target:
Remove a contributor from a subreddit
--

863=========
->Original Input:
['def', 'unban_user', 'container', ',', 'user', ',', 'subreddit', 'unfriend_wrapper', 'container', ':', 'container', ',', 'name', ':', 'user', ',', 'r', ':', 'subreddit', ',', 'type', ':', '"banned"', 'end']
->Original Target:
['Unban', 'a', 'user', 'from', 'a', 'subreddit']
->Reconstructed Target:
Unban a user from a subreddit
->Reconstructed Predication:
user : useruser : user
->Raw Input:
summarize:def unban_user container, user, subreddit unfriend_wrapper container : container, name : user, r : subreddit, type : "banned" end
->Raw Target:
Unban a user from a subreddit
--

864=========
->Original Input:
['def', 'get', '*', 'args', ',', '&', 'block', 'response', '=', 'self', '.', 'class', '.', 'get', '*', 'args', ',', '&', 'block', 'raise', 'WebserverError', ',', 'response', '.', 'code', 'unless', 'response', '.', 'code', '==', '200', 'response', 'end']
->Original Target:
['HTTParty', 'get', 'wrapper', '.', 'This', 'serves', 'to', 'clean', 'up', 'code', 'as', 'well', 'as', 'throw', 'webserver', 'errors', 'wherever', 'needed']
->Reconstructed Target:
HTTParty get wrapper. This serves to clean up code as well as throw webserver errors wherever needed
->Reconstructed Predication:
return the response
->Raw Input:
summarize:def get * args, & block response = self. class. get * args, & block raise WebserverError, response. code unless response. code == 200 response end
->Raw Target:
HTTParty get wrapper. This serves to clean up code as well as throw webserver errors wherever needed
--

865=========
->Original Input:
['def', 'log_in', 'username', ',', 'password', 'login', '=', 'post', '(', '"/api/login"', ',', ':body', '=>', '{', 'user', ':', 'username', ',', 'passwd', ':', 'password', ',', 'api_type', ':', "'json'", '}', ')', 'errors', '=', 'login', '[', "'json'", ']', '[', "'errors'", ']', 'raise', 'errors', '[', '0', ']', '[', '1', ']', 'unless', 'errors', '.', 'size', '==', '0', 'set_cookies', 'login', '.', 'headers', '[', "'set-cookie'", ']', '@modhash', '=', 'login', '[', "'json'", ']', '[', "'data'", ']', '[', "'modhash'", ']', '@username', '=', 'username', '@userid', '=', "'t2_'", '+', 'get', '(', "'/api/me.json'", ')', '[', "'data'", ']', '[', "'id'", ']', 'return', 'login', 'end']
->Original Target:
['Log', 'into', 'a', 'reddit', 'account', '.', 'You', 'need', 'to', 'do', 'this', 'to', 'use', 'any', 'restricted', 'or', 'write', 'APIs']
->Reconstructed Target:
Log into a reddit account. You need to do this to use any restricted or write APIs
->Reconstructed Predication:
login  def loginlogin end
->Raw Input:
summarize:def log_in username, password login = post ( "/api/login", :body => { user : username, passwd : password, api_type : 'json' } ) errors = login [ 'json' ] [ 'errors' ] raise errors [ 0 ] [ 1 ] unless errors. size == 0 set_cookies login. headers ['set-cookie' ] @modhash = login [ 'json' ] [ 'data' ] ['modhash' ] @username = username @userid = 't2_' + get ( '/api/me.json' ) [ 'data' ] [ 'id' ] return login end
->Raw Target:
Log into a reddit account. You need to do this to use any restricted or write APIs
--

866=========
->Original Input:
['def', 'auth', 'modhash', ',', 'cookies', 'set_cookies', 'cookies', '@modhash', '=', 'modhash', 'meinfo', '=', 'get', '(', '"/api/me.json"', ')', '@username', '=', 'meinfo', '[', "'data'", ']', '[', "'name'", ']', '@userid', '=', "'t2_'", '+', 'meinfo', '[', "'data'", ']', '[', "'id'", ']', 'end']
->Original Target:
['Auth', 'into', 'reddit', 'via', 'modhash', 'and', 'cookie', '.', 'This', 'has', 'the', 'advantage', 'of', 'not', 'throttling', 'you', 'if', 'you', 'call', 'it', 'a', 'lot']
->Reconstructed Target:
Auth into reddit via modhash and cookie. This has the advantage of not throttling you if you call it a lot
->Reconstructed Predication:
@modhash  def auth
->Raw Input:
summarize:def auth modhash, cookies set_cookies cookies @modhash = modhash meinfo = get ( "/api/me.json" ) @username = meinfo [ 'data' ] [ 'name' ] @userid = 't2_' + meinfo [ 'data' ] [ 'id' ] end
->Raw Target:
Auth into reddit via modhash and cookie. This has the advantage of not throttling you if you call it a lot
--

867=========
->Original Input:
['def', 'delete_user', 'password', ',', 'reason', '=', '"deleted by script command"', 'logged_in?', 'delete', '=', 'post', '(', "'/api/delete_user'", ',', 'body', ':', '{', 'confirm', ':', 'true', ',', 'delete_message', ':', 'reason', ',', 'passwd', ':', 'password', ',', 'uh', ':', '@modhash', ',', 'user', ':', '@username', ',', 'api_type', ':', "'json'", '}', ')', 'return', 'delete', 'end']
->Original Target:
['Deletes', 'the', 'current', 'user', '.', 'This', 'requires', 'a', 'password', 'for', 'security', 'reasons', '.']
->Reconstructed Target:
Deletes the current user. This requires a password for security reasons.
->Reconstructed Predication:
the user to be deleted
->Raw Input:
summarize:def delete_user password, reason = "deleted by script command" logged_in? delete = post ( '/api/delete_user', body : { confirm : true, delete_message : reason, passwd : password, uh : @modhash, user : @username, api_type : 'json' } ) return delete end
->Raw Target:
Deletes the current user. This requires a password for security reasons.
--

868=========
->Original Input:
['def', 'get_messages', 'where', '=', '"inbox"', ',', 'opts', '=', '{', '}', 'query', '=', '{', 'mark', ':', 'false', '}', 'query', '.', 'merge!', 'opts', 'get', '(', '"/message/#{where}.json"', ',', 'query', ':', 'query', ')', 'end']
->Original Target:
['Gets', 'a', 'listing', 'of', 'PMs']
->Reconstructed Target:
Gets a listing of PMs
->Reconstructed Predication:
returns a list of messages
->Raw Input:
summarize:def get_messages where = "inbox", opts = { } query = { mark : false } query. merge! opts get ( "/message/#{where}.json", query : query ) end
->Raw Target:
Gets a listing of PMs
--

869=========
->Original Input:
['def', 'clear_flair_templates', 'type', ',', 'subreddit', 'logged_in?', 'post', '(', "'/api/clearflairtemplates'", ',', 'body', ':', '{', 'flair_type', ':', 'type', ',', 'r', ':', 'subreddit', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Clear', 'all', 'the', 'flair', 'templates', 'of', 'a', 'particular', 'type']
->Reconstructed Target:
Clear all the flair templates of a particular type
->Reconstructed Predication:
 def clear_flair_templates ( type
->Raw Input:
summarize:def clear_flair_templates type, subreddit logged_in? post ( '/api/clearflairtemplates', body : { flair_type : type, r : subreddit, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Clear all the flair templates of a particular type
--

870=========
->Original Input:
['def', 'delete_user_flair', 'user', ',', 'subreddit', 'logged_in?', 'post', '(', "'/api/deleteflair'", ',', 'body', ':', '{', 'name', ':', 'user', ',', 'r', ':', 'subreddit', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Deletes', 'a', 'user', 's', 'flair']
->Reconstructed Target:
Deletes a user s flair
->Reconstructed Predication:
user : useruser : user
->Raw Input:
summarize:def delete_user_flair user, subreddit logged_in? post ( '/api/deleteflair', body : { name : user, r : subreddit, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Deletes a user s flair
--

871=========
->Original Input:
['def', 'delete_flair_template', 'id', ',', 'subreddit', 'logged_in?', 'post', '(', "'/api/deleteflairtemplate'", ',', 'body', ':', '{', 'flair_template_id', ':', 'id', ',', 'r', ':', 'subreddit', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Deletes', 'a', 'flair', 'template', 'by', 'ID', '.']
->Reconstructed Target:
Deletes a flair template by ID.
->Reconstructed Predication:
 def delete_flair_template ( id
->Raw Input:
summarize:def delete_flair_template id, subreddit logged_in? post ( '/api/deleteflairtemplate', body : { flair_template_id : id, r : subreddit, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Deletes a flair template by ID.
--

872=========
->Original Input:
['def', 'flair_config', 'subreddit', ',', 'opts', '=', '{', '}', 'logged_in?', 'options', '=', '{', 'flair_enabled', ':', 'true', ',', 'flair_position', ':', "'right'", ',', 'flair_self_assign_enabled', ':', 'false', ',', 'link_flair_position', ':', "'right'", ',', 'link_flair_self_assign_enabled', ':', 'false', ',', 'uh', ':', '@modhash', ',', 'r', ':', 'subreddit', ',', 'api_type', ':', "'json'", '}', 'options', '.', 'merge!', 'opts', 'post', '(', "'/api/flairconfig'", ',', 'body', ':', 'options', ')', 'end']
->Original Target:
['Configures', 'flair', 'options', 'for', 'a', 'subreddit', '.', 'All', 'options', 'are', 'required']
->Reconstructed Target:
Configures flair options for a subreddit. All options are required
->Reconstructed Predication:
 def flair_configreturn
->Raw Input:
summarize:def flair_config subreddit, opts = { } logged_in? options = { flair_enabled : true, flair_position : 'right', flair_self_assign_enabled : false, link_flair_position : 'right', link_flair_self_assign_enabled : false, uh : @modhash, r : subreddit, api_type : 'json' } options. merge! opts post ( '/api/flairconfig', body : options ) end
->Raw Target:
Configures flair options for a subreddit. All options are required
--

873=========
->Original Input:
['def', 'flair_csv', 'csv', ',', 'subreddit', 'logged_in?', 'post', '(', "'/api/flaircsv.json'", ',', 'body', ':', '{', 'flair_csv', ':', 'csv', ',', 'r', ':', 'subreddit', ',', 'uh', ':', '@modhash', '}', ')', 'end']
->Original Target:
['Post', 'flair', 'in', 'a', 'CSV', 'file', 'to', 'reddit']
->Reconstructed Target:
Post flair in a CSV file to reddit
->Reconstructed Predication:
 def summarizereturn
->Raw Input:
summarize:def flair_csv csv, subreddit logged_in? post ( '/api/flaircsv.json', body : { flair_csv : csv, r : subreddit, uh : @modhash } ) end
->Raw Target:
Post flair in a CSV file to reddit
--

874=========
->Original Input:
['def', 'flair_template', 'subreddit', ',', 'opts', '=', '{', '}', 'logged_in?', 'params', '=', '{', 'flair_type', ':', "'USER_FLAIR'", ',', 'text_editable', ':', 'false', ',', 'uh', ':', '@modhash', ',', 'r', ':', 'subreddit', ',', 'api_type', ':', "'json'", '}', 'params', '.', 'merge!', 'opts', 'post', '(', "'/api/flairtemplate'", ',', 'body', ':', 'params', ')', 'end']
->Original Target:
['Create', 'or', 'edit', 'a', 'flair', 'template', '.']
->Reconstructed Target:
Create or edit a flair template.
->Reconstructed Predication:
 def flair_template ( subreddit)
->Raw Input:
summarize:def flair_template subreddit, opts = { } logged_in? params = { flair_type : 'USER_FLAIR', text_editable : false, uh : @modhash, r : subreddit, api_type : 'json' } params. merge! opts post ( '/api/flairtemplate', body : params ) end
->Raw Target:
Create or edit a flair template.
--

875=========
->Original Input:
['def', 'select_flair_template', 'template_id', ',', 'subreddit', ',', 'opts', '=', '{', '}', 'logged_in?', 'params', '=', '{', 'flair_template_id', ':', 'template_id', ',', 'uh', ':', '@modhash', ',', 'r', ':', 'subreddit', ',', 'api_type', ':', "'json'", '}', 'params', '.', 'merge!', 'opts', 'post', '(', "'/api/selectflair'", ',', 'body', ':', 'params', ')', 'end']
->Original Target:
['Select', 'a', 'flair', 'template', 'and', 'apply', 'it', 'to', 'a', 'user', 'or', 'link']
->Reconstructed Target:
Select a flair template and apply it to a user or link
->Reconstructed Predication:
 def select_flair_template template_id, subreddit
->Raw Input:
summarize:def select_flair_template template_id, subreddit, opts = { } logged_in? params = { flair_template_id : template_id, uh : @modhash, r : subreddit, api_type : 'json' } params. merge! opts post ( '/api/selectflair', body : params ) end
->Raw Target:
Select a flair template and apply it to a user or link
--

876=========
->Original Input:
['def', 'flair_toggle', 'enabled', ',', 'subreddit', 'logged_in?', 'post', '(', "'/api/setflairenabled'", ',', 'body', ':', '{', 'flair_enabled', ':', 'enabled', ',', 'uh', ':', '@modhash', ',', 'r', ':', 'subreddit', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Toggle', 'flair', 'on', 'and', 'off', 'for', 'a', 'subreddit']
->Reconstructed Target:
Toggle flair on and off for a subreddit
->Reconstructed Predication:
 def flair_toggle ( enabled
->Raw Input:
summarize:def flair_toggle enabled, subreddit logged_in? post ( '/api/setflairenabled', body : { flair_enabled : enabled, uh : @modhash, r : subreddit, api_type : 'json' } ) end
->Raw Target:
Toggle flair on and off for a subreddit
--

877=========
->Original Input:
['def', 'get_comments', 'opts', '=', '{', '}', 'query', '=', '{', 'limit', ':', '100', '}', 'query', '.', 'merge!', 'opts', 'url', '=', '"%s/comments/%s%s.json"', '%', '[', '(', "'/r/'", '+', 'opts', '[', ':subreddit', ']', 'if', 'opts', '[', ':subreddit', ']', ')', ',', 'opts', '[', ':link_id', ']', ',', '(', "'/blah/'", '+', 'opts', '[', ':comment_id', ']', 'if', 'opts', '[', ':comment_id', ']', ')', ']', 'get', '(', 'url', ',', 'query', ':', 'query', ')', 'end']
->Original Target:
['Get', 'a', 'comment', 'listing', 'from', 'the', 'site']
->Reconstructed Target:
Get a comment listing from the site
->Reconstructed Predication:
the comments for a comment
->Raw Input:
summarize:def get_comments opts = { } query = { limit : 100 } query. merge! opts url = "%s/comments/%s%s.json" % [ ( '/r/' + opts [ :subreddit ] if opts [ :subreddit ] ), opts [ :link_id ], ( '/blah/' + opts [ :comment_id ] if opts [ :comment_id ] ) ] get ( url, query : query ) end
->Raw Target:
Get a comment listing from the site
--

878=========
->Original Input:
['def', 'get_listing', 'opts', '=', '{', '}', 'url', '=', '"%s/%s.json"', '%', '[', '(', "'/r/'", '+', 'opts', '[', ':subreddit', ']', 'if', 'opts', '[', ':subreddit', ']', ')', ',', '(', 'opts', '[', ':page', ']', 'if', 'opts', '[', ':page', ']', ')', ']', '[', ':subreddit', ',', ':page', ']', '.', 'each', '{', '|', 'k', '|', 'opts', '.', 'delete', 'k', '}', 'query', '=', 'opts', 'get', '(', 'url', ',', 'query', ':', 'query', ')', 'end']
->Original Target:
['Gets', 'a', 'listing', 'of', 'links', 'from', 'reddit', '.']
->Reconstructed Target:
Gets a listing of links from reddit.
->Reconstructed Predication:
listing of a users subreddits page.
->Raw Input:
summarize:def get_listing opts = { } url = "%s/%s.json" % [ ( '/r/' + opts [ :subreddit ] if opts [ :subreddit ] ), ( opts [ :page ] if opts [ :page ] ) ] [ :subreddit, :page ]. each { | k | opts. delete k } query = opts get ( url, query : query ) end
->Raw Target:
Gets a listing of links from reddit.
--

879=========
->Original Input:
['def', 'distinguish', 'id', ',', 'how', '=', '"yes"', 'logged_in?', 'hows', '=', '%w{', 'yes', 'no', 'admin', 'special', '}', 'post', '(', "'/api/distinguish'", ',', 'body', ':', '{', 'id', ':', 'id', ',', 'how', ':', 'how', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Distinguish', 'a', 'thing']
->Reconstructed Target:
Distinguish a thing
->Reconstructed Predication:
the user to distinguish thethe user to distinguish the userthe user to distinguish the user
->Raw Input:
summarize:def distinguish id, how = "yes" logged_in? hows = %w{ yes no admin special } post ( '/api/distinguish', body : { id : id, how : how, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Distinguish a thing
--

880=========
->Original Input:
['def', 'remove', 'id', ',', 'spam', '=', 'false', 'logged_in?', 'post', '(', "'/api/remove'", ',', 'body', ':', '{', 'id', ':', 'id', ',', 'spam', ':', 'spam', ',', 'uh', ':', '@modhash', ',', 'api_type', ':', "'json'", '}', ')', 'end']
->Original Target:
['Removes', 'a', 'thing']
->Reconstructed Target:
Removes a thing
->Reconstructed Predication:
 def remove ( id)
->Raw Input:
summarize:def remove id, spam = false logged_in? post ( '/api/remove', body : { id : id, spam : spam, uh : @modhash, api_type : 'json' } ) end
->Raw Target:
Removes a thing
--

881=========
->Original Input:
['def', 'get_modlog', 'subreddit', ',', 'opts', '=', '{', '}', 'logged_in?', 'options', '=', '{', 'limit', ':', '100', '}', '.', 'merge', 'opts', 'data', '=', 'Nokogiri', '::', 'HTML', '.', 'parse', '(', 'get', '(', '"/r/#{subreddit}/about/log"', ',', 'query', ':', 'options', ')', '.', 'body', ')', '.', 'css', '(', "'.modactionlisting tr'", ')', 'processed', '=', '{', 'data', ':', '[', ']', ',', 'first', ':', 'data', '[', '0', ']', '[', "'data-fullname'", ']', ',', 'first_date', ':', 'Time', '.', 'parse', '(', 'data', '[', '0', ']', '.', 'children', '[', '0', ']', '.', 'child', '[', "'datetime'", ']', ')', ',', 'last', ':', 'data', '[', '-', '1', ']', '[', "'data-fullname'", ']', ',', 'last_date', ':', 'Time', '.', 'parse', '(', 'data', '[', '-', '1', ']', '.', 'children', '[', '0', ']', '.', 'child', '[', "'datetime'", ']', ')', ',', '}', 'data', '.', 'each', 'do', '|', 'tr', '|', 'processed', '[', ':data', ']', '<<', '{', 'fullname', ':', 'tr', '[', "'data-fullname'", ']', ',', 'time', ':', 'Time', '.', 'parse', '(', 'tr', '.', 'children', '[', '0', ']', '.', 'child', '[', "'datetime'", ']', ')', ',', 'author', ':', 'tr', '.', 'children', '[', '1', ']', '.', 'child', '.', 'content', ',', 'action', ':', 'tr', '.', 'children', '[', '2', ']', '.', 'child', '[', "'class'", ']', '.', 'split', '[', '1', ']', ',', 'description', ':', 'tr', '.', 'children', '[', '3', ']', '.', 'content', ',', 'href', ':', 'tr', '.', 'children', '[', '3', ']', '.', 'css', '(', "'a'", ')', '.', 'count', '==', '0', '?', 'nil', ':', 'tr', '.', 'children', '[', '3', ']', '.', 'css', '(', "'a'", ')', '[', '0', ']', '[', "'href'", ']', '}', 'end', 'return', 'processed', 'end']
->Original Target:
['Gets', 'a', 'moderation', 'log', 'This', 'is', 'a', 'tricky', 'function', 'and', 'may', 'break', 'a', 'lot', '.', 'Blame', 'the', 'lack', 'of', 'a', 'real', 'api']
->Reconstructed Target:
Gets a moderation log This is a tricky function and may break a lot. Blame the lack of a real api
->Reconstructed Predication:
::::::::::::::::::::::::::
->Raw Input:
summarize:def get_modlog subreddit, opts = { } logged_in? options = { limit : 100 }. merge opts data = Nokogiri :: HTML. parse ( get ( "/r/#{subreddit}/about/log", query : options ). body ). css ( '.modactionlisting tr' ) processed = { data : [ ], first : data [ 0 ] [ 'data-fullname' ], first_date : Time. parse ( data [ 0 ]. children [ 0 ]. child [ 'datetime' ] ), last : data [ - 1 ] [ 'data-fullname' ], last_date : Time. parse ( data [ - 1 ]. children [ 0 ]. child [ 'datetime' ] ), } data. each do | tr | processed [ :data ] << { fullname : tr [ 'data-fullname' ], time : Time. parse ( tr. children [ 0 ]. child [ 'datetime' ] ), author : tr. children [ 1 ]. child. content, action : tr. children [ 2 ]. child [ 'class' ]. split [ 1 ], description : tr. children [ 3 ]. content, href : tr. children [ 3 ]. css ( 'a' ). count == 0? nil : tr. children [ 3 ]. css ( 'a' ) [ 0 ] [ 'href' ] } end return processed end
->Raw Target:
Gets a moderation log This is a tricky function and may break a lot. Blame the lack of a real api
--

882=========
->Original Input:
['def', 'post', '(', 'query_params', ')', 'servers', '||=', 'SERVERS', '.', 'map', '{', '|', 'hostname', '|', '"https://#{hostname}/minfraud/chargeback"', '}', 'url', '=', 'URI', '.', 'parse', '(', 'servers', '.', 'shift', ')', 'req', '=', 'Net', '::', 'HTTP', '::', 'Post', '.', 'new', '(', 'url', '.', 'path', ',', 'initheader', '=', '{', "'Content-Type'", '=>', "'application/json'", '}', ')', 'req', '.', 'basic_auth', 'Maxmind', '::', 'user_id', ',', 'Maxmind', '::', 'license_key', 'req', '.', 'body', '=', 'query_params', 'h', '=', 'Net', '::', 'HTTP', '.', 'new', '(', 'url', '.', 'host', ',', 'url', '.', 'port', ')', 'h', '.', 'use_ssl', '=', 'true', 'h', '.', 'verify_mode', '=', 'OpenSSL', '::', 'SSL', '::', 'VERIFY_NONE', 'h', '.', 'open_timeout', '=', '60', 'h', '.', 'read_timeout', '=', 'self', '.', 'class', '.', 'timeout', '||', 'DefaultTimeout', 'h', '.', 'ssl_timeout', '=', 'self', '.', 'class', '.', 'timeout', '||', 'DefaultTimeout', 'h', '.', 'start', '{', '|', 'http', '|', 'http', '.', 'request', '(', 'req', ')', '}', 'rescue', 'Exception', '=>', 'e', 'retry', 'if', 'servers', '.', 'size', '>', '0', 'raise', 'e', 'end']
->Original Target:
['Upon', 'a', 'failure', 'at', 'the', 'first', 'URL', 'will', 'automatically', 'retry', 'with', 'the', 'second', '&', 'third', 'ones', 'before', 'finally', 'raising', 'an', 'exception', 'Returns', 'an', 'HTTPResponse', 'object']
->Reconstructed Target:
Upon a failure at the first URL will automatically retry with the second & third ones before finally raising an exception Returns an HTTPResponse object
->Reconstructed Predication:
the........
->Raw Input:
summarize:def post ( query_params ) servers ||= SERVERS. map { | hostname | "https://#{hostname}/minfraud/chargeback" } url = URI. parse ( servers. shift ) req = Net :: HTTP :: Post. new ( url. path, initheader = { 'Content-Type' => 'application/json' } ) req. basic_auth Maxmind :: user_id, Maxmind :: license_key req. body = query_params h = Net :: HTTP. new ( url. host, url. port ) h. use_ssl = true h. verify_mode = OpenSSL :: SSL :: VERIFY_NONE h. open_timeout = 60 h. read_timeout = self. class. timeout || DefaultTimeout h. ssl_timeout = self. class. timeout || DefaultTimeout h. start { | http | http. request ( req ) } rescue Exception => e retry if servers. size > 0 raise e end
->Raw Target:
Upon a failure at the first URL will automatically retry with the second & third ones before finally raising an exception Returns an HTTPResponse object
--

883=========
->Original Input:
['def', 'lifespan', '=', '(', 'lifespan', ')', '@lifespan', '=', 'lifespan', '@@lifespans', '.', 'each_with_index', 'do', '|', 'span', ',', 'index', '|', 'if', 'span', '[', '0', ']', '==', 'lifespan', '&&', 'lifespan', '!=', '"Forever"', 'self', '.', 'expires', '=', 'DateTime', '.', 'now', '.', 'advance', '(', '@@lifespans', '[', 'index', ']', '[', '1', ']', ')', 'end', 'end', 'end']
->Original Target:
['Setter', 'to', 'convert', 'user', 's', 'choice', 'of', 'A', 'Week', 'etc', '.', 'to', 'an', 'actual', 'DateTime']
->Reconstructed Target:
Setter to convert user s choice of A Week etc. to an actual DateTime
->Reconstructed Predication:
the lifespan to the current
->Raw Input:
summarize:def lifespan = ( lifespan ) @lifespan = lifespan @@lifespans. each_with_index do | span, index | if span [ 0 ] == lifespan && lifespan!= "Forever" self. expires = DateTime. now. advance ( @@lifespans [ index ] [ 1 ] ) end end end
->Raw Target:
Setter to convert user s choice of A Week etc. to an actual DateTime
--

884=========
->Original Input:
['def', 'div', 'cr_scanner', '=', 'CodeRay', '.', 'scan', '(', 'self', '.', 'clip', ',', 'self', '.', 'language', ')', 'if', 'cr_scanner', '.', 'loc', '<=', '1', 'return', 'cr_scanner', '.', 'div', 'else', 'return', 'cr_scanner', '.', 'div', '(', ':line_numbers', '=>', ':table', ')', 'end', 'end']
->Original Target:
['Creates', 'the', 'div', 'for', 'the', 'clip']
->Reconstructed Target:
Creates the div for the clip
->Reconstructed Predication:
return table. div
->Raw Input:
summarize:def div cr_scanner = CodeRay. scan ( self. clip, self. language ) if cr_scanner. loc <= 1 return cr_scanner. div else return cr_scanner. div ( :line_numbers => :table ) end end
->Raw Target:
Creates the div for the clip
--

885=========
->Original Input:
['def', 'set_variables', '(', 'instance_variables', ')', 'instance_variables', '.', 'each', '{', '|', 'name', ',', 'value', '|', 'instance_variable_set', '(', '"@#{name}"', ',', 'value', ')', '}', 'yield', '(', 'self', ')', 'instance_variables', '.', 'each', '{', '|', 'name', ',', '_', '|', 'remove_instance_variable', '(', '"@#{name}"', ')', '}', 'self', 'end']
->Original Target:
['sets', 'instance', 'variables', 'when', 'block', 'is', 'yielded']
->Reconstructed Target:
sets instance variables when block is yielded
->Reconstructed Predication:
the instance variables to the
->Raw Input:
summarize:def set_variables ( instance_variables ) instance_variables. each { | name, value | instance_variable_set ( "@#{name}", value ) } yield ( self ) instance_variables. each { | name, _ | remove_instance_variable ( "@#{name}" ) } self end
->Raw Target:
sets instance variables when block is yielded
--

886=========
->Original Input:
['def', 'render', '(', 'object', ',', 'method', ',', '*', 'args', ',', '&', 'block', ')', 'object', '.', '__send__', 'method', ',', 'self', ',', '*', 'args', ',', '&', 'block', 'self', 'end']
->Original Target:
['renders', '+', 'object', '+', 'with', '+', 'method', '+']
->Reconstructed Target:
renders + object + with + method +
->Reconstructed Predication:
render object with block block
->Raw Input:
summarize:def render ( object, method, * args, & block ) object. __send__ method, self, * args, & block self end
->Raw Target:
renders + object + with + method +
--

887=========
->Original Input:
['def', 'join', '(', 'collection', ',', 'glue', '=', 'nil', ',', '&', 'it', ')', 'glue_block', '=', 'case', 'glue', 'when', 'String', 'lambda', '{', 'text', 'glue', '}', 'when', 'Proc', 'glue', 'else', 'lambda', '{', '}', 'end', 'collection', '.', 'each_with_index', 'do', '|', 'obj', ',', 'i', '|', 'glue_block', '.', 'call', '(', ')', 'if', 'i', '>', '0', 'obj', '.', 'is_a?', '(', 'Proc', ')', '?', 'obj', '.', 'call', ':', 'it', '.', 'call', '(', 'obj', ')', 'end', 'end']
->Original Target:
['joins', 'and', 'renders', '+', 'collection', '+', 'with', '+', 'glue', '+']
->Reconstructed Target:
joins and renders + collection + with + glue +
->Reconstructed Predication:
the collection of elements
->Raw Input:
summarize:def join ( collection, glue = nil, & it ) glue_block = case glue when String lambda { text glue } when Proc glue else lambda { } end collection. each_with_index do | obj, i | glue_block. call ( ) if i > 0 obj. is_a? ( Proc )? obj. call : it. call ( obj ) end end
->Raw Target:
joins and renders + collection + with + glue +
--

888=========
->Original Input:
['def', 'open_session', '(', 'uri', ')', 'validate_presence_of', 'uri', ',', "'Channel URI'", 'response', '=', '@client', '.', 'call', '(', ':open_publication_session', ',', 'message', ':', '{', "'ChannelURI'", '=>', 'uri', '}', ')', 'response', '.', 'to_hash', '[', ':open_publication_session_response', ']', '[', ':session_id', ']', '.', 'to_s', 'end']
->Original Target:
['Creates', 'a', 'new', 'ISBM', 'ProviderPublication', 'client', '.']
->Reconstructed Target:
Creates a new ISBM ProviderPublication client.
->Reconstructed Predication:
the publication session for the
->Raw Input:
summarize:def open_session ( uri ) validate_presence_of uri, 'Channel URI' response = @client. call ( :open_publication_session, message : { 'ChannelURI' => uri } ) response. to_hash [ :open_publication_session_response ] [ :session_id ]. to_s end
->Raw Target:
Creates a new ISBM ProviderPublication client.
--

889=========
->Original Input:
['def', 'post_publication', '(', 'session_id', ',', 'content', ',', 'topics', ',', 'expiry', '=', 'nil', ')', 'validate_presence_of', 'session_id', ',', "'Session Id'", 'validate_presence_of', 'content', ',', "'Content'", 'validate_presence_of', 'topics', ',', "'Topics'", 'validate_xml', 'content', 'topics', '=', '[', 'topics', ']', '.', 'flatten', 'xml', '=', 'Builder', '::', 'XmlMarkup', '.', 'new', 'xml', '.', 'isbm', ':SessionID', ',', 'session_id', 'xml', '.', 'isbm', ':MessageContent', 'do', 'xml', '<<', 'content', 'end', 'topics', '.', 'each', 'do', '|', 'topic', '|', 'xml', '.', 'isbm', ':Topic', ',', 'topic', 'end', 'duration', '=', 'expiry', '.', 'to_s', 'xml', '.', 'isbm', ':Expiry', ',', 'duration', 'unless', 'duration', '.', 'nil?', 'response', '=', '@client', '.', 'call', '(', ':post_publication', ',', 'message', ':', 'xml', '.', 'target!', ')', 'response', '.', 'to_hash', '[', ':post_publication_response', ']', '[', ':message_id', ']', '.', 'to_s', 'end']
->Original Target:
['Posts', 'a', 'publication', 'message', '.']
->Reconstructed Target:
Posts a publication message.
->Reconstructed Predication:
:Topic:Expiry, duration :
->Raw Input:
summarize:def post_publication ( session_id, content, topics, expiry = nil ) validate_presence_of session_id, 'Session Id' validate_presence_of content, 'Content' validate_presence_of topics, 'Topics' validate_xml content topics = [ topics ]. flatten xml = Builder :: XmlMarkup. new xml. isbm :SessionID, session_id xml. isbm :MessageContent do xml << content end topics. each do | topic | xml. isbm :Topic, topic end duration = expiry. to_s xml. isbm :Expiry, duration unless duration. nil? response = @client. call ( :post_publication, message : xml. target! ) response. to_hash [ :post_publication_response ] [ :message_id ]. to_s end
->Raw Target:
Posts a publication message.
--

890=========
->Original Input:
['def', 'expire_publication', '(', 'session_id', ',', 'message_id', ')', 'validate_presence_of', 'session_id', ',', "'Session Id'", 'validate_presence_of', 'message_id', ',', "'Message Id'", '@client', '.', 'call', '(', ':expire_publication', ',', 'message', ':', '{', "'SessionID'", '=>', 'session_id', ',', "'MessageID'", '=>', 'message_id', '}', ')', 'return', 'true', 'end']
->Original Target:
['Expires', 'a', 'posted', 'publication', 'message', '.']
->Reconstructed Target:
Expires a posted publication message.
->Reconstructed Predication:
 def expire_publication ( session_id
->Raw Input:
summarize:def expire_publication ( session_id, message_id ) validate_presence_of session_id, 'Session Id' validate_presence_of message_id, 'Message Id' @client. call ( :expire_publication, message : { 'SessionID' => session_id, 'MessageID' => message_id } ) return true end
->Raw Target:
Expires a posted publication message.
--

891=========
->Original Input:
['def', 'validate_presence_of', '(', 'value', ',', 'name', ')', 'if', 'value', '.', 'respond_to?', '(', ':each', ')', 'value', '.', 'each', 'do', '|', 'v', '|', 'if', 'v', '.', 'blank?', 'raise', 'ArgumentError', ',', '"Values in #{name} must not be blank"', 'end', 'end', 'else', 'if', 'value', '.', 'blank?', 'raise', 'ArgumentError', ',', '"#{name} must not be blank"', 'end', 'end', 'end']
->Original Target:
['Creates', 'a', 'new', 'ISBM', 'client', '.']
->Reconstructed Target:
Creates a new ISBM client.
->Reconstructed Predication:
the value of a field
->Raw Input:
summarize:def validate_presence_of ( value, name ) if value. respond_to? ( :each ) value. each do | v | if v. blank? raise ArgumentError, "Values in #{name} must not be blank" end end else if value. blank? raise ArgumentError, "#{name} must not be blank" end end end
->Raw Target:
Creates a new ISBM client.
--

892=========
->Original Input:
['def', 'validate_xml', '(', 'xml', ')', 'doc', '=', 'Nokogiri', '.', 'XML', '(', 'xml', ')', 'raise', 'ArgumentError', ',', '"XML is not well formed: #{xml}"', 'unless', 'doc', '.', 'errors', '.', 'empty?', 'end']
->Original Target:
['Validates', 'the', 'well', 'formedness', 'of', 'the', 'XML', 'string', 'and', 'raises', 'an', 'error', 'if', 'any', 'errors', 'are', 'encountered', '.']
->Reconstructed Target:
Validates the well formedness of the XML string and raises an error if any errors are encountered.
->Reconstructed Predication:
validate the XMLthe XML to validate the
->Raw Input:
summarize:def validate_xml ( xml ) doc = Nokogiri. XML ( xml ) raise ArgumentError, "XML is not well formed: #{xml}" unless doc. errors. empty? end
->Raw Target:
Validates the well formedness of the XML string and raises an error if any errors are encountered.
--

893=========
->Original Input:
['def', 'default_savon_options', '(', 'options', ')', 'options', '[', ':logger', ']', '=', 'Rails', '.', 'logger', 'if', 'options', '[', ':logger', ']', '.', 'nil?', '&&', 'defined?', '(', 'Rails', ')', 'options', '[', ':log', ']', '=', 'false', 'if', 'options', '[', ':log', ']', '.', 'nil?', 'options', '[', ':pretty_print_xml', ']', '=', 'true', 'if', 'options', '[', ':pretty_print_xml', ']', '.', 'nil?', 'end']
->Original Target:
['Sets', 'default', 'values', 'for', 'certain', 'Savon', 'options', '.']
->Reconstructed Target:
Sets default values for certain Savon options.
->Reconstructed Predication:
the default configuration for the
->Raw Input:
summarize:def default_savon_options ( options ) options [ :logger ] = Rails. logger if options [ :logger ]. nil? && defined? ( Rails ) options [ :log ] = false if options [ :log ]. nil? options [ :pretty_print_xml ] = true if options [ :pretty_print_xml ]. nil? end
->Raw Target:
Sets default values for certain Savon options.
--

894=========
->Original Input:
['def', 'read_publication', '(', 'session_id', ')', 'validate_presence_of', 'session_id', ',', "'Session Id'", 'response', '=', '@client', '.', 'call', '(', ':read_publication', ',', 'message', ':', '{', "'SessionID'", '=>', 'session_id', '}', ')', 'extract_message', '(', 'response', ')', 'end']
->Original Target:
['Reads', 'the', 'first', 'message', 'if', 'any', 'in', 'the', 'session', 'queue', '.']
->Reconstructed Target:
Reads the first message if any in the session queue.
->Reconstructed Predication:
 def read_publication ( session_id
->Raw Input:
summarize:def read_publication ( session_id ) validate_presence_of session_id, 'Session Id' response = @client. call ( :read_publication, message : { 'SessionID' => session_id } ) extract_message ( response ) end
->Raw Target:
Reads the first message if any in the session queue.
--

895=========
->Original Input:
['def', 'open_session', '(', 'uri', ',', 'listener_url', '=', 'nil', ')', 'validate_presence_of', 'uri', ',', "'Channel URI'", 'message', '=', '{', "'ChannelURI'", '=>', 'uri', '}', 'message', '[', "'ListenerURL'", ']', '=', 'listener_url', 'if', 'listener_url', 'response', '=', '@client', '.', 'call', '(', ':open_consumer_request_session', ',', 'message', ':', 'message', ')', 'response', '.', 'to_hash', '[', ':open_consumer_request_session_response', ']', '[', ':session_id', ']', '.', 'to_s', 'end']
->Original Target:
['Creates', 'a', 'new', 'ISBM', 'ConsumerRequest', 'client', '.']
->Reconstructed Target:
Creates a new ISBM ConsumerRequest client.
->Reconstructed Predication:
the session to be opened
->Raw Input:
summarize:def open_session ( uri, listener_url = nil ) validate_presence_of uri, 'Channel URI' message = { 'ChannelURI' => uri } message [ 'ListenerURL' ] = listener_url if listener_url response = @client. call ( :open_consumer_request_session, message : message ) response. to_hash [ :open_consumer_request_session_response ] [ :session_id ]. to_s end
->Raw Target:
Creates a new ISBM ConsumerRequest client.
--

896=========
->Original Input:
['def', 'post_request', '(', 'session_id', ',', 'content', ',', 'topic', ',', 'expiry', '=', 'nil', ')', 'validate_presence_of', 'session_id', ',', "'Session Id'", 'validate_presence_of', 'content', ',', "'Content'", 'validate_presence_of', 'topic', ',', "'Topic'", 'validate_xml', 'content', 'xml', '=', 'Builder', '::', 'XmlMarkup', '.', 'new', 'xml', '.', 'isbm', ':SessionID', ',', 'session_id', 'xml', '.', 'isbm', ':MessageContent', 'do', 'xml', '<<', 'content', 'end', 'xml', '.', 'isbm', ':Topic', ',', 'topic', 'duration', '=', 'expiry', '.', 'to_s', 'xml', '.', 'isbm', ':Expiry', ',', 'duration', 'unless', 'duration', '.', 'nil?', 'response', '=', '@client', '.', 'call', '(', ':post_request', ',', 'message', ':', 'xml', '.', 'target!', ')', 'response', '.', 'to_hash', '[', ':post_request_response', ']', '[', ':message_id', ']', '.', 'to_s', 'end']
->Original Target:
['Posts', 'a', 'request', 'message', 'on', 'a', 'channel', '.']
->Reconstructed Target:
Posts a request message on a channel.
->Reconstructed Predication:
:Topic, topic:Expiry, duration
->Raw Input:
summarize:def post_request ( session_id, content, topic, expiry = nil ) validate_presence_of session_id, 'Session Id' validate_presence_of content, 'Content' validate_presence_of topic, 'Topic' validate_xml content xml = Builder :: XmlMarkup. new xml. isbm :SessionID, session_id xml. isbm :MessageContent do xml << content end xml. isbm :Topic, topic duration = expiry. to_s xml. isbm :Expiry, duration unless duration. nil? response = @client. call ( :post_request, message : xml. target! ) response. to_hash [ :post_request_response ] [ :message_id ]. to_s end
->Raw Target:
Posts a request message on a channel.
--

897=========
->Original Input:
['def', 'expire_request', '(', 'session_id', ',', 'message_id', ')', 'validate_presence_of', 'session_id', ',', "'Session Id'", 'validate_presence_of', 'message_id', ',', "'Message Id'", '@client', '.', 'call', '(', ':expire_request', ',', 'message', ':', '{', "'SessionID'", '=>', 'session_id', ',', "'MessageID'", '=>', 'message_id', '}', ')', 'return', 'true', 'end']
->Original Target:
['Expires', 'a', 'posted', 'request', 'message', '.']
->Reconstructed Target:
Expires a posted request message.
->Reconstructed Predication:
 def expire_request ( session_id
->Raw Input:
summarize:def expire_request ( session_id, message_id ) validate_presence_of session_id, 'Session Id' validate_presence_of message_id, 'Message Id' @client. call ( :expire_request, message : { 'SessionID' => session_id, 'MessageID' => message_id } ) return true end
->Raw Target:
Expires a posted request message.
--

898=========
->Original Input:
['def', 'read_response', '(', 'session_id', ',', 'request_message_id', ')', 'validate_presence_of', 'session_id', ',', "'Session Id'", 'validate_presence_of', 'request_message_id', ',', "'Request Message Id'", 'message', '=', '{', "'SessionID'", '=>', 'session_id', ',', "'RequestMessageID'", '=>', 'request_message_id', '}', 'response', '=', '@client', '.', 'call', '(', ':read_response', ',', 'message', ':', 'message', ')', 'extract_message', '(', 'response', ')', 'end']
->Original Target:
['Returns', 'the', 'first', 'response', 'message', 'if', 'any', 'in', 'the', 'message', 'queue', 'associated', 'with', 'the', 'request', '.']
->Reconstructed Target:
Returns the first response message if any in the message queue associated with the request.
->Reconstructed Predication:
the response to the requestthe response to the request
->Raw Input:
summarize:def read_response ( session_id, request_message_id ) validate_presence_of session_id, 'Session Id' validate_presence_of request_message_id, 'Request Message Id' message = { 'SessionID' => session_id, 'RequestMessageID' => request_message_id } response = @client. call ( :read_response, message : message ) extract_message ( response ) end
->Raw Target:
Returns the first response message if any in the message queue associated with the request.
--

899=========
->Original Input:
['def', 'remove_response', '(', 'session_id', ',', 'request_message_id', ')', 'validate_presence_of', 'session_id', ',', "'Session Id'", 'validate_presence_of', 'request_message_id', ',', "'Request Message Id'", 'message', '=', '{', "'SessionID'", '=>', 'session_id', ',', "'RequestMessageID'", '=>', 'request_message_id', '}', '@client', '.', 'call', '(', ':remove_response', ',', 'message', ':', 'message', ')', 'return', 'true', 'end']
->Original Target:
['Deletes', 'the', 'first', 'response', 'message', 'if', 'any', 'in', 'the', 'message', 'queue', 'associated', 'with', 'the', 'request', '.']
->Reconstructed Target:
Deletes the first response message if any in the message queue associated with the request.
->Reconstructed Predication:
Remove a response from athe response to the specified request
->Raw Input:
summarize:def remove_response ( session_id, request_message_id ) validate_presence_of session_id, 'Session Id' validate_presence_of request_message_id, 'Request Message Id' message = { 'SessionID' => session_id, 'RequestMessageID' => request_message_id } @client. call ( :remove_response, message : message ) return true end
->Raw Target:
Deletes the first response message if any in the message queue associated with the request.
--

900=========
->Original Input:
['def', 'open_session', '(', 'uri', ',', 'topics', ',', 'listener_url', '=', 'nil', ',', 'xpath_expression', '=', 'nil', ',', 'xpath_namespaces', '=', '[', ']', ')', 'validate_presence_of', 'uri', ',', "'Channel URI'", 'validate_presence_of', 'topics', ',', "'Topics'", 'validate_presence_of', 'xpath_expression', ',', "'XPath Expression'", 'if', 'xpath_namespaces', '.', 'present?', 'topics', '=', '[', 'topics', ']', '.', 'flatten', 'xml', '=', 'Builder', '::', 'XmlMarkup', '.', 'new', 'xml', '.', 'isbm', ':ChannelURI', ',', 'uri', 'topics', '.', 'each', 'do', '|', 'topic', '|', 'xml', '.', 'isbm', ':Topic', ',', 'topic', 'end', 'xml', '.', 'isbm', ':ListenerURL', ',', 'listener_url', 'unless', 'listener_url', '.', 'nil?', 'xml', '.', 'isbm', ':XPathExpression', ',', 'xpath_expression', 'unless', 'xpath_expression', '.', 'nil?', 'xpath_namespaces', '.', 'each', 'do', '|', 'prefix', ',', 'name', '|', 'xml', '.', 'isbm', ':XPathNamespace', 'do', 'xml', '.', 'isbm', ':NamespacePrefix', ',', 'prefix', 'xml', '.', 'isbm', ':NamespaceName', ',', 'name', 'end', 'end', 'response', '=', '@client', '.', 'call', '(', ':open_provider_request_session', ',', 'message', ':', 'xml', '.', 'target!', ')', 'response', '.', 'to_hash', '[', ':open_provider_request_session_response', ']', '[', ':session_id', ']', '.', 'to_s', 'end']
->Original Target:
['Creates', 'a', 'new', 'ISBM', 'ProviderRequest', 'client', '.']
->Reconstructed Target:
Creates a new ISBM ProviderRequest client.
->Reconstructed Predication:
:ChannelURI,:Topic, topic:Topic, topic:Topic, topic, topic, topic, listener_url,, topic, xpath_expression, topic, listener_url,, topic, xpath_expression, topic, listener_url,, topic, xpath_namespaces,,, topic, listener_url,,
->Raw Input:
summarize:def open_session ( uri, topics, listener_url = nil, xpath_expression = nil, xpath_namespaces = [ ] ) validate_presence_of uri, 'Channel URI' validate_presence_of topics, 'Topics' validate_presence_of xpath_expression, 'XPath Expression' if xpath_namespaces. present? topics = [ topics ]. flatten xml = Builder :: XmlMarkup. new xml. isbm :ChannelURI, uri topics. each do | topic | xml. isbm :Topic, topic end xml. isbm :ListenerURL, listener_url unless listener_url. nil? xml. isbm :XPathExpression, xpath_expression unless xpath_expression. nil? xpath_namespaces. each do | prefix, name | xml. isbm :XPathNamespace do xml. isbm :NamespacePrefix, prefix xml. isbm :NamespaceName, name end end response = @client. call ( :open_provider_request_session, message : xml. target! ) response. to_hash [ :open_provider_request_session_response ] [ :session_id ]. to_s end
->Raw Target:
Creates a new ISBM ProviderRequest client.
--

901=========
->Original Input:
['def', 'post_response', '(', 'session_id', ',', 'request_message_id', ',', 'content', ')', 'validate_presence_of', 'session_id', ',', "'Session Id'", 'validate_presence_of', 'request_message_id', ',', "'Request Message Id'", 'validate_presence_of', 'content', ',', "'Content'", 'validate_xml', 'content', 'xml', '=', 'Builder', '::', 'XmlMarkup', '.', 'new', 'xml', '.', 'isbm', ':SessionID', ',', 'session_id', 'xml', '.', 'isbm', ':RequestMessageID', ',', 'request_message_id', 'xml', '.', 'isbm', ':MessageContent', 'do', 'xml', '<<', 'content', 'end', 'response', '=', '@client', '.', 'call', '(', ':post_response', ',', 'message', ':', 'xml', '.', 'target!', ')', 'response', '.', 'to_hash', '[', ':post_response_response', ']', '[', ':message_id', ']', '.', 'to_s', 'end']
->Original Target:
['Posts', 'a', 'response', 'message', 'on', 'a', 'channel', '.']
->Reconstructed Target:
Posts a response message on a channel.
->Reconstructed Predication:
the response to the requestthe response to the request.
->Raw Input:
summarize:def post_response ( session_id, request_message_id, content ) validate_presence_of session_id, 'Session Id' validate_presence_of request_message_id, 'Request Message Id' validate_presence_of content, 'Content' validate_xml content xml = Builder :: XmlMarkup. new xml. isbm :SessionID, session_id xml. isbm :RequestMessageID, request_message_id xml. isbm :MessageContent do xml << content end response = @client. call ( :post_response, message : xml. target! ) response. to_hash [ :post_response_response ] [ :message_id ]. to_s end
->Raw Target:
Posts a response message on a channel.
--

902=========
->Original Input:
['def', 'create_channel', '(', 'uri', ',', 'type', ',', 'description', '=', 'nil', ',', 'tokens', '=', '{', '}', ')', 'validate_presence_of', 'uri', ',', "'Channel URI'", 'validate_presence_of', 'type', ',', "'Channel Type'", 'channel_type', '=', 'type', '.', 'to_s', '.', 'downcase', '.', 'capitalize', 'validate_inclusion_in', 'channel_type', ',', 'IsbmAdaptor', '::', 'Channel', '::', 'TYPES', ',', "'Channel Type'", 'message', '=', '{', "'ChannelURI'", '=>', 'uri', ',', "'ChannelType'", '=>', 'channel_type', '}', 'message', '[', "'ChannelDescription'", ']', '=', 'description', 'unless', 'description', '.', 'nil?', 'message', '[', "'SecurityToken'", ']', '=', 'security_token_hash', '(', 'tokens', ')', 'if', 'tokens', '.', 'any?', '@client', '.', 'call', '(', ':create_channel', ',', 'message', ':', 'message', ')', 'return', 'true', 'end']
->Original Target:
['Creates', 'a', 'new', 'ISBM', 'ChannelManagement', 'client', '.']
->Reconstructed Target:
Creates a new ISBM ChannelManagement client.
->Reconstructed Predication:
Create a channel with thethe channel to be created'
->Raw Input:
summarize:def create_channel ( uri, type, description = nil, tokens = { } ) validate_presence_of uri, 'Channel URI' validate_presence_of type, 'Channel Type' channel_type = type. to_s. downcase. capitalize validate_inclusion_in channel_type, IsbmAdaptor :: Channel :: TYPES, 'Channel Type' message = { 'ChannelURI' => uri, 'ChannelType' => channel_type } message [ 'ChannelDescription' ] = description unless description. nil? message [ 'SecurityToken' ] = security_token_hash ( tokens ) if tokens. any? @client. call ( :create_channel, message : message ) return true end
->Raw Target:
Creates a new ISBM ChannelManagement client.
--

903=========
->Original Input:
['def', 'add_security_tokens', '(', 'uri', ',', 'tokens', '=', '{', '}', ')', 'validate_presence_of', 'uri', ',', "'Channel URI'", 'validate_presence_of', 'tokens', ',', "'Security Tokens'", 'message', '=', '{', "'ChannelURI'", '=>', 'uri', ',', "'SecurityToken'", '=>', 'security_token_hash', '(', 'tokens', ')', '}', '@client', '.', 'call', '(', ':add_security_tokens', ',', 'message', ':', 'message', ')', 'return', 'true', 'end']
->Original Target:
['Adds', 'security', 'tokens', 'to', 'a', 'channel', '.']
->Reconstructed Target:
Adds security tokens to a channel.
->Reconstructed Predication:
Add security tokens to a channelthe channel to add security tokens
->Raw Input:
summarize:def add_security_tokens ( uri, tokens = { } ) validate_presence_of uri, 'Channel URI' validate_presence_of tokens, 'Security Tokens' message = { 'ChannelURI' => uri, 'SecurityToken' => security_token_hash ( tokens ) } @client. call ( :add_security_tokens, message : message ) return true end
->Raw Target:
Adds security tokens to a channel.
--

904=========
->Original Input:
['def', 'remove_security_tokens', '(', 'uri', ',', 'tokens', '=', '{', '}', ')', 'validate_presence_of', 'uri', ',', "'Channel URI'", 'validate_presence_of', 'tokens', ',', "'Security Tokens'", 'message', '=', '{', "'ChannelURI'", '=>', 'uri', ',', "'SecurityToken'", '=>', 'security_token_hash', '(', 'tokens', ')', '}', '@client', '.', 'call', '(', ':remove_security_tokens', ',', 'message', ':', 'message', ')', 'return', 'true', 'end']
->Original Target:
['Removes', 'security', 'tokens', 'from', 'a', 'channel', '.']
->Reconstructed Target:
Removes security tokens from a channel.
->Reconstructed Predication:
remove security tokens for a channel
->Raw Input:
summarize:def remove_security_tokens ( uri, tokens = { } ) validate_presence_of uri, 'Channel URI' validate_presence_of tokens, 'Security Tokens' message = { 'ChannelURI' => uri, 'SecurityToken' => security_token_hash ( tokens ) } @client. call ( :remove_security_tokens, message : message ) return true end
->Raw Target:
Removes security tokens from a channel.
--

905=========
->Original Input:
['def', 'get_channel', '(', 'uri', ',', '&', 'block', ')', 'validate_presence_of', 'uri', ',', "'Channel URI'", 'response', '=', '@client', '.', 'call', '(', ':get_channel', ',', 'message', ':', '{', "'ChannelURI'", '=>', 'uri', '}', ',', '&', 'block', ')', 'hash', '=', 'response', '.', 'to_hash', '[', ':get_channel_response', ']', '[', ':channel', ']', 'IsbmAdaptor', '::', 'Channel', '.', 'from_hash', '(', 'hash', ')', 'end']
->Original Target:
['Gets', 'information', 'about', 'the', 'specified', 'channel', '.']
->Reconstructed Target:
Gets information about the specified channel.
->Reconstructed Predication:
the channel to retrieve
->Raw Input:
summarize:def get_channel ( uri, & block ) validate_presence_of uri, 'Channel URI' response = @client. call ( :get_channel, message : { 'ChannelURI' => uri }, & block ) hash = response. to_hash [ :get_channel_response ] [ :channel ] IsbmAdaptor :: Channel. from_hash ( hash ) end
->Raw Target:
Gets information about the specified channel.
--

906=========
->Original Input:
['def', 'get_channels', '(', '&', 'block', ')', 'response', '=', '@client', '.', 'call', '(', ':get_channels', ',', '{', '}', ',', '&', 'block', ')', 'channels', '=', 'response', '.', 'to_hash', '[', ':get_channels_response', ']', '[', ':channel', ']', 'channels', '=', '[', 'channels', ']', '.', 'compact', 'unless', 'channels', '.', 'is_a?', '(', 'Array', ')', 'channels', '.', 'map', 'do', '|', 'hash', '|', 'IsbmAdaptor', '::', 'Channel', '.', 'from_hash', '(', 'hash', ')', 'end', 'end']
->Original Target:
['Gets', 'information', 'about', 'all', 'channels', '.']
->Reconstructed Target:
Gets information about all channels.
->Reconstructed Predication:
the channels to be returned
->Raw Input:
summarize:def get_channels ( & block ) response = @client. call ( :get_channels, { }, & block ) channels = response. to_hash [ :get_channels_response ] [ :channel ] channels = [ channels ]. compact unless channels. is_a? ( Array ) channels. map do | hash | IsbmAdaptor :: Channel. from_hash ( hash ) end end
->Raw Target:
Gets information about all channels.
--

907=========
->Original Input:
['def', 'update_backend', 'if', 'Idioma', '.', 'configuration', '.', 'redis_backend', 'if', 'i18n_value', '.', 'present?', 'Idioma', '::', 'RedisBackend', '.', 'update_phrase', '(', 'self', ')', 'else', 'Idioma', '::', 'RedisBackend', '.', 'delete_phrase', '(', 'self', ')', 'end', 'end', 'end']
->Original Target:
['Will', 'update', 'the', 'i18n', 'backend', 'if', 'it', 'has', 'been', 'configured']
->Reconstructed Target:
Will update the i18n backend if it has been configured
->Reconstructed Predication:
the backend to be used for
->Raw Input:
summarize:def update_backend if Idioma. configuration. redis_backend if i18n_value. present? Idioma :: RedisBackend. update_phrase ( self ) else Idioma :: RedisBackend. delete_phrase ( self ) end end end
->Raw Target:
Will update the i18n backend if it has been configured
--

908=========
->Original Input:
['def', 'set_phrase', '@phrase', '=', 'Phrase', '.', 'find', '(', 'params', '[', ':id', ']', ')', 'rescue', 'ActiveRecord', '::', 'RecordNotFound', 'respond_to', 'do', '|', 'format', '|', 'format', '.', 'json', '{', 'render', 'json', ':', '{', '}', '.', 'to_json', ',', 'status', ':', ':not_found', '}', 'format', '.', 'html', '{', 'flash', '[', ':error', ']', '=', 't', '(', "'idioma.record_not_found'", ')', 'redirect_to', 'phrases_path', '}', 'end', 'end']
->Original Target:
['Use', 'callbacks', 'to', 'share', 'common', 'setup', 'or', 'constraints', 'between', 'actions', '.']
->Reconstructed Target:
Use callbacks to share common setup or constraints between actions.
->Reconstructed Predication:
@phrase = nil end  defend
->Raw Input:
summarize:def set_phrase @phrase = Phrase. find ( params [ :id ] ) rescue ActiveRecord :: RecordNotFound respond_to do | format | format. json { render json : { }. to_json, status : :not_found } format. html { flash [ :error ] = t ( 'idioma.record_not_found' ) redirect_to phrases_path } end end
->Raw Target:
Use callbacks to share common setup or constraints between actions.
--

909=========
->Original Input:
['def', 'to_s', 'date', '=', '[', ']', 'date', '<<', '"#{@years}Y"', 'unless', '@years', '.', 'nil?', 'date', '<<', '"#{@months}M"', 'unless', '@months', '.', 'nil?', 'date', '<<', '"#{@days}D"', 'unless', '@days', '.', 'nil?', 'time', '=', '[', ']', 'time', '<<', '"#{@hours}H"', 'unless', '@hours', '.', 'nil?', 'time', '<<', '"#{@minutes}M"', 'unless', '@minutes', '.', 'nil?', 'time', '<<', '"#{@seconds}S"', 'unless', '@seconds', '.', 'nil?', 'result', '=', 'nil', 'if', '!', 'date', '.', 'empty?', '||', '!', 'time', '.', 'empty?', 'result', '=', "'P'", 'result', '+=', 'date', '.', 'join', 'unless', 'date', '.', 'empty?', 'result', '+=', "'T'", '+', 'time', '.', 'join', 'unless', 'time', '.', 'empty?', 'end', 'result', 'end']
->Original Target:
['Creates', 'a', 'new', 'Duration', 'based', 'on', 'specified', 'time', 'components', '.']
->Reconstructed Target:
Creates a new Duration based on specified time components.
->Reconstructed Predication:
@days + @months + @days
->Raw Input:
summarize:def to_s date = [ ] date << "#{@years}Y" unless @years. nil? date << "#{@months}M" unless @months. nil? date << "#{@days}D" unless @days. nil? time = [ ] time << "#{@hours}H" unless @hours. nil? time << "#{@minutes}M" unless @minutes. nil? time << "#{@seconds}S" unless @seconds. nil? result = nil if! date. empty? ||! time. empty? result = 'P' result += date. join unless date. empty? result += 'T' + time. join unless time. empty? end result end
->Raw Target:
Creates a new Duration based on specified time components.
--

910=========
->Original Input:
['def', 'to_lat', 'format', '=', ':dms', ',', 'dp', '=', '0', 'return', 'lat', 'if', '!', 'format', 'GeoUnits', '::', 'Converter', '.', 'to_lat', 'lat', ',', 'format', ',', 'dp', 'end']
->Original Target:
['Returns', 'the', 'latitude', 'of', 'this', 'point', ';', 'signed', 'numeric', 'degrees', 'if', 'no', 'format', 'otherwise', 'format', '&', 'dp']
->Reconstructed Target:
Returns the latitude of this point ; signed numeric degrees if no format otherwise format & dp
->Reconstructed Predication:
return lat if not
->Raw Input:
summarize:def to_lat format = :dms, dp = 0 return lat if! format GeoUnits :: Converter. to_lat lat, format, dp end
->Raw Target:
Returns the latitude of this point ; signed numeric degrees if no format otherwise format & dp
--

911=========
->Original Input:
['def', 'projects', 'if', '@projects', '.', 'nil?', 'response', '=', 'self', '.', 'get', '(', '"projects"', ')', '@projects', '=', 'response', '.', 'collect', '{', '|', 'project_json', '|', 'Project', '.', 'new', '(', 'project_json', ')', '}', 'end', '@projects', 'end']
->Original Target:
['Returns', 'the', 'list', 'of', 'projects', 'available', 'to', 'the', 'authenticated', 'user', '.']
->Reconstructed Target:
Returns the list of projects available to the authenticated user.
->Reconstructed Predication:
projects  def projects
->Raw Input:
summarize:def projects if @projects. nil? response = self. get ( "projects" ) @projects = response. collect { | project_json | Project. new ( project_json ) } end @projects end
->Raw Target:
Returns the list of projects available to the authenticated user.
--

912=========
->Original Input:
['def', 'project', '(', 'id', ')', '@url', '=', '"projects/#{id}"', 'raise', 'OptimizelyError', '::', 'NoProjectID', ',', '"A Project ID is required to retrieve the project."', 'if', 'id', '.', 'nil?', 'response', '=', 'self', '.', 'get', '(', '@url', ')', 'Project', '.', 'new', '(', 'response', ')', 'end']
->Original Target:
['Returns', 'the', 'details', 'for', 'a', 'specific', 'project', '.']
->Reconstructed Target:
Returns the details for a specific project.
->Reconstructed Predication:
the project with the given ID
->Raw Input:
summarize:def project ( id ) @url = "projects/#{id}" raise OptimizelyError :: NoProjectID, "A Project ID is required to retrieve the project." if id. nil? response = self. get ( @url ) Project. new ( response ) end
->Raw Target:
Returns the details for a specific project.
--

913=========
->Original Input:
['def', 'experiments', '(', 'project_id', ')', 'raise', 'OptimizelyError', '::', 'NoProjectID', ',', '"A Project ID is required to retrieve experiments."', 'if', 'project_id', '.', 'nil?', 'response', '=', 'self', '.', 'get', '(', '"projects/#{project_id}/experiments"', ')', 'response', '.', 'collect', '{', '|', 'response_json', '|', 'Experiment', '.', 'new', '(', 'response_json', ')', '}', 'end']
->Original Target:
['Returns', 'the', 'list', 'of', 'experiments', 'for', 'a', 'specified', 'project', '.']
->Reconstructed Target:
Returns the list of experiments for a specified project.
->Reconstructed Predication:
the experiments for a project
->Raw Input:
summarize:def experiments ( project_id ) raise OptimizelyError :: NoProjectID, "A Project ID is required to retrieve experiments." if project_id. nil? response = self. get ( "projects/#{project_id}/experiments" ) response. collect { | response_json | Experiment. new ( response_json ) } end
->Raw Target:
Returns the list of experiments for a specified project.
--

914=========
->Original Input:
['def', 'experiment', '(', 'id', ')', '@url', '=', '"experiments/#{id}"', 'raise', 'OptimizelyError', '::', 'NoExperimentID', ',', '"An Experiment ID is required to retrieve the experiment."', 'if', 'id', '.', 'nil?', 'response', '=', 'self', '.', 'get', '(', '@url', ')', 'Experiment', '.', 'new', '(', 'response', ')', 'end']
->Original Target:
['Returns', 'the', 'details', 'for', 'a', 'specific', 'experiment', '.']
->Reconstructed Target:
Returns the details for a specific experiment.
->Reconstructed Predication:
the experiment with the given ID
->Raw Input:
summarize:def experiment ( id ) @url = "experiments/#{id}" raise OptimizelyError :: NoExperimentID, "An Experiment ID is required to retrieve the experiment." if id. nil? response = self. get ( @url ) Experiment. new ( response ) end
->Raw Target:
Returns the details for a specific experiment.
--

915=========
->Original Input:
['def', 'stats', '(', 'experiment_id', ')', '@url', '=', '"experiments/#{experiment_id}/stats"', 'raise', 'OptimizelyError', '::', 'NoExperimentID', ',', '"An Experiment ID is required to retrieve the stats."', 'if', 'experiment_id', '.', 'nil?', 'response', '=', 'self', '.', 'get', '(', '@url', ')', 'response', '.', 'collect', '{', '|', 'response_json', '|', 'Stat', '.', 'new', '(', 'response_json', ')', '}', 'end']
->Original Target:
['Returns', 'the', 'stats', 'for', 'a', 'specific', 'experiment', '.']
->Reconstructed Target:
Returns the stats for a specific experiment.
->Reconstructed Predication:
the experiment stats for the given
->Raw Input:
summarize:def stats ( experiment_id ) @url = "experiments/#{experiment_id}/stats" raise OptimizelyError :: NoExperimentID, "An Experiment ID is required to retrieve the stats." if experiment_id. nil? response = self. get ( @url ) response. collect { | response_json | Stat. new ( response_json ) } end
->Raw Target:
Returns the stats for a specific experiment.
--

916=========
->Original Input:
['def', 'variations', '(', 'experiment_id', ')', 'raise', 'OptimizelyError', '::', 'NoExperimentID', ',', '"An Experiment ID is required to retrieve variations."', 'if', 'experiment_id', '.', 'nil?', 'response', '=', 'self', '.', 'get', '(', '"experiments/#{experiment_id}/variations"', ')', 'response', '.', 'collect', '{', '|', 'variation_json', '|', 'Variation', '.', 'new', '(', 'variation_json', ')', '}', 'end']
->Original Target:
['Returns', 'the', 'list', 'of', 'variations', 'for', 'a', 'specified', 'experiment', '.']
->Reconstructed Target:
Returns the list of variations for a specified experiment.
->Reconstructed Predication:
the experiment s variations for thethe experiment s variations for the
->Raw Input:
summarize:def variations ( experiment_id ) raise OptimizelyError :: NoExperimentID, "An Experiment ID is required to retrieve variations." if experiment_id. nil? response = self. get ( "experiments/#{experiment_id}/variations" ) response. collect { | variation_json | Variation. new ( variation_json ) } end
->Raw Target:
Returns the list of variations for a specified experiment.
--

917=========
->Original Input:
['def', 'variation', '(', 'id', ')', '@url', '=', '"variations/#{id}"', 'raise', 'OptimizelyError', '::', 'NoVariationID', ',', '"A Variation ID is required to retrieve the variation."', 'if', 'id', '.', 'nil?', 'response', '=', 'self', '.', 'get', '(', '@url', ')', 'Variation', '.', 'new', '(', 'response', ')', 'end']
->Original Target:
['Returns', 'the', 'details', 'for', 'a', 'specific', 'variation', '.']
->Reconstructed Target:
Returns the details for a specific variation.
->Reconstructed Predication:
the variation for the giventhe variation you want to retrieve
->Raw Input:
summarize:def variation ( id ) @url = "variations/#{id}" raise OptimizelyError :: NoVariationID, "A Variation ID is required to retrieve the variation." if id. nil? response = self. get ( @url ) Variation. new ( response ) end
->Raw Target:
Returns the details for a specific variation.
--

918=========
->Original Input:
['def', 'audiences', '(', 'project_id', ')', 'raise', 'OptimizelyError', '::', 'NoProjectID', ',', '"A Project ID is required to retrieve audiences."', 'if', 'project_id', '.', 'nil?', 'response', '=', 'self', '.', 'get', '(', '"projects/#{project_id}/audiences"', ')', 'response', '.', 'collect', '{', '|', 'audience_json', '|', 'Audience', '.', 'new', '(', 'audience_json', ')', '}', 'end']
->Original Target:
['Returns', 'the', 'list', 'of', 'audiences', 'for', 'a', 'specified', 'project', '.']
->Reconstructed Target:
Returns the list of audiences for a specified project.
->Reconstructed Predication:
a project audiences. 
->Raw Input:
summarize:def audiences ( project_id ) raise OptimizelyError :: NoProjectID, "A Project ID is required to retrieve audiences." if project_id. nil? response = self. get ( "projects/#{project_id}/audiences" ) response. collect { | audience_json | Audience. new ( audience_json ) } end
->Raw Target:
Returns the list of audiences for a specified project.
--

919=========
->Original Input:
['def', 'audience', '(', 'id', ')', '@url', '=', '"audiences/#{id}"', 'raise', 'OptimizelyError', '::', 'NoAudienceID', ',', '"An Audience ID is required to retrieve the audience."', 'if', 'id', '.', 'nil?', 'response', '=', 'self', '.', 'get', '(', '@url', ')', 'Audience', '.', 'new', '(', 'response', ')', 'end']
->Original Target:
['Returns', 'the', 'details', 'for', 'a', 'specific', 'audience', '.']
->Reconstructed Target:
Returns the details for a specific audience.
->Reconstructed Predication:
audience.  def retrieve
->Raw Input:
summarize:def audience ( id ) @url = "audiences/#{id}" raise OptimizelyError :: NoAudienceID, "An Audience ID is required to retrieve the audience." if id. nil? response = self. get ( @url ) Audience. new ( response ) end
->Raw Target:
Returns the details for a specific audience.
--

920=========
->Original Input:
['def', 'get', '(', 'url', ')', 'uri', '=', 'URI', '.', 'parse', '(', '"#{BASE_URL}#{url}/"', ')', 'https', '=', 'Net', '::', 'HTTP', '.', 'new', '(', 'uri', '.', 'host', ',', 'uri', '.', 'port', ')', 'https', '.', 'read_timeout', '=', '@options', '[', ':timeout', ']', 'if', '@options', '[', ':timeout', ']', 'https', '.', 'verify_mode', '=', 'OpenSSL', '::', 'SSL', '::', 'VERIFY_NONE', 'https', '.', 'use_ssl', '=', 'true', 'request', '=', 'Net', '::', 'HTTP', '::', 'Get', '.', 'new', '(', 'uri', '.', 'request_uri', ',', '@headers', ')', 'response', '=', 'https', '.', 'request', '(', 'request', ')', 'if', 'response', '.', 'code', '!=', "'200'", 'check_response', '(', 'response', '.', 'code', ',', 'response', '.', 'body', ')', 'else', 'parse_json', '(', 'response', '.', 'body', ')', 'end', 'end']
->Original Target:
['Return', 'the', 'parsed', 'JSON', 'data', 'for', 'a', 'request', 'that', 'is', 'done', 'to', 'the', 'Optimizely', 'REST', 'API', '.']
->Reconstructed Target:
Return the parsed JSON data for a request that is done to the Optimizely REST API.
->Reconstructed Predication:
httphttp = http.http.= https...
->Raw Input:
summarize:def get ( url ) uri = URI. parse ( "#{BASE_URL}#{url}/" ) https = Net :: HTTP. new ( uri. host, uri. port ) https. read_timeout = @options [ :timeout ] if @options [ :timeout ] https. verify_mode = OpenSSL :: SSL :: VERIFY_NONE https. use_ssl = true request = Net :: HTTP :: Get. new ( uri. request_uri, @headers ) response = https. request ( request ) if response. code!= '200' check_response ( response. code, response. body ) else parse_json ( response. body ) end end
->Raw Target:
Return the parsed JSON data for a request that is done to the Optimizely REST API.
--

921=========
->Original Input:
['def', 'lget', '(', '*', 'keys', ')', 'h', '=', 'keys', '.', 'flatten', '.', 'inject', '(', '{', '}', ')', '{', '|', 'hh', ',', 'k', '|', 'hh', '[', 'k', ']', '=', 'nil', ';', 'hh', '}', 'r', '=', '@db', '.', 'mget', '(', 'h', ')', 'raise', "'lget failure'", 'if', 'r', '==', '-', '1', 'h', 'end']
->Original Target:
['Connects', 'to', 'the', 'Tyrant', 'table', 'listening', 'at', 'the', 'given', 'host', 'and', 'port', '.']
->Reconstructed Target:
Connects to the Tyrant table listening at the given host and port.
->Reconstructed Predication:
return the value of a def lget ( * keys
->Raw Input:
summarize:def lget ( * keys ) h = keys. flatten. inject ( { } ) { | hh, k | hh [ k ] = nil ; hh } r = @db. mget ( h ) raise 'lget failure' if r == - 1 h end
->Raw Target:
Connects to the Tyrant table listening at the given host and port.
--

922=========
->Original Input:
['def', 'get_random_number', '(', 'bytes', ')', 'RbNaCl', '::', 'Util', '.', 'bin2hex', '(', 'RbNaCl', '::', 'Random', '.', 'random_bytes', '(', 'bytes', ')', '.', 'to_s', ')', '.', 'to_i', '(', '16', ')', 'end']
->Original Target:
['Create', 'a', 'random', 'number', 'of', 'a', 'specified', 'Byte', 'length', 'returns', 'Bignum']
->Reconstructed Target:
Create a random number of a specified Byte length returns Bignum
->Reconstructed Predication:
return a random number
->Raw Input:
summarize:def get_random_number ( bytes ) RbNaCl :: Util. bin2hex ( RbNaCl :: Random. random_bytes ( bytes ). to_s ). to_i ( 16 ) end
->Raw Target:
Create a random number of a specified Byte length returns Bignum
--

923=========
->Original Input:
['def', 'get_random_number_with_bitlength', '(', 'bits', ')', 'byte_length', '=', '(', 'bits', '/', '8.0', ')', '.', 'ceil', '+', '10', 'random_num', '=', 'get_random_number', '(', 'byte_length', ')', 'random_num_bin_str', '=', 'random_num', '.', 'to_s', '(', '2', ')', 'random_num_bin_str', '.', 'slice', '(', '0', ',', 'bits', ')', '.', 'to_i', '(', '2', ')', 'end']
->Original Target:
['Creates', 'a', 'random', 'number', 'of', 'a', 'exact', 'bitlength', 'returns', 'Bignum']
->Reconstructed Target:
Creates a random number of a exact bitlength returns Bignum
->Reconstructed Predication:
the random number with the given
->Raw Input:
summarize:def get_random_number_with_bitlength ( bits ) byte_length = ( bits / 8.0 ). ceil + 10 random_num = get_random_number ( byte_length ) random_num_bin_str = random_num. to_s ( 2 ) random_num_bin_str. slice ( 0, bits ). to_i ( 2 ) end
->Raw Target:
Creates a random number of a exact bitlength returns Bignum
--

924=========
->Original Input:
['def', 'add', '(', 'colname', ',', 'operator', ',', 'val', ',', 'affirmative', '=', 'true', ',', 'no_index', '=', 'false', ')', 'colname', '=', 'colname', '.', 'to_s', 'val', '=', 'val', '.', 'to_s', 'op', '=', 'operator', '.', 'is_a?', '(', 'Fixnum', ')', '?', 'operator', ':', 'OPERATORS', '[', 'operator', ']', 'op', '=', 'op', '|', 'TDBQCNEGATE', 'unless', 'affirmative', 'op', '=', 'op', '|', 'TDBQCNOIDX', 'if', 'no_index', '@query', '.', 'addcond', '(', 'colname', ',', 'op', ',', 'val', ')', 'end']
->Original Target:
['Adds', 'a', 'condition']
->Reconstructed Target:
Adds a condition
->Reconstructed Predication:
the column to be added
->Raw Input:
summarize:def add ( colname, operator, val, affirmative = true, no_index = false ) colname = colname. to_s val = val. to_s op = operator. is_a? ( Fixnum )? operator : OPERATORS [ operator ] op = op | TDBQCNEGATE unless affirmative op = op | TDBQCNOIDX if no_index @query. addcond ( colname, op, val ) end
->Raw Target:
Adds a condition
--

925=========
->Original Input:
['def', 'keys', '(', 'options', '=', '{', '}', ')', 'if', '@db', '.', 'respond_to?', ':fwmkeys', 'pref', '=', 'options', '.', 'fetch', '(', ':prefix', ',', '""', ')', '@db', '.', 'fwmkeys', '(', 'pref', ',', 'options', '[', ':limit', ']', '||', '-', '1', ')', 'elsif', '@db', '.', 'respond_to?', ':range', '@db', '.', 'range', '(', '"[min,max]"', ',', 'nil', ')', 'else', 'raise', 'NotImplementedError', ',', '"Database does not support keys()"', 'end', 'end']
->Original Target:
['Returns', 'an', 'array', 'of', 'all', 'the', 'primary', 'keys', 'in', 'the', 'db', '.']
->Reconstructed Target:
Returns an array of all the primary keys in the db.
->Reconstructed Predication:
the keys of the keys
->Raw Input:
summarize:def keys ( options = { } ) if @db. respond_to? :fwmkeys pref = options. fetch ( :prefix, "" ) @db. fwmkeys ( pref, options [ :limit ] || - 1 ) elsif @db. respond_to? :range @db. range ( "[min,max]", nil ) else raise NotImplementedError, "Database does not support keys()" end end
->Raw Target:
Returns an array of all the primary keys in the db.
--

926=========
->Original Input:
['def', 'autocomplete_to_add_item', '(', 'name', ',', 'f', ',', 'association', ',', 'source', ',', 'options', '=', '{', '}', ')', 'new_object', '=', 'f', '.', 'object', '.', 'send', '(', 'association', ')', '.', 'klass', '.', 'new', 'options', '[', ':class', ']', '=', '[', '"autocomplete add-item"', ',', 'options', '[', ':class', ']', ']', '.', 'compact', '.', 'join', '" "', 'options', '[', ':data', ']', '||=', '{', '}', 'options', '[', ':data', ']', '[', ':id', ']', '=', 'new_object', '.', 'object_id', 'options', '[', ':data', ']', '[', ':source', ']', '=', 'source', 'options', '[', ':data', ']', '[', ':item', ']', '=', 'f', '.', 'fields_for', '(', 'association', ',', 'new_object', ',', 'child_index', ':', 'options', '[', ':data', ']', '[', ':id', ']', ')', 'do', '|', 'builder', '|', 'render', '(', 'association', '.', 'to_s', '.', 'singularize', '+', '"_item"', ',', 'f', ':', 'builder', ')', '.', 'gsub', '"\\n"', ',', '""', 'end', 'text_field_tag', '"autocomplete_nested_content"', ',', 'nil', ',', 'options', 'end']
->Original Target:
['.', 'nested', '-', 'container', '.', 'nested', '-', 'autocomplete', '.', 'nested', '-', 'items', '.', 'nested', '-', 'item', '.', 'nested', '-', 'content', '.', 'nested', '-', 'value', '.', 'remove', '-', 'item']
->Reconstructed Target:
. nested - container. nested - autocomplete. nested - items. nested - item. nested - content. nested - value. remove - item
->Reconstructed Predication:
::data ] [ :item ]:data ] [ :item ]:data ] [ :item ]:data ] [ :item ]:data ] [ :item ]:data ] [ :item ]:data ] [ :item ]:data ] [ :item ]:data ] [ :item ]
->Raw Input:
summarize:def autocomplete_to_add_item ( name, f, association, source, options = { } ) new_object = f. object. send ( association ). klass. new options [ :class ] = [ "autocomplete add-item", options [ :class ] ]. compact. join " " options [ :data ] ||= { } options [ :data ] [ :id ] = new_object. object_id options [ :data ] [ :source ] = source options [ :data ] [ :item ] = f. fields_for ( association, new_object, child_index : options [ :data ] [ :id ] ) do | builder | render ( association. to_s. singularize + "_item", f : builder ). gsub "\n", "" end text_field_tag "autocomplete_nested_content", nil, options end
->Raw Target:
. nested - container. nested - autocomplete. nested - items. nested - item. nested - content. nested - value. remove - item
--

927=========
->Original Input:
['def', 'fetch', '(', 'id', ')', 'r', '=', 'nil', 'begin', 'r', '=', 'lib', '.', 'tcidbget', '(', '@db', ',', 'id', ')', 'rescue', '=>', 'e', 'if', 'lib', '.', 'tcidbecode', '(', '@db', ')', '==', '22', 'then', 'return', 'nil', 'else', 'raise_error', 'end', 'end', 'return', 'r', 'end']
->Original Target:
['Return', 'the', 'document', 'at', 'the', 'specified', 'index']
->Reconstructed Target:
Return the document at the specified index
->Reconstructed Predication:
return nil if the object is
->Raw Input:
summarize:def fetch ( id ) r = nil begin r = lib. tcidbget ( @db, id ) rescue => e if lib. tcidbecode ( @db ) == 22 then return nil else raise_error end end return r end
->Raw Target:
Return the document at the specified index
--

928=========
->Original Input:
['def', 'search', '(', 'expression', ')', 'out_count', '=', '::', 'FFI', '::', 'MemoryPointer', '.', 'new', ':pointer', 'out_list', '=', '::', 'FFI', '::', 'MemoryPointer', '.', 'new', ':pointer', 'out_list', '=', 'lib', '.', 'tcidbsearch2', '(', '@db', ',', 'expression', ',', 'out_count', ')', 'count', '=', 'out_count', '.', 'read_int', 'results', '=', 'out_list', '.', 'get_array_of_uint64', '(', '0', ',', 'count', ')', 'return', 'results', 'end']
->Original Target:
['Return', 'the', 'document', 'ids', 'of', 'the', 'documents', 'that', 'matche', 'the', 'search', 'expression']
->Reconstructed Target:
Return the document ids of the documents that matche the search expression
->Reconstructed Predication:
search the given expression.
->Raw Input:
summarize:def search ( expression ) out_count = :: FFI :: MemoryPointer. new :pointer out_list = :: FFI :: MemoryPointer. new :pointer out_list = lib. tcidbsearch2 ( @db, expression, out_count ) count = out_count. read_int results = out_list. get_array_of_uint64 ( 0, count ) return results end
->Raw Target:
Return the document ids of the documents that matche the search expression
--

929=========
->Original Input:
['def', 'char_freq', '(', 'str', ')', 'freqs', '=', 'Hash', '.', 'new', '(', '0', ')', '(', '1', '..', '4', ')', '.', 'each', 'do', '|', 'i', '|', 'str', '.', 'chars', '.', 'each_cons', '(', 'i', ')', '.', 'inject', '(', 'freqs', ')', 'do', '|', 'freq', ',', 'ngram', '|', 'ngram', '=', 'ngram', '.', 'join', 'freq', '[', 'ngram', ']', '=', 'freq', '[', 'ngram', ']', '+', '1', 'freq', 'end', 'end', 'freqs', 'end']
->Original Target:
['Computes', 'a', 'hash', 'of', 'each', 'character']
->Reconstructed Target:
Computes a hash of each character
->Reconstructed Predication:
the frequency of a string
->Raw Input:
summarize:def char_freq ( str ) freqs = Hash. new ( 0 ) ( 1.. 4 ). each do | i | str. chars. each_cons ( i ). inject ( freqs ) do | freq, ngram | ngram = ngram. join freq [ ngram ] = freq [ ngram ] + 1 freq end end freqs end
->Raw Target:
Computes a hash of each character
--

930=========
->Original Input:
['def', 'top', '(', 'n', ',', 'scores', ')', 'scores', '.', 'sort', '{', '|', 'a', ',', 'b', '|', 'a', '[', '1', ']', '<=>', 'b', '[', '1', ']', '}', '.', 'map', '{', '|', 'x', '|', 'x', '[', '0', ']', '}', '.', 'first', '(', 'n', ')', 'end']
->Original Target:
['Return', 'top', 'scoring', 'sorted', 'by', 'lowest']
->Reconstructed Target:
Return top scoring sorted by lowest
->Reconstructed Predication:
scores  def top ( n
->Raw Input:
summarize:def top ( n, scores ) scores. sort { | a, b | a [ 1 ] <=> b [ 1 ] }. map { | x | x [ 0 ] }. first ( n ) end
->Raw Target:
Return top scoring sorted by lowest
--

931=========
->Original Input:
['def', 'recolor', '(', 'bg', ':', "'#000'", ',', 'fg', ':', "'#fff'", ',', 'bg_opacity', ':', '"1.0"', ',', 'fg_opacity', ':', '"1.0"', ')', 'OptionalDeps', '.', 'require_nokogiri', 'bg', '.', 'prepend', '(', "'#'", ')', 'unless', 'bg', '.', 'start_with?', "'#'", 'fg', '.', 'prepend', '(', "'#'", ')', 'unless', 'fg', '.', 'start_with?', "'#'", 'doc', '=', 'Nokogiri', '::', 'XML', '(', 'self', '.', 'string', ')', 'doc', '.', 'css', '(', "'path'", ')', '[', '0', ']', '[', "'fill'", ']', '=', 'bg', 'doc', '.', 'css', '(', "'path'", ')', '[', '1', ']', '[', "'fill'", ']', '=', 'fg', 'doc', '.', 'css', '(', "'path'", ')', '[', '0', ']', '[', "'fill-opacity'", ']', '=', 'bg_opacity', '.', 'to_s', 'doc', '.', 'css', '(', "'path'", ')', '[', '1', ']', '[', "'fill-opacity'", ']', '=', 'fg_opacity', '.', 'to_s', '@svgstr', '=', 'doc', '.', 'to_xml', 'self', 'end']
->Original Target:
['Modify', 'the', 'background', 'and', 'foreground', 'colors', 'and', 'their', 'opacities']
->Reconstructed Target:
Modify the background and foreground colors and their opacities
->Reconstructed Predication:
..
->Raw Input:
summarize:def recolor ( bg : '#000', fg : '#fff', bg_opacity : "1.0", fg_opacity : "1.0" ) OptionalDeps. require_nokogiri bg. prepend ( '#' ) unless bg. start_with? '#' fg. prepend ( '#' ) unless fg. start_with? '#' doc = Nokogiri :: XML ( self. string ) doc. css ( 'path' ) [ 0 ] [ 'fill' ] = bg doc. css ( 'path' ) [ 1 ] [ 'fill' ] = fg doc. css ( 'path' ) [ 0 ] [ 'fill-opacity' ] = bg_opacity. to_s doc. css ( 'path' ) [ 1 ] [ 'fill-opacity' ] = fg_opacity. to_s @svgstr = doc. to_xml self end
->Raw Target:
Modify the background and foreground colors and their opacities
--

932=========
->Original Input:
['def', 'compact_copy', '(', 'target_path', ')', '@other_db', '=', 'Cabinet', '.', 'new', '(', 'target_path', ')', 'self', '.', 'each', '{', '|', 'k', ',', 'v', '|', '@other_db', '[', 'k', ']', '=', 'v', '}', '@other_db', '.', 'close', 'end']
->Original Target:
['Copies', 'the', 'current', 'cabinet', 'to', 'a', 'new', 'file', '.']
->Reconstructed Target:
Copies the current cabinet to a new file.
->Reconstructed Predication:
 def compact_copy
->Raw Input:
summarize:def compact_copy ( target_path ) @other_db = Cabinet. new ( target_path ) self. each { | k, v | @other_db [ k ] = v } @other_db. close end
->Raw Target:
Copies the current cabinet to a new file.
--

933=========
->Original Input:
['def', 'keys', '(', 'options', '=', '{', '}', ')', 'if', '@type', '==', '"tcf"', 'min', ',', 'max', '=', '"min"', ',', '"max"', 'l', '=', 'lib', '.', 'tcfdbrange2', '(', 'as_fixed', ',', 'min', ',', 'Rufus', '::', 'Tokyo', '.', 'blen', '(', 'min', ')', ',', 'max', ',', 'Rufus', '::', 'Tokyo', '.', 'blen', '(', 'max', ')', ',', '-', '1', ')', 'else', 'pre', '=', 'options', '.', 'fetch', '(', ':prefix', ',', '""', ')', 'l', '=', 'lib', '.', 'abs_fwmkeys', '(', '@db', ',', 'pre', ',', 'Rufus', '::', 'Tokyo', '.', 'blen', '(', 'pre', ')', ',', 'options', '[', ':limit', ']', '||', '-', '1', ')', 'end', 'l', '=', 'Rufus', '::', 'Tokyo', '::', 'List', '.', 'new', '(', 'l', ')', 'options', '[', ':native', ']', '?', 'l', ':', 'l', '.', 'release', 'end']
->Original Target:
['Returns', 'an', 'array', 'with', 'all', 'the', 'keys', 'in', 'the', 'databse']
->Reconstructed Target:
Returns an array with all the keys in the databse
->Reconstructed Predication:
the keys of thethe keys of the keys
->Raw Input:
summarize:def keys ( options = { } ) if @type == "tcf" min, max = "min", "max" l = lib. tcfdbrange2 ( as_fixed, min, Rufus :: Tokyo. blen ( min ), max, Rufus :: Tokyo. blen ( max ), - 1 ) else pre = options. fetch ( :prefix, "" ) l = lib. abs_fwmkeys ( @db, pre, Rufus :: Tokyo. blen ( pre ), options [ :limit ] || - 1 ) end l = Rufus :: Tokyo :: List. new ( l ) options [ :native ]? l : l. release end
->Raw Target:
Returns an array with all the keys in the databse
--

934=========
->Original Input:
['def', 'get4', '(', 'k', ')', 'l', '=', 'lib', '.', 'tcbdbget4', '(', 'as_btree', ',', 'k', ',', 'Rufus', '::', 'Tokyo', '.', 'blen', '(', 'k', ')', ')', 'Rufus', '::', 'Tokyo', '::', 'List', '.', 'new', '(', 'l', ')', '.', 'release', 'end']
->Original Target:
['This', 'is', 'a', 'B', '+', 'Tree', 'method', 'only', 'returns', 'all', 'the', 'values', 'for', 'a', 'given', 'key', '.']
->Reconstructed Target:
This is a B + Tree method only returns all the values for a given key.
->Reconstructed Predication:
a list of thethe list of the
->Raw Input:
summarize:def get4 ( k ) l = lib. tcbdbget4 ( as_btree, k, Rufus :: Tokyo. blen ( k ) ) Rufus :: Tokyo :: List. new ( l ). release end
->Raw Target:
This is a B + Tree method only returns all the values for a given key.
--

935=========
->Original Input:
['def', '[]=', '(', 'k', ',', 'v', ')', 'clib', '.', 'tcmapput', '(', 'pointer', ',', 'k', ',', 'Rufus', '::', 'Tokyo', '::', 'blen', '(', 'k', ')', ',', 'v', ',', 'Rufus', '::', 'Tokyo', '::', 'blen', '(', 'v', ')', ')', 'v', 'end']
->Original Target:
['Creates', 'an', 'empty', 'instance', 'of', 'a', 'Tokyo', 'Cabinet', 'in', '-', 'memory', 'map']
->Reconstructed Target:
Creates an empty instance of a Tokyo Cabinet in - memory map
->Reconstructed Predication:
k = k v =
->Raw Input:
summarize:def []= ( k, v ) clib. tcmapput ( pointer, k, Rufus :: Tokyo :: blen ( k ), v, Rufus :: Tokyo :: blen ( v ) ) v end
->Raw Target:
Creates an empty instance of a Tokyo Cabinet in - memory map
--

936=========
->Original Input:
['def', 'delete', '(', 'k', ')', 'v', '=', 'self', '[', 'k', ']', 'return', 'nil', 'unless', 'v', 'clib', '.', 'tcmapout', '(', 'pointer_or_raise', ',', 'k', ',', 'Rufus', '::', 'Tokyo', '::', 'blen', '(', 'k', ')', ')', '||', 'raise', '(', '"failed to remove key \'#{k}\'"', ')', 'v', 'end']
->Original Target:
['Deletes', 'an', 'entry']
->Reconstructed Target:
Deletes an entry
->Reconstructed Predication:
the key to remove.
->Raw Input:
summarize:def delete ( k ) v = self [ k ] return nil unless v clib. tcmapout ( pointer_or_raise, k, Rufus :: Tokyo :: blen ( k ) ) || raise ( "failed to remove key '#{k}'" ) v end
->Raw Target:
Deletes an entry
--

937=========
->Original Input:
['def', 'keys', 'clib', '.', 'tcmapiterinit', '(', 'pointer_or_raise', ')', 'a', '=', '[', ']', 'klen', '=', 'FFI', '::', 'MemoryPointer', '.', 'new', '(', ':int', ')', 'loop', 'do', 'k', '=', 'clib', '.', 'tcmapiternext', '(', '@pointer', ',', 'klen', ')', 'break', 'if', 'k', '.', 'address', '==', '0', 'a', '<<', 'k', '.', 'get_bytes', '(', '0', ',', 'klen', '.', 'get_int', '(', '0', ')', ')', 'end', 'return', 'a', 'ensure', 'klen', '.', 'free', 'end']
->Original Target:
['Returns', 'an', 'array', 'of', 'all', 'the', 'keys', 'in', 'the', 'map']
->Reconstructed Target:
Returns an array of all the keys in the map
->Reconstructed Predication:
the key to the key
->Raw Input:
summarize:def keys clib. tcmapiterinit ( pointer_or_raise ) a = [ ] klen = FFI :: MemoryPointer. new ( :int ) loop do k = clib. tcmapiternext ( @pointer, klen ) break if k. address == 0 a << k. get_bytes ( 0, klen. get_int ( 0 ) ) end return a ensure klen. free end
->Raw Target:
Returns an array of all the keys in the map
--

938=========
->Original Input:
['def', '[]=', '(', 'a', ',', 'b', ',', 'c', '=', 'nil', ')', 'i', ',', 's', '=', 'c', '.', 'nil?', '?', '[', 'a', ',', 'b', ']', ':', '[', '[', 'a', ',', 'b', ']', ',', 'c', ']', 'range', '=', 'if', 'i', '.', 'is_a?', '(', 'Range', ')', 'i', 'elsif', 'i', '.', 'is_a?', '(', 'Array', ')', 'start', ',', 'count', '=', 'i', '(', 'start', '..', 'start', '+', 'count', '-', '1', ')', 'else', '[', 'i', ']', 'end', 'range', '=', 'norm', '(', 'range', ')', 'values', '=', 's', '.', 'is_a?', '(', 'Array', ')', '?', 's', ':', '[', 's', ']', 'range', '.', 'each_with_index', 'do', '|', 'offset', ',', 'index', '|', 'val', '=', 'values', '[', 'index', ']', 'if', 'val', 'clib', '.', 'tclistover', '(', '@pointer', ',', 'offset', ',', 'val', ',', 'Rufus', '::', 'Tokyo', '.', 'blen', '(', 'val', ')', ')', 'else', 'outlen_op', '(', ':tclistremove', ',', 'values', '.', 'size', ')', 'end', 'end', 'self', 'end']
->Original Target:
['The', 'put', 'operation', '.']
->Reconstructed Target:
The put operation.
->Reconstructed Predication:
aa, b, ca, b, c
->Raw Input:
summarize:def []= ( a, b, c = nil ) i, s = c. nil?? [ a, b ] : [ [ a, b ], c ] range = if i. is_a? ( Range ) i elsif i. is_a? ( Array ) start, count = i ( start.. start + count - 1 ) else [ i ] end range = norm ( range ) values = s. is_a? ( Array )? s : [ s ] range. each_with_index do | offset, index | val = values [ index ] if val clib. tclistover ( @pointer, offset, val, Rufus :: Tokyo. blen ( val ) ) else outlen_op ( :tclistremove, values. size ) end end self end
->Raw Target:
The put operation.
--

939=========
->Original Input:
['def', 'keys', '(', 'options', '=', '{', '}', ')', 'pre', '=', 'options', '.', 'fetch', '(', ':prefix', ',', '""', ')', 'l', '=', 'lib', '.', 'tab_fwmkeys', '(', '@db', ',', 'pre', ',', 'Rufus', '::', 'Tokyo', '.', 'blen', '(', 'pre', ')', ',', 'options', '[', ':limit', ']', '||', '-', '1', ')', 'l', '=', 'Rufus', '::', 'Tokyo', '::', 'List', '.', 'new', '(', 'l', ')', 'options', '[', ':native', ']', '?', 'l', ':', 'l', '.', 'release', 'end']
->Original Target:
['Returns', 'an', 'array', 'of', 'all', 'the', 'primary', 'keys', 'in', 'the', 'table']
->Reconstructed Target:
Returns an array of all the primary keys in the table
->Reconstructed Predication:
the keys of the keys
->Raw Input:
summarize:def keys ( options = { } ) pre = options. fetch ( :prefix, "" ) l = lib. tab_fwmkeys ( @db, pre, Rufus :: Tokyo. blen ( pre ), options [ :limit ] || - 1 ) l = Rufus :: Tokyo :: List. new ( l ) options [ :native ]? l : l. release end
->Raw Target:
Returns an array of all the primary keys in the table
--

940=========
->Original Input:
['def', 'lget', '(', '*', 'keys', ')', 'keys', '.', 'flatten', '.', 'inject', '(', '{', '}', ')', '{', '|', 'h', ',', 'k', '|', 'k', '=', 'k', '.', 'to_s', 'v', '=', 'self', '[', 'k', ']', 'h', '[', 'k', ']', '=', 'v', 'if', 'v', 'h', '}', 'end']
->Original Target:
['No', 'misc', 'methods', 'for', 'the', 'table', 'library', 'so', 'this', 'lget', 'is', 'equivalent', 'to', 'calling', 'get', 'for', 'each', 'key', '.', 'Hoping', 'later', 'versions', 'of', 'TC', 'will', 'provide', 'a', 'mget', 'method', '.']
->Reconstructed Target:
No misc methods for the table library so this lget is equivalent to calling get for each key. Hoping later versions of TC will provide a mget method.
->Reconstructed Predication:
return a hash of the
->Raw Input:
summarize:def lget ( * keys ) keys. flatten. inject ( { } ) { | h, k | k = k. to_s v = self [ k ] h [ k ] = v if v h } end
->Raw Target:
No misc methods for the table library so this lget is equivalent to calling get for each key. Hoping later versions of TC will provide a mget method.
--

941=========
->Original Input:
['def', 'raise_error', 'err_code', '=', 'lib', '.', 'tab_ecode', '(', '@db', ')', 'err_msg', '=', 'lib', '.', 'tab_errmsg', '(', 'err_code', ')', 'raise', 'TokyoError', '.', 'new', '(', '"(err #{err_code}) #{err_msg}"', ')', 'end']
->Original Target:
['Obviously', 'something', 'got', 'wrong', 'let', 's', 'ask', 'the', 'db', 'about', 'it', 'and', 'raise', 'a', 'TokyoError']
->Reconstructed Target:
Obviously something got wrong let s ask the db about it and raise a TokyoError
->Reconstructed Predication:
the error message to thethe error message to the
->Raw Input:
summarize:def raise_error err_code = lib. tab_ecode ( @db ) err_msg = lib. tab_errmsg ( err_code ) raise TokyoError. new ( "(err #{err_code}) #{err_msg}" ) end
->Raw Target:
Obviously something got wrong let s ask the db about it and raise a TokyoError
--

942=========
->Original Input:
['def', 'each', '(', '0', '..', 'size', '-', '1', ')', '.', 'each', 'do', '|', 'i', '|', 'pk', '=', '@list', '[', 'i', ']', 'if', '@opts', '[', ':pk_only', ']', 'yield', '(', 'pk', ')', 'else', 'val', '=', '@table', '[', 'pk', ']', 'val', '[', ':pk', ']', '=', 'pk', 'unless', '@opts', '[', ':no_pk', ']', 'yield', '(', 'val', ')', 'end', 'end', 'end']
->Original Target:
['The', 'classical', 'each']
->Reconstructed Target:
The classical each
->Reconstructed Predication:
the table for the given
->Raw Input:
summarize:def each ( 0.. size - 1 ). each do | i | pk = @list [ i ] if @opts [ :pk_only ] yield ( pk ) else val = @table [ pk ] val [ :pk ] = pk unless @opts [ :no_pk ] yield ( val ) end end end
->Raw Target:
The classical each
--

943=========
->Original Input:
['def', 'find', '(', 'icon', ')', 'str', '=', 'icon', '.', 'to_s', '.', 'downcase', 'file', '=', 'DB', '.', 'files', '[', 'str', ']', '||', 'DB', '.', 'files', '[', 'str', '.', 'sub', '(', '/', '\\.', '/', ',', "''", ')', ']', '||', 'not_found', '(', 'str', ',', 'icon', ')', 'Icon', '.', 'new', '(', 'file', ')', 'end']
->Original Target:
['Find', 'the', 'icon', 'possibly', 'without', 'the', 'extension', '.']
->Reconstructed Target:
Find the icon possibly without the extension.
->Reconstructed Predication:
the icon to be usedthe icon to be used for
->Raw Input:
summarize:def find ( icon ) str = icon. to_s. downcase file = DB. files [ str ] || DB. files [ str. sub ( / \. /, '' ) ] || not_found ( str, icon ) Icon. new ( file ) end
->Raw Target:
Find the icon possibly without the extension.
--

944=========
->Original Input:
['def', 'get_columns', '(', 'table_name', ')', 'columns_arr', '=', '[', ']', 'pst', '=', '@db', '.', 'prepare', '"SELECT * FROM #{table_name} LIMIT 6"', 'pst', '.', 'columns', '.', 'each', 'do', '|', 'c', '|', 'columns_arr', '.', 'push', '(', 'c', ')', 'end', 'columns_arr', 'end']
->Original Target:
['Get', 'all', 'colums', 'for', 'a', 'given', 'table', '.']
->Reconstructed Target:
Get all colums for a given table.
->Reconstructed Predication:
the columns of a table
->Raw Input:
summarize:def get_columns ( table_name ) columns_arr = [ ] pst = @db. prepare "SELECT * FROM #{table_name} LIMIT 6" pst. columns. each do | c | columns_arr. push ( c ) end columns_arr end
->Raw Target:
Get all colums for a given table.
--

945=========
->Original Input:
['def', 'is_numeric', '(', 'table_name', ',', 'column_name', ')', 'if', '@db', '.', 'execute', '(', '"SELECT #{column_name} from #{table_name} LIMIT 1"', ')', '.', 'first', '.', 'first', '.', 'is_a?', 'Numeric', 'return', 'true', 'else', 'return', 'false', 'end', 'end']
->Original Target:
['If', 'the', 'column', 'type', 'is', 'nominal', 'return', 'true', '.']
->Reconstructed Target:
If the column type is nominal return true.
->Reconstructed Predication:
the column is a numeric
->Raw Input:
summarize:def is_numeric ( table_name, column_name ) if @db. execute ( "SELECT #{column_name} from #{table_name} LIMIT 1" ). first. first. is_a? Numeric return true else return false end end
->Raw Target:
If the column type is nominal return true.
--

946=========
->Original Input:
['def', 'deal_with_valid_option', '(', 'temp_tables', ',', 'temp_columns', ',', 'temp_column_types', ',', 'res', ')', 'if', '!', 'temp_tables', '.', 'empty?', 'check_given_tables_validity', '(', 'temp_tables', ')', 'temp_tables', '.', 'each', 'do', '|', 't', '|', 'res', '<<', 'convert_table', '(', 't', ')', 'end', 'elsif', '!', 'temp_columns', '.', 'keys', '.', 'empty?', 'check_given_columns_validity', '(', 'temp_columns', ')', 'res', '<<', 'convert_from_columns_hash', '(', 'temp_columns', ')', 'elsif', '!', 'temp_column_types', '.', 'empty?', 'check_given_columns_validity', '(', 'temp_column_types', ')', 'res', '<<', 'convert_from_column_types_hash', '(', 'temp_column_types', ')', 'end', 'end']
->Original Target:
['If', 'valid', 'option', 'was', 'provided', 'in', 'convert', 'method']
->Reconstructed Target:
If valid option was provided in convert method
->Reconstructed Predication:
the given options and the
->Raw Input:
summarize:def deal_with_valid_option ( temp_tables, temp_columns, temp_column_types, res ) if! temp_tables. empty? check_given_tables_validity ( temp_tables ) temp_tables. each do | t | res << convert_table ( t ) end elsif! temp_columns. keys. empty? check_given_columns_validity ( temp_columns ) res << convert_from_columns_hash ( temp_columns ) elsif! temp_column_types. empty? check_given_columns_validity ( temp_column_types ) res << convert_from_column_types_hash ( temp_column_types ) end end
->Raw Target:
If valid option was provided in convert method
--

947=========
->Original Input:
['def', 'let_context', '(', '*', 'args', ',', '&', 'block', ')', 'context_string', ',', 'hash', '=', 'case', 'args', '.', 'map', '(', '&', ':class', ')', 'when', '[', 'String', ',', 'Hash', ']', 'then', '[', '"#{args[0]} #{args[1]}"', ',', 'args', '[', '1', ']', ']', 'when', '[', 'Hash', ']', 'then', '[', 'args', '[', '0', ']', '.', 'inspect', ',', 'args', '[', '0', ']', ']', 'end', 'context', '(', 'context_string', ')', 'do', 'hash', '.', 'each', '{', '|', 'var', ',', 'value', '|', 'let', '(', 'var', ')', '{', 'value', '}', '}', 'instance_eval', '(', '&', 'block', ')', 'end', 'end']
->Original Target:
['This', 'allows', 'us', 'to', 'simplify', 'the', 'case', 'where', 'we', 'want', 'to', 'have', 'a', 'context', 'which', 'contains', 'one', 'or', 'more', 'let', 'statements']
->Reconstructed Target:
This allows us to simplify the case where we want to have a context which contains one or more let statements
->Reconstructed Predication:
context context
->Raw Input:
summarize:def let_context ( * args, & block ) context_string, hash = case args. map ( & :class ) when [ String, Hash ] then [ "#{args[0]} #{args[1]}", args [ 1 ] ] when [ Hash ] then [ args [ 0 ]. inspect, args [ 0 ] ] end context ( context_string ) do hash. each { | var, value | let ( var ) { value } } instance_eval ( & block ) end end
->Raw Target:
This allows us to simplify the case where we want to have a context which contains one or more let statements
--

948=========
->Original Input:
['def', 'subject_should_raise', '(', '*', 'args', ')', 'error', ',', 'message', '=', 'args', 'it_string', '=', '"subject should raise #{error}"', 'it_string', '+=', '" (#{message.inspect})"', 'if', 'message', 'it', 'it_string', 'do', 'expect', '{', 'subject', '}', '.', 'to', 'raise_error', 'error', ',', 'message', 'end', 'end']
->Original Target:
['Allows', 'you', 'to', 'simply', 'specify', 'that', 'the', 'subject', 'should', 'raise', 'an', 'exception', 'Takes', 'no', 'arguments', 'or', 'arguments', 'of', 'an', 'exception', 'class', 'a', 'string', 'or', 'both', '.']
->Reconstructed Target:
Allows you to simply specify that the subject should raise an exception Takes no arguments or arguments of an exception class a string or both.
->Reconstructed Predication:
it it does the assertion
->Raw Input:
summarize:def subject_should_raise ( * args ) error, message = args it_string = "subject should raise #{error}" it_string += " (#{message.inspect})" if message it it_string do expect { subject }. to raise_error error, message end end
->Raw Target:
Allows you to simply specify that the subject should raise an exception Takes no arguments or arguments of an exception class a string or both.
--

949=========
->Original Input:
['def', 'subject_should_not_raise', '(', '*', 'args', ')', 'error', ',', 'message', '=', 'args', 'it_string', '=', '"subject should not raise #{error}"', 'it_string', '+=', '" (#{message.inspect})"', 'if', 'message', 'it', 'it_string', 'do', 'expect', '{', 'subject', '}', '.', 'not_to', 'raise_error', 'error', ',', 'message', 'end', 'end']
->Original Target:
['Allows', 'you', 'to', 'simply', 'specify', 'that', 'the', 'subject', 'should', 'not', 'raise', 'an', 'exception', '.', 'Takes', 'no', 'arguments', 'or', 'arguments', 'of', 'an', 'exception', 'class', 'a', 'string', 'or', 'both', '.']
->Reconstructed Target:
Allows you to simply specify that the subject should not raise an exception. Takes no arguments or arguments of an exception class a string or both.
->Reconstructed Predication:
it should not raise
->Raw Input:
summarize:def subject_should_not_raise ( * args ) error, message = args it_string = "subject should not raise #{error}" it_string += " (#{message.inspect})" if message it it_string do expect { subject }. not_to raise_error error, message end end
->Raw Target:
Allows you to simply specify that the subject should not raise an exception. Takes no arguments or arguments of an exception class a string or both.
--

950=========
->Original Input:
['def', 'login', '(', 'user', ',', 'options', '=', '{', '}', ')', 'options', '[', ':scope', ']', '||=', 'Janus', '.', 'scope_for', '(', 'user', ')', 'set_user', '(', 'user', ',', 'options', ')', 'Janus', '::', 'Manager', '.', 'run_callbacks', '(', ':login', ',', 'user', ',', 'self', ',', 'options', ')', 'end']
->Original Target:
['Logs', 'a', 'user', 'in', '.']
->Reconstructed Target:
Logs a user in.
->Reconstructed Predication:
login a user andthe user to login with the
->Raw Input:
summarize:def login ( user, options = { } ) options [ :scope ] ||= Janus. scope_for ( user ) set_user ( user, options ) Janus :: Manager. run_callbacks ( :login, user, self, options ) end
->Raw Target:
Logs a user in.
--

951=========
->Original Input:
['def', 'logout', '(', '*', 'scopes', ')', 'scopes', '=', 'janus_sessions', '.', 'keys', 'if', 'scopes', '.', 'empty?', 'scopes', '.', 'each', 'do', '|', 'scope', '|', '_user', '=', 'user', '(', 'scope', ')', 'unset_user', '(', 'scope', ')', 'Janus', '::', 'Manager', '.', 'run_callbacks', '(', ':logout', ',', '_user', ',', 'self', ',', ':scope', '=>', 'scope', ')', 'end', 'request', '.', 'reset_session', 'if', 'janus_sessions', '.', 'empty?', 'end']
->Original Target:
['Logs', 'a', 'user', 'out', 'from', 'the', 'given', 'scopes', 'or', 'from', 'all', 'scopes', 'at', 'once', 'if', 'no', 'scope', 'is', 'defined', '.', 'If', 'no', 'scope', 'is', 'left', 'after', 'logout', 'then', 'the', 'whole', 'session', 'will', 'be', 'resetted', '.']
->Reconstructed Target:
Logs a user out from the given scopes or from all scopes at once if no scope is defined. If no scope is left after logout then the whole session will be resetted.
->Reconstructed Predication:
logout the user and the
->Raw Input:
summarize:def logout ( * scopes ) scopes = janus_sessions. keys if scopes. empty? scopes. each do | scope | _user = user ( scope ) unset_user ( scope ) Janus :: Manager. run_callbacks ( :logout, _user, self, :scope => scope ) end request. reset_session if janus_sessions. empty? end
->Raw Target:
Logs a user out from the given scopes or from all scopes at once if no scope is defined. If no scope is left after logout then the whole session will be resetted.
--

952=========
->Original Input:
['def', 'set_user', '(', 'user', ',', 'options', '=', '{', '}', ')', 'scope', '=', 'options', '[', ':scope', ']', '||', 'Janus', '.', 'scope_for', '(', 'user', ')', 'janus_sessions', '[', 'scope', '.', 'to_s', ']', '=', '{', "'user_class'", '=>', 'user', '.', 'class', '.', 'name', ',', "'user_id'", '=>', 'user', '.', 'id', '}', 'end']
->Original Target:
['Manually', 'sets', 'a', 'user', 'without', 'going', 'throught', 'the', 'whole', 'login', 'or', 'authenticate', 'process', '.']
->Reconstructed Target:
Manually sets a user without going throught the whole login or authenticate process.
->Reconstructed Predication:
the user to be used forthe user to be used for
->Raw Input:
summarize:def set_user ( user, options = { } ) scope = options [ :scope ] || Janus. scope_for ( user ) janus_sessions [ scope. to_s ] = { 'user_class' => user. class. name, 'user_id' => user. id } end
->Raw Target:
Manually sets a user without going throught the whole login or authenticate process.
--

953=========
->Original Input:
['def', 'unset_user', '(', 'scope', ')', 'janus_sessions', '.', 'delete', '(', 'scope', '.', 'to_s', ')', '@users', '.', 'delete', '(', 'scope', '.', 'to_sym', ')', 'unless', '@users', '.', 'nil?', 'end']
->Original Target:
['Manually', 'removes', 'the', 'user', 'without', 'going', 'throught', 'the', 'whole', 'logout', 'process', '.']
->Reconstructed Target:
Manually removes the user without going throught the whole logout process.
->Reconstructed Predication:
the user to be unset.
->Raw Input:
summarize:def unset_user ( scope ) janus_sessions. delete ( scope. to_s ) @users. delete ( scope. to_sym ) unless @users. nil? end
->Raw Target:
Manually removes the user without going throught the whole logout process.
--

954=========
->Original Input:
['def', 'user', '(', 'scope', ')', 'scope', '=', 'scope', '.', 'to_sym', '@users', '||=', '{', '}', 'if', 'authenticated?', '(', 'scope', ')', 'if', '@users', '[', 'scope', ']', '.', 'nil?', 'begin', '@users', '[', 'scope', ']', '=', 'user_class', '(', 'scope', ')', '.', 'find', '(', 'session', '(', 'scope', ')', '[', "'user_id'", ']', ')', 'rescue', 'ActiveRecord', '::', 'RecordNotFound', 'unset_user', '(', 'scope', ')', 'else', 'Janus', '::', 'Manager', '.', 'run_callbacks', '(', ':fetch', ',', '@users', '[', 'scope', ']', ',', 'self', ',', ':scope', '=>', 'scope', ')', 'end', 'end', '@users', '[', 'scope', ']', 'end', 'end']
->Original Target:
['Returns', 'the', 'currently', 'connected', 'user', '.']
->Reconstructed Target:
Returns the currently connected user.
->Reconstructed Predication:
the user for the given scopethe user for the given scope
->Raw Input:
summarize:def user ( scope ) scope = scope. to_sym @users ||= { } if authenticated? ( scope ) if @users [ scope ]. nil? begin @users [ scope ] = user_class ( scope ). find ( session ( scope ) [ 'user_id' ] ) rescue ActiveRecord :: RecordNotFound unset_user ( scope ) else Janus :: Manager. run_callbacks ( :fetch, @users [ scope ], self, :scope => scope ) end end @users [ scope ] end end
->Raw Target:
Returns the currently connected user.
--

955=========
->Original Input:
['def', 'namespace', 'return', "'#'", 'if', 'Tml', '.', 'config', '.', 'disabled?', '@namespace', '||', 'Tml', '.', 'config', '.', 'cache', '[', ':namespace', ']', '||', 'Tml', '.', 'config', '.', 'application', '[', ':key', ']', '[', '0', '..', '5', ']', 'end']
->Original Target:
['namespace', 'of', 'each', 'cache', 'key']
->Reconstructed Target:
namespace of each cache key
->Reconstructed Predication:
@return the namespace of the
->Raw Input:
summarize:def namespace return '#' if Tml. config. disabled? @namespace || Tml. config. cache [ :namespace ] || Tml. config. application [ :key ] [ 0.. 5 ] end
->Raw Target:
namespace of each cache key
--

956=========
->Original Input:
['def', 'extract_version', '(', 'app', ',', 'version', '=', 'nil', ')', 'if', 'version', 'Tml', '.', 'cache', '.', 'version', '.', 'set', '(', 'version', '.', 'to_s', ')', 'else', 'version_data', '=', 'app', '.', 'api_client', '.', 'get_from_cdn', '(', "'version'", ',', '{', 't', ':', 'Time', '.', 'now', '.', 'to_i', '}', ',', '{', 'uncompressed', ':', 'true', '}', ')', 'unless', 'version_data', 'Tml', '.', 'logger', '.', 'debug', '(', "'No releases have been generated yet. Please visit your Dashboard and publish translations.'", ')', 'return', 'end', 'Tml', '.', 'cache', '.', 'version', '.', 'set', '(', 'version_data', '[', "'version'", ']', ')', 'end', 'end']
->Original Target:
['Pulls', 'cache', 'version', 'from', 'CDN']
->Reconstructed Target:
Pulls cache version from CDN
->Reconstructed Predication:
the version of the applicationthe version of the application
->Raw Input:
summarize:def extract_version ( app, version = nil ) if version Tml. cache. version. set ( version. to_s ) else version_data = app. api_client. get_from_cdn ('version', { t : Time. now. to_i }, { uncompressed : true } ) unless version_data Tml. logger. debug ( 'No releases have been generated yet. Please visit your Dashboard and publish translations.' ) return end Tml. cache. version. set ( version_data ['version' ] ) end end
->Raw Target:
Pulls cache version from CDN
--

957=========
->Original Input:
['def', 'warmup', '(', 'version', '=', 'nil', ',', 'cache_path', '=', 'nil', ')', 'if', 'cache_path', '.', 'nil?', 'warmup_from_cdn', '(', 'version', ')', 'else', 'warmup_from_files', '(', 'version', ',', 'cache_path', ')', 'end', 'end']
->Original Target:
['Warms', 'up', 'cache', 'from', 'CDN', 'or', 'local', 'files']
->Reconstructed Target:
Warms up cache from CDN or local files
->Reconstructed Predication:
the file to be used for
->Raw Input:
summarize:def warmup ( version = nil, cache_path = nil ) if cache_path. nil? warmup_from_cdn ( version ) else warmup_from_files ( version, cache_path ) end end
->Raw Target:
Warms up cache from CDN or local files
--

958=========
->Original Input:
['def', 'warmup_from_files', '(', 'version', '=', 'nil', ',', 'cache_path', '=', 'nil', ')', 't0', '=', 'Time', '.', 'now', 'Tml', '.', 'logger', '=', 'Logger', '.', 'new', '(', 'STDOUT', ')', 'Tml', '.', 'logger', '.', 'debug', '(', "'Starting cache warmup from local files...'", ')', 'version', '||=', 'Tml', '.', 'config', '.', 'cache', '[', ':version', ']', 'cache_path', '||=', 'Tml', '.', 'config', '.', 'cache', '[', ':path', ']', 'cache_path', '=', '"#{cache_path}/#{version}"', 'Tml', '.', 'cache', '.', 'version', '.', 'set', '(', 'version', '.', 'to_s', ')', 'Tml', '.', 'logger', '.', 'debug', '(', '"Warming Up Version: #{Tml.cache.version}"', ')', 'application', '=', 'JSON', '.', 'parse', '(', 'File', '.', 'read', '(', '"#{cache_path}/application.json"', ')', ')', 'Tml', '.', 'cache', '.', 'store', '(', 'Tml', '::', 'Application', '.', 'cache_key', ',', 'application', ')', 'sources', '=', 'JSON', '.', 'parse', '(', 'File', '.', 'read', '(', '"#{cache_path}/sources.json"', ')', ')', 'application', '[', "'languages'", ']', '.', 'each', 'do', '|', 'lang', '|', 'locale', '=', 'lang', '[', "'locale'", ']', 'language', '=', 'JSON', '.', 'parse', '(', 'File', '.', 'read', '(', '"#{cache_path}/#{locale}/language.json"', ')', ')', 'Tml', '.', 'cache', '.', 'store', '(', 'Tml', '::', 'Language', '.', 'cache_key', '(', 'locale', ')', ',', 'language', ')', 'sources', '.', 'each', 'do', '|', 'src', '|', 'source', '=', 'JSON', '.', 'parse', '(', 'File', '.', 'read', '(', '"#{cache_path}/#{locale}/sources/#{src}.json"', ')', ')', 'Tml', '.', 'cache', '.', 'store', '(', 'Tml', '::', 'Source', '.', 'cache_key', '(', 'locale', ',', 'src', ')', ',', 'source', ')', 'end', 'end', 't1', '=', 'Time', '.', 'now', 'Tml', '.', 'logger', '.', 'debug', '(', '"Cache warmup took #{t1-t0}s"', ')', 'end']
->Original Target:
['Warms', 'up', 'cache', 'from', 'local', 'files']
->Reconstructed Target:
Warms up cache from local files
->Reconstructed Predication:
. cache.. cache_key, application ). cache.. cache_key,). cache. store (. cache_key,. cache. store (. cache_key,. cache. store (). cache_key,. cache. store (. cache_key,. cache_key,. cache_key,. cache_key,. cache_key,
->Raw Input:
summarize:def warmup_from_files ( version = nil, cache_path = nil ) t0 = Time. now Tml. logger = Logger. new ( STDOUT ) Tml. logger. debug ( 'Starting cache warmup from local files...' ) version ||= Tml. config. cache [ :version ] cache_path ||= Tml. config. cache [ :path ] cache_path = "#{cache_path}/#{version}" Tml. cache. version. set ( version. to_s ) Tml. logger. debug ( "Warming Up Version: #{Tml.cache.version}" ) application = JSON. parse ( File. read ( "#{cache_path}/application.json" ) ) Tml. cache. store ( Tml :: Application. cache_key, application ) sources = JSON. parse ( File. read ( "#{cache_path}/sources.json" ) ) application [ 'languages' ]. each do | lang | locale = lang [ 'locale' ] language = JSON. parse ( File. read ( "#{cache_path}/#{locale}/language.json" ) ) Tml. cache. store ( Tml :: Language. cache_key ( locale ), language ) sources. each do | src | source = JSON. parse ( File. read ( "#{cache_path}/#{locale}/sources/#{src}.json" ) ) Tml. cache. store ( Tml :: Source. cache_key ( locale, src ), source ) end end t1 = Time. now Tml. logger. debug ( "Cache warmup took #{t1-t0}s" ) end
->Raw Target:
Warms up cache from local files
--

959=========
->Original Input:
['def', 'warmup_from_cdn', '(', 'version', '=', 'nil', ')', 't0', '=', 'Time', '.', 'now', 'Tml', '.', 'logger', '=', 'Logger', '.', 'new', '(', 'STDOUT', ')', 'Tml', '.', 'logger', '.', 'debug', '(', "'Starting cache warmup from CDN...'", ')', 'app', '=', 'Tml', '::', 'Application', '.', 'new', '(', 'key', ':', 'Tml', '.', 'config', '.', 'application', '[', ':key', ']', ',', 'cdn_host', ':', 'Tml', '.', 'config', '.', 'application', '[', ':cdn_host', ']', ')', 'extract_version', '(', 'app', ',', 'version', ')', 'Tml', '.', 'logger', '.', 'debug', '(', '"Warming Up Version: #{Tml.cache.version}"', ')', 'application', '=', 'app', '.', 'api_client', '.', 'get_from_cdn', '(', "'application'", ',', '{', 't', ':', 'Time', '.', 'now', '.', 'to_i', '}', ')', 'Tml', '.', 'cache', '.', 'store', '(', 'Tml', '::', 'Application', '.', 'cache_key', ',', 'application', ')', 'sources', '=', 'app', '.', 'api_client', '.', 'get_from_cdn', '(', "'sources'", ',', '{', 't', ':', 'Time', '.', 'now', '.', 'to_i', '}', ',', '{', 'uncompressed', ':', 'true', '}', ')', 'application', '[', "'languages'", ']', '.', 'each', 'do', '|', 'lang', '|', 'locale', '=', 'lang', '[', "'locale'", ']', 'language', '=', 'app', '.', 'api_client', '.', 'get_from_cdn', '(', '"#{locale}/language"', ',', '{', 't', ':', 'Time', '.', 'now', '.', 'to_i', '}', ')', 'Tml', '.', 'cache', '.', 'store', '(', 'Tml', '::', 'Language', '.', 'cache_key', '(', 'locale', ')', ',', 'language', ')', 'sources', '.', 'each', 'do', '|', 'src', '|', 'source', '=', 'app', '.', 'api_client', '.', 'get_from_cdn', '(', '"#{locale}/sources/#{src}"', ',', '{', 't', ':', 'Time', '.', 'now', '.', 'to_i', '}', ')', 'Tml', '.', 'cache', '.', 'store', '(', 'Tml', '::', 'Source', '.', 'cache_key', '(', 'locale', ',', 'src', ')', ',', 'source', ')', 'end', 'end', 't1', '=', 'Time', '.', 'now', 'Tml', '.', 'logger', '.', 'debug', '(', '"Cache warmup took #{t1-t0}s"', ')', 'end']
->Original Target:
['Warms', 'up', 'cache', 'from', 'CDN']
->Reconstructed Target:
Warms up cache from CDN
->Reconstructed Predication:
. cache.. cache_key, application ). cache.. cache_key,. cache.). cache.. cache_key,. cache.). cache.. cache_key, application ). cache.. cache_key,. cache.. cache_key,. cache_key,. cache.. cache_key,. cache..
->Raw Input:
summarize:def warmup_from_cdn ( version = nil ) t0 = Time. now Tml. logger = Logger. new ( STDOUT ) Tml. logger. debug ( 'Starting cache warmup from CDN...' ) app = Tml :: Application. new ( key : Tml. config. application [ :key ], cdn_host : Tml. config. application [ :cdn_host ] ) extract_version ( app, version ) Tml. logger. debug ( "Warming Up Version: #{Tml.cache.version}" ) application = app. api_client. get_from_cdn ( 'application', { t : Time. now. to_i } ) Tml. cache. store ( Tml :: Application. cache_key, application ) sources = app. api_client. get_from_cdn ('sources', { t : Time. now. to_i }, { uncompressed : true } ) application [ 'languages' ]. each do | lang | locale = lang [ 'locale' ] language = app. api_client. get_from_cdn ( "#{locale}/language", { t : Time. now. to_i } ) Tml. cache. store ( Tml :: Language. cache_key ( locale ), language ) sources. each do | src | source = app. api_client. get_from_cdn ( "#{locale}/sources/#{src}", { t : Time. now. to_i } ) Tml. cache. store ( Tml :: Source. cache_key ( locale, src ), source ) end end t1 = Time. now Tml. logger. debug ( "Cache warmup took #{t1-t0}s" ) end
->Raw Target:
Warms up cache from CDN
--

960=========
->Original Input:
['def', 'default_cache_path', '@cache_path', '||=', 'begin', 'path', '=', 'Tml', '.', 'config', '.', 'cache', '[', ':path', ']', 'path', '||=', "'config/tml'", 'FileUtils', '.', 'mkdir_p', '(', 'path', ')', 'FileUtils', '.', 'chmod', '(', '0777', ',', 'path', ')', 'path', 'end', 'end']
->Original Target:
['default', 'cache', 'path']
->Reconstructed Target:
default cache path
->Reconstructed Predication:
the cache path for the
->Raw Input:
summarize:def default_cache_path @cache_path ||= begin path = Tml. config. cache [ :path ] path ||= 'config/tml' FileUtils. mkdir_p ( path ) FileUtils. chmod ( 0777, path ) path end end
->Raw Target:
default cache path
--

961=========
->Original Input:
['def', 'download', '(', 'cache_path', '=', 'default_cache_path', ',', 'version', '=', 'nil', ')', 't0', '=', 'Time', '.', 'now', 'Tml', '.', 'logger', '=', 'Logger', '.', 'new', '(', 'STDOUT', ')', 'Tml', '.', 'logger', '.', 'debug', '(', "'Starting cache download...'", ')', 'app', '=', 'Tml', '::', 'Application', '.', 'new', '(', 'key', ':', 'Tml', '.', 'config', '.', 'application', '[', ':key', ']', ',', 'cdn_host', ':', 'Tml', '.', 'config', '.', 'application', '[', ':cdn_host', ']', ')', 'extract_version', '(', 'app', ',', 'version', ')', 'Tml', '.', 'logger', '.', 'debug', '(', '"Downloading Version: #{Tml.cache.version}"', ')', 'archive_name', '=', '"#{Tml.cache.version}.tar.gz"', 'path', '=', '"#{cache_path}/#{archive_name}"', 'url', '=', '"#{app.cdn_host}/#{Tml.config.application[:key]}/#{archive_name}"', 'Tml', '.', 'logger', '.', 'debug', '(', '"Downloading cache file: #{url}"', ')', 'open', '(', 'path', ',', "'wb'", ')', 'do', '|', 'file', '|', 'file', '<<', 'open', '(', 'url', ')', '.', 'read', 'end', 'Tml', '.', 'logger', '.', 'debug', '(', "'Extracting cache file...'", ')', 'version_path', '=', '"#{cache_path}/#{Tml.cache.version}"', 'Tml', '::', 'Utils', '.', 'untar', '(', 'Tml', '::', 'Utils', '.', 'ungzip', '(', 'File', '.', 'new', '(', 'path', ')', ')', ',', 'version_path', ')', 'Tml', '.', 'logger', '.', 'debug', '(', '"Cache has been stored in #{version_path}"', ')', 'File', '.', 'unlink', '(', 'path', ')', 'begin', 'current_path', '=', "'current'", 'FileUtils', '.', 'chdir', '(', 'cache_path', ')', 'FileUtils', '.', 'rm', '(', 'current_path', ')', 'if', 'File', '.', 'exist?', '(', 'current_path', ')', 'FileUtils', '.', 'ln_s', '(', 'Tml', '.', 'cache', '.', 'version', '.', 'to_s', ',', 'current_path', ')', 'Tml', '.', 'logger', '.', 'debug', '(', '"The new version #{Tml.cache.version} has been marked as current"', ')', 'rescue', 'Exception', '=>', 'ex', 'Tml', '.', 'logger', '.', 'debug', '(', '"Could not generate current symlink to the cache path: #{ex.message}"', ')', 'end', 't1', '=', 'Time', '.', 'now', 'Tml', '.', 'logger', '.', 'debug', '(', '"Cache download took #{t1-t0}s"', ')', 'end']
->Original Target:
['downloads', 'cache', 'from', 'the', 'CDN']
->Reconstructed Target:
downloads cache from the CDN
->Reconstructed Predication:
. debug ( "DownloadTml. cache. version. debug ( "Downloadfile). debug ( "Downloadfile). debug ( "DownloadTml. cache. version. debug ( "DownloadTml. cache. version. debug ( "DownloadTml. cache. version. debug ( "DownloadTml. cache. version. debug ( "Downloadfile. debug ( "
->Raw Input:
summarize:def download ( cache_path = default_cache_path, version = nil ) t0 = Time. now Tml. logger = Logger. new ( STDOUT ) Tml. logger. debug ( 'Starting cache download...' ) app = Tml :: Application. new ( key : Tml. config. application [ :key ], cdn_host : Tml. config. application [ :cdn_host ] ) extract_version ( app, version ) Tml. logger. debug ( "Downloading Version: #{Tml.cache.version}" ) archive_name = "#{Tml.cache.version}.tar.gz" path = "#{cache_path}/#{archive_name}" url = "#{app.cdn_host}/#{Tml.config.application[:key]}/#{archive_name}" Tml. logger. debug ( "Downloading cache file: #{url}" ) open ( path, 'wb' ) do | file | file << open ( url ). read end Tml. logger. debug ( 'Extracting cache file...' ) version_path = "#{cache_path}/#{Tml.cache.version}" Tml :: Utils. untar ( Tml :: Utils. ungzip ( File. new ( path ) ), version_path ) Tml. logger. debug ( "Cache has been stored in #{version_path}" ) File. unlink ( path ) begin current_path = 'current' FileUtils. chdir ( cache_path ) FileUtils. rm ( current_path ) if File. exist? ( current_path ) FileUtils. ln_s ( Tml. cache. version. to_s, current_path ) Tml. logger. debug ( "The new version #{Tml.cache.version} has been marked as current" ) rescue Exception => ex Tml. logger. debug ( "Could not generate current symlink to the cache path: #{ex.message}" ) end t1 = Time. now Tml. logger. debug ( "Cache download took #{t1-t0}s" ) end
->Raw Target:
downloads cache from the CDN
--

962=========
->Original Input:
['def', 'say', '(', 'message', ',', 'color', '=', 'nil', ')', '@shell', '||=', 'Thor', '::', 'Shell', '::', 'Basic', '.', 'new', '@shell', '.', 'say', 'message', ',', 'color', 'end']
->Original Target:
['shortcut', 'to', 'say']
->Reconstructed Target:
shortcut to say
->Reconstructed Predication:
the shell to the shell.
->Raw Input:
summarize:def say ( message, color = nil ) @shell ||= Thor :: Shell :: Basic. new @shell. say message, color end
->Raw Target:
shortcut to say
--

963=========
->Original Input:
['def', 'validate_cache_version', '(', 'version', ')', 'if', 'Tml', '.', 'config', '.', 'cache', '[', ':version', ']', 'return', 'Tml', '.', 'config', '.', 'cache', '[', ':version', ']', 'end', 'return', 'version', 'unless', 'version', '.', 'is_a?', '(', 'Hash', ')', 'return', "'undefined'", 'unless', 'version', '[', "'t'", ']', '.', 'is_a?', '(', 'Numeric', ')', 'return', 'version', '[', "'version'", ']', 'if', 'cache', '.', 'read_only?', 'if', 'version_check_interval', '==', '-', '1', 'Tml', '.', 'logger', '.', 'debug', '(', "'Cache version check is disabled'", ')', 'return', 'version', '[', "'version'", ']', 'end', 'expires_at', '=', 'version', '[', "'t'", ']', '+', 'version_check_interval', 'if', 'expires_at', '<', 'Time', '.', 'now', '.', 'to_i', 'Tml', '.', 'logger', '.', 'debug', '(', "'Cache version is outdated, needs refresh'", ')', 'return', "'undefined'", 'end', 'delta', '=', 'expires_at', '-', 'Time', '.', 'now', '.', 'to_i', 'Tml', '.', 'logger', '.', 'debug', '(', '"Cache version is up to date, expires in #{delta}s"', ')', 'version', '[', "'version'", ']', 'end']
->Original Target:
['validate', 'that', 'current', 'cache', 'version', 'hasn', 't', 'expired']
->Reconstructed Target:
validate that current cache version hasn t expired
->Reconstructed Predication:
cache. read_only?cache. read_only?cache. write_only?cache. write_only?cache. write_only? return 'undefined'
->Raw Input:
summarize:def validate_cache_version ( version ) if Tml. config. cache [ :version ] return Tml. config. cache [ :version ] end return version unless version. is_a? ( Hash ) return 'undefined' unless version [ 't' ]. is_a? ( Numeric ) return version ['version' ] if cache. read_only? if version_check_interval == - 1 Tml. logger. debug ( 'Cache version check is disabled' ) return version ['version' ] end expires_at = version [ 't' ] + version_check_interval if expires_at < Time. now. to_i Tml. logger. debug ( 'Cache version is outdated, needs refresh' ) return 'undefined' end delta = expires_at - Time. now. to_i Tml. logger. debug ( "Cache version is up to date, expires in #{delta}s" ) version ['version' ] end
->Raw Target:
validate that current cache version hasn t expired
--

964=========
->Original Input:
['def', 'fetch', 'self', '.', 'version', '=', 'begin', 'ver', '=', 'cache', '.', 'fetch', '(', 'CACHE_VERSION_KEY', ')', 'do', '{', "'version'", '=>', 'Tml', '.', 'config', '.', 'cache', '[', ':version', ']', '||', "'undefined'", ',', "'t'", '=>', 'cache_timestamp', '}', 'end', 'validate_cache_version', '(', 'ver', ')', 'end', 'end']
->Original Target:
['fetches', 'the', 'version', 'from', 'the', 'cache']
->Reconstructed Target:
fetches the version from the cache
->Reconstructed Predication:
the cache version. 
->Raw Input:
summarize:def fetch self. version = begin ver = cache. fetch ( CACHE_VERSION_KEY ) do {'version' => Tml. config. cache [ :version ] || 'undefined', 't' => cache_timestamp } end validate_cache_version ( ver ) end end
->Raw Target:
fetches the version from the cache
--

965=========
->Original Input:
['def', '[]', 'file', ',', '*', 'ps', ',', '&', 'exe', 'opts', '=', '::', 'Hash', '===', 'ps', '.', 'last', '?', 'ps', '.', 'pop', ':', '{', '}', 'opts', '[', ':env', ']', '=', 'self', 'name', ',', 'type', ',', 'flg', '=', 'ps', '[', '0', ']', '||', 'opts', '[', ':name', ']', ',', 'ps', '[', '1', ']', '||', 'opts', '[', ':type', ']', ',', 'ps', '[', '2', ']', '||', 'opts', '[', ':flags', ']', 'ps', '.', 'push', 'opts', '@dbs', '[', '[', 'file', ',', 'name', ',', 'flg', '|', 'CREATE', ']', ']', '||=', '(', 'type', '||', 'SBDB', '::', 'Unknown', ')', '.', 'new', 'file', ',', '*', 'ps', ',', '&', 'exe', 'end']
->Original Target:
['Returns', 'the', 'DB', 'like', 'open', 'but', 'if', 'it', 's', 'already', 'opened', 'it', 'returns', 'the', 'old', 'instance', '.', 'If', 'you', 'use', 'this', 'never', 'use', 'close', '.', 'It', 's', 'possible', 'somebody', 'else', 'use', 'it', 'too', '.', 'The', 'Databases', 'which', 'are', 'opened', 'will', 'close', 'if', 'the', 'Environment', 'will', 'close', '.']
->Reconstructed Target:
Returns the DB like open but if it s already opened it returns the old instance. If you use this never use close. It s possible somebody else use it too. The Databases which are opened will close if the Environment will close.
->Reconstructed Predication:
| file | file| file | file |
->Raw Input:
summarize:def [] file, * ps, & exe opts = :: Hash === ps. last? ps. pop : { } opts [ :env ] = self name, type, flg = ps [ 0 ] || opts [ :name ], ps [ 1 ] || opts [ :type ], ps [ 2 ] || opts [ :flags ] ps. push opts @dbs [ [ file, name, flg | CREATE ] ] ||= ( type || SBDB :: Unknown ). new file, * ps, & exe end
->Raw Target:
Returns the DB like open but if it s already opened it returns the old instance. If you use this never use close. It s possible somebody else use it too. The Databases which are opened will close if the Environment will close.
--

966=========
->Original Input:
['def', 'run_strategies', '(', 'scope', ')', 'Janus', '::', 'Manager', '.', 'strategies', '.', 'each', '{', '|', 'name', '|', 'break', 'if', 'run_strategy', '(', 'name', ',', 'scope', ')', '}', 'end']
->Original Target:
['Runs', 'authentication', 'strategies', 'to', 'log', 'a', 'user', 'in', '.']
->Reconstructed Target:
Runs authentication strategies to log a user in.
->Reconstructed Predication:
the strategy to run.
->Raw Input:
summarize:def run_strategies ( scope ) Janus :: Manager. strategies. each { | name | break if run_strategy ( name, scope ) } end
->Raw Target:
Runs authentication strategies to log a user in.
--

967=========
->Original Input:
['def', 'run_strategy', '(', 'name', ',', 'scope', ')', 'strategy', '=', '"Janus::Strategies::#{name.to_s.camelize}"', '.', 'constantize', '.', 'new', '(', 'scope', ',', 'self', ')', 'if', 'strategy', '.', 'valid?', 'strategy', '.', 'authenticate!', 'if', 'strategy', '.', 'success?', 'send', '(', 'strategy', '.', 'auth_method', ',', 'strategy', '.', 'user', ',', ':scope', '=>', 'scope', ')', 'Janus', '::', 'Manager', '.', 'run_callbacks', '(', ':authenticate', ',', 'strategy', '.', 'user', ',', 'self', ',', ':scope', '=>', 'scope', ')', 'end', 'end', 'strategy', '.', 'success?', 'end']
->Original Target:
['Runs', 'a', 'given', 'strategy', 'and', 'returns', 'true', 'if', 'it', 'succeeded', '.']
->Reconstructed Target:
Runs a given strategy and returns true if it succeeded.
->Reconstructed Predication:
the user to authenticate the given
->Raw Input:
summarize:def run_strategy ( name, scope ) strategy = "Janus::Strategies::#{name.to_s.camelize}". constantize. new ( scope, self ) if strategy. valid? strategy. authenticate! if strategy. success? send ( strategy. auth_method, strategy. user, :scope => scope ) Janus :: Manager. run_callbacks ( :authenticate, strategy. user, self, :scope => scope ) end end strategy. success? end
->Raw Target:
Runs a given strategy and returns true if it succeeded.
--

968=========
->Original Input:
['def', 'perform', '(', 'script', ')', 'export_variables', '=', '@params', '.', 'reverse_merge', '(', '"PARADUCT_JOB_ID"', '=>', '@job_id', ',', '"PARADUCT_JOB_NAME"', '=>', 'job_name', ')', 'variable_string', '=', 'export_variables', '.', 'map', '{', '|', 'key', ',', 'value', '|', '%(export #{key}="#{value}";)', '}', '.', 'join', '(', '" "', ')', 'Array', '.', 'wrap', '(', 'script', ')', '.', 'inject', '(', '""', ')', 'do', '|', 'stdout', ',', 'command', '|', 'stdout', '<<', 'run_command', '(', '"#{variable_string} #{command}"', ')', 'stdout', 'end', 'end']
->Original Target:
['run', 'script', 'with', 'params']
->Reconstructed Target:
run script with params
->Reconstructed Predication:
the script to execute the jobthe job to perform the job
->Raw Input:
summarize:def perform ( script ) export_variables = @params. reverse_merge ( "PARADUCT_JOB_ID" => @job_id, "PARADUCT_JOB_NAME" => job_name ) variable_string = export_variables. map { | key, value | %(export #{key}="#{value}";) }. join ( " " ) Array. wrap ( script ). inject ( "" ) do | stdout, command | stdout << run_command ( "#{variable_string} #{command}" ) stdout end end
->Raw Target:
run script with params
--

969=========
->Original Input:
['def', 'print_hex', '(', 'data', ',', 'chunk_index', ',', 'cols', '=', '80', ')', 'case', 'hex_style', 'when', "'lower'", ',', "'lowercase'", 'print', 'Sixword', '::', 'Hex', '.', 'encode', '(', 'data', ')', 'when', "'finger'", ',', "'fingerprint'", 'newlines_every', '=', 'cols', '/', '5', 'if', 'chunk_index', '!=', '0', 'if', 'chunk_index', '%', 'newlines_every', '==', '0', 'print', '"\\n"', 'else', 'print', "' '", 'end', 'end', 'print', 'Sixword', '::', 'Hex', '.', 'encode_fingerprint', '(', 'data', ')', 'when', "'colon'", ',', "'colons'", 'print', "':'", 'unless', 'chunk_index', '==', '0', 'print', 'Sixword', '::', 'Hex', '.', 'encode_colons', '(', 'data', ')', 'end', 'end']
->Original Target:
['Format', 'data', 'as', 'hex', 'in', 'various', 'styles', '.']
->Reconstructed Target:
Format data as hex in various styles.
->Reconstructed Predication:
the chunk index of thethe chunk index of the chunk
->Raw Input:
summarize:def print_hex ( data, chunk_index, cols = 80 ) case hex_style when 'lower', 'lowercase' print Sixword :: Hex. encode ( data ) when 'finger', 'fingerprint' newlines_every = cols / 5 if chunk_index!= 0 if chunk_index % newlines_every == 0 print "\n" else print'' end end print Sixword :: Hex. encode_fingerprint ( data ) when 'colon', 'colons' print ':' unless chunk_index == 0 print Sixword :: Hex. encode_colons ( data ) end end
->Raw Target:
Format data as hex in various styles.
--

970=========
->Original Input:
['def', 'read_input_by_6_words', 'word_arr', '=', '[', ']', 'while', 'true', 'line', '=', 'stream', '.', 'gets', 'if', 'line', '.', 'nil?', 'break', 'end', 'line', '.', 'scan', '(', '/', '\\S', '/', ')', 'do', '|', 'word', '|', 'word_arr', '<<', 'word', 'if', 'word_arr', '.', 'length', '==', '6', 'yield', 'word_arr', 'word_arr', '.', 'clear', 'end', 'end', 'end', 'if', '!', 'word_arr', '.', 'empty?', 'yield', 'word_arr', 'end', 'end']
->Original Target:
['Yield', 'data', '6', 'words', 'at', 'a', 'time', 'until', 'EOF']
->Reconstructed Target:
Yield data 6 words at a time until EOF
->Reconstructed Predication:
the input stream
->Raw Input:
summarize:def read_input_by_6_words word_arr = [ ] while true line = stream. gets if line. nil? break end line. scan ( / \S / ) do | word | word_arr << word if word_arr. length == 6 yield word_arr word_arr. clear end end end if! word_arr. empty? yield word_arr end end
->Raw Target:
Yield data 6 words at a time until EOF
--

971=========
->Original Input:
['def', 'select', '(', 'query', ',', 'filters', ')', 'where', ',', '*', 'bind_values', '=', 'conditions', '(', 'query', ',', 'filters', ')', '[', '[', 'from', '(', 'filters', ')', ',', 'where', ',', 'order_by', '(', 'filters', ')', ',', 'limits', '(', 'filters', ')', ']', '.', 'join', '(', '" "', ')', ',', '*', 'bind_values', ']', 'end']
->Original Target:
['Initialize', 'a', 'new', 'QueryBuilder', 'for', '+', 'index_name', '+', '.']
->Reconstructed Target:
Initialize a new QueryBuilder for + index_name +.
->Reconstructed Predication:
the query and the querythe query and the query to
->Raw Input:
summarize:def select ( query, filters ) where, * bind_values = conditions ( query, filters ) [ [ from ( filters ), where, order_by ( filters ), limits ( filters ) ]. join ( " " ), * bind_values ] end
->Raw Target:
Initialize a new QueryBuilder for + index_name +.
--

972=========
->Original Input:
['def', 'update', '(', 'id', ',', 'attributes', ')', 'set_attrs', ',', '*', 'bind_values', '=', 'update_attributes', '(', 'attributes', ')', '[', '[', '"UPDATE #{@index_name} SET"', ',', 'set_attrs', ',', '"WHERE id = ?"', ']', '.', 'join', '(', '" "', ')', ',', '*', 'bind_values', '.', 'push', '(', 'id', ')', ']', 'end']
->Original Target:
['Build', 'a', 'SphinxQL', 'query', 'to', 'update', 'the', 'record', 'identified', 'by', '+', 'id', '+', 'with', 'the', 'given', 'attributes', '.']
->Reconstructed Target:
Build a SphinxQL query to update the record identified by + id + with the given attributes.
->Reconstructed Predication:
update the index with the given
->Raw Input:
summarize:def update ( id, attributes ) set_attrs, * bind_values = update_attributes ( attributes ) [ [ "UPDATE #{@index_name} SET", set_attrs, "WHERE id =?" ]. join ( " " ), * bind_values. push ( id ) ] end
->Raw Target:
Build a SphinxQL query to update the record identified by + id + with the given attributes.
--

973=========
->Original Input:
['def', 'query', '(', 'sql', ',', '*', 'bind_values', ')', '@pool', '.', 'acquire', '{', '|', 'conn', '|', 'conn', '.', 'query', '(', 'sql', ',', '*', 'bind_values', ')', '.', 'first', '}', 'end']
->Original Target:
['Execute', 'a', 'single', 'read', 'query', '.']
->Reconstructed Target:
Execute a single read query.
->Reconstructed Predication:
the query to the database
->Raw Input:
summarize:def query ( sql, * bind_values ) @pool. acquire { | conn | conn. query ( sql, * bind_values ). first } end
->Raw Target:
Execute a single read query.
--

974=========
->Original Input:
['def', 'method_missing', '(', 'method', ',', '*', 'args', ',', '&', 'block', ')', 'if', 'method', '.', 'to_s', '=~', '/', '/', 'if', 'instance_methods', '(', 'false', ')', '.', 'detect', '{', '|', 'meth', '|', 'meth', '.', 'to_s', '==', '$1', '}', 'Woodhouse', '.', 'dispatch', '(', '@worker_name', ',', '$1', ',', 'args', '.', 'first', ')', 'else', 'super', 'end', 'else', 'super', 'end', 'end']
->Original Target:
['You', 'can', 'dispatch', 'a', 'job', '+', 'baz', '+', 'on', 'class', '+', 'FooBar', '+', 'by', 'calling', 'FooBar', '.', 'async_baz', '.']
->Reconstructed Target:
You can dispatch a job + baz + on class + FooBar + by calling FooBar. async_baz.
->Reconstructed Predication:
the method to be called
->Raw Input:
summarize:def method_missing ( method, * args, & block ) if method. to_s =~ / / if instance_methods ( false ). detect { | meth | meth. to_s == $1 } Woodhouse. dispatch ( @worker_name, $1, args. first ) else super end else super end end
->Raw Target:
You can dispatch a job + baz + on class + FooBar + by calling FooBar. async_baz.
--

975=========
->Original Input:
['def', 'add_node', '(', 'node', ')', 'if', 'node', '.', 'respond_to?', '(', ':to_sym', ')', 'node', '=', 'Woodhouse', '::', 'Layout', '::', 'Node', '.', 'new', '(', 'node', '.', 'to_sym', ')', 'end', 'expect_arg', ':node', ',', 'Woodhouse', '::', 'Layout', '::', 'Node', ',', 'node', '@nodes', '<<', 'node', 'node', 'end']
->Original Target:
['Adds', 'a', 'Node', 'to', 'this', 'layout', '.', 'If', '+', 'node', '+', 'is', 'a', 'Symbol', 'a', 'Node', 'will', 'be', 'automatically', 'created', 'with', 'that', 'name', '.']
->Reconstructed Target:
Adds a Node to this layout. If + node + is a Symbol a Node will be automatically created with that name.
->Reconstructed Predication:
Add a node to the layoutthe node to be added to
->Raw Input:
summarize:def add_node ( node ) if node. respond_to? ( :to_sym ) node = Woodhouse :: Layout :: Node. new ( node. to_sym ) end expect_arg :node, Woodhouse :: Layout :: Node, node @nodes << node node end
->Raw Target:
Adds a Node to this layout. If + node + is a Symbol a Node will be automatically created with that name.
--

976=========
->Original Input:
['def', 'node', '(', 'name', ')', 'name', '=', 'name', '.', 'to_sym', '@nodes', '.', 'detect', '{', '|', 'node', '|', 'node', '.', 'name', '==', 'name', '}', 'end']
->Original Target:
['Looks', 'up', 'a', 'Node', 'by', 'name', 'and', 'returns', 'it', '.']
->Reconstructed Target:
Looks up a Node by name and returns it.
->Reconstructed Predication:
the node with the given name
->Raw Input:
summarize:def node ( name ) name = name. to_sym @nodes. detect { | node | node. name == name } end
->Raw Target:
Looks up a Node by name and returns it.
--

977=========
->Original Input:
['def', 'canonical', '(', 'attribute_list', ')', 'case', 'attribute_list', 'when', 'nil', 'then', '{', '}', 'when', 'Hash', 'then', 'attribute_list', 'when', 'Array', 'attribute_list', '.', 'map', 'do', '|', 'attributes', '|', 'case', 'attributes', 'when', 'Symbol', '{', 'attributes', '=>', 'AUTO', '}', 'when', 'Hash', 'attributes', 'else', 'raise', '"Unexpected attributes #{attributes}"', 'end', 'end', '.', 'inject', '(', '{', '}', ',', ':merge', ')', 'else', 'raise', '"Unexpected attribute_list #{attribute_list}"', 'end', 'end']
->Original Target:
['Converts', 'an', 'attribute_list', 'to', 'a', 'single', 'Hash', ';', 'some', 'of', 'the', 'values', 'may', 'be', 'set', 'to', 'AUTO', '.']
->Reconstructed Target:
Converts an attribute_list to a single Hash ; some of the values may be set to AUTO.
->Reconstructed Predication:
the canonical form of the attribute
->Raw Input:
summarize:def canonical ( attribute_list ) case attribute_list when nil then { } when Hash then attribute_list when Array attribute_list. map do | attributes | case attributes when Symbol { attributes => AUTO } when Hash attributes else raise "Unexpected attributes #{attributes}" end end. inject ( { }, :merge ) else raise "Unexpected attribute_list #{attribute_list}" end end
->Raw Target:
Converts an attribute_list to a single Hash ; some of the values may be set to AUTO.
--

978=========
->Original Input:
['def', 'imagine', '(', 'character_or_model', ',', 'attributes', '=', 'nil', ')', 'character', '=', 'to_character', '(', 'character_or_model', ')', 'prev', ',', '@building', '=', '@building', ',', '[', ']', 'CharacterBuilder', '.', 'new', '(', 'character', ')', '.', 'build', '(', 'attributes', ')', 'do', '|', 'ar', '|', 'ar', '.', 'save!', '@building', '.', 'each', 'do', '|', 'built', '|', 'raise', 'ActiveRecord', '::', 'RecordInvalid', ',', 'built', 'unless', 'built', '.', 'persisted?', '||', 'built', '.', 'valid?', 'end', 'Scheherazade', '.', 'log', '(', ':saving', ',', 'character', ',', 'ar', ')', 'handle_callbacks', '(', '@building', ')', 'end', 'ensure', '@built', '.', 'concat', '(', '@building', ')', '@building', '=', 'prev', 'end']
->Original Target:
['Creates', 'a', 'character', 'with', 'the', 'given', 'attributes']
->Reconstructed Target:
Creates a character with the given attributes
->Reconstructed Predication:
the character to be imagineed
->Raw Input:
summarize:def imagine ( character_or_model, attributes = nil ) character = to_character ( character_or_model ) prev, @building = @building, [ ] CharacterBuilder. new ( character ). build ( attributes ) do | ar | ar. save! @building. each do | built | raise ActiveRecord :: RecordInvalid, built unless built. persisted? || built. valid? end Scheherazade. log ( :saving, character, ar ) handle_callbacks ( @building ) end ensure @built. concat ( @building ) @building = prev end
->Raw Target:
Creates a character with the given attributes
--

979=========
->Original Input:
['def', 'with', '(', 'temp_current', ')', 'keys', '=', 'temp_current', '.', 'keys', '.', 'map', '{', '|', 'k', '|', 'to_character', '(', 'k', ')', '}', 'previous_values', '=', 'current', '.', 'values_at', '(', '*', 'keys', ')', 'current', '.', 'merge!', '(', 'Hash', '[', 'keys', '.', 'zip', '(', 'temp_current', '.', 'values', ')', ']', ')', 'yield', 'ensure', 'current', '.', 'merge!', '(', 'Hash', '[', 'keys', '.', 'zip', '(', 'previous_values', ')', ']', ')', 'end']
->Original Target:
['Allows', 'one', 'to', 'temporarily', 'override', 'the', 'current', 'characters', 'while', 'the', 'given', 'block', 'executes']
->Reconstructed Target:
Allows one to temporarily override the current characters while the given block executes
->Reconstructed Predication:
the current current
->Raw Input:
summarize:def with ( temp_current ) keys = temp_current. keys. map { | k | to_character ( k ) } previous_values = current. values_at ( * keys ) current. merge! ( Hash [ keys. zip ( temp_current. values ) ] ) yield ensure current. merge! ( Hash [ keys. zip ( previous_values ) ] ) end
->Raw Target:
Allows one to temporarily override the current characters while the given block executes
--

980=========
->Original Input:
['def', 'failure', '(', 'exception_class_or_message', ',', 'message_or_nil', '=', 'nil', ')', 'blank', '.', 'tap', 'do', '|', 'd', '|', 'd', '.', 'fail', '(', 'case', 'exception_class_or_message', 'when', 'Exception', 'raise', 'ArgumentError', ',', '"can\'t specify both exception and message"', 'if', 'message_or_nil', 'exception_class_or_message', 'when', 'Class', 'exception_class_or_message', '.', 'new', '(', 'message_or_nil', ')', 'else', 'RuntimeError', '.', 'new', '(', 'exception_class_or_message', '.', 'to_s', ')', 'end', ')', 'end', 'end']
->Original Target:
['Return', 'a', 'Deferrable', 'which', 'immediately', 'fails', 'with', 'an', 'exception', '.']
->Reconstructed Target:
Return a Deferrable which immediately fails with an exception.
->Reconstructed Predication:
the failure of the given exception
->Raw Input:
summarize:def failure ( exception_class_or_message, message_or_nil = nil ) blank. tap do | d | d. fail ( case exception_class_or_message when Exception raise ArgumentError, "can't specify both exception and message" if message_or_nil exception_class_or_message when Class exception_class_or_message. new ( message_or_nil ) else RuntimeError. new ( exception_class_or_message. to_s ) end ) end end
->Raw Target:
Return a Deferrable which immediately fails with an exception.
--

981=========
->Original Input:
['def', 'file_length', 'if', 'self', '.', 'audio', '.', 'is_a?', '(', 'File', ')', '&&', 'self', '.', 'audio', '.', 'size', '>', 'MAX_FILE_SIZE', 'self', '.', 'errors', '.', 'add', ':audio', ',', '"It\'s length is excesive. #{MAX_FILE_SIZE} is the limit."', 'return', 'false', 'end', 'return', 'true', 'end']
->Original Target:
['Function', 'to', 'check', 'that', 'the', 'file', 'size', 'isn', 't', 'excesive', '.']
->Reconstructed Target:
Function to check that the file size isn t excesive.
->Reconstructed Predication:
the file length of the
->Raw Input:
summarize:def file_length if self. audio. is_a? ( File ) && self. audio. size > MAX_FILE_SIZE self. errors. add :audio, "It's length is excesive. #{MAX_FILE_SIZE} is the limit." return false end return true end
->Raw Target:
Function to check that the file size isn t excesive.
--

982=========
->Original Input:
['def', 'api_call', 'method', ',', 'payload', 'raise', 'ArgumentError', ',', '"API method not specified."', 'if', 'method', '.', 'blank?', 'payload', '||=', '{', '}', 'res', '=', '@conn', '.', 'post', 'method', '.', 'to_s', ',', 'payload', 'raise', 'Faraday', '::', 'Error', ',', '"Wrong response: #{res.inspect}"', 'if', '(', 'res', '.', 'status', '!=', '200', ')', 'return', 'res', 'end']
->Original Target:
['Function', 'to', 'call', 'API', 'passing', 'a', 'payload']
->Reconstructed Target:
Function to call API passing a payload
->Reconstructed Predication:
 def api_call ( method
->Raw Input:
summarize:def api_call method, payload raise ArgumentError, "API method not specified." if method. blank? payload ||= { } res = @conn. post method. to_s, payload raise Faraday :: Error, "Wrong response: #{res.inspect}" if ( res. status!= 200 ) return res end
->Raw Target:
Function to call API passing a payload
--

983=========
->Original Input:
['def', 'multi_search', '(', 'queries', ')', 'unless', 'queries', '.', 'kind_of?', '(', 'Hash', ')', 'raise', 'ArgumentError', ',', '"Argument must be a Hash of named queries (#{queries.class} given)"', 'end', 'stmts', '=', '[', ']', 'bind_values', '=', '[', ']', 'queries', '.', 'each', 'do', '|', 'key', ',', 'args', '|', 'str', ',', '*', 'values', '=', '@builder', '.', 'select', '(', '*', 'extract_query_data', '(', 'args', ')', ')', 'stmts', '.', 'push', '(', 'str', ',', '"SHOW META"', ')', 'bind_values', '.', 'push', '(', '*', 'values', ')', 'end', 'rs', '=', '@conn', '.', 'multi_query', '(', 'stmts', '.', 'join', '(', '";\\n"', ')', ',', '*', 'bind_values', ')', 'Hash', '[', ']', '.', 'tap', 'do', '|', 'result', '|', 'queries', '.', 'keys', '.', 'each', 'do', '|', 'key', '|', 'records', ',', 'meta', '=', 'rs', '.', 'shift', ',', 'rs', '.', 'shift', 'result', '[', 'key', ']', '=', 'meta_to_hash', '(', 'meta', ')', '.', 'tap', 'do', '|', 'r', '|', 'r', '[', ':records', ']', '=', 'records', '.', 'map', '{', '|', 'hash', '|', 'hash', '.', 'inject', '(', '{', '}', ')', '{', '|', 'o', ',', '(', 'k', ',', 'v', ')', '|', 'o', '.', 'merge!', '(', 'k', '.', 'to_sym', '=>', 'v', ')', '}', '}', 'end', 'end', 'end', 'end']
->Original Target:
['Perform', 'a', 'a', 'batch', 'search', 'on', 'the', 'index', '.']
->Reconstructed Target:
Perform a a batch search on the index.
->Reconstructed Predication:
thethe query to be returned.. join ( ";\n" ). join ( ";\n" ). join ( ";\n" ). join ( "\n" ). join ( "\n" ). join ( "\n" ). join ( "\n" ). join ( "\n" )
->Raw Input:
summarize:def multi_search ( queries ) unless queries. kind_of? ( Hash ) raise ArgumentError, "Argument must be a Hash of named queries (#{queries.class} given)" end stmts = [ ] bind_values = [ ] queries. each do | key, args | str, * values = @builder. select ( * extract_query_data ( args ) ) stmts. push ( str, "SHOW META" ) bind_values. push ( * values ) end rs = @conn. multi_query ( stmts. join ( ";\n" ), * bind_values ) Hash [ ]. tap do | result | queries. keys. each do | key | records, meta = rs. shift, rs. shift result [ key ] = meta_to_hash ( meta ). tap do | r | r [ :records ] = records. map { | hash | hash. inject ( { } ) { | o, ( k, v ) | o. merge! ( k. to_sym => v ) } } end end end end
->Raw Target:
Perform a a batch search on the index.
--

984=========
->Original Input:
['def', 'has_whereabouts', 'klass', '=', ':address', ',', '*', 'args', 'options', '=', 'args', '.', 'extract_options!', 'unless', 'klass', '==', ':address', '||', 'Object', '.', 'const_defined?', '(', 'klass', '.', 'to_s', '.', 'camelize', ')', 'create_address_class', '(', 'klass', '.', 'to_s', '.', 'camelize', ')', 'end', 'has_one', 'klass', ',', ':as', '=>', ':addressable', ',', ':dependent', '=>', ':destroy', 'accepts_nested_attributes_for', 'klass', 'if', 'options', '[', ':validate', ']', '&&', 'options', '[', ':validate', ']', '.', 'is_a?', '(', 'Array', ')', 'validators', '=', 'options', '[', ':validate', ']', 'set_validators', '(', 'klass', ',', 'validators', ')', 'else', 'validators', '=', '[', ']', 'end', 'define_singleton_method', 'validate_singleton_for', '(', 'klass', ')', 'do', 'validators', 'end', 'if', 'options', '[', ':geocode', ']', '&&', 'options', '[', ':geocode', ']', '==', 'true', '&&', 'defined?', '(', 'Geocoder', ')', 'geocode', '=', 'true', 'set_geocoding', '(', 'klass', ')', 'else', 'geocode', '=', 'false', 'end', 'define_singleton_method', 'geocode_singleton_for', '(', 'klass', ')', 'do', 'geocode', 'end', 'end']
->Original Target:
['Accepts', 'a', 'symbol', 'that', 'will', 'define', 'the', 'inherited', 'type', 'of', 'Address', '.', 'Defaults', 'to', 'the', 'parent', 'class', '.']
->Reconstructed Target:
Accepts a symbol that will define the inherited type of Address. Defaults to the parent class.
->Reconstructed Predication:
thethe given addressthe given addressthe given address.the given address. Thethe given address. Thethe given address. Thethethe given address. Thethe given address. The
->Raw Input:
summarize:def has_whereabouts klass = :address, * args options = args. extract_options! unless klass == :address || Object. const_defined? ( klass. to_s. camelize ) create_address_class ( klass. to_s. camelize ) end has_one klass, :as => :addressable, :dependent => :destroy accepts_nested_attributes_for klass if options [ :validate ] && options [ :validate ]. is_a? ( Array ) validators = options [ :validate ] set_validators ( klass, validators ) else validators = [ ] end define_singleton_method validate_singleton_for ( klass ) do validators end if options [ :geocode ] && options [ :geocode ] == true && defined? ( Geocoder ) geocode = true set_geocoding ( klass ) else geocode = false end define_singleton_method geocode_singleton_for ( klass ) do geocode end end
->Raw Target:
Accepts a symbol that will define the inherited type of Address. Defaults to the parent class.
--

985=========
->Original Input:
['def', 'set_validators', 'klass', ',', 'fields', '=', '[', ']', '_single', '=', 'validate_singleton_for', '(', 'klass', ')', 'klass', '.', 'to_s', '.', 'camelize', '.', 'constantize', '.', 'class_eval', 'do', 'fields', '.', 'each', 'do', '|', 'f', '|', 'validates_presence_of', 'f', ',', ':if', '=>', 'lambda', '{', '|', 'a', '|', 'a', '.', 'addressable_type', '.', 'constantize', '.', 'send', '(', '_single', ')', '.', 'include?', '(', 'f', ')', '}', 'end', 'end', 'end']
->Original Target:
['Sets', 'validates_presence_of', 'fields', 'for', 'the', 'Address', 'based', 'on', 'the', 'singleton', 'method', 'created', 'on', 'the', 'Address', 'addressable_type', 'class', '.']
->Reconstructed Target:
Sets validates_presence_of fields for the Address based on the singleton method created on the Address addressable_type class.
->Reconstructed Predication:
the fields to validate.
->Raw Input:
summarize:def set_validators klass, fields = [ ] _single = validate_singleton_for ( klass ) klass. to_s. camelize. constantize. class_eval do fields. each do | f | validates_presence_of f, :if => lambda { | a | a. addressable_type. constantize. send ( _single ). include? ( f ) } end end end
->Raw Target:
Sets validates_presence_of fields for the Address based on the singleton method created on the Address addressable_type class.
--

986=========
->Original Input:
['def', 'create_address_class', '(', 'class_name', ',', '&', 'block', ')', 'klass', '=', 'Class', '.', 'new', 'Address', ',', '&', 'block', 'Object', '.', 'const_set', 'class_name', ',', 'klass', 'end']
->Original Target:
['Generate', 'a', 'new', 'class', 'using', 'Address', 'as', 'the', 'superclass', '.', 'Accepts', 'a', 'string', 'defining', 'the', 'inherited', 'type', '.']
->Reconstructed Target:
Generate a new class using Address as the superclass. Accepts a string defining the inherited type.
->Reconstructed Predication:
the class to be created
->Raw Input:
summarize:def create_address_class ( class_name, & block ) klass = Class. new Address, & block Object. const_set class_name, klass end
->Raw Target:
Generate a new class using Address as the superclass. Accepts a string defining the inherited type.
--

987=========
->Original Input:
['def', 'event_loop', 'Qwirk', '.', 'logger', '.', 'debug', '"#{self}: Starting receive loop"', '@start_worker_time', '=', 'Time', '.', 'now', 'until', '@stopped', '||', '(', 'config', '.', 'stopped?', '&&', '@impl', '.', 'ready_to_stop?', ')', 'Qwirk', '.', 'logger', '.', 'debug', '"#{self}: Waiting for read"', '@start_read_time', '=', 'Time', '.', 'now', 'msg', '=', '@impl', '.', 'receive_message', 'if', 'msg', '@start_processing_time', '=', 'Time', '.', 'now', 'Qwirk', '.', 'logger', '.', 'debug', '{', '"#{self}: Done waiting for read in #{@start_processing_time - @start_read_time} seconds"', '}', 'delta', '=', 'config', '.', 'timer', '.', 'measure', 'do', '@processing_mutex', '.', 'synchronize', 'do', 'on_message', '(', 'msg', ')', '@impl', '.', 'acknowledge_message', '(', 'msg', ')', 'end', 'end', 'Qwirk', '.', 'logger', '.', 'info', '{', '"#{self}::on_message (#{\'%.1f\' % delta}ms)"', '}', 'if', 'self', '.', 'config', '.', 'log_times', 'Qwirk', '.', 'logger', '.', 'flush', 'if', 'Qwirk', '.', 'logger', '.', 'respond_to?', '(', ':flush', ')', 'end', 'end', 'Qwirk', '.', 'logger', '.', 'info', '"#{self}: Exiting"', 'rescue', 'Exception', '=>', 'e', '@status', '=', '"Terminated: #{e.message}"', 'Qwirk', '.', 'logger', '.', 'error', '"#{self}: Exception, thread terminating: #{e.message}\\n\\t#{e.backtrace.join("\\n\\t")}"', 'ensure', '@status', '=', "'Stopped'", 'Qwirk', '.', 'logger', '.', 'flush', 'if', 'Qwirk', '.', 'logger', '.', 'respond_to?', '(', ':flush', ')', 'config', '.', 'worker_stopped', '(', 'self', ')', 'end']
->Original Target:
['Start', 'the', 'event', 'loop', 'for', 'handling', 'messages', 'off', 'the', 'queue']
->Reconstructed Target:
Start the event loop for handling messages off the queue
->Reconstructed Predication:
. logger. info() end end end
->Raw Input:
summarize:def event_loop Qwirk. logger. debug "#{self}: Starting receive loop" @start_worker_time = Time. now until @stopped || ( config. stopped? && @impl. ready_to_stop? ) Qwirk. logger. debug "#{self}: Waiting for read" @start_read_time = Time. now msg = @impl. receive_message if msg @start_processing_time = Time. now Qwirk. logger. debug { "#{self}: Done waiting for read in #{@start_processing_time - @start_read_time} seconds" } delta = config. timer. measure do @processing_mutex. synchronize do on_message ( msg ) @impl. acknowledge_message ( msg ) end end Qwirk. logger. info { "#{self}::on_message (#{'%.1f' % delta}ms)" } if self. config. log_times Qwirk. logger. flush if Qwirk. logger. respond_to? ( :flush ) end end Qwirk. logger. info "#{self}: Exiting" rescue Exception => e @status = "Terminated: #{e.message}" Qwirk. logger. error "#{self}: Exception, thread terminating: #{e.message}\n\t#{e.backtrace.join("\n\t")}" ensure @status = 'Stopped' Qwirk. logger. flush if Qwirk. logger. respond_to? ( :flush ) config. worker_stopped ( self ) end
->Raw Target:
Start the event loop for handling messages off the queue
--

988=========
->Original Input:
['def', 'arel_attributes_values', '(', 'include_primary_key', '=', 'true', ',', 'include_readonly_attributes', '=', 'true', ',', 'attribute_names', '=', '@attributes', '.', 'keys', ')', 'attrs', '=', '{', '}', 'attribute_names', '.', 'each', 'do', '|', 'name', '|', 'if', '(', 'column', '=', 'column_for_attribute', '(', 'name', ')', ')', '&&', '(', 'include_primary_key', '||', '!', 'column', '.', 'primary', ')', 'if', 'include_readonly_attributes', '||', '(', '!', 'include_readonly_attributes', '&&', '!', 'self', '.', 'class', '.', 'readonly_attributes', '.', 'include?', '(', 'name', ')', ')', 'value', '=', 'read_attribute', '(', 'name', ')', 'if', 'self', '.', 'class', '.', 'columns_hash', '[', 'name', ']', '.', 'type', '==', ':hstore', '&&', 'value', '&&', 'value', '.', 'is_a?', '(', 'Hash', ')', 'value', '=', 'value', '.', 'to_hstore', 'elsif', 'value', '&&', 'self', '.', 'class', '.', 'serialized_attributes', '.', 'has_key?', '(', 'name', ')', '&&', '(', 'value', '.', 'acts_like?', '(', ':date', ')', '||', 'value', '.', 'acts_like?', '(', ':time', ')', '||', 'value', '.', 'is_a?', '(', 'Hash', ')', '||', 'value', '.', 'is_a?', '(', 'Array', ')', ')', 'value', '=', 'value', '.', 'to_yaml', 'end', 'attrs', '[', 'self', '.', 'class', '.', 'arel_table', '[', 'name', ']', ']', '=', 'value', 'end', 'end', 'end', 'attrs', 'end']
->Original Target:
['This', 'method', 'is', 'replaced', 'for', 'Rails', '3', 'compatibility', '.', 'All', 'I', 'do', 'is', 'add', 'the', 'condition', 'when', 'the', 'field', 'is', 'a', 'hash', 'that', 'converts', 'the', 'value', 'to', 'hstore', 'format', '.', 'IMHO', 'this', 'should', 'be', 'delegated', 'to', 'the', 'column', 'so', 'it', 'won', 't', 'be', 'necessary', 'to', 'rewrite', 'all', 'this', 'method', '.']
->Reconstructed Target:
This method is replaced for Rails 3 compatibility. All I do is add the condition when the field is a hash that converts the value to hstore format. IMHO this should be delegated to the column so it won t be necessary to rewrite all this method.
->Reconstructed Predication:
attributes values for theattributes. keysattributes. keysattributes. keysattributes. keysattributes. keysattributes. keysattributes. keysattributes. keysattributes. keysattributes. keys.attributes. keys.attributes. keys.attributes. keys.attributes. keys.attributes. keys.attributes. keys.attributes. keys.attributes. keys.. keys.. keys.. keys.
->Raw Input:
summarize:def arel_attributes_values ( include_primary_key = true, include_readonly_attributes = true, attribute_names = @attributes. keys ) attrs = { } attribute_names. each do | name | if ( column = column_for_attribute ( name ) ) && ( include_primary_key ||! column. primary ) if include_readonly_attributes || (! include_readonly_attributes &&! self. class. readonly_attributes. include? ( name ) ) value = read_attribute ( name ) if self. class. columns_hash [ name ]. type == :hstore && value && value. is_a? ( Hash ) value = value. to_hstore elsif value && self. class. serialized_attributes. has_key? ( name ) && ( value. acts_like? ( :date ) || value. acts_like? ( :time ) || value. is_a? ( Hash ) || value. is_a? ( Array ) ) value = value. to_yaml end attrs [ self. class. arel_table [ name ] ] = value end end end attrs end
->Raw Target:
This method is replaced for Rails 3 compatibility. All I do is add the condition when the field is a hash that converts the value to hstore format. IMHO this should be delegated to the column so it won t be necessary to rewrite all this method.
--

989=========
->Original Input:
['def', 'requires_version', '(', 'cmd', ',', 'version_', ')', 'v', '=', 'check_version', '(', 'version_', ')', 'raise', 'NoMethodError', ',', 'format', '(', "'%s is not supported in Bugzilla %s'", ',', 'cmd', ',', 'v', '[', '1', ']', ')', 'unless', 'v', '[', '0', ']', 'end']
->Original Target:
['def', 'check_version', 'rdoc']
->Reconstructed Target:
def check_version rdoc
->Reconstructed Predication:
the version of the Bugzilla
->Raw Input:
summarize:def requires_version ( cmd, version_ ) v = check_version ( version_ ) raise NoMethodError, format ( '%s is not supported in Bugzilla %s', cmd, v [ 1 ] ) unless v [ 0 ] end
->Raw Target:
def check_version rdoc
--

990=========
->Original Input:
['def', 'run', 'begin', 'Clacks', '.', 'logger', '.', 'info', '"Clacks v#{Clacks::VERSION} started"', 'if', 'Clacks', '.', 'config', '[', ':pop3', ']', 'run_pop3', 'elsif', 'Clacks', '.', 'config', '[', ':imap', ']', 'run_imap', 'else', 'raise', '"Either a POP3 or an IMAP server must be configured"', 'end', 'rescue', 'Exception', '=>', 'e', 'fatal', '(', 'e', ')', 'end', 'end']
->Original Target:
['default', '10', 'minutes']
->Reconstructed Target:
default 10 minutes
->Reconstructed Predication:
Run the server andthe server and the server tothe server and the server tothe server and the server to
->Raw Input:
summarize:def run begin Clacks. logger. info "Clacks v#{Clacks::VERSION} started" if Clacks. config [ :pop3 ] run_pop3 elsif Clacks. config [ :imap ] run_imap else raise "Either a POP3 or an IMAP server must be configured" end rescue Exception => e fatal ( e ) end end
->Raw Target:
default 10 minutes
--

991=========
->Original Input:
['def', 'imap_validate_options', '(', 'options', ')', 'options', '||=', '{', '}', 'options', '[', ':mailbox', ']', '||=', "'INBOX'", 'options', '[', ':count', ']', '||=', '5', 'options', '[', ':order', ']', '||=', ':asc', 'options', '[', ':what', ']', '||=', ':first', 'options', '[', ':keys', ']', '||=', "'ALL'", 'options', '[', ':delete_after_find', ']', '||=', 'false', 'options', '[', ':mailbox', ']', '=', 'Net', '::', 'IMAP', '.', 'encode_utf7', '(', 'options', '[', ':mailbox', ']', ')', 'if', 'options', '[', ':archivebox', ']', 'options', '[', ':archivebox', ']', '=', 'Net', '::', 'IMAP', '.', 'encode_utf7', '(', 'options', '[', ':archivebox', ']', ')', 'end', 'options', 'end']
->Original Target:
['Follows', 'mostly', 'the', 'defaults', 'from', 'the', 'Mail', 'gem']
->Reconstructed Target:
Follows mostly the defaults from the Mail gem
->Reconstructed Predication:
: archivebox ] = Net :::archivebox ] = Net ::
->Raw Input:
summarize:def imap_validate_options ( options ) options ||= { } options [ :mailbox ] ||= 'INBOX' options [ :count ] ||= 5 options [ :order ] ||= :asc options [ :what ] ||= :first options [ :keys ] ||= 'ALL' options [ :delete_after_find ] ||= false options [ :mailbox ] = Net :: IMAP. encode_utf7 ( options [ :mailbox ] ) if options [ :archivebox ] options [ :archivebox ] = Net :: IMAP. encode_utf7 ( options [ :archivebox ] ) end options end
->Raw Target:
Follows mostly the defaults from the Mail gem
--

992=========
->Original Input:
['def', 'imap_find', '(', 'imap', ')', 'options', '=', 'Clacks', '.', 'config', '[', ':find_options', ']', 'delete_after_find', '=', 'options', '[', ':delete_after_find', ']', 'begin', 'break', 'if', 'stopping?', 'uids', '=', 'imap', '.', 'uid_search', '(', 'options', '[', ':keys', ']', '||', "'ALL'", ')', 'uids', '.', 'reverse!', 'if', 'options', '[', ':what', ']', '.', 'to_sym', '==', ':last', 'uids', '=', 'uids', '.', 'first', '(', 'options', '[', ':count', ']', ')', 'if', 'options', '[', ':count', ']', '.', 'is_a?', '(', 'Integer', ')', 'uids', '.', 'reverse!', 'if', '(', 'options', '[', ':what', ']', '.', 'to_sym', '==', ':last', '&&', 'options', '[', ':order', ']', '.', 'to_sym', '==', ':asc', ')', '||', '(', 'options', '[', ':what', ']', '.', 'to_sym', '!=', ':last', '&&', 'options', '[', ':order', ']', '.', 'to_sym', '==', ':desc', ')', 'processed', '=', '0', 'expunge', '=', 'false', 'uids', '.', 'each', 'do', '|', 'uid', '|', 'break', 'if', 'stopping?', 'source', '=', 'imap', '.', 'uid_fetch', '(', 'uid', ',', '[', "'RFC822'", ']', ')', '.', 'first', '.', 'attr', '[', "'RFC822'", ']', 'mail', '=', 'nil', 'begin', 'mail', '=', 'Mail', '.', 'new', '(', 'source', ')', 'mail', '.', 'mark_for_delete', '=', 'true', 'if', 'delete_after_find', 'Clacks', '.', 'config', '[', ':on_mail', ']', '.', 'call', '(', 'mail', ')', 'rescue', 'StandardError', '=>', 'e', 'Clacks', '.', 'logger', '.', 'error', '(', 'e', '.', 'message', ')', 'Clacks', '.', 'logger', '.', 'error', '(', 'e', '.', 'backtrace', ')', 'end', 'begin', 'imap', '.', 'uid_copy', '(', 'uid', ',', 'options', '[', ':archivebox', ']', ')', 'if', 'options', '[', ':archivebox', ']', 'if', 'delete_after_find', '&&', '(', 'mail', '.', 'nil?', '||', 'mail', '.', 'is_marked_for_delete?', ')', 'expunge', '=', 'true', 'imap', '.', 'uid_store', '(', 'uid', ',', '"+FLAGS"', ',', '[', 'Net', '::', 'IMAP', '::', 'DELETED', ']', ')', 'end', 'rescue', 'StandardError', '=>', 'e', 'Clacks', '.', 'logger', '.', 'error', '(', 'e', '.', 'message', ')', 'end', 'processed', '+=', '1', 'end', 'imap', '.', 'expunge', 'if', 'expunge', 'end', 'while', 'uids', '.', 'any?', '&&', 'processed', '==', 'uids', '.', 'length', 'end']
->Original Target:
['Keep', 'processing', 'emails', 'until', 'nothing', 'is', 'found', 'anymore', 'or', 'until', 'a', 'QUIT', 'signal', 'is', 'received', 'to', 'stop', 'the', 'process', '.']
->Reconstructed Target:
Keep processing emails until nothing is found anymore or until a QUIT signal is received to stop the process.
->Reconstructed Predication:
() { | uid |uid.. uid_store ( uid,). uid_store ( uid,). uid_store ( uid,). uid_store ( uid,) if.( uid.). uid_store ( uid,) if. uid_store ( uid,) if.( uid.). uid_store ( uid,
->Raw Input:
summarize:def imap_find ( imap ) options = Clacks. config [ :find_options ] delete_after_find = options [ :delete_after_find ] begin break if stopping? uids = imap. uid_search ( options [ :keys ] || 'ALL' ) uids. reverse! if options [ :what ]. to_sym == :last uids = uids. first ( options [ :count ] ) if options [ :count ]. is_a? ( Integer ) uids. reverse! if ( options [ :what ]. to_sym == :last && options [ :order ]. to_sym == :asc ) || ( options [ :what ]. to_sym!= :last && options [ :order ]. to_sym == :desc ) processed = 0 expunge = false uids. each do | uid | break if stopping? source = imap. uid_fetch ( uid, [ 'RFC822' ] ). first. attr [ 'RFC822' ] mail = nil begin mail = Mail. new ( source ) mail. mark_for_delete = true if delete_after_find Clacks. config [ :on_mail ]. call ( mail ) rescue StandardError => e Clacks. logger. error ( e. message ) Clacks. logger. error ( e. backtrace ) end begin imap. uid_copy ( uid, options [ :archivebox ] ) if options [ :archivebox ] if delete_after_find && ( mail. nil? || mail. is_marked_for_delete? ) expunge = true imap. uid_store ( uid, "+FLAGS", [ Net :: IMAP :: DELETED ] ) end rescue StandardError => e Clacks. logger. error ( e. message ) end processed += 1 end imap. expunge if expunge end while uids. any? && processed == uids. length end
->Raw Target:
Keep processing emails until nothing is found anymore or until a QUIT signal is received to stop the process.
--

993=========
->Original Input:
['def', 'rainbow', '(', 'str', ')', 'i', '=', '0', 'ret', '=', "''", 'str', '=', 'str', '.', 'to_s', 'while', '(', 'i', '<', 'str', '.', 'length', ')', 'ch', '=', 'str', '[', 'i', ']', 'palette', '=', '$color_db', '[', '0', ']', '[', 'i', '%', '$color_db', '[', '0', ']', '.', 'length', ']', 'ret', '<<', '(', 'colora', '(', 'palette', ',', 'str', '[', 'i', ',', '1', ']', ')', ')', 'i', '+=', '1', 'end', 'ret', 'end']
->Original Target:
['carattere', 'per', 'carattere', '...']
->Reconstructed Target:
carattere per carattere...
->Reconstructed Predication:
the color of a string
->Raw Input:
summarize:def rainbow ( str ) i = 0 ret = '' str = str. to_s while ( i < str. length ) ch = str [ i ] palette = $color_db [ 0 ] [ i % $color_db [ 0 ]. length ] ret << ( colora ( palette, str [ i, 1 ] ) ) i += 1 end ret end
->Raw Target:
carattere per carattere...
--

994=========
->Original Input:
['def', 'large_enough_prime', '(', 'input', ')', 'standard_primes', '.', 'each', 'do', '|', 'prime', '|', 'return', 'prime', 'if', 'prime', '>', 'input', 'end', 'fail', 'CannotFindLargeEnoughPrime', ',', '"Input too large"', 'end']
->Original Target:
['Retrieves', 'the', 'next', 'largest', 'prime', 'for', 'the', 'largest', 'number', 'in', 'batch']
->Reconstructed Target:
Retrieves the next largest prime for the largest number in batch
->Reconstructed Predication:
the large enough prime
->Raw Input:
summarize:def large_enough_prime ( input ) standard_primes. each do | prime | return prime if prime > input end fail CannotFindLargeEnoughPrime, "Input too large" end
->Raw Target:
Retrieves the next largest prime for the largest number in batch
--

995=========
->Original Input:
['def', 'enhance_content', '(', 'value', ',', 'separator', '=', "', '", ')', 'value', '.', 'is_a?', '(', 'Array', ')', '?', 'value', '.', 'join', '(', 'separator', ')', ':', 'value', 'end']
->Original Target:
['Combines', 'array', 'into', 'a', 'string', 'with', 'given', 'separator']
->Reconstructed Target:
Combines array into a string with given separator
->Reconstructed Predication:
the content of the content
->Raw Input:
summarize:def enhance_content ( value, separator = ',') value. is_a? ( Array )? value. join ( separator ) : value end
->Raw Target:
Combines array into a string with given separator
--

996=========
->Original Input:
['def', 'i_to_s', '(', 'input', ')', 'if', '!', 'input', '.', 'is_a?', '(', 'Integer', ')', '||', 'input', '<', '0', 'fail', 'NotPositiveInteger', ',', '"input must be a non-negative integer"', 'end', 'output', '=', '""', 'while', 'input', '>', '0', 'input', ',', 'codepoint', '=', 'input', '.', 'divmod', '(', 'charset', '.', 'length', ')', 'output', '.', 'prepend', '(', 'codepoint_to_char', '(', 'codepoint', ')', ')', 'end', 'output', 'end']
->Original Target:
['The', 'null', '-', 'byte', 'character', 'is', 'prepended', 'to', 'be', 'the', 'first', 'character', 'in', 'the', 'charset', 'to', 'avoid', 'loosing', 'the', 'first', 'character', 'of', 'the', 'charset', 'when', 'it', 'is', 'also', 'the', 'first', 'character', 'in', 'a', 'string', 'to', 'convert', '.']
->Reconstructed Target:
The null - byte character is prepended to be the first character in the charset to avoid loosing the first character of the charset when it is also the first character in a string to convert.
->Reconstructed Predication:
the string to a string
->Raw Input:
summarize:def i_to_s ( input ) if! input. is_a? ( Integer ) || input < 0 fail NotPositiveInteger, "input must be a non-negative integer" end output = "" while input > 0 input, codepoint = input. divmod ( charset. length ) output. prepend ( codepoint_to_char ( codepoint ) ) end output end
->Raw Target:
The null - byte character is prepended to be the first character in the charset to avoid loosing the first character of the charset when it is also the first character in a string to convert.
--

997=========
->Original Input:
['def', 's_to_i', '(', 'string', ')', 'string', '.', 'chars', '.', 'reduce', '(', '0', ')', 'do', '|', 'output', ',', 'char', '|', 'output', '*', 'charset', '.', 'length', '+', 'char_to_codepoint', '(', 'char', ')', 'end', 'end']
->Original Target:
['Calculate', 'an', 'integer', 'from', 'a', 'string', '.']
->Reconstructed Target:
Calculate an integer from a string.
->Reconstructed Predication:
return the string
->Raw Input:
summarize:def s_to_i ( string ) string. chars. reduce ( 0 ) do | output, char | output * charset. length + char_to_codepoint ( char ) end end
->Raw Target:
Calculate an integer from a string.
--

998=========
->Original Input:
['def', 'char_to_codepoint', '(', 'c', ')', 'codepoint', '=', 'charset', '.', 'index', 'c', 'if', 'codepoint', '.', 'nil?', 'fail', 'NotInCharset', ',', '"Char \\"#{c}\\" not part of the supported charset"', 'end', 'codepoint', 'end']
->Original Target:
['Convert', 'a', 'single', 'character', 'into', 'its', 'integer', 'representation', 'according', 'to', 'the', 'charset', '.']
->Reconstructed Target:
Convert a single character into its integer representation according to the charset.
->Reconstructed Predication:
the codepoint of the given
->Raw Input:
summarize:def char_to_codepoint ( c ) codepoint = charset. index c if codepoint. nil? fail NotInCharset, "Char \"#{c}\" not part of the supported charset" end codepoint end
->Raw Target:
Convert a single character into its integer representation according to the charset.
--

999=========
->Original Input:
['def', 'subset?', '(', 'string', ')', '(', 'Set', '.', 'new', '(', 'string', '.', 'chars', ')', '-', 'Set', '.', 'new', '(', 'charset', ')', ')', '.', 'empty?', 'end']
->Original Target:
['Check', 'if', 'the', 'provided', 'string', 'can', 'be', 'represented', 'by', 'the', 'charset', '.']
->Reconstructed Target:
Check if the provided string can be represented by the charset.
->Reconstructed Predication:
return string if string is empty
->Raw Input:
summarize:def subset? ( string ) ( Set. new ( string. chars ) - Set. new ( charset ) ). empty? end
->Raw Target:
Check if the provided string can be represented by the charset.
--

1000=========
->Original Input:
['def', 'points', '(', 'num_points', ',', 'prime', ')', 'intercept', '=', '@coefficients', '[', '0', ']', '(', '1', '..', 'num_points', ')', '.', 'map', 'do', '|', 'x', '|', 'y', '=', 'intercept', '(', '1', '...', '@coefficients', '.', 'length', ')', '.', 'each', 'do', '|', 'i', '|', 'y', '=', '(', 'y', '+', '@coefficients', '[', 'i', ']', '*', 'x', '**', 'i', ')', '%', 'prime', 'end', 'Point', '.', 'new', '(', 'x', ',', 'y', ')', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'instance', 'of', 'a', 'Polynomial', 'with', 'n', 'coefficients', 'when', 'having', 'the', 'polynomial', 'in', 'standard', 'polynomial', 'form', '.']
->Reconstructed Target:
Create a new instance of a Polynomial with n coefficients when having the polynomial in standard polynomial form.
->Reconstructed Predication:
the point of the point
->Raw Input:
summarize:def points ( num_points, prime ) intercept = @coefficients [ 0 ] ( 1.. num_points ). map do | x | y = intercept ( 1... @coefficients. length ). each do | i | y = ( y + @coefficients [ i ] * x ** i ) % prime end Point. new ( x, y ) end end
->Raw Target:
Create a new instance of a Polynomial with n coefficients when having the polynomial in standard polynomial form.
--

1001=========
->Original Input:
['def', 'validate!', 'files', '=', 'Dir', '.', 'glob', '(', 'File', '.', 'join', '(', '@directory', ',', "'*.xml'", ')', ')', '.', 'sort', 'threads', '=', '[', ']', 'files', '.', 'map', 'do', '|', 'path', '|', 'threads', '<<', 'Thread', '.', 'new', '(', 'path', ')', 'do', '|', 'path_t', '|', 'eadid', '=', 'File', '.', 'basename', '(', 'path_t', ',', "'.xml'", ')', 'begin', 'ead', '=', 'Mead', '::', 'Ead', '.', 'new', '(', '{', ':file', '=>', 'File', '.', 'open', '(', 'path_t', ')', ',', ':eadid', '=>', 'eadid', '}', ')', 'rescue', '=>', 'e', 'record_invalid', '(', 'eadid', ',', 'ead', ',', 'e', ')', 'next', 'end', 'if', 'ead', '.', 'valid?', '@valid', '<<', 'eadid', 'else', 'record_invalid', '(', 'eadid', ',', 'ead', ')', 'end', 'end', 'end', 'threads', '.', 'each', '{', '|', 'thread', '|', 'thread', '.', 'join', '}', 'metadata', 'end']
->Original Target:
['Creates', 'a', 'new', 'EadValidator', 'when', 'given', 'the', 'path', 'to', 'a', 'directory', 'as', 'a', 'String']
->Reconstructed Target:
Creates a new EadValidator when given the path to a directory as a String
->Reconstructed Predication:
metadata metadata
->Raw Input:
summarize:def validate! files = Dir. glob ( File. join ( @directory, '*.xml' ) ). sort threads = [ ] files. map do | path | threads << Thread. new ( path ) do | path_t | eadid = File. basename ( path_t, '.xml' ) begin ead = Mead :: Ead. new ( { :file => File. open ( path_t ), :eadid => eadid } ) rescue => e record_invalid ( eadid, ead, e ) next end if ead. valid? @valid << eadid else record_invalid ( eadid, ead ) end end end threads. each { | thread | thread. join } metadata end
->Raw Target:
Creates a new EadValidator when given the path to a directory as a String
--

1002=========
->Original Input:
['def', 'notify_create', 'self', '.', 'ChannelPublications', '.', 'each', 'do', '|', 'publication', ',', 'options', '|', 'if', 'options', '[', ':actions', ']', '.', 'include?', ':create', 'records', '=', 'self', '.', 'class', '.', 'scoped_collection', '(', 'options', '[', ':scope', ']', ')', 'if', 'options', '[', ':scope', ']', '==', ':all', 'or', 'record_within_scope', '(', 'records', ')', 'ActionCable', '.', 'server', '.', 'broadcast', 'publication', ',', 'msg', ':', "'create'", ',', 'id', ':', 'self', '.', 'id', ',', 'data', ':', 'self', 'end', 'end', 'end', 'end']
->Original Target:
['Broadcast', 'notifications', 'when', 'a', 'new', 'record', 'is', 'created']
->Reconstructed Target:
Broadcast notifications when a new record is created
->Reconstructed Predication:
the channel to create a newthe publication to create the
->Raw Input:
summarize:def notify_create self. ChannelPublications. each do | publication, options | if options [ :actions ]. include? :create records = self. class. scoped_collection ( options [ :scope ] ) if options [ :scope ] == :all or record_within_scope ( records ) ActionCable. server. broadcast publication, msg : 'create', id : self. id, data : self end end end end
->Raw Target:
Broadcast notifications when a new record is created
--

1003=========
->Original Input:
['def', 'notify_update', 'if', 'self', '.', 'respond_to?', '(', ':saved_changes', ')', 'changes', '=', 'self', '.', 'saved_changes', '.', 'transform_values', '(', '&', ':second', ')', 'else', 'changes', '=', 'self', '.', 'changes', '.', 'transform_values', '(', '&', ':second', ')', 'end', 'if', '!', 'changes', '.', 'empty?', 'self', '.', 'ChannelPublications', '.', 'each', 'do', '|', 'publication', ',', 'options', '|', 'if', 'options', '[', ':actions', ']', '.', 'include?', ':update', 'record', '=', 'record_within_scope', '(', 'options', '[', ':records', ']', ')', 'was_in_scope', '=', 'record', '.', 'present?', 'options', '[', ':records', ']', '.', 'delete', '(', 'record', ')', 'if', 'was_in_scope', 'if', 'options', '[', ':track_scope_changes', ']', '==', 'true', 'is_in_scope', '=', 'false', 'if', 'options', '[', ':scope', ']', '==', ':all', 'record', '=', 'self', 'is_in_scope', '=', 'true', 'else', 'record', '=', 'record_within_scope', '(', 'self', '.', 'class', '.', 'scoped_collection', '(', 'options', '[', ':scope', ']', ')', ')', 'if', 'record', '.', 'present?', 'is_in_scope', '=', 'true', 'end', 'end', 'else', 'is_in_scope', '=', 'was_in_scope', 'end', 'if', 'is_in_scope', 'if', 'was_in_scope', 'changes', '.', 'select!', '{', '|', 'k', ',', 'v', '|', 'record', '.', 'respond_to?', '(', 'k', ')', '}', 'if', '!', 'changes', '.', 'empty?', 'ActionCable', '.', 'server', '.', 'broadcast', 'publication', ',', 'msg', ':', "'update'", ',', 'id', ':', 'self', '.', 'id', ',', 'data', ':', 'changes', 'end', 'else', 'ActionCable', '.', 'server', '.', 'broadcast', 'publication', ',', 'msg', ':', "'create'", ',', 'id', ':', 'record', '.', 'id', ',', 'data', ':', 'record', 'end', 'elsif', 'was_in_scope', 'ActionCable', '.', 'server', '.', 'broadcast', 'publication', ',', 'msg', ':', "'destroy'", ',', 'id', ':', 'self', '.', 'id', 'end', 'end', 'end', 'end', 'end']
->Original Target:
['Broadcast', 'notifications', 'when', 'a', 'record', 'is', 'updated', '.', 'Only', 'changed', 'fields', 'will', 'be', 'sent', 'if', 'they', 'are', 'within', 'configured', 'scope']
->Reconstructed Target:
Broadcast notifications when a record is updated. Only changed fields will be sent if they are within configured scope
->Reconstructed Predication:
:id,:id, data : changes:id, data : changes:id, data : changes:id, data : changes:id,:id,:id,:id, data : changes:id,:id,:id,:id, data : changes:id,:id,:id,:id,: id,: id,: id,
->Raw Input:
summarize:def notify_update if self. respond_to? ( :saved_changes ) changes = self. saved_changes. transform_values ( & :second ) else changes = self. changes. transform_values ( & :second ) end if! changes. empty? self. ChannelPublications. each do | publication, options | if options [ :actions ]. include? :update record = record_within_scope ( options [ :records ] ) was_in_scope = record. present? options [ :records ]. delete ( record ) if was_in_scope if options [ :track_scope_changes ] == true is_in_scope = false if options [ :scope ] == :all record = self is_in_scope = true else record = record_within_scope ( self. class. scoped_collection ( options [ :scope ] ) ) if record. present? is_in_scope = true end end else is_in_scope = was_in_scope end if is_in_scope if was_in_scope changes. select! { | k, v | record. respond_to? ( k ) } if! changes. empty? ActionCable. server. broadcast publication, msg : 'update', id : self. id, data : changes end else ActionCable. server. broadcast publication, msg : 'create', id : record. id, data : record end elsif was_in_scope ActionCable. server. broadcast publication, msg : 'destroy', id : self. id end end end end end
->Raw Target:
Broadcast notifications when a record is updated. Only changed fields will be sent if they are within configured scope
--

1004=========
->Original Input:
['def', 'notify_destroy', 'self', '.', 'ChannelPublications', '.', 'each', 'do', '|', 'publication', ',', 'options', '|', 'if', 'options', '[', ':scope', ']', '==', ':all', 'or', 'options', '[', ':actions', ']', '.', 'include?', ':destroy', 'if', 'options', '[', ':scope', ']', '==', ':all', 'or', 'record_within_scope', '(', 'self', '.', 'class', '.', 'scoped_collection', '(', 'options', '[', ':scope', ']', ')', ')', '.', 'present?', 'ActionCable', '.', 'server', '.', 'broadcast', 'publication', ',', 'msg', ':', "'destroy'", ',', 'id', ':', 'self', '.', 'id', 'end', 'end', 'end', 'end']
->Original Target:
['Broadcast', 'notifications', 'when', 'a', 'record', 'is', 'destroyed', '.']
->Reconstructed Target:
Broadcast notifications when a record is destroyed.
->Reconstructed Predication:
the channel to be destroyed
->Raw Input:
summarize:def notify_destroy self. ChannelPublications. each do | publication, options | if options [ :scope ] == :all or options [ :actions ]. include? :destroy if options [ :scope ] == :all or record_within_scope ( self. class. scoped_collection ( options [ :scope ] ) ). present? ActionCable. server. broadcast publication, msg : 'destroy', id : self. id end end end end
->Raw Target:
Broadcast notifications when a record is destroyed.
--

1005=========
->Original Input:
['def', 'logger', '(', 'obj', ')', '%w(', 'debug', 'info', 'warn', 'error', 'fatal', 'level', ')', '.', 'each', 'do', '|', 'm', '|', 'next', 'if', 'obj', '.', 'respond_to?', '(', 'm', ')', 'raise', 'ArgumentError', ',', '"logger #{obj} does not respond to method #{m}"', 'end', 'map', '[', ':logger', ']', '=', 'obj', 'end']
->Original Target:
['Sets', 'the', 'Logger', '-', 'like', 'object', '.', 'The', 'default', 'Logger', 'will', 'log', 'its', 'output', 'to', 'Rails', '.', 'logger', 'if', 'you', 're', 'running', 'within', 'a', 'rails', 'environment', 'otherwise', 'it', 'will', 'output', 'to', 'the', 'path', 'specified', 'by', '+', 'stdout_path', '+', '.']
->Reconstructed Target:
Sets the Logger - like object. The default Logger will log its output to Rails. logger if you re running within a rails environment otherwise it will output to the path specified by + stdout_path +.
->Reconstructed Predication:
logger logger objectlogger object
->Raw Input:
summarize:def logger ( obj ) %w( debug info warn error fatal level ). each do | m | next if obj. respond_to? ( m ) raise ArgumentError, "logger #{obj} does not respond to method #{m}" end map [ :logger ] = obj end
->Raw Target:
Sets the Logger - like object. The default Logger will log its output to Rails. logger if you re running within a rails environment otherwise it will output to the path specified by + stdout_path +.
--

1006=========
->Original Input:
['def', 'fetch_rates', 'if', 'self', '.', 'class', '.', 'superclass', '.', 'eql?', '(', 'Object', ')', 'raise', 'Exception', '.', 'new', '(', '"This method should be invoked from CurrencySpy::Scraper sub class"', ')', 'else', 'check_currency_code_validity', 'rate_results', '=', '{', '}', 'RATE_DATA', '.', 'each', 'do', '|', 'rate', '|', 'symbol', '=', 'rate', '.', 'to_sym', 'if', 'self', '.', 'class', '.', 'instance_methods', '.', 'include?', '(', 'symbol', ')', 'value', '=', 'self', '.', 'send', '(', 'symbol', ')', 'rate_results', '[', 'symbol', ']', '=', 'value', 'unless', 'value', '.', 'nil?', 'end', 'end', 'rate_results', 'end', 'end']
->Original Target:
['Method', 'which', 'calls', 'all', 'rate', 'fetching', 'methods', 'from', 'the', 'sub', 'class', 'and', 'returns', 'a', 'Hash', 'with', 'appropriate', 'values', '.']
->Reconstructed Target:
Method which calls all rate fetching methods from the sub class and returns a Hash with appropriate values.
->Reconstructed Predication:
the rate of the current
->Raw Input:
summarize:def fetch_rates if self. class. superclass. eql? ( Object ) raise Exception. new ( "This method should be invoked from CurrencySpy::Scraper sub class" ) else check_currency_code_validity rate_results = { } RATE_DATA. each do | rate | symbol = rate. to_sym if self. class. instance_methods. include? ( symbol ) value = self. send ( symbol ) rate_results [ symbol ] = value unless value. nil? end end rate_results end end
->Raw Target:
Method which calls all rate fetching methods from the sub class and returns a Hash with appropriate values.
--

1007=========
->Original Input:
['def', 'parse', '(', 'target', ')', 'if', '(', 'width', '=', 'fmt', '.', 'width', ')', '>', '0', 'head', ',', 'tail', '=', 'src', '[', '0', '...', 'width', ']', ',', 'src', '[', 'width', '..', '-', '1', ']', '||', '""', 'else', 'head', ',', 'tail', '=', 'src', ',', '""', 'end', '@prematch', ',', '@match', ',', '@postmatch', '=', 'head', '.', 'partition', '(', 'target', ')', 'if', 'found?', '@src', '=', '@postmatch', '+', 'tail', '@match', 'else', 'nil', 'end', 'end']
->Original Target:
['Parse', 'the', 'source', 'string', 'for', 'a', 'target', 'string', 'or', 'regex', 'or', 'return', 'nil', '.']
->Reconstructed Target:
Parse the source string for a target string or regex or return nil.
->Reconstructed Predication:
the source string to parsethe target string to parse.
->Raw Input:
summarize:def parse ( target ) if ( width = fmt. width ) > 0 head, tail = src [ 0... width ], src [ width.. - 1 ] || "" else head, tail = src, "" end @prematch, @match, @postmatch = head. partition ( target ) if found? @src = @postmatch + tail @match else nil end end
->Raw Target:
Parse the source string for a target string or regex or return nil.
--

1008=========
->Original Input:
['def', 'grab', 'width', '=', 'fmt', '.', 'width', 'if', 'width', '>', '0', 'result', ',', '@src', '=', 'src', '[', '0', '...', 'width', ']', ',', 'src', '[', 'width', '..', '-', '1', ']', '||', '""', 'elsif', 'width', '==', '0', 'result', ',', '@src', '=', 'src', '[', '0', '...', '1', ']', ',', 'src', '[', '1', '..', '-', '1', ']', '||', '""', 'elsif', 'width', '==', '-', '1', 'result', ',', '@src', '=', 'src', ',', '""', 'else', 'result', ',', '@src', '=', 'src', '[', '0', '..', 'width', ']', ',', 'src', '[', '(', 'width', '+', '1', ')', '..', '-', '1', ']', '||', '""', 'end', 'result', 'end']
->Original Target:
['Grab', 'some', 'text']
->Reconstructed Target:
Grab some text
->Reconstructed Predication:
+ 1 ++ 1 + 1 +
->Raw Input:
summarize:def grab width = fmt. width if width > 0 result, @src = src [ 0... width ], src [ width.. - 1 ] || "" elsif width == 0 result, @src = src [ 0... 1 ], src [ 1.. - 1 ] || "" elsif width == - 1 result, @src = src, "" else result, @src = src [ 0.. width ], src [ ( width + 1 ).. - 1 ] || "" end result end
->Raw Target:
Grab some text
--

1009=========
->Original Input:
['def', 'get_comments', '(', 'bugs', ')', 'params', '=', '{', '}', 'params', '[', "'ids'", ']', '=', 'case', 'bugs', 'when', 'Array', 'bugs', 'when', 'Integer', '||', 'String', '[', 'bugs', ']', 'else', 'raise', 'ArgumentError', ',', 'format', '(', "'Unknown type of arguments: %s'", ',', 'bugs', '.', 'class', ')', 'end', 'result', '=', 'comments', '(', 'params', ')', 'ret', '=', 'result', '[', "'bugs'", ']', 'unless', 'check_version', '(', '4.4', ')', '[', '0', ']', 'ret', '.', 'each', 'do', '|', '_id', ',', 'o', '|', 'o', '[', "'comments'", ']', '.', 'each', 'do', '|', 'c', '|', 'c', '[', "'creation_time'", ']', '=', 'c', '[', "'time'", ']', 'unless', 'c', '.', 'include?', '(', "'creation_time'", ')', 'end', 'end', 'end', 'ret', 'end']
->Original Target:
['def', 'get_bugs', 'rdoc']
->Reconstructed Target:
def get_bugs rdoc
->Reconstructed Predication:
the comments for the giventhe comments for the giventhe comments for the giventhe comments for the giventhe comments for the given
->Raw Input:
summarize:def get_comments ( bugs ) params = { } params [ 'ids' ] = case bugs when Array bugs when Integer || String [ bugs ] else raise ArgumentError, format ( 'Unknown type of arguments: %s', bugs. class ) end result = comments ( params ) ret = result [ 'bugs' ] unless check_version ( 4.4 ) [ 0 ] ret. each do | _id, o | o [ 'comments' ]. each do | c | c [ 'creation_time' ] = c [ 'time' ] unless c. include? ( 'creation_time' ) end end end ret end
->Raw Target:
def get_bugs rdoc
--

1010=========
->Original Input:
['def', 'save_persist_state', 'return', 'unless', '@persist_file', 'new_persist_options', '=', '{', '}', 'BaseWorker', '.', 'worker_classes', '.', 'each', 'do', '|', 'worker_class', '|', 'worker_class', '.', 'each_config', '(', '@adapter_factory', '.', 'worker_config_class', ')', 'do', '|', 'config_name', ',', 'ignored_extended_worker_config_class', ',', 'default_options', '|', 'static_options', '=', 'default_options', '.', 'merge', '(', '@worker_options', '[', 'config_name', ']', '||', '{', '}', ')', 'worker_config', '=', 'self', '[', 'config_name', ']', 'hash', '=', '{', '}', 'worker_config', '.', 'bean_get_attributes', 'do', '|', 'attribute_info', '|', 'if', 'attribute_info', '.', 'attribute', '[', ':config_item', ']', '&&', 'attribute_info', '.', 'ancestry', '.', 'size', '==', '1', 'param_name', '=', 'attribute_info', '.', 'ancestry', '[', '0', ']', '.', 'to_sym', 'value', '=', 'attribute_info', '.', 'value', 'hash', '[', 'param_name', ']', '=', 'value', 'if', 'static_options', '[', 'param_name', ']', '!=', 'value', 'end', 'end', 'new_persist_options', '[', 'config_name', ']', '=', 'hash', 'unless', 'hash', '.', 'empty?', 'end', 'end', 'if', 'new_persist_options', '!=', '@persist_options', '@persist_options', '=', 'new_persist_options', 'File', '.', 'open', '(', '@persist_file', ',', "'w'", ')', 'do', '|', 'out', '|', 'YAML', '.', 'dump', '(', '@persist_options', ',', 'out', ')', 'end', 'end', 'end']
->Original Target:
['Store', 'off', 'any', 'options', 'that', 'are', 'no', 'longer', 'set', 'to', 'default']
->Reconstructed Target:
Store off any options that are no longer set to default
->Reconstructed Predication:
@persist_file = File. open@persist_file, 'w' )@persist_options = YAML. dump (@persist_options = YAML. dump (
->Raw Input:
summarize:def save_persist_state return unless @persist_file new_persist_options = { } BaseWorker. worker_classes. each do | worker_class | worker_class. each_config ( @adapter_factory. worker_config_class ) do | config_name, ignored_extended_worker_config_class, default_options | static_options = default_options. merge ( @worker_options [ config_name ] || { } ) worker_config = self [ config_name ] hash = { } worker_config. bean_get_attributes do | attribute_info | if attribute_info. attribute [ :config_item ] && attribute_info. ancestry. size == 1 param_name = attribute_info. ancestry [ 0 ]. to_sym value = attribute_info. value hash [ param_name ] = value if static_options [ param_name ]!= value end end new_persist_options [ config_name ] = hash unless hash. empty? end end if new_persist_options!= @persist_options @persist_options = new_persist_options File. open ( @persist_file, 'w' ) do | out | YAML. dump ( @persist_options, out ) end end end
->Raw Target:
Store off any options that are no longer set to default
--

1011=========
->Original Input:
['def', 'read_pages', 'results_projects', '=', 'database', '.', 'query', '(', '"SELECT id, identifier, name FROM projects;"', ')', 'results_projects', '.', 'each', 'do', '|', 'row_project', '|', 'namespaces', '<<', 'OpenStruct', '.', 'new', '(', 'identifier', ':', 'row_project', '[', '"identifier"', ']', ',', 'name', ':', 'row_project', '[', '"name"', ']', ')', 'end', 'results_wikis', '=', 'database', '.', 'query', '(', '"SELECT id, project_id FROM wikis;"', ')', 'results_pages', '=', 'database', '.', 'query', '(', '"SELECT id, title, wiki_id FROM wiki_pages;"', ')', 'results_pages', '.', 'each', 'do', '|', 'row_page', '|', 'results_contents', '=', 'database', '.', 'query', '(', '"SELECT * FROM wiki_content_versions WHERE page_id=\'#{row_page["id"]}\' ORDER BY updated_on;"', ')', 'wiki_row', '=', 'nil', 'project_row', '=', 'nil', 'results_wikis', '.', 'each', 'do', '|', 'wiki', '|', 'wiki_row', '=', 'wiki', 'if', 'wiki', '[', '"id"', ']', '==', 'row_page', '[', '"wiki_id"', ']', 'end', 'if', 'wiki_row', 'results_projects', '.', 'each', 'do', '|', 'project', '|', 'project_row', '=', 'project', 'if', 'project', '[', '"id"', ']', '==', 'wiki_row', '[', '"project_id"', ']', 'end', 'end', 'project_identifier', '=', 'project_row', '?', 'project_row', '[', '"identifier"', ']', '+', "'/'", ':', '""', 'title', '=', 'project_identifier', '+', 'row_page', '[', '"title"', ']', 'titles', '<<', 'title', '@latest_revisions', '=', '{', '}', 'results_contents', '.', 'each', 'do', '|', 'row_content', '|', 'author', '=', 'authors', '[', 'row_content', '[', '"author_id"', ']', ']', '?', '@authors', '[', 'row_content', '[', '"author_id"', ']', ']', ':', 'nil', 'page', '=', 'Page', '.', 'new', '(', '{', ':id', '=>', 'row_content', '[', '"id"', ']', ',', ':title', '=>', 'title', ',', ':body', '=>', 'row_content', '[', '"data"', ']', ',', ':markup', '=>', ':textile', ',', ':latest', '=>', 'false', ',', ':time', '=>', 'row_content', '[', '"updated_on"', ']', ',', ':message', '=>', 'row_content', '[', '"comments"', ']', ',', ':author', '=>', 'author', ',', ':author_name', '=>', 'author', '.', 'name', '}', ')', 'revisions', '<<', 'page', '@latest_revisions', '[', 'title', ']', '=', 'page', 'end', 'end', 'titles', '.', 'uniq!', '@latest_revisions', '.', 'each', '{', '|', 'rev', '|', 'rev', '[', '1', ']', '.', 'set_latest', '}', 'revisions', '.', 'sort!', '{', '|', 'a', ',', 'b', '|', 'a', '.', 'time', '<=>', 'b', '.', 'time', '}', 'revisions', 'end']
->Original Target:
['after', 'calling', 'this', 'action', 'I', 'expect', 'the', 'titles', 'and', 'revisions', 'to', 'be', 'filled']
->Reconstructed Target:
after calling this action I expect the titles and revisions to be filled
->Reconstructed Predication:
(). each do | row_content]. set_latest.. each { |. time }. each { |. time }. time }. each { |. time }. time }. time }. time }. time }. time }. time }. time }. time }. time }. time }. time }. time
->Raw Input:
summarize:def read_pages results_projects = database. query ( "SELECT id, identifier, name FROM projects;" ) results_projects. each do | row_project | namespaces << OpenStruct. new ( identifier : row_project [ "identifier" ], name : row_project [ "name" ] ) end results_wikis = database. query ( "SELECT id, project_id FROM wikis;" ) results_pages = database. query ( "SELECT id, title, wiki_id FROM wiki_pages;" ) results_pages. each do | row_page | results_contents = database. query ( "SELECT * FROM wiki_content_versions WHERE page_id='#{row_page["id"]}' ORDER BY updated_on;" ) wiki_row = nil project_row = nil results_wikis. each do | wiki | wiki_row = wiki if wiki [ "id" ] == row_page [ "wiki_id" ] end if wiki_row results_projects. each do | project | project_row = project if project [ "id" ] == wiki_row [ "project_id" ] end end project_identifier = project_row? project_row [ "identifier" ] + '/' : "" title = project_identifier + row_page [ "title" ] titles << title @latest_revisions = { } results_contents. each do | row_content | author = authors [ row_content [ "author_id" ] ]? @authors [ row_content [ "author_id" ] ] : nil page = Page. new ( { :id => row_content [ "id" ], :title => title, :body => row_content [ "data" ], :markup => :textile, :latest => false, :time => row_content [ "updated_on" ], :message => row_content [ "comments" ], :author => author, :author_name => author. name } ) revisions << page @latest_revisions [ title ] = page end end titles. uniq! @latest_revisions. each { | rev | rev [ 1 ]. set_latest } revisions. sort! { | a, b | a. time <=> b. time } revisions end
->Raw Target:
after calling this action I expect the titles and revisions to be filled
--

1012=========
->Original Input:
['def', 'read_response', '(', 'timeout', ',', '&', 'block', ')', 'raise', '"Invalid call to read_response for #{@producer}, not setup for responding"', 'unless', '@producer', '.', 'response_options', '@producer', '.', 'impl', '.', 'with_response', '(', '@adapter_info', ')', 'do', '|', 'consumer', '|', 'if', 'block_given?', 'return', 'read_multiple_response', '(', 'consumer', ',', 'timeout', ',', '&', 'block', ')', 'else', 'tri', '=', 'read_single_response', '(', 'consumer', ',', 'timeout', ')', 'if', 'tri', 'response', '=', 'tri', '[', '1', ']', 'raise', 'response', 'if', 'response', '.', 'kind_of?', '(', 'Qwirk', '::', 'RemoteException', ')', 'return', 'response', 'else', '@timeout', '=', '!', 'tri', 'return', 'nil', 'end', 'end', 'end', 'end']
->Original Target:
['Waits', 'the', 'given', 'timeout', 'for', 'a', 'response', 'message', 'on', 'the', 'queue', '.']
->Reconstructed Target:
Waits the given timeout for a response message on the queue.
->Reconstructed Predication:
the response for the given
->Raw Input:
summarize:def read_response ( timeout, & block ) raise "Invalid call to read_response for #{@producer}, not setup for responding" unless @producer. response_options @producer. impl. with_response ( @adapter_info ) do | consumer | if block_given? return read_multiple_response ( consumer, timeout, & block ) else tri = read_single_response ( consumer, timeout ) if tri response = tri [ 1 ] raise response if response. kind_of? ( Qwirk :: RemoteException ) return response else @timeout =! tri return nil end end end end
->Raw Target:
Waits the given timeout for a response message on the queue.
--

1013=========
->Original Input:
['def', 'add_filter', '(', 'id', ',', 'pattern', ',', '&', 'block', ')', 'filter', '=', 'LineFilter', '.', 'new', '(', 'id', ',', 'pattern', ',', 'block', ')', '@filters', '<<', 'filter', 'end']
->Original Target:
['if', 'a', 'line', 'doesn', 't', 'match', 'any', 'of', 'the', 'patterns', 'then']
->Reconstructed Target:
if a line doesn t match any of the patterns then
->Reconstructed Predication:
the filter to be added to
->Raw Input:
summarize:def add_filter ( id, pattern, & block ) filter = LineFilter. new ( id, pattern, block ) @filters << filter end
->Raw Target:
if a line doesn t match any of the patterns then
--

1014=========
->Original Input:
['def', 'write', '(', 'template', '=', 'nil', ')', 'if', 'not', 'template', '.', 'nil?', 'then', 'template', '=', 'template', '.', 'to_mixml_template', 'end', 'each_node', 'do', '|', 'node', '|', 'if', 'template', '.', 'nil?', 'then', 'node', '.', 'write_xml_to', '(', '$stdout', ')', 'puts', 'else', 'puts', 'template', '.', 'evaluate', '(', 'node', ')', 'end', 'end', 'end']
->Original Target:
['Print', 'selected', 'nodes', 'to', 'stdout']
->Reconstructed Target:
Print selected nodes to stdout
->Reconstructed Predication:
the template to be written to
->Raw Input:
summarize:def write ( template = nil ) if not template. nil? then template = template. to_mixml_template end each_node do | node | if template. nil? then node. write_xml_to ( $stdout ) puts else puts template. evaluate ( node ) end end end
->Raw Target:
Print selected nodes to stdout
--

1015=========
->Original Input:
['def', 'replace', '(', 'template', ')', 'template', '=', 'template', '.', 'to_mixml_template', 'each_node', 'do', '|', 'node', '|', 'value', '=', 'template', '.', 'evaluate', '(', 'node', ')', 'node', '.', 'replace', '(', 'value', ')', 'end', 'end']
->Original Target:
['Replace', 'selected', 'nodes', 'with', 'a', 'template']
->Reconstructed Target:
Replace selected nodes with a template
->Reconstructed Predication:
template template template template template template
->Raw Input:
summarize:def replace ( template ) template = template. to_mixml_template each_node do | node | value = template. evaluate ( node ) node. replace ( value ) end end
->Raw Target:
Replace selected nodes with a template
--

1016=========
->Original Input:
['def', 'rename', '(', 'template', ')', 'template', '=', 'template', '.', 'to_mixml_template', 'each_node', 'do', '|', 'node', '|', 'value', '=', 'template', '.', 'evaluate', '(', 'node', ')', 'node', '.', 'name', '=', 'value', 'end', 'end']
->Original Target:
['Rename', 'selected', 'nodes', 'with', 'a', 'template']
->Reconstructed Target:
Rename selected nodes with a template
->Reconstructed Predication:
rename a node to a new
->Raw Input:
summarize:def rename ( template ) template = template. to_mixml_template each_node do | node | value = template. evaluate ( node ) node. name = value end end
->Raw Target:
Rename selected nodes with a template
--

1017=========
->Original Input:
['def', 'commit_revision', '(', 'page', ',', 'markup', ')', 'gollum_page', '=', 'gollum', '.', 'page', '(', 'page', '.', 'title', ')', 'if', 'gollum_page', 'gollum', '.', 'update_page', '(', 'gollum_page', ',', 'gollum_page', '.', 'name', ',', 'gollum_page', '.', 'format', ',', 'page', '.', 'body', ',', 'build_commit', '(', 'page', ')', ')', 'else', 'gollum', '.', 'write_page', '(', 'page', '.', 'title', ',', 'markup', ',', 'page', '.', 'body', ',', 'build_commit', '(', 'page', ')', ')', 'end', 'end']
->Original Target:
['Commit', 'the', 'given', 'page', 'into', 'the', 'gollum', '-', 'wiki', '-', 'repository', '.', 'Make', 'sure', 'the', 'target', 'markup', 'is', 'correct', 'before', 'calling', 'this', 'method', '.']
->Reconstructed Target:
Commit the given page into the gollum - wiki - repository. Make sure the target markup is correct before calling this method.
->Reconstructed Predication:
the page and the revision
->Raw Input:
summarize:def commit_revision ( page, markup ) gollum_page = gollum. page ( page. title ) if gollum_page gollum. update_page ( gollum_page, gollum_page. name, gollum_page. format, page. body, build_commit ( page ) ) else gollum. write_page ( page. title, markup, page. body, build_commit ( page ) ) end end
->Raw Target:
Commit the given page into the gollum - wiki - repository. Make sure the target markup is correct before calling this method.
--

1018=========
->Original Input:
['def', 'commit_history', '(', 'revisions', ',', 'options', '=', '{', '}', ',', '&', 'block', ')', 'options', '[', ':markup', ']', '=', ':markdown', 'if', '!', 'options', '[', ':markup', ']', 'revisions', '.', 'each_with_index', 'do', '|', 'page', ',', 'index', '|', 'block', '.', 'call', '(', 'page', ',', 'index', ')', 'if', 'block_given?', 'commit_revision', '(', 'page', ',', 'options', '[', ':markup', ']', ')', 'end', 'end']
->Original Target:
['Commit', 'all', 'revisions', 'of', 'the', 'given', 'history', 'into', 'this', 'gollum', '-', 'wiki', '-', 'repository', '.']
->Reconstructed Target:
Commit all revisions of the given history into this gollum - wiki - repository.
->Reconstructed Predication:
the revisions to the repository
->Raw Input:
summarize:def commit_history ( revisions, options = { }, & block ) options [ :markup ] = :markdown if! options [ :markup ] revisions. each_with_index do | page, index | block. call ( page, index ) if block_given? commit_revision ( page, options [ :markup ] ) end end
->Raw Target:
Commit all revisions of the given history into this gollum - wiki - repository.
--

1019=========
->Original Input:
['def', 'scan_spec', '(', 'fmt_string', ')', 'until', 'fmt_string', '.', 'empty?', 'if', '(', 'match_data', '=', 'PARSE_REGEX', '.', 'match', '(', 'fmt_string', ')', ')', 'mid', '=', 'match_data', '.', 'to_s', 'pre', '=', 'match_data', '.', 'pre_match', '@specs', '<<', 'FormatLiteral', '.', 'new', '(', 'pre', ')', 'unless', 'pre', '.', 'empty?', '@specs', '<<', 'case', 'when', 'match_data', '[', ':var', ']', 'then', 'FormatVariable', '.', 'new', '(', 'mid', ')', 'when', 'match_data', '[', ':set', ']', 'then', 'FormatSet', '.', 'new', '(', 'mid', ')', 'when', 'match_data', '[', ':rgx', ']', 'then', 'FormatRgx', '.', 'new', '(', 'mid', ')', 'when', 'match_data', '[', ':per', ']', 'then', 'FormatLiteral', '.', 'new', '(', '"\\%"', ')', 'else', 'fail', '"Impossible case in scan_spec."', 'end', 'fmt_string', '=', 'match_data', '.', 'post_match', 'else', '@specs', '<<', 'FormatLiteral', '.', 'new', '(', 'fmt_string', ')', 'fmt_string', '=', '""', 'end', 'end', 'end']
->Original Target:
['Scan', 'the', 'format', 'string', 'extracting', 'literals', 'and', 'variables', '.']
->Reconstructed Target:
Scan the format string extracting literals and variables.
->Reconstructed Predication:
the spec to be scanned.
->Raw Input:
summarize:def scan_spec ( fmt_string ) until fmt_string. empty? if ( match_data = PARSE_REGEX. match ( fmt_string ) ) mid = match_data. to_s pre = match_data. pre_match @specs << FormatLiteral. new ( pre ) unless pre. empty? @specs << case when match_data [ :var ] then FormatVariable. new ( mid ) when match_data [ :set ] then FormatSet. new ( mid ) when match_data [ :rgx ] then FormatRgx. new ( mid ) when match_data [ :per ] then FormatLiteral. new ( "\%" ) else fail "Impossible case in scan_spec." end fmt_string = match_data. post_match else @specs << FormatLiteral. new ( fmt_string ) fmt_string = "" end end end
->Raw Target:
Scan the format string extracting literals and variables.
--

1020=========
->Original Input:
['def', 'to_textile', 'str', 'body', '=', 'body', '.', 'dup', 'body', '.', 'gsub!', '(', '/', '\\r', '/', ',', "''", ')', 'body', '.', 'gsub!', '(', '/', '\\{', '\\{', '\\{', '\\n', '\\}', '\\}', '\\}', '/', ',', "'@\\1@'", ')', 'body', '.', 'gsub!', '(', '/', '\\{', '\\{', '\\{', '\\n', '\\n', '\\}', '\\}', '\\}', '/m', ',', '\'<pre><code class="\\1">\\2</code></pre>\'', ')', 'body', '.', 'gsub!', '(', '/', '\\{', '\\{', '\\{', '\\}', '\\}', '\\}', '/m', ',', "'<pre>\\1</pre>'", ')', 'body', '.', 'gsub!', '(', '/', '\\[', '\\[', '\\]', '\\]', '/', ',', "''", ')', 'body', '.', 'gsub!', '(', '/', '\\[', '\\[', '\\]', '\\]', '/', ',', "'{{toc}}'", ')', 'body', '.', 'gsub!', '(', '/', '\\[', '\\[', '\\(', '\\)', '\\]', '\\]', '/', ',', "'!\\1!'", ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\s', '/', ',', '"h5. #{\'\\1\'} \\n\\n"', ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\s', '/', ',', '"h4. #{\'\\1\'} \\n\\n"', ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\s', '/', ',', '"h3. #{\'\\1\'} \\n\\n"', ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\s', '/', ',', '"h2. #{\'\\1\'} \\n\\n"', ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\s', '\\s', '\\n', '/', ',', '"h1. #{\'\\1\'} \\n\\n"', ')', 'body', '.', 'gsub!', '(', '/', '\\|', '\\|', '/', ',', '"|"', ')', 'body', '.', 'gsub!', '(', '/', '\\[', '\\s', '\\[', '\\]', '\\s', '\\[', '\\]', '\\]', '/', ',', '\' "\\2":\\1\'', ')', 'body', '.', 'gsub!', '(', '/', '\\[', '\\s', '\\s', '\\]', '/', ',', "' [[\\1 | \\2]] '", ')', 'body', '.', 'gsub!', '(', '/', '\\/', '\\!', '/', ',', "' \\1[[\\2]] '", ')', 'body', '.', 'gsub!', '(', '/', '\\!', '/', ',', "'\\1'", ')', 'body', '.', 'gsub!', '(', '/', '/', ',', "'*\\1*'", ')', 'body', '.', 'gsub!', '(', '/', '/', ',', "'_\\1_'", ')', 'body', '.', 'gsub!', '(', '/', '/', ',', "'@\\1@'", ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\s', '\\s', '\\*', '/', ',', "'***'", ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\s', '\\*', '/', ',', "'**'", ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\*', '/', ',', "'*'", ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\s', '\\s', '\\d', '\\.', '/', ',', "'###'", ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\s', '\\d', '\\.', '/', ',', "'##'", ')', 'body', '.', 'gsub!', '(', '/', '\\s', '\\d', '\\.', '/', ',', "'#'", ')', 'body', 'end']
->Original Target:
['take', 'an', 'input', 'stream', 'and', 'convert', 'all', 'wikka', 'syntax', 'to', 'markdown', 'syntax', 'taken', 'from', 'trac_wiki_to_textile', 'at']
->Reconstructed Target:
take an input stream and convert all wikka syntax to markdown syntax taken from trac_wiki_to_textile at
->Reconstructed Predication:
\s \s \s \* /\s \s \* /,\s \s \* /,\s \s \* /,\s \s \* /,\s \s \* /,\s \s \* /,\s \s \* /,\s \s \* /,\s \s \* /,\s \s \*
->Raw Input:
summarize:def to_textile str body = body. dup body. gsub! ( / \r /, '' ) body. gsub! ( / \{ \{ \{ \n \} \} \} /, '@\1@' ) body. gsub! ( / \{ \{ \{ \n \n \} \} \} /m, '<pre><code class="\1">\2</code></pre>' ) body. gsub! ( / \{ \{ \{ \} \} \} /m, '<pre>\1</pre>' ) body. gsub! ( / \[ \[ \] \] /, '' ) body. gsub! ( / \[ \[ \] \] /, '{{toc}}' ) body. gsub! ( / \[ \[ \( \) \] \] /, '!\1!' ) body. gsub! ( / \s \s /, "h5. #{'\1'} \n\n" ) body. gsub! ( / \s \s /, "h4. #{'\1'} \n\n" ) body. gsub! ( / \s \s /, "h3. #{'\1'} \n\n" ) body. gsub! ( / \s \s /, "h2. #{'\1'} \n\n" ) body. gsub! ( / \s \s \s \n /, "h1. #{'\1'} \n\n" ) body. gsub! ( / \| \| /, "|" ) body. gsub! ( / \[ \s \[ \] \s \[ \] \] /,'"\2":\1' ) body. gsub! ( / \[ \s \s \] /,'[[\1 | \2]]') body. gsub! ( / \/ \! /,'\1[[\2]]') body. gsub! ( / \! /, '\1' ) body. gsub! ( / /, '*\1*' ) body. gsub! ( / /, '_\1_' ) body. gsub! ( / /, '@\1@' ) body. gsub! ( / \s \s \s \* /, '***' ) body. gsub! ( / \s \s \* /, '**' ) body. gsub!
->Raw Target:
take an input stream and convert all wikka syntax to markdown syntax taken from trac_wiki_to_textile at
--

1021=========
->Original Input:
['def', 'debug2', '(', 's', ',', 'opts', '=', '{', '}', ')', 'out', '=', 'opts', '.', 'fetch', '(', ':out', ',', '$stdout', ')', 'tag', '=', 'opts', '.', 'fetch', '(', ':tag', ',', "'_DFLT_'", ')', 'really_write', '=', 'opts', '.', 'fetch', '(', ':really_write', ',', 'true', ')', 'write_always', '=', 'opts', '.', 'fetch', '(', ':write_always', ',', 'false', ')', 'raise', '"ERROR: \':tags\' must be an array in debug(), maybe you meant to use :tag?"', 'if', '(', 'opts', '[', ':tags', ']', '&&', 'opts', '[', ':tags', ']', '.', 'class', '!=', 'Array', ')', 'final_str', '=', '"#RDeb#{write_always ? \'!\' : \'\'}[#{opts[:tag] || \'-\'}] #{s}"', 'final_str', '=', '"\\033[1;30m"', '+', 'final_str', '+', '"\\033[0m"', 'if', 'opts', '.', 'fetch', '(', ':coloured_debug', ',', 'true', ')', 'if', '(', 'debug_tags_enabled?', ')', 'puts', '(', 'final_str', ')', 'if', 'debug_tag_include?', '(', 'opts', ')', 'else', 'puts', '(', 'final_str', ')', 'if', '(', '(', 'really_write', '&&', '$DEBUG', ')', '||', 'write_always', ')', '&&', '!', 'opts', '[', ':tag', ']', 'end', 'end']
->Original Target:
['shouldnt', 'work', 'right', 'now', 'yet', '..']
->Reconstructed Target:
shouldnt work right now yet..
->Reconstructed Predication:
: tags:tag ] =:tag ] =if ( write_always && $DEBUG) || () || ( write_always &&) || ( write_always &&) || ( write_always &&) || ( write_always &&) || ( write_always &&) || ( write_always &&) )( out )
->Raw Input:
summarize:def debug2 ( s, opts = { } ) out = opts. fetch ( :out, $stdout ) tag = opts. fetch ( :tag, '_DFLT_' ) really_write = opts. fetch ( :really_write, true ) write_always = opts. fetch ( :write_always, false ) raise "ERROR: ':tags' must be an array in debug(), maybe you meant to use :tag?" if ( opts [ :tags ] && opts [ :tags ]. class!= Array ) final_str = "#RDeb#{write_always? '!' : ''}[#{opts[:tag] || '-'}] #{s}" final_str = "\033[1;30m" + final_str + "\033[0m" if opts. fetch ( :coloured_debug, true ) if ( debug_tags_enabled? ) puts ( final_str ) if debug_tag_include? ( opts ) else puts ( final_str ) if ( ( really_write && $DEBUG ) || write_always ) &&! opts [ :tag ] end end
->Raw Target:
shouldnt work right now yet..
--

1022=========
->Original Input:
['def', 'exec', '(', 'command', ',', 'options', '=', '{', '}', ',', '&', 'block', ')', 'raise', 'ConnectionClosed', '.', 'new', '(', "'Connection is closed.'", ')', 'unless', '@channel', 'options', '=', '{', 'on_non_zero_exit_code', ':', ':default', '}', '.', 'merge', '(', 'options', '||', '{', '}', ')', 'options', '[', ':on_non_zero_exit_code', ']', '=', '@options', '[', ':on_non_zero_exit_code', ']', 'if', 'options', '[', ':on_non_zero_exit_code', ']', '==', ':default', 'push_buffer', 'if', 'block_given?', 'buffer_input', '(', '&', 'block', ')', 'end', '@channel', '.', 'send_data', 'command', '+', '"\\n"', 'wait_for_prompt', 'if', 'block_given?', 'buffer_input', 'end', 'ret', '=', 'command_output', '(', 'command', ')', 'pop_merge_buffer', 'if', '@options', '[', ':retrieve_exit_code', ']', 'push_buffer', 'retrieve_command', '=', "'echo $?'", '@channel', '.', 'send_data', 'retrieve_command', '+', '"\\n"', 'wait_for_prompt', '@last_exit_code', '=', 'command_output', '(', 'retrieve_command', ')', '.', 'strip', '.', 'to_i', 'pop_discard_buffer', 'if', 'options', '[', ':on_non_zero_exit_code', ']', '==', ':raise_error', 'raise', 'NonZeroExitCode', '.', 'new', '(', '"Exit code was #{@last_exit_code}."', ')', 'unless', '@last_exit_code', '==', '0', 'end', 'end', 'ret', 'end']
->Original Target:
['Executes', 'a', 'command', 'during', 'the', 'shell', 'session', '.']
->Reconstructed Target:
Executes a command during the shell session.
->Reconstructed Predication:
@channel. send_data command +@last_exit_code@last_exit_code@last_exit_code = command_output ( command@last_exit_code ). strip.@last_exit_code = command_output ( command@last_exit_code ). strip@last_exit_code = command_output ( command@last_exit_code ). strip.@last_
->Raw Input:
summarize:def exec ( command, options = { }, & block ) raise ConnectionClosed. new ( 'Connection is closed.' ) unless @channel options = { on_non_zero_exit_code : :default }. merge ( options || { } ) options [ :on_non_zero_exit_code ] = @options [ :on_non_zero_exit_code ] if options [ :on_non_zero_exit_code ] == :default push_buffer if block_given? buffer_input ( & block ) end @channel. send_data command + "\n" wait_for_prompt if block_given? buffer_input end ret = command_output ( command ) pop_merge_buffer if @options [ :retrieve_exit_code ] push_buffer retrieve_command = 'echo $?' @channel. send_data retrieve_command + "\n" wait_for_prompt @last_exit_code = command_output ( retrieve_command ). strip. to_i pop_discard_buffer if options [ :on_non_zero_exit_code ] == :raise_error raise NonZeroExitCode. new ( "Exit code was #{@last_exit_code}." ) unless @last_exit_code == 0 end end ret end
->Raw Target:
Executes a command during the shell session.
--

1023=========
->Original Input:
['def', 'upload', '(', 'local_file', ',', 'remote_file', ')', 'raise', 'ConnectionClosed', '.', 'new', '(', "'Connection is closed.'", ')', 'unless', '@ssh', 'sftp', '.', 'upload!', '(', 'local_file', ',', 'remote_file', ')', 'end']
->Original Target:
['Uses', 'SFTP', 'to', 'upload', 'a', 'single', 'file', 'to', 'the', 'host', '.']
->Reconstructed Target:
Uses SFTP to upload a single file to the host.
->Reconstructed Predication:
 def upload ( local_filelocal_file, remote_file )
->Raw Input:
summarize:def upload ( local_file, remote_file ) raise ConnectionClosed. new ( 'Connection is closed.' ) unless @ssh sftp. upload! ( local_file, remote_file ) end
->Raw Target:
Uses SFTP to upload a single file to the host.
--

1024=========
->Original Input:
['def', 'download', '(', 'remote_file', ',', 'local_file', ')', 'raise', 'ConnectionClosed', '.', 'new', '(', "'Connection is closed.'", ')', 'unless', '@ssh', 'sftp', '.', 'download!', '(', 'remote_file', ',', 'local_file', ')', 'end']
->Original Target:
['Uses', 'SFTP', 'to', 'download', 'a', 'single', 'file', 'from', 'the', 'host', '.']
->Reconstructed Target:
Uses SFTP to download a single file from the host.
->Reconstructed Predication:
 def download ( remote_file
->Raw Input:
summarize:def download ( remote_file, local_file ) raise ConnectionClosed. new ( 'Connection is closed.' ) unless @ssh sftp. download! ( remote_file, local_file ) end
->Raw Target:
Uses SFTP to download a single file from the host.
--

1025=========
->Original Input:
['def', 'write_file', '(', 'remote_file', ',', 'data', ')', 'raise', 'ConnectionClosed', '.', 'new', '(', "'Connection is closed.'", ')', 'unless', '@ssh', 'sftp', '.', 'file', '.', 'open', '(', 'remote_file', ',', "'w'", ')', 'do', '|', 'f', '|', 'f', '.', 'write', 'data', 'end', 'end']
->Original Target:
['Uses', 'SFTP', 'to', 'write', 'data', 'to', 'a', 'single', 'file', '.']
->Reconstructed Target:
Uses SFTP to write data to a single file.
->Reconstructed Predication:
 def write_file ( remote_file
->Raw Input:
summarize:def write_file ( remote_file, data ) raise ConnectionClosed. new ( 'Connection is closed.' ) unless @ssh sftp. file. open ( remote_file, 'w' ) do | f | f. write data end end
->Raw Target:
Uses SFTP to write data to a single file.
--

1026=========
->Original Input:
['def', 'distance', '(', 'other', ')', 'unless', 'other', '.', 'is_a?', 'Point', 'raise', 'ArgumentError', '.', 'new', "'other must be a Point.'", 'end', 'dlng', '=', 'GpsUtils', '::', 'to_radians', '(', 'other', '.', 'lng', '-', '@lng', ')', 'dlat', '=', 'GpsUtils', '::', 'to_radians', '(', 'other', '.', 'lat', '-', '@lat', ')', 'x', '=', 'dlng', '*', 'Math', '.', 'cos', '(', 'dlat', '/', '2', ')', 'y', '=', 'GpsUtils', '::', 'to_radians', '(', 'other', '.', 'lat', '-', '@lat', ')', 'Math', '.', 'sqrt', '(', 'x', '**', '2', '+', 'y', '**', '2', ')', '*', 'GpsUtils', '::', 'R', 'end']
->Original Target:
['Measure', 'the', 'distance', 'between', 'this', 'point', 'and', 'another', '.']
->Reconstructed Target:
Measure the distance between this point and another.
->Reconstructed Predication:
the distance between the pointthe distance between the point
->Raw Input:
summarize:def distance ( other ) unless other. is_a? Point raise ArgumentError. new 'other must be a Point.' end dlng = GpsUtils :: to_radians ( other. lng - @lng ) dlat = GpsUtils :: to_radians ( other. lat - @lat ) x = dlng * Math. cos ( dlat / 2 ) y = GpsUtils :: to_radians ( other. lat - @lat ) Math. sqrt ( x ** 2 + y ** 2 ) * GpsUtils :: R end
->Raw Target:
Measure the distance between this point and another.
--

1027=========
->Original Input:
['def', 'cover?', '(', 'point', ')', 'p', '=', '[', 'point', '.', 'lat', '-', '@nw', '.', 'lat', ',', 'point', '.', 'lng', '-', '@se', '.', 'lng', ']', 'p21x', '=', 'p', '[', '0', ']', '*', '@p21', 'p41x', '=', 'p', '[', '1', ']', '*', '@p41', '0', '<', 'p21x', 'and', 'p21x', '<', '@p21ms', 'and', '0', '<=', 'p41x', 'and', 'p41x', '<=', '@p41ms', 'end']
->Original Target:
['Initialize', 'BoundingBox', '.']
->Reconstructed Target:
Initialize BoundingBox.
->Reconstructed Predication:
the point covering the point
->Raw Input:
summarize:def cover? ( point ) p = [ point. lat - @nw. lat, point. lng - @se. lng ] p21x = p [ 0 ] * @p21 p41x = p [ 1 ] * @p41 0 < p21x and p21x < @p21ms and 0 <= p41x and p41x <= @p41ms end
->Raw Target:
Initialize BoundingBox.
--

1028=========
->Original Input:
['def', 'send', '(', 'method', ',', '*', 'args', ',', '&', 'block', ')', 'if', 'respond_to?', '(', 'method', ')', 'super', 'else', 'subject', '.', 'send', '(', 'method', ',', '*', 'args', ',', '&', 'block', ')', 'end', 'end']
->Original Target:
['for', 'will', 'paginate', 'support']
->Reconstructed Target:
for will paginate support
->Reconstructed Predication:
the subject to the method.
->Raw Input:
summarize:def send ( method, * args, & block ) if respond_to? ( method ) super else subject. send ( method, * args, & block ) end end
->Raw Target:
for will paginate support
--

1029=========
->Original Input:
['def', 'output', '(', 'elapsed', ')', 'case', '@result', 'when', 'MATCH_SUCCESS', 'color', '=', ':green', 'header', '=', "'OK'", 'when', 'MATCH_FAILURE', 'color', '=', ':red', 'header', '=', "'FAIL'", 'when', 'MATCH_WARNING', 'color', '=', ':light_red', 'header', '=', "'WARN'", 'end', 'header', '=', 'header', '.', 'ljust', '(', '12', ')', '.', 'colorize', '(', 'color', ')', 'str_elapsed', '=', '"#{elapsed.round(2)}s"', 'name', '=', '@name', '.', 'to_s', '[', '0', '..', '17', ']', 'puts', '"#{header}   #{name.ljust(20)}   #{str_elapsed.ljust(9)} #{@message}"', 'end']
->Original Target:
['Called', 'to', 'output', 'the', 'result', 'to', 'the', 'console', '.']
->Reconstructed Target:
Called to output the result to the console.
->Reconstructed Predication:
@message  def output
->Raw Input:
summarize:def output ( elapsed ) case @result when MATCH_SUCCESS color = :green header = 'OK' when MATCH_FAILURE color = :red header = 'FAIL' when MATCH_WARNING color = :light_red header = 'WARN' end header = header. ljust ( 12 ). colorize ( color ) str_elapsed = "#{elapsed.round(2)}s" name = @name. to_s [ 0.. 17 ] puts "#{header}   #{name.ljust(20)}   #{str_elapsed.ljust(9)} #{@message}" end
->Raw Target:
Called to output the result to the console.
--

1030=========
->Original Input:
['def', 'get_userinfo', '(', 'user', ')', 'p', '=', '{', '}', 'ids', '=', '[', ']', 'names', '=', '[', ']', 'if', 'user', '.', 'is_a?', '(', 'Array', ')', 'user', '.', 'each', 'do', '|', 'u', '|', 'names', '<<', 'u', 'if', 'u', '.', 'is_a?', '(', 'String', ')', 'id', '<<', 'u', 'if', 'u', '.', 'is_a?', '(', 'Integer', ')', 'end', 'elsif', 'user', '.', 'is_a?', '(', 'String', ')', 'names', '<<', 'user', 'elsif', 'user', '.', 'is_a?', '(', 'Integer', ')', 'ids', '<<', 'user', 'else', 'raise', 'ArgumentError', ',', 'format', '(', "'Unknown type of arguments: %s'", ',', 'user', '.', 'class', ')', 'end', 'result', '=', 'get', '(', "'ids'", '=>', 'ids', ',', "'names'", '=>', 'names', ')', 'result', '[', "'users'", ']', 'end']
->Original Target:
['def', 'session', 'rdoc']
->Reconstructed Target:
def session rdoc
->Reconstructed Predication:
the user sthe user sthe user sthe user sthe userthe user sthe user sthe user s
->Raw Input:
summarize:def get_userinfo ( user ) p = { } ids = [ ] names = [ ] if user. is_a? ( Array ) user. each do | u | names << u if u. is_a? ( String ) id << u if u. is_a? ( Integer ) end elsif user. is_a? ( String ) names << user elsif user. is_a? ( Integer ) ids << user else raise ArgumentError, format ( 'Unknown type of arguments: %s', user. class ) end result = get ( 'ids' => ids, 'names' => names ) result [ 'users' ] end
->Raw Target:
def session rdoc
--

1031=========
->Original Input:
['def', 'options', '&', 'block', 'options', '=', 'Options', '.', 'new', 'options', '.', 'instance_eval', '(', '&', 'block', ')', '@options', '=', 'options', '.', 'to_hash', 'end']
->Original Target:
['define', 'a', 'DSL', 'for', 'options', 'any', 'string', 'is', 'processed', 'as', 'an', 'option', 'and', 'it', 'ends', 'up', 'in', 'the']
->Reconstructed Target:
define a DSL for options any string is processed as an option and it ends up in the
->Reconstructed Predication:
the options to be used for
->Raw Input:
summarize:def options & block options = Options. new options. instance_eval ( & block ) @options = options. to_hash end
->Raw Target:
define a DSL for options any string is processed as an option and it ends up in the
--

1032=========
->Original Input:
['def', 'column', 'name', ',', '&', 'block', 'column', '=', 'Column', '.', 'new', 'column', '.', 'instance_eval', '(', '&', 'block', ')', '@colspec', '<<', 'column', '.', 'to_hash', '.', 'merge', '(', '{', 'name', ':', 'name', '}', ')', 'end']
->Original Target:
['define', 'a', 'DSL', 'for', 'column', 'specification', '-', 'name', 'is', 'the', 'name', 'of', 'the', 'column', '-', 'block', 'contains', 'two', 'declarations', 'process', 'and', 'check', 'which', 'are', 'used', 'respectively', 'to', 'make', 'a', 'cell', 'into', 'the', 'desired', 'data', 'and', 'to', 'check', 'whether', 'the', 'desired', 'data', 'is', 'ok']
->Reconstructed Target:
define a DSL for column specification - name is the name of the column - block contains two declarations process and check which are used respectively to make a cell into the desired data and to check whether the desired data is ok
->Reconstructed Predication:
column name column block
->Raw Input:
summarize:def column name, & block column = Column. new column. instance_eval ( & block ) @colspec << column. to_hash. merge ( { name : name } ) end
->Raw Target:
define a DSL for column specification - name is the name of the column - block contains two declarations process and check which are used respectively to make a cell into the desired data and to check whether the desired data is ok
--

1033=========
->Original Input:
['def', 'bulk_declare', 'hash', ',', '&', 'block', 'hash', '.', 'keys', '.', 'each', 'do', '|', 'key', '|', 'column', '=', 'Column', '.', 'new', 'column', '.', 'colref', 'hash', '[', 'key', ']', 'if', 'block', 'column', '.', 'instance_eval', '(', '&', 'block', ')', 'end', '@colspec', '<<', 'column', '.', 'to_hash', '.', 'merge', '(', '{', 'name', ':', 'key', '}', ')', 'end', 'end']
->Original Target:
['bulk', 'declare', 'columns', 'we', 'intend', 'to', 'read']
->Reconstructed Target:
bulk declare columns we intend to read
->Reconstructed Predication:
the columns to be used in
->Raw Input:
summarize:def bulk_declare hash, & block hash. keys. each do | key | column = Column. new column. colref hash [ key ] if block column. instance_eval ( & block ) end @colspec << column. to_hash. merge ( { name : key } ) end end
->Raw Target:
bulk declare columns we intend to read
--

1034=========
->Original Input:
['def', 'read', 'args', '=', '{', '}', 'if', 'args', '.', 'class', '==', 'Hash', 'hash', '=', '@options', '.', 'merge', '(', 'args', ')', 'else', 'puts', '"dreader error at #{__callee__}: this function takes a Hash as input"', 'exit', 'end', 'spreadsheet', '=', 'Dreader', '::', 'Engine', '.', 'open_spreadsheet', '(', 'hash', '[', ':filename', ']', ')', 'sheet', '=', 'spreadsheet', '.', 'sheet', '(', 'hash', '[', ':sheet', ']', '||', '0', ')', '@table', '=', 'Array', '.', 'new', '@errors', '=', 'Array', '.', 'new', 'first_row', '=', 'hash', '[', ':first_row', ']', '||', '1', 'last_row', '=', 'hash', '[', ':last_row', ']', '||', 'sheet', '.', 'last_row', '(', 'first_row', '..', 'last_row', ')', '.', 'each', 'do', '|', 'row_number', '|', 'r', '=', 'Hash', '.', 'new', '@colspec', '.', 'each_with_index', 'do', '|', 'colspec', ',', 'index', '|', 'cell', '=', 'sheet', '.', 'cell', '(', 'row_number', ',', 'colspec', '[', ':colref', ']', ')', 'colname', '=', 'colspec', '[', ':name', ']', 'r', '[', 'colname', ']', '=', 'Hash', '.', 'new', 'r', '[', 'colname', ']', '[', ':row_number', ']', '=', 'row_number', 'r', '[', 'colname', ']', '[', ':col_number', ']', '=', 'colspec', '[', ':colref', ']', 'begin', 'r', '[', 'colname', ']', '[', ':value', ']', '=', 'value', '=', 'colspec', '[', ':process', ']', '?', 'colspec', '[', ':process', ']', '.', 'call', '(', 'cell', ')', ':', 'cell', 'rescue', '=>', 'e', 'puts', '"dreader error at #{__callee__}: \'process\' specification for :#{colname} raised an exception at row #{row_number} (col #{index + 1}, value: #{cell})"', 'raise', 'e', 'end', 'begin', 'if', 'colspec', '[', ':check', ']', 'and', 'not', 'colspec', '[', ':check', ']', '.', 'call', '(', 'value', ')', 'then', 'r', '[', 'colname', ']', '[', ':error', ']', '=', 'true', '@errors', '<<', '"dreader error at #{__callee__}: value \\"#{cell}\\" for #{colname} at row #{row_number} (col #{index + 1}) does not pass the check function"', 'else', 'r', '[', 'colname', ']', '[', ':error', ']', '=', 'false', 'end', 'rescue', '=>', 'e', 'puts', '"dreader error at #{__callee__}: \'check\' specification for :#{colname} raised an exception at row #{row_number} (col #{index + 1}, value: #{cell})"', 'raise', 'e', 'end', 'end', '@table', '<<', 'r', 'end', '@table', 'end']
->Original Target:
['read', 'a', 'file', 'and', 'store', 'it', 'internally']
->Reconstructed Target:
read a file and store it internally
->Reconstructed Predication:
@table.@table.@table..( row_number, colspeccolspec [ :name ]colspec [ :error ]:error ] = false @errors. each (colspec [ :error ]= true @table.. each (. each (. each (. each (. each (. each (. each (. each (. each (
->Raw Input:
summarize:def read args = { } if args. class == Hash hash = @options. merge ( args ) else puts "dreader error at #{__callee__}: this function takes a Hash as input" exit end spreadsheet = Dreader :: Engine. open_spreadsheet ( hash [ :filename ] ) sheet = spreadsheet. sheet ( hash [ :sheet ] || 0 ) @table = Array. new @errors = Array. new first_row = hash [ :first_row ] || 1 last_row = hash [ :last_row ] || sheet. last_row ( first_row.. last_row ). each do | row_number | r = Hash. new @colspec. each_with_index do | colspec, index | cell = sheet. cell ( row_number, colspec [ :colref ] ) colname = colspec [ :name ] r [ colname ] = Hash. new r [ colname ] [ :row_number ] = row_number r [ colname ] [ :col_number ] = colspec [ :colref ] begin r [ colname ] [ :value ] = value = colspec [ :process ]? colspec [ :process ]. call ( cell ) : cell rescue => e puts "dreader error at #{__callee__}: 'process' specification for :#{colname} raised an exception at row #{row_number} (col #{index + 1}, value: #{cell})" raise e end begin if colspec [ :check ] and not colspec [ :check ]. call ( value ) then r [ colname ] [ :error ] = true @errors << "dreader error at #{__callee__}: value \"#{cell}\" for #{colname} at row #{row_number} (col #{index + 1}) does not pass the check function" else r [ colname ] [ :error ] = false end rescue => e puts "dreader error at #{__callee__}: 'check' specification for :#{colname} raised an exception at row #{row_number} (col #{index + 1}, value: #{cell})" raise e end end @table << r end @table end
->Raw Target:
read a file and store it internally
--

1035=========
->Original Input:
['def', 'backtrace_lineno_for_config', '(', 'file_path', ',', 'exception', ')', 'if', 'exception', '.', 'kind_of?', 'SyntaxError', 'if', 'm', '=', '/', '\\d', '/', '.', 'match', '(', 'exception', '.', 'message', ')', 'return', 'm', '[', '1', ']', '.', 'to_i', 'end', 'end', 'if', '(', 'exception', '.', 'respond_to?', '(', ':backtrace_locations', ')', '&&', 'exception', '.', 'backtrace_locations', '&&', 'exception', '.', 'backtrace_locations', '.', 'length', '>', '0', ')', 'location', '=', 'exception', '.', 'backtrace_locations', '.', 'find', 'do', '|', 'bt', '|', 'bt', '.', 'path', '==', 'file_path', 'end', 'return', 'location', '?', 'location', '.', 'lineno', ':', 'nil', 'else', 'exception', '.', 'backtrace', '.', 'each', 'do', '|', 'line', '|', 'if', 'line', '.', 'start_with?', '(', 'file_path', ')', 'if', 'm', '=', '/', '\\A', '\\:', '\\d', '\\:', '/', '.', 'match', '(', 'line', ')', 'return', 'm', '[', '1', ']', '.', 'to_i', 'break', 'end', 'end', 'end', 'return', 'nil', 'end', 'end']
->Original Target:
['Provide', 'a', 'config', 'source', 'file', 'path', 'and', 'an', 'exception', '.']
->Reconstructed Target:
Provide a config source file path and an exception.
->Reconstructed Predication:
the line number for thethe line number for the giventhe file paththe line number for thethe line number for thethe line number for the giventhe file paththe line number for thethe linethe line number for thethe line number for thethe linethe line number for thethe linethe line number for thethe linethe line number for thethe linethe linethe line number
->Raw Input:
summarize:def backtrace_lineno_for_config ( file_path, exception ) if exception. kind_of? SyntaxError if m = / \d /. match ( exception. message ) return m [ 1 ]. to_i end end if ( exception. respond_to? ( :backtrace_locations ) && exception. backtrace_locations && exception. backtrace_locations. length > 0 ) location = exception. backtrace_locations. find do | bt | bt. path == file_path end return location? location. lineno : nil else exception. backtrace. each do | line | if line. start_with? ( file_path ) if m = / \A \: \d \: /. match ( line ) return m [ 1 ]. to_i break end end end return nil end end
->Raw Target:
Provide a config source file path and an exception.
--

1036=========
->Original Input:
['def', 'backtrace_from_config', '(', 'file_path', ',', 'exception', ')', 'filtered_trace', '=', '[', ']', 'found', '=', 'false', 'if', '(', 'exception', '.', 'respond_to?', '(', ':backtrace_locations', ')', '&&', 'exception', '.', 'backtrace_locations', '&&', 'exception', '.', 'backtrace_locations', '.', 'length', '>', '0', ')', 'exception', '.', 'backtrace_locations', '.', 'each', 'do', '|', 'location', '|', 'filtered_trace', '<<', 'location', '(', 'found', '=', 'true', 'and', 'break', ')', 'if', 'location', '.', 'path', '==', 'file_path', 'end', 'else', 'filtered_trace', '=', '[', ']', 'exception', '.', 'backtrace', '.', 'each', 'do', '|', 'line', '|', 'filtered_trace', '<<', 'line', '(', 'found', '=', 'true', 'and', 'break', ')', 'if', 'line', '.', 'start_with?', '(', 'file_path', ')', 'end', 'end', 'return', 'found', '?', 'filtered_trace', ':', '[', ']', 'end']
->Original Target:
['Extract', 'just', 'the', 'part', 'of', 'the', 'backtrace', 'that', 'is', 'below', 'the', 'config', 'file', 'mentioned', '.', 'If', 'we', 'can', 't', 'find', 'the', 'config', 'file', 'in', 'the', 'stack', 'trace', 'we', 'might', 'return', 'empty', 'array', '.']
->Reconstructed Target:
Extract just the part of the backtrace that is below the config file mentioned. If we can t find the config file in the stack trace we might return empty array.
->Reconstructed Predication:
the trace from the configthe file path to thethe file path to thethe file path to thethe file path to thethe file path to the
->Raw Input:
summarize:def backtrace_from_config ( file_path, exception ) filtered_trace = [ ] found = false if ( exception. respond_to? ( :backtrace_locations ) && exception. backtrace_locations && exception. backtrace_locations. length > 0 ) exception. backtrace_locations. each do | location | filtered_trace << location ( found = true and break ) if location. path == file_path end else filtered_trace = [ ] exception. backtrace. each do | line | filtered_trace << line ( found = true and break ) if line. start_with? ( file_path ) end end return found? filtered_trace : [ ] end
->Raw Target:
Extract just the part of the backtrace that is below the config file mentioned. If we can t find the config file in the stack trace we might return empty array.
--

1037=========
->Original Input:
['def', 'drain_queue', '(', 'queue', ')', 'result', '=', '[', ']', 'queue_size', '=', 'queue', '.', 'size', 'begin', 'queue_size', '.', 'times', 'do', 'result', '<<', 'queue', '.', 'deq', '(', ':raise_if_empty', ')', 'end', 'rescue', 'ThreadError', 'end', 'return', 'result', 'end']
->Original Target:
['Ruby', 'stdlib', 'queue', 'lacks', 'a', 'drain', 'function', 'we', 'write', 'one', '.']
->Reconstructed Target:
Ruby stdlib queue lacks a drain function we write one.
->Reconstructed Predication:
the queue to drain. 
->Raw Input:
summarize:def drain_queue ( queue ) result = [ ] queue_size = queue. size begin queue_size. times do result << queue. deq ( :raise_if_empty ) end rescue ThreadError end return result end
->Raw Target:
Ruby stdlib queue lacks a drain function we write one.
--

1038=========
->Original Input:
['def', 'get_hash', '(', 'params', '=', '{', '}', ',', 'sorted', '=', 'true', ')', 'get_nodes', '(', 'sorted', ')', '.', 'map', '{', '|', 'n', '|', 'n', '.', 'to_hash', '(', 'params', '[', 'n', '.', 'name', ']', ')', '}', 'end']
->Original Target:
['Return', 'all', 'nodes', 'in', 'order', 'as', 'an', 'hashalways_use']
->Reconstructed Target:
Return all nodes in order as an hashalways_use
->Reconstructed Predication:
the hash of the nodes
->Raw Input:
summarize:def get_hash ( params = { }, sorted = true ) get_nodes ( sorted ). map { | n | n. to_hash ( params [ n. name ] ) } end
->Raw Target:
Return all nodes in order as an hashalways_use
--

1039=========
->Original Input:
['def', 'get_sentence', '(', 'params', '=', '{', '}', ',', 'sorted', '=', 'true', ',', 'separator', '=', "' '", ')', 'build_sentence_from_hash', '(', 'get_hash', '(', 'params', ',', 'sorted', ')', ')', '.', 'select', '(', '&', ':present?', ')', '.', 'join', '(', 'separator', ')', 'end']
->Original Target:
['Returns', 'the', 'string', 'representation', 'of', 'nodes', 'and', 'blocks', 'by', 'updating', 'with', 'given', 'parameters']
->Reconstructed Target:
Returns the string representation of nodes and blocks by updating with given parameters
->Reconstructed Predication:
the sentence to be returned.
->Raw Input:
summarize:def get_sentence ( params = { }, sorted = true, separator ='' ) build_sentence_from_hash ( get_hash ( params, sorted ) ). select ( & :present? ). join ( separator ) end
->Raw Target:
Returns the string representation of nodes and blocks by updating with given parameters
--

1040=========
->Original Input:
['def', 'get_nodes', '(', 'sorted', '=', 'true', ')', 'SentenceBuilder', '::', 'Helper', '.', 'to_boolean', '(', 'sorted', ')', '?', '@nodes', '.', 'sort_by', '{', '|', 'i', '|', 'i', '.', 'sort_by_value', '}', ':', '@nodes', 'end']
->Original Target:
['Return', 'nodes', 'by', 'sorting', 'option']
->Reconstructed Target:
Return nodes by sorting option
->Reconstructed Predication:
the nodes to be returned.
->Raw Input:
summarize:def get_nodes ( sorted = true ) SentenceBuilder :: Helper. to_boolean ( sorted )? @nodes. sort_by { | i | i. sort_by_value } : @nodes end
->Raw Target:
Return nodes by sorting option
--

1041=========
->Original Input:
['def', 'build_sentence_from_hash', '(', 'nodes', ')', 'result', '=', '[', ']', 'nodes', '.', 'each', 'do', '|', 'node', '|', 'if', 'node', '[', ':current_value', ']', '.', 'nil?', 'if', 'node', '[', ':always_use', ']', 'result', '<<', 'node', '[', ':sentence', ']', 'end', 'else', 'result', '<<', 'node', '[', ':sentence', ']', 'end', 'end', 'result', 'end']
->Original Target:
['By', 'parsing', 'each', 'node', 's', 'hash', 'create', 'a', 'sentence']
->Reconstructed Target:
By parsing each node s hash create a sentence
->Reconstructed Predication:
the nodes to be built
->Raw Input:
summarize:def build_sentence_from_hash ( nodes ) result = [ ] nodes. each do | node | if node [ :current_value ]. nil? if node [ :always_use ] result << node [ :sentence ] end else result << node [ :sentence ] end end result end
->Raw Target:
By parsing each node s hash create a sentence
--

1042=========
->Original Input:
['def', 'read_pages', 'sql', '=', '"SELECT id, tag, body, time, latest, user, note FROM wikka_pages ORDER BY time;"', 'results', '=', 'database', '.', 'query', '(', 'sql', ')', 'results', '.', 'each', 'do', '|', 'row', '|', 'titles', '<<', 'row', '[', '"tag"', ']', 'author', '=', 'authors', '[', 'row', '[', '"user"', ']', ']', 'page', '=', 'Page', '.', 'new', '(', '{', ':id', '=>', 'row', '[', '"id"', ']', ',', ':title', '=>', 'row', '[', '"tag"', ']', ',', ':body', '=>', 'row', '[', '"body"', ']', ',', ':markup', '=>', ':wikka', ',', ':latest', '=>', 'row', '[', '"latest"', ']', '==', '"Y"', ',', ':time', '=>', 'row', '[', '"time"', ']', ',', ':message', '=>', 'row', '[', '"note"', ']', ',', ':author', '=>', 'author', ',', ':author_name', '=>', 'row', '[', '"user"', ']', '}', ')', 'revisions', '<<', 'page', 'end', 'titles', '.', 'uniq!', 'revisions', 'end']
->Original Target:
['after', 'calling', 'this', 'action', 'I', 'expect', 'the', 'titles', 'and']
->Reconstructed Target:
after calling this action I expect the titles and
->Reconstructed Predication:
the pagethe pagethe pagethe pagethe pagethe pagethe pagethe pagethe page
->Raw Input:
summarize:def read_pages sql = "SELECT id, tag, body, time, latest, user, note FROM wikka_pages ORDER BY time;" results = database. query ( sql ) results. each do | row | titles << row [ "tag" ] author = authors [ row [ "user" ] ] page = Page. new ( { :id => row [ "id" ], :title => row [ "tag" ], :body => row [ "body" ], :markup => :wikka, :latest => row [ "latest" ] == "Y", :time => row [ "time" ], :message => row [ "note" ], :author => author, :author_name => row [ "user" ] } ) revisions << page end titles. uniq! revisions end
->Raw Target:
after calling this action I expect the titles and
--

1043=========
->Original Input:
['def', 'filter', '(', 'params', ')', 'results', '=', 'where', '(', 'nil', ')', 'params', '.', 'each', 'do', '|', 'key', ',', 'value', '|', 'results', '=', 'results', '.', 'public_send', '(', 'key', ',', 'value', ')', 'if', 'value', '.', 'present?', 'end', 'results', 'end']
->Original Target:
['Iterates', 'over', 'params', 'hash', 'and', 'applies', 'non', '-', 'empty', 'values', 'as', 'filters']
->Reconstructed Target:
Iterates over params hash and applies non - empty values as filters
->Reconstructed Predication:
the results to the query
->Raw Input:
summarize:def filter ( params ) results = where ( nil ) params. each do | key, value | results = results. public_send ( key, value ) if value. present? end results end
->Raw Target:
Iterates over params hash and applies non - empty values as filters
--

1044=========
->Original Input:
['def', 'sites', 'response', '=', 'conn', '.', 'get', '(', '"#{base_url}/site"', ',', '{', '}', ',', 'query_headers', ')', 'body', '=', 'JSON', '.', 'parse', '(', 'response', '.', 'body', ')', 'body', '.', 'map', '{', '|', 'b', '|', 'Site', '.', 'new', '(', 'b', ')', '}', 'rescue', 'JSON', '::', 'ParserError', 'fail', 'QueryError', ',', '"Query Failed! HTTPStatus: #{response.status} - Response: #{body}"', 'end']
->Original Target:
['Gets', 'a', 'list', 'of', 'all', 'the', 'sites', 'for', 'the', 'company']
->Reconstructed Target:
Gets a list of all the sites for the company
->Reconstructed Predication:
the site list of thethe site list of the
->Raw Input:
summarize:def sites response = conn. get ( "#{base_url}/site", { }, query_headers ) body = JSON. parse ( response. body ) body. map { | b | Site. new ( b ) } rescue JSON :: ParserError fail QueryError, "Query Failed! HTTPStatus: #{response.status} - Response: #{body}" end
->Raw Target:
Gets a list of all the sites for the company
--

1045=========
->Original Input:
['def', 'site_query', '(', '*', 'args', ')', 'response', '=', 'conn', '.', 'get', '(', 'url_picker', '(', '*', 'args', ')', ',', '{', '}', ',', 'query_headers', ')', 'if', 'response', '.', 'body', '[', "'SiteId'", ']', '||', 'response', '.', 'body', '[', "'PointId'", ']', 'JSON', '.', 'parse', '(', 'response', '.', 'body', ')', 'else', 'fail', 'QueryError', ',', '"Query Failed! HTTPStatus: #{response.status}"', 'end', 'end']
->Original Target:
['Returns', 'site', 'attributes', 'and', 'history', 'data', 'if', 'an', 'optional', 'query_hash', 'is', 'supplied']
->Reconstructed Target:
Returns site attributes and history data if an optional query_hash is supplied
->Reconstructed Predication:
the site query for athe site query
->Raw Input:
summarize:def site_query ( * args ) response = conn. get ( url_picker ( * args ), { }, query_headers ) if response. body [ 'SiteId' ] || response. body [ 'PointId' ] JSON. parse ( response. body ) else fail QueryError, "Query Failed! HTTPStatus: #{response.status}" end end
->Raw Target:
Returns site attributes and history data if an optional query_hash is supplied
--

1046=========
->Original Input:
['def', 'rate_time', 'regexp', '=', 'Regexp', '.', 'new', '(', 'currency_code', ')', 'page', '.', 'search', '(', '"//span[@name=\'pair\']"', ')', '.', 'each', 'do', '|', 'td', '|', 'if', 'regexp', '.', 'match', '(', 'td', '.', 'content', ')', 'hour', '=', 'td', '.', 'next_element', '.', 'next_element', '.', 'content', 'return', 'DateTime', '.', 'parse', '(', 'hour', ')', 'end', 'end', 'end']
->Original Target:
['The', 'hour', 'of', 'the', 'rate']
->Reconstructed Target:
The hour of the rate
->Reconstructed Predication:
the currency codethe currency code the currency
->Raw Input:
summarize:def rate_time regexp = Regexp. new ( currency_code ) page. search ( "//span[@name='pair']" ). each do | td | if regexp. match ( td. content ) hour = td. next_element. next_element. content return DateTime. parse ( hour ) end end end
->Raw Target:
The hour of the rate
--

1047=========
->Original Input:
['def', 'outfile', '=', 'f', 'io', '=', 'f', '.', 'kind_of?', '(', 'IO', ')', '?', 'f', ':', 'File', '.', 'new', '(', 'f', ',', '"w"', ')', '@writer', '.', 'output', '=', 'io', 'end']
->Original Target:
['Assigns', 'output', 'to', 'a', 'file', 'with', 'the', 'given', 'name', '.', 'Returns', 'the', 'file', ';', 'the', 'client', 'is', 'responsible', 'for', 'closing', 'it', '.']
->Reconstructed Target:
Assigns output to a file with the given name. Returns the file ; the client is responsible for closing it.
->Reconstructed Predication:
the file to write to
->Raw Input:
summarize:def outfile = f io = f. kind_of? ( IO )? f : File. new ( f, "w" ) @writer. output = io end
->Raw Target:
Assigns output to a file with the given name. Returns the file ; the client is responsible for closing it.
--

1048=========
->Original Input:
['def', 'log', 'msg', '=', '""', ',', 'obj', '=', 'nil', ',', 'level', ':', 'Level', '::', 'DEBUG', ',', 'classname', ':', 'nil', ',', '&', 'blk', 'log_frames', 'msg', ',', 'obj', ',', 'classname', ':', 'classname', ',', 'level', ':', 'level', ',', 'nframes', ':', '0', ',', '&', 'blk', 'end']
->Original Target:
['Logs', 'the', 'given', 'message', '.']
->Reconstructed Target:
Logs the given message.
->Reconstructed Predication:
log_frames msg objblock block
->Raw Input:
summarize:def log msg = "", obj = nil, level : Level :: DEBUG, classname : nil, & blk log_frames msg, obj, classname : classname, level : level, nframes : 0, & blk end
->Raw Target:
Logs the given message.
--

1049=========
->Original Input:
['def', 'options', 'option_hash', '=', '{', '}', 'my_labels', '=', 'option_names', 'my_inputs', '=', 'option_fields', 'my_labels', '.', 'count', '.', 'times', 'do', '|', 'index', '|', 'option_hash', '[', 'my_labels', '[', 'index', ']', ']', '=', 'my_inputs', '[', 'index', ']', 'end', 'option_hash', 'end']
->Original Target:
['Returns', 'all', 'available', 'options', 'fields', 'and', 'their', 'respective', 'label', 'as', 'a', 'Hash', '.']
->Reconstructed Target:
Returns all available options fields and their respective label as a Hash.
->Reconstructed Predication:
option_hash  def options
->Raw Input:
summarize:def options option_hash = { } my_labels = option_names my_inputs = option_fields my_labels. count. times do | index | option_hash [ my_labels [ index ] ] = my_inputs [ index ] end option_hash end
->Raw Target:
Returns all available options fields and their respective label as a Hash.
--

1050=========
->Original Input:
['def', 'selected_options', 'selected', '=', '[', ']', 'my_labels', '=', 'option_names', 'inputs', '.', 'each_with_index', 'do', '|', 'field', ',', 'index', '|', 'selected', '<<', 'my_labels', '[', 'index', ']', 'if', 'field', '.', 'checked?', 'end', 'selected', 'end']
->Original Target:
['Returns', 'the', 'selected', 'options', 'of', 'this', 'OptionGroup', '.']
->Reconstructed Target:
Returns the selected options of this OptionGroup.
->Reconstructed Predication:
the selected options for the given
->Raw Input:
summarize:def selected_options selected = [ ] my_labels = option_names inputs. each_with_index do | field, index | selected << my_labels [ index ] if field. checked? end selected end
->Raw Target:
Returns the selected options of this OptionGroup.
--

1051=========
->Original Input:
['def', 'transmit_packet', '(', 'packet', ',', 'options', '=', '{', '}', ')', 'options', '=', '{', 'cache', ':', 'false', '}', '.', 'merge', '(', 'options', ')', 'packet', '=', 'packet', '.', 'as_json', '.', 'deep_symbolize_keys', 'if', 'validate_packet', '(', 'packet', ',', 'options', ')', 'if', 'options', '[', ':cache', ']', '==', 'true', 'if', 'update_cache', '(', 'packet', ')', 'transmit', 'packet', 'end', 'else', 'transmit', 'packet', 'end', 'end', 'end']
->Original Target:
['Transmits', 'packets', 'to', 'connected', 'client']
->Reconstructed Target:
Transmits packets to connected client
->Reconstructed Predication:
the packet to be sent
->Raw Input:
summarize:def transmit_packet ( packet, options = { } ) options = { cache : false }. merge ( options ) packet = packet. as_json. deep_symbolize_keys if validate_packet ( packet, options ) if options [ :cache ] == true if update_cache ( packet ) transmit packet end else transmit packet end end end
->Raw Target:
Transmits packets to connected client
--

1052=========
->Original Input:
['def', 'strict_ancestor_of?', '(', 'block_start', ')', 'block_start', '&&', 'block_start', '.', 'parent', '&&', '(', 'self', '==', 'block_start', '.', 'parent', '||', 'strict_ancestor_of?', '(', 'block_start', '.', 'parent', ')', ')', 'end']
->Original Target:
['Returns', 'true', 'if', 'strict', 'ancestor', 'of']
->Reconstructed Target:
Returns true if strict ancestor of
->Reconstructed Predication:
return the block that is the
->Raw Input:
summarize:def strict_ancestor_of? ( block_start ) block_start && block_start. parent && ( self == block_start. parent || strict_ancestor_of? ( block_start. parent ) ) end
->Raw Target:
Returns true if strict ancestor of
--

1053=========
->Original Input:
['def', 'built_in_object_ids', '@built_in_object_ids', '||=', 'Hash', '.', 'new', 'do', '|', 'hash', ',', 'key', '|', 'hash', '[', 'key', ']', '=', 'where', '(', 'built_in_key', ':', 'key', ')', '.', 'pluck', '(', ':id', ')', '.', 'first', 'end', 'end']
->Original Target:
['memoized', 'hash', 'of', 'built', 'in', 'object', 'ids']
->Reconstructed Target:
memoized hash of built in object ids
->Reconstructed Predication:
the object ids of the built_in objects
->Raw Input:
summarize:def built_in_object_ids @built_in_object_ids ||= Hash. new do | hash, key | hash [ key ] = where ( built_in_key : key ). pluck ( :id ). first end end
->Raw Target:
memoized hash of built in object ids
--

1054=========
->Original Input:
['def', 'daemonize', '(', 'safe', '=', 'true', ')', '$stdin', '.', 'reopen', "'/dev/null'", 'exit', 'if', 'fork', 'Process', '.', 'setsid', 'exit', 'if', 'fork', 'unless', 'safe', '::', 'Dir', '.', 'chdir', '(', "'/'", ')', '::', 'File', '.', 'umask', '(', '0000', ')', 'end', 'cfg_defaults', '=', 'Clacks', '::', 'Configurator', '::', 'DEFAULTS', 'cfg_defaults', '[', ':stdout_path', ']', '||=', '"/dev/null"', 'cfg_defaults', '[', ':stderr_path', ']', '||=', '"/dev/null"', 'end']
->Original Target:
['See', 'Stevens', 's', 'Advanced', 'Programming', 'in', 'the', 'UNIX', 'Environment', 'chapter', '13']
->Reconstructed Target:
See Stevens s Advanced Programming in the UNIX Environment chapter 13
->Reconstructed Predication:
 def daemonize= nil end
->Raw Input:
summarize:def daemonize ( safe = true ) $stdin. reopen '/dev/null' exit if fork Process. setsid exit if fork unless safe :: Dir. chdir ( '/' ) :: File. umask ( 0000 ) end cfg_defaults = Clacks :: Configurator :: DEFAULTS cfg_defaults [ :stdout_path ] ||= "/dev/null" cfg_defaults [ :stderr_path ] ||= "/dev/null" end
->Raw Target:
See Stevens s Advanced Programming in the UNIX Environment chapter 13
--

1055=========
->Original Input:
['def', 'reopen_io', '(', 'io', ',', 'path', ')', 'io', '.', 'reopen', '(', '::', 'File', '.', 'open', '(', 'path', ',', '"ab"', ')', ')', 'if', 'path', 'io', '.', 'sync', '=', 'true', 'end']
->Original Target:
['Redirect', 'file', 'descriptors', 'inherited', 'from', 'the', 'parent', '.']
->Reconstructed Target:
Redirect file descriptors inherited from the parent.
->Reconstructed Predication:
 def reopen_io ( io
->Raw Input:
summarize:def reopen_io ( io, path ) io. reopen ( :: File. open ( path, "ab" ) ) if path io. sync = true end
->Raw Target:
Redirect file descriptors inherited from the parent.
--

1056=========
->Original Input:
['def', 'running?', '(', 'path', ')', 'wpid', '=', '::', 'File', '.', 'read', '(', 'path', ')', '.', 'to_i', 'return', 'if', 'wpid', '<=', '0', 'Process', '.', 'kill', '(', '0', ',', 'wpid', ')', 'wpid', 'rescue', 'Errno', '::', 'EPERM', ',', 'Errno', '::', 'ESRCH', ',', 'Errno', '::', 'ENOENT', 'end']
->Original Target:
['Read', 'the', 'working', 'pid', 'from', 'the', 'pid', 'file', '.']
->Reconstructed Target:
Read the working pid from the pid file.
->Reconstructed Predication:
the running process.  defreturn false if path. nil?
->Raw Input:
summarize:def running? ( path ) wpid = :: File. read ( path ). to_i return if wpid <= 0 Process. kill ( 0, wpid ) wpid rescue Errno :: EPERM, Errno :: ESRCH, Errno :: ENOENT end
->Raw Target:
Read the working pid from the pid file.
--

1057=========
->Original Input:
['def', 'write_pid', '(', 'pid', ')', '::', 'File', '.', 'open', '(', 'pid', ',', "'w'", ')', '{', '|', 'f', '|', 'f', '.', 'write', '(', '"#{Process.pid}"', ')', '}', 'at_exit', '{', '::', 'File', '.', 'delete', '(', 'pid', ')', 'if', '::', 'File', '.', 'exist?', '(', 'pid', ')', 'rescue', 'nil', '}', 'end']
->Original Target:
['Write', 'the', 'pid', '.']
->Reconstructed Target:
Write the pid.
->Reconstructed Predication:
 def write_pid pid
->Raw Input:
summarize:def write_pid ( pid ) :: File. open ( pid, 'w' ) { | f | f. write ( "#{Process.pid}" ) } at_exit { :: File. delete ( pid ) if :: File. exist? ( pid ) rescue nil } end
->Raw Target:
Write the pid.
--

1058=========
->Original Input:
['def', 'parse_mead', '(', '*', 'args', ')', 'parts', '=', '@mead', '.', 'split', '(', "'-'", ')', 'args', '.', 'each_with_index', 'do', '|', 'field', ',', 'i', '|', 'instance_variable_set', '(', "'@'", '+', 'field', ',', 'parts', '[', 'i', ']', ')', 'end', 'end']
->Original Target:
['If', 'a', 'location', 'is', 'given', 'then', 'extraction', 'can', 'take', 'place']
->Reconstructed Target:
If a location is given then extraction can take place
->Reconstructed Predication:
the mead name. 
->Raw Input:
summarize:def parse_mead ( * args ) parts = @mead. split ( '-' ) args. each_with_index do | field, i | instance_variable_set ( '@' + field, parts [ i ] ) end end
->Raw Target:
If a location is given then extraction can take place
--

1059=========
->Original Input:
['def', 'load', '(', '*', 'file_names', ')', 'file_names', '.', 'flatten', '.', 'each', 'do', '|', 'file_name', '|', 'xml', '=', 'File', '.', 'open', '(', 'file_name', ',', "'r'", ')', 'do', '|', 'file', '|', 'Nokogiri', '::', 'XML', '(', 'file', ')', 'do', '|', 'config', '|', 'if', '@pretty', 'then', 'config', '.', 'default_xml', '.', 'noblanks', 'end', 'end', 'end', '@documents', '<<', 'Document', '.', 'new', '(', 'file_name', ',', 'xml', ')', 'end', 'end']
->Original Target:
['Intialize', 'a', 'new', 'mixml', 'tool', 'Load', 'XML', 'files']
->Reconstructed Target:
Intialize a new mixml tool Load XML files
->Reconstructed Predication:
the document to be loaded
->Raw Input:
summarize:def load ( * file_names ) file_names. flatten. each do | file_name | xml = File. open ( file_name, 'r' ) do | file | Nokogiri :: XML ( file ) do | config | if @pretty then config. default_xml. noblanks end end end @documents << Document. new ( file_name, xml ) end end
->Raw Target:
Intialize a new mixml tool Load XML files
--

1060=========
->Original Input:
['def', 'save_all', 'output_all', 'do', '|', 'document', ',', 'options', '|', 'File', '.', 'open', '(', 'document', '.', 'name', ',', "'w'", ')', 'do', '|', 'file', '|', 'document', '.', 'xml', '.', 'write_xml_to', '(', 'file', ',', 'options', ')', 'end', 'end', 'end']
->Original Target:
['Save', 'all', 'loaded', 'XML', 'files']
->Reconstructed Target:
Save all loaded XML files
->Reconstructed Predication:
the document to the file
->Raw Input:
summarize:def save_all output_all do | document, options | File. open ( document. name, 'w' ) do | file | document. xml. write_xml_to ( file, options ) end end end
->Raw Target:
Save all loaded XML files
--

1061=========
->Original Input:
['def', 'print_all', 'output_all', 'do', '|', 'document', ',', 'options', '|', 'if', '@documents', '.', 'size', '>', '1', 'then', 'puts', "'-'", '*', 'document', '.', 'name', '.', 'length', 'puts', 'document', '.', 'name', 'puts', "'-'", '*', 'document', '.', 'name', '.', 'length', 'end', 'puts', 'document', '.', 'xml', '.', 'to_xml', '(', 'options', ')', 'end', 'end']
->Original Target:
['Print', 'all', 'loaded', 'XML', 'files']
->Reconstructed Target:
Print all loaded XML files
->Reconstructed Predication:
the document to the output
->Raw Input:
summarize:def print_all output_all do | document, options | if @documents. size > 1 then puts '-' * document. name. length puts document. name puts '-' * document. name. length end puts document. xml. to_xml ( options ) end end
->Raw Target:
Print all loaded XML files
--

1062=========
->Original Input:
['def', 'work', '(', '*', 'file_names', ',', '&', 'block', ')', 'remove_all', 'file_names', '.', 'each', 'do', '|', 'file_name', '|', 'load', '(', 'file_name', ')', 'if', 'not', 'block', '.', 'nil?', 'then', 'execute', '(', '&', 'block', ')', 'end', 'flush', 'remove_all', 'end', 'end']
->Original Target:
['Perform', 'work', 'on', 'a', 'list', 'of', 'XML', 'files']
->Reconstructed Target:
Perform work on a list of XML files
->Reconstructed Predication:
the file to be processed
->Raw Input:
summarize:def work ( * file_names, & block ) remove_all file_names. each do | file_name | load ( file_name ) if not block. nil? then execute ( & block ) end flush remove_all end end
->Raw Target:
Perform work on a list of XML files
--

1063=========
->Original Input:
['def', 'xpath', '(', '*', 'paths', ',', '&', 'block', ')', 'nodesets', '=', '[', ']', 'process', 'do', '|', 'xml', '|', 'nodesets', '<<', 'xml', '.', 'xpath', '(', '*', 'paths', ')', 'end', 'selection', '=', 'Selection', '.', 'new', '(', 'nodesets', ')', 'if', 'block_given?', 'then', 'Docile', '.', 'dsl_eval', '(', 'selection', ',', '&', 'block', ')', 'end', 'selection', 'end']
->Original Target:
['Select', 'nodes', 'using', 'an', 'XPath', 'expression', 'and', 'execute', 'DSL', 'commands', 'for', 'these', 'nodes']
->Reconstructed Target:
Select nodes using an XPath expression and execute DSL commands for these nodes
->Reconstructed Predication:
the nodesets that are xpath
->Raw Input:
summarize:def xpath ( * paths, & block ) nodesets = [ ] process do | xml | nodesets << xml. xpath ( * paths ) end selection = Selection. new ( nodesets ) if block_given? then Docile. dsl_eval ( selection, & block ) end selection end
->Raw Target:
Select nodes using an XPath expression and execute DSL commands for these nodes
--

1064=========
->Original Input:
['def', 'css', '(', '*', 'selectors', ',', '&', 'block', ')', 'nodesets', '=', '[', ']', 'process', 'do', '|', 'xml', '|', 'nodesets', '<<', 'xml', '.', 'css', '(', '*', 'selectors', ')', 'end', 'selection', '=', 'Selection', '.', 'new', '(', 'nodesets', ')', 'if', 'block_given?', 'then', 'Docile', '.', 'dsl_eval', '(', 'selection', ',', '&', 'block', ')', 'end', 'selection', 'end']
->Original Target:
['Select', 'nodes', 'using', 'CSS', 'selectors', 'and', 'execute', 'DSL', 'commands', 'for', 'these', 'nodes']
->Reconstructed Target:
Select nodes using CSS selectors and execute DSL commands for these nodes
->Reconstructed Predication:
the document to be rendered
->Raw Input:
summarize:def css ( * selectors, & block ) nodesets = [ ] process do | xml | nodesets << xml. css ( * selectors ) end selection = Selection. new ( nodesets ) if block_given? then Docile. dsl_eval ( selection, & block ) end selection end
->Raw Target:
Select nodes using CSS selectors and execute DSL commands for these nodes
--

1065=========
->Original Input:
['def', 'execute', '(', 'program', '=', 'nil', ',', '&', 'block', ')', 'if', 'not', 'program', '.', 'nil?', 'then', 'instance_eval', '(', 'program', ')', 'end', 'if', 'not', 'block', '.', 'nil?', 'then', 'Docile', '.', 'dsl_eval', '(', 'self', ',', '&', 'block', ')', 'end', 'end']
->Original Target:
['Execute', 'a', 'script', 'or', 'a', 'block']
->Reconstructed Target:
Execute a script or a block
->Reconstructed Predication:
the program and the block to
->Raw Input:
summarize:def execute ( program = nil, & block ) if not program. nil? then instance_eval ( program ) end if not block. nil? then Docile. dsl_eval ( self, & block ) end end
->Raw Target:
Execute a script or a block
--

1066=========
->Original Input:
['def', 'with_nodes', '(', 'selection', ')', 'selection', '.', 'nodesets', '.', 'each', 'do', '|', 'nodeset', '|', 'nodeset', '.', 'each', 'do', '|', 'node', '|', 'yield', 'node', 'end', 'end', 'end']
->Original Target:
['Execute', 'block', 'for', 'each', 'node']
->Reconstructed Target:
Execute block for each node
->Reconstructed Predication:
the nodes to be selected
->Raw Input:
summarize:def with_nodes ( selection ) selection. nodesets. each do | nodeset | nodeset. each do | node | yield node end end end
->Raw Target:
Execute block for each node
--

1067=========
->Original Input:
['def', 'tagify', 'input', 'output', '=', 'input', '.', 'dup', 'raise', 'StandardError', ',', '"@tags is empty!"', 'if', '@tags', '.', 'empty?', '@tags', '.', 'each', '{', '|', 'key', ',', 'value', '|', 'output', '.', 'gsub!', '(', 'tag_start', '.', 'to_s', '+', 'key', '.', 'to_s', '+', 'tag_end', '.', 'to_s', ',', 'value', '.', 'to_s', ')', '}', 'return', 'output', 'end']
->Original Target:
['Tagifies', 'the', 'supplied', 'input', '.']
->Reconstructed Target:
Tagifies the supplied input.
->Reconstructed Predication:
the tags to be tagged
->Raw Input:
summarize:def tagify input output = input. dup raise StandardError, "@tags is empty!" if @tags. empty? @tags. each { | key, value | output. gsub! ( tag_start. to_s + key. to_s + tag_end. to_s, value. to_s ) } return output end
->Raw Target:
Tagifies the supplied input.
--

1068=========
->Original Input:
['def', 'option_group', '(', '*', 'args', ')', 'selector', '=', 'if', 'args', '.', 'first', '.', 'respond_to?', '(', ':elements', ')', 'args', '.', 'first', 'else', 'extract_selector', '(', 'args', ')', 'end', 'OptionGroup', '.', 'new', '(', 'self', ',', 'selector', ')', 'end']
->Original Target:
['Returns', 'an', 'OptionGroup']
->Reconstructed Target:
Returns an OptionGroup
->Reconstructed Predication:
option group options  def option_group
->Raw Input:
summarize:def option_group ( * args ) selector = if args. first. respond_to? ( :elements ) args. first else extract_selector ( args ) end OptionGroup. new ( self, selector ) end
->Raw Target:
Returns an OptionGroup
--

1069=========
->Original Input:
['def', 'execute', '(', 'args', ')', 'target_file', '=', '@config_file', '.', 'nil?', '?', '"caramel.rb"', ':', '@config_file', 'FileUtils', '.', 'cp', '(', 'File', '.', 'dirname', '(', '__FILE__', ')', '+', '"/../caramel.rb"', ',', 'target_file', ')', 'if', 'commandparser', '.', 'verbosity', '==', ':normal', 'puts', '"Created new configuration file: #{target_file}"', 'end', 'end']
->Original Target:
['Create', 'a', 'caramelize', 'config', 'file', '.']
->Reconstructed Target:
Create a caramelize config file.
->Reconstructed Predication:
the configuration file to be.
->Raw Input:
summarize:def execute ( args ) target_file = @config_file. nil?? "caramel.rb" : @config_file FileUtils. cp ( File. dirname ( __FILE__ ) + "/../caramel.rb", target_file ) if commandparser. verbosity == :normal puts "Created new configuration file: #{target_file}" end end
->Raw Target:
Create a caramelize config file.
--

1070=========
->Original Input:
['def', 'has_machete_workflow_of', '(', 'jobs_active_record_relation_symbol', ')', 'cattr_accessor', ':jobs_active_record_relation_symbol', 'self', '.', 'jobs_active_record_relation_symbol', '=', 'jobs_active_record_relation_symbol', 'self', '.', 'send', ':include', ',', 'OscMacheteRails', '::', 'Workflow', '::', 'JobsRelation', 'self', '.', 'send', ':include', ',', 'OscMacheteRails', '::', 'Workflow', '::', 'BuilderMethods', 'self', '.', 'send', ':include', ',', 'OscMacheteRails', '::', 'Workflow', '::', 'StatusMethods', 'end']
->Original Target:
['Registers', 'a', 'workflow', 'relationship', 'and', 'sets', 'up', 'a', 'hook', 'to', 'additional', 'builder', 'methods', '.']
->Reconstructed Target:
Registers a workflow relationship and sets up a hook to additional builder methods.
->Reconstructed Predication:
the workflow to be run
->Raw Input:
summarize:def has_machete_workflow_of ( jobs_active_record_relation_symbol ) cattr_accessor :jobs_active_record_relation_symbol self. jobs_active_record_relation_symbol = jobs_active_record_relation_symbol self. send :include, OscMacheteRails :: Workflow :: JobsRelation self. send :include, OscMacheteRails :: Workflow :: BuilderMethods self. send :include, OscMacheteRails :: Workflow :: StatusMethods end
->Raw Target:
Registers a workflow relationship and sets up a hook to additional builder methods.
--

1071=========
->Original Input:
['def', 'check_retry', 'if', '@finished_publishing', '&&', '@pending_hash', '.', 'empty?', '&&', '@exception_count', '>', '0', '&&', '(', '@retry', '||', '@auto_retry', ')', 'return', 'if', '!', '@retry', '&&', '@auto_retry', '&&', '@exception_count', '==', '@exceptions_per_run', '.', 'last', 'Qwirk', '.', 'logger', '.', 'info', '"#{self}: Retrying exception records, exception count = #{@exception_count}"', '@exceptions_per_run', '<<', '@exception_count', '@exception_count', '=', '0', '@finished_publishing', '=', 'false', '@fail_thread', '=', 'Thread', '.', 'new', '(', '@exceptions_per_run', '.', 'last', ')', 'do', '|', 'count', '|', 'begin', 'java', '.', 'lang', '.', 'Thread', '.', 'current_thread', '.', 'name', '=', '"Qwirk fail task: #{task_id}"', 'while', '!', '@stopped', '&&', '(', 'count', '>', '0', ')', '&&', '(', 'object', '=', '@fail_consumer', '.', 'receive', ')', 'count', '-=', '1', 'publish', '(', 'object', ')', '@fail_consumer', '.', 'acknowledge_message', 'end', '@finished_publishing', '=', 'true', '@pending_hash_mutex', '.', 'synchronize', '{', 'check_finish', '}', 'rescue', 'Exception', '=>', 'e', 'do_stop', 'Qwirk', '.', 'logger', '.', 'error', '"#{self}: Exception, thread terminating: #{e.message}\\n\\t#{e.backtrace.join("\\n\\t")}"', 'end', 'end', 'end', 'end']
->Original Target:
['Must', 'be', 'called', 'within', 'a', 'mutex', 'synchronize']
->Reconstructed Target:
Must be called within a mutex synchronize
->Reconstructed Predication:
@exception_count += 1@exception_count@exception_count@exception_count
->Raw Input:
summarize:def check_retry if @finished_publishing && @pending_hash. empty? && @exception_count > 0 && ( @retry || @auto_retry ) return if! @retry && @auto_retry && @exception_count == @exceptions_per_run. last Qwirk. logger. info "#{self}: Retrying exception records, exception count = #{@exception_count}" @exceptions_per_run << @exception_count @exception_count = 0 @finished_publishing = false @fail_thread = Thread. new ( @exceptions_per_run. last ) do | count | begin java. lang. Thread. current_thread. name = "Qwirk fail task: #{task_id}" while! @stopped && ( count > 0 ) && ( object = @fail_consumer. receive ) count -= 1 publish ( object ) @fail_consumer. acknowledge_message end @finished_publishing = true @pending_hash_mutex. synchronize { check_finish } rescue Exception => e do_stop Qwirk. logger. error "#{self}: Exception, thread terminating: #{e.message}\n\t#{e.backtrace.join("\n\t")}" end end end end
->Raw Target:
Must be called within a mutex synchronize
--

1072=========
->Original Input:
['def', 'run', 'program', ':name', ',', "'mixml'", 'program', ':version', ',', 'Mixml', '::', 'VERSION', 'program', ':description', ',', "'XML helper tool'", '$tool', '=', 'Mixml', '::', 'Tool', '.', 'new', 'global_option', '(', "'-p'", ',', "'--pretty'", ',', "'Pretty print output'", ')', 'do', '|', 'value', '|', '$tool', '.', 'pretty', '=', 'value', 'end', 'global_option', '(', "'-i'", ',', "'--inplace'", ',', "'Replace the processed files with the new files'", ')', 'do', '|', 'value', '|', '$tool', '.', 'save', '=', 'value', '$tool', '.', 'print', '=', '!', 'value', 'end', 'global_option', '(', "'-q'", ',', "'--quiet'", ',', "'Do not print nodes'", ')', 'do', '|', 'value', '|', '$tool', '.', 'print', '=', '!', 'value', 'end', 'command', ':pretty', 'do', '|', 'c', '|', 'c', '.', 'description', '=', "'Pretty print XML files'", 'c', '.', 'action', 'do', '|', 'args', ',', 'options', '|', '$tool', '.', 'pretty', '=', 'true', '$tool', '.', 'work', '(', 'args', ')', 'end', 'end', 'modify_command', ':write', 'do', '|', 'c', '|', 'c', '.', 'description', '=', "'Write selected nodes to the console'", 'c', '.', 'suppress_output', '=', 'true', 'c', '.', 'optional_expression', '=', 'true', 'end', 'select_command', ':remove', 'do', '|', 'c', '|', 'c', '.', 'description', '=', "'Remove nodes from the XML documents'", 'end', 'modify_command', ':replace', 'do', '|', 'c', '|', 'c', '.', 'description', '=', "'Replace nodes in the XML documents'", 'end', 'modify_command', ':append', 'do', '|', 'c', '|', 'c', '.', 'description', '=', "'Append child nodes in the XML documents'", 'end', 'modify_command', ':rename', 'do', '|', 'c', '|', 'c', '.', 'description', '=', "'Rename nodes in the XML documents'", 'end', 'modify_command', ':value', 'do', '|', 'c', '|', 'c', '.', 'description', '=', "'Set node values'", 'end', 'command', ':execute', 'do', '|', 'c', '|', 'c', '.', 'description', '=', "'Execute script on the XML documents'", 'c', '.', 'option', "'-s'", ',', "'--script STRING'", ',', 'String', ',', "'Script file to execute'", 'c', '.', 'option', "'-e'", ',', "'--expression STRING'", ',', 'String', ',', "'Command to execute'", 'c', '.', 'action', 'do', '|', 'args', ',', 'options', '|', 'script', '=', 'options', '.', 'expression', '||', 'File', '.', 'read', '(', 'options', '.', 'script', ')', '$tool', '.', 'work', '(', 'args', ')', 'do', 'execute', '(', 'script', ')', 'end', 'end', 'end', 'run!', 'end']
->Original Target:
['Run', 'the', 'mixml', 'command']
->Reconstructed Target:
Run the mixml command
->Reconstructed Predication:
the XML.........................
->Raw Input:
summarize:def run program :name,'mixml' program :version, Mixml :: VERSION program :description, 'XML helper tool' $tool = Mixml :: Tool. new global_option ( '-p', '--pretty', 'Pretty print output' ) do | value | $tool. pretty = value end global_option ( '-i', '--inplace', 'Replace the processed files with the new files' ) do | value | $tool. save = value $tool. print =! value end global_option ( '-q', '--quiet', 'Do not print nodes' ) do | value | $tool. print =! value end command :pretty do | c | c. description = 'Pretty print XML files' c. action do | args, options | $tool. pretty = true $tool. work ( args ) end end modify_command :write do | c | c. description = 'Write selected nodes to the console' c. suppress_output = true c. optional_expression = true end select_command :remove do | c | c. description = 'Remove nodes from the XML documents' end modify_command :replace do | c | c. description = 'Replace nodes in the XML documents' end modify_command :append do | c | c. description = 'Append child nodes in the XML documents' end modify_command :rename do | c | c. description = 'Rename nodes in the XML documents' end modify_command :value do | c | c. description = 'Set node values' end command :execute do | c | c. description = 'Execute script on the XML documents' c. option '-s', '--script STRING', String, 'Script file to execute' c. option '-e', '--expression STRING', String, 'Command to execute' c. action do | args, options | script = options. expression || File. read ( options. script ) $tool. work ( args ) do execute ( script ) end end end run! end
->Raw Target:
Run the mixml command
--

1073=========
->Original Input:
['def', 'list', 'entities', '=', '@db', '.', 'list', 'out', 'entities', '=', 'entities', '.', 'is_a?', '(', 'Fixnum', ')', '?', '@db', '.', 'list', '[', '0', '...', 'entities', ']', ':', 'entities', 'entities', '.', 'reject', '{', '|', 'e', '|', 'e', '[', ':status', ']', '==', ':removed', '}', '.', 'each_with_index', 'do', '|', 'e', ',', 'i', '|', 'out', '" [#{i}]"', '.', 'blue', '+', '"#{e.sticky?? " + ".bold : "   "}"', '+', 'e', '[', ':title', ']', '.', 'underline', '+', '" #{e[:tags].join(\' \')}"', '.', 'cyan', 'end', '.', 'tap', 'do', '|', 'list', '|', 'out', '" ..."', 'if', '@db', '.', 'list', '.', 'length', '>', 'entities', '.', 'length', '&&', '!', 'entities', '.', 'length', '.', 'zero?', 'out', '"  there are no koi in the water"', '.', 'green', 'if', 'list', '.', 'size', '.', 'zero?', 'end', 'out', 'entities', 'end']
->Original Target:
['List', 'current', 'tasks']
->Reconstructed Target:
List current tasks
->Reconstructed Predication:
the water. green + " . green + " . green + " 
->Raw Input:
summarize:def list entities = @db. list out entities = entities. is_a? ( Fixnum )? @db. list [ 0... entities ] : entities entities. reject { | e | e [ :status ] == :removed }. each_with_index do | e, i | out " [#{i}]". blue + "#{e.sticky?? " + ".bold : "   "}" + e [ :title ]. underline + " #{e[:tags].join(' ')}". cyan end. tap do | list | out "..." if @db. list. length > entities. length &&! entities. length. zero? out "  there are no koi in the water". green if list. size. zero? end out entities end
->Raw Target:
List current tasks
--

1074=========
->Original Input:
['def', 'method_missing', 'meth', ',', '*', 'args', ',', '&', 'blk', 'if', 'meth', '.', 'to_s', '.', 'end_with?', '(', "'?'", ')', '&&', 'Status', '.', 'include?', '(', 's', '=', 'meth', '.', 'to_s', '.', 'chop', '.', 'to_sym', ')', 'self', '[', ':status', ']', '==', 's', 'else', 'super', 'end', 'end']
->Original Target:
['Handle', 'things', 'like', 'self', '.', 'removed?']
->Reconstructed Target:
Handle things like self. removed?
->Reconstructed Predication:
the method to call with thethe method to call with the
->Raw Input:
summarize:def method_missing meth, * args, & blk if meth. to_s. end_with? ( '?' ) && Status. include? ( s = meth. to_s. chop. to_sym ) self [ :status ] == s else super end end
->Raw Target:
Handle things like self. removed?
--

1075=========
->Original Input:
['def', 'v3_get', '(', 'path', ',', 'options', '=', '{', '}', ')', 'get_params', '=', '{', ':method', '=>', '"get"', '}', 'get_params', '[', ':params', ']', '=', 'options', 'unless', 'options', '.', 'empty?', 'v3_do_request', '(', 'get_params', ',', 'path', ',', ':cache', '=>', 'true', ')', 'end']
->Original Target:
['Perform', 'a', 'GET', 'request', 'options', 'hash', 'should', 'contain', 'query', 'parameters']
->Reconstructed Target:
Perform a GET request options hash should contain query parameters
->Reconstructed Predication:
GET a path with query parameters
->Raw Input:
summarize:def v3_get ( path, options = { } ) get_params = { :method => "get" } get_params [ :params ] = options unless options. empty? v3_do_request ( get_params, path, :cache => true ) end
->Raw Target:
Perform a GET request options hash should contain query parameters
--

1076=========
->Original Input:
['def', 'v3_put', '(', 'path', ',', 'options', '=', '{', '}', ')', 'expire_matching', '"#{parent_path(path)}.*"', 'put_params', '=', '{', ':method', '=>', '"put"', ',', ':body', '=>', 'options', '[', ':body', ']', '?', 'options', '[', ':body', ']', ':', 'form_encode', '(', 'options', ')', '}', 'if', 'options', '[', ':content_type', ']', 'put_params', '[', ':headers', ']', '=', '{', ":'", "'", '=>', 'content_type', '(', 'options', '[', ':content_type', ']', ')', '}', 'end', 'v3_do_request', '(', 'put_params', ',', 'path', ')', 'end']
->Original Target:
['Perform', 'a', 'PUT', 'request', 'options', 'hash', 'should', 'contain', 'request', 'body', 'parameters']
->Reconstructed Target:
Perform a PUT request options hash should contain request body parameters
->Reconstructed Predication:
the content of the resourcethe resource you want to
->Raw Input:
summarize:def v3_put ( path, options = { } ) expire_matching "#{parent_path(path)}.*" put_params = { :method => "put", :body => options [ :body ]? options [ :body ] : form_encode ( options ) } if options [ :content_type ] put_params [ :headers ] = { :''=> content_type ( options [ :content_type ] ) } end v3_do_request ( put_params, path ) end
->Raw Target:
Perform a PUT request options hash should contain request body parameters
--

1077=========
->Original Input:
['def', 'v3_do_request', '(', 'params', ',', 'path', ',', 'options', '=', '{', '}', ')', 'req', '=', 'Typhoeus', '::', 'Request', '.', 'new', '(', '"https://#{v3_hostname}#{path}"', ',', 'v3_defaults', '.', 'merge', '(', 'params', ')', ')', 'response', '=', 'do_request', '(', 'req', ',', ':xml', ',', 'options', ')', 'options', '[', ':return_obj', ']', '==', 'true', '?', 'response', ':', 'response', '.', 'body', 'end']
->Original Target:
['Wrap', 'up', 'parameters', 'into', 'a', 'request', 'and', 'execute', 'it']
->Reconstructed Target:
Wrap up parameters into a request and execute it
->Reconstructed Predication:
the request to the API
->Raw Input:
summarize:def v3_do_request ( params, path, options = { } ) req = Typhoeus :: Request. new ( "https://#{v3_hostname}#{path}", v3_defaults. merge ( params ) ) response = do_request ( req, :xml, options ) options [ :return_obj ] == true? response : response. body end
->Raw Target:
Wrap up parameters into a request and execute it
--

1078=========
->Original Input:
['def', 'add', '(', 'token', ',', 'timestamp', '=', 'nil', ')', '@net', '.', 'call_callbacks', '(', ':place', ',', ':add', ',', 'Event', '.', 'new', '(', '@name', ',', '[', 'token', ']', ',', '@net', ')', ')', 'unless', '@net', '.', 'nil?', 'if', 'timestamp', '.', 'nil?', '@marking', '.', 'add', 'token', 'else', '@marking', '.', 'add', 'token', ',', 'timestamp', 'end', 'end']
->Original Target:
['Adds', 'token', 'with', 'specified', 'timestamp', 'to', 'the', 'place', '.', 'Any', 'callbacks', 'defined', 'for', 'places', 'will', 'be', 'fired', '.']
->Reconstructed Target:
Adds token with specified timestamp to the place. Any callbacks defined for places will be fired.
->Reconstructed Predication:
the event to be added
->Raw Input:
summarize:def add ( token, timestamp = nil ) @net. call_callbacks ( :place, :add, Event. new ( @name, [ token ], @net ) ) unless @net. nil? if timestamp. nil? @marking. add token else @marking. add token, timestamp end end
->Raw Target:
Adds token with specified timestamp to the place. Any callbacks defined for places will be fired.
--

1079=========
->Original Input:
['def', 'authorize', 'client_id', '=', 'Google', '::', 'Auth', '::', 'ClientId', '.', 'from_file', '(', 'CLIENT_SECRETS_PATH', ')', 'token_store', '=', 'Google', '::', 'Auth', '::', 'Stores', '::', 'FileTokenStore', '.', 'new', '(', 'file', ':', 'CREDENTIALS_PATH', ')', 'authorizer', '=', 'Google', '::', 'Auth', '::', 'UserAuthorizer', '.', 'new', '(', 'client_id', ',', 'SCOPE', ',', 'token_store', ')', 'user_id', '=', "'default'", 'credentials', '=', 'authorizer', '.', 'get_credentials', '(', 'user_id', ')', 'if', 'credentials', '.', 'nil?', 'url', '=', 'authorizer', '.', 'get_authorization_url', '(', 'base_url', ':', 'OOB_URI', ')', 'puts', "'Open the following URL in the browser and enter the '", '"resulting code after authorization:\\n"', '+', 'url', 'code', '=', 'STDIN', '.', 'gets', 'credentials', '=', 'authorizer', '.', 'get_and_store_credentials_from_code', '(', 'user_id', ':', 'user_id', ',', 'code', ':', 'code', ',', 'base_url', ':', 'OOB_URI', ')', 'end', 'credentials', 'end']
->Original Target:
['Ensure', 'valid', 'credentials', 'either', 'by', 'restoring', 'from', 'the', 'saved', 'credentials', 'files', 'or', 'intitiating', 'an', 'OAuth2', 'authorization', '.', 'If', 'authorization', 'is', 'required', 'the', 'user', 's', 'default', 'browser', 'will', 'be', 'launched', 'to', 'approve', 'the', 'request', '.']
->Reconstructed Target:
Ensure valid credentials either by restoring from the saved credentials files or intitiating an OAuth2 authorization. If authorization is required the user s default browser will be launched to approve the request.
->Reconstructed Predication:
the clientthe client credentials for thethe client credentials for thethe client credentials for thethe client credentials for thethe client credentials for thethe client credentials for thethe client credentials for thethe client credentials for thethe client credentials for the
->Raw Input:
summarize:def authorize client_id = Google :: Auth :: ClientId. from_file ( CLIENT_SECRETS_PATH ) token_store = Google :: Auth :: Stores :: FileTokenStore. new ( file : CREDENTIALS_PATH ) authorizer = Google :: Auth :: UserAuthorizer. new ( client_id, SCOPE, token_store ) user_id = 'default' credentials = authorizer. get_credentials ( user_id ) if credentials. nil? url = authorizer. get_authorization_url ( base_url : OOB_URI ) puts 'Open the following URL in the browser and enter the'"resulting code after authorization:\n" + url code = STDIN. gets credentials = authorizer. get_and_store_credentials_from_code ( user_id : user_id, code : code, base_url : OOB_URI ) end credentials end
->Raw Target:
Ensure valid credentials either by restoring from the saved credentials files or intitiating an OAuth2 authorization. If authorization is required the user s default browser will be launched to approve the request.
--

1080=========
->Original Input:
['def', 'get', '(', 'path', ',', 'data', '=', '{', '}', ')', 'format', '=', 'data', '.', 'delete', '(', ':format', ')', '||', '@format', 'get_params', '=', '{', ':method', '=>', '"get"', ',', ':verbose', '=>', 'DEBUG', '}', 'get_params', '[', ':params', ']', '=', 'data', 'unless', 'data', '.', 'empty?', 'get', '=', 'Typhoeus', '::', 'Request', '.', 'new', '(', '"#{protocol}#{@server}#{path}"', ',', 'get_params', ')', 'do_request', '(', 'get', ',', 'format', ',', ':cache', '=>', 'true', ')', 'end']
->Original Target:
['GET', 'data', 'from', 'the', 'API', 'passing', 'in', 'a', 'hash', 'of', 'parameters']
->Reconstructed Target:
GET data from the API passing in a hash of parameters
->Reconstructed Predication:
the request to the specifiedthe request to the specified path
->Raw Input:
summarize:def get ( path, data = { } ) format = data. delete ( :format ) || @format get_params = { :method => "get", :verbose => DEBUG } get_params [ :params ] = data unless data. empty? get = Typhoeus :: Request. new ( "#{protocol}#{@server}#{path}", get_params ) do_request ( get, format, :cache => true ) end
->Raw Target:
GET data from the API passing in a hash of parameters
--

1081=========
->Original Input:
['def', 'post', '(', 'path', ',', 'data', '=', '{', '}', ')', 'format', '=', 'data', '.', 'delete', '(', ':format', ')', '||', '@format', 'expire_matching', '"#{raw_path(path)}.*"', 'query_params', '=', '{', '}', 'query_params', '[', ':returnUnit', ']', '=', 'data', '.', 'delete', '(', ':returnUnit', ')', 'if', 'data', '[', ':returnUnit', ']', 'query_params', '[', ':returnPerUnit', ']', '=', 'data', '.', 'delete', '(', ':returnPerUnit', ')', 'if', 'data', '[', ':returnPerUnit', ']', 'post_params', '=', '{', ':verbose', '=>', 'DEBUG', ',', ':method', '=>', '"post"', ',', ':body', '=>', 'form_encode', '(', 'data', ')', '}', 'post_params', '[', ':params', ']', '=', 'query_params', 'unless', 'query_params', '.', 'empty?', 'post', '=', 'Typhoeus', '::', 'Request', '.', 'new', '(', '"#{protocol}#{@server}#{path}"', ',', 'post_params', ')', 'do_request', '(', 'post', ',', 'format', ')', 'end']
->Original Target:
['POST', 'to', 'the', 'AMEE', 'API', 'passing', 'in', 'a', 'hash', 'of', 'values']
->Reconstructed Target:
POST to the AMEE API passing in a hash of values
->Reconstructed Predication:
thethe request to thethe request to thethe request to thethe request to thethe request to the server.
->Raw Input:
summarize:def post ( path, data = { } ) format = data. delete ( :format ) || @format expire_matching "#{raw_path(path)}.*" query_params = { } query_params [ :returnUnit ] = data. delete ( :returnUnit ) if data [ :returnUnit ] query_params [ :returnPerUnit ] = data. delete ( :returnPerUnit ) if data [ :returnPerUnit ] post_params = { :verbose => DEBUG, :method => "post", :body => form_encode ( data ) } post_params [ :params ] = query_params unless query_params. empty? post = Typhoeus :: Request. new ( "#{protocol}#{@server}#{path}", post_params ) do_request ( post, format ) end
->Raw Target:
POST to the AMEE API passing in a hash of values
--

1082=========
->Original Input:
['def', 'raw_post', '(', 'path', ',', 'body', ',', 'options', '=', '{', '}', ')', 'format', '=', 'options', '.', 'delete', '(', ':format', ')', '||', '@format', 'expire_matching', '"#{raw_path(path)}.*"', 'post', '=', 'Typhoeus', '::', 'Request', '.', 'new', '(', '"#{protocol}#{@server}#{path}"', ',', ':verbose', '=>', 'DEBUG', ',', ':method', '=>', '"post"', ',', ':body', '=>', 'body', ',', ':headers', '=>', '{', ":'", "'", '=>', 'options', '[', ':content_type', ']', '||', 'content_type', '(', 'format', ')', '}', ')', 'do_request', '(', 'post', ',', 'format', ')', 'end']
->Original Target:
['POST', 'to', 'the', 'AMEE', 'API', 'passing', 'in', 'a', 'string', 'of', 'data']
->Reconstructed Target:
POST to the AMEE API passing in a string of data
->Reconstructed Predication:
the request body and thethe body and the bodythe body and the body
->Raw Input:
summarize:def raw_post ( path, body, options = { } ) format = options. delete ( :format ) || @format expire_matching "#{raw_path(path)}.*" post = Typhoeus :: Request. new ( "#{protocol}#{@server}#{path}", :verbose => DEBUG, :method => "post", :body => body, :headers => { :''=> options [ :content_type ] || content_type ( format ) } ) do_request ( post, format ) end
->Raw Target:
POST to the AMEE API passing in a string of data
--

1083=========
->Original Input:
['def', 'put', '(', 'path', ',', 'data', '=', '{', '}', ')', 'format', '=', 'data', '.', 'delete', '(', ':format', ')', '||', '@format', 'expire_matching', '"#{parent_path(path)}.*"', 'query_params', '=', '{', '}', 'query_params', '[', ':returnUnit', ']', '=', 'data', '.', 'delete', '(', ':returnUnit', ')', 'if', 'data', '[', ':returnUnit', ']', 'query_params', '[', ':returnPerUnit', ']', '=', 'data', '.', 'delete', '(', ':returnPerUnit', ')', 'if', 'data', '[', ':returnPerUnit', ']', 'put_params', '=', '{', ':verbose', '=>', 'DEBUG', ',', ':method', '=>', '"put"', ',', ':body', '=>', 'form_encode', '(', 'data', ')', '}', 'put_params', '[', ':params', ']', '=', 'query_params', 'unless', 'query_params', '.', 'empty?', 'put', '=', 'Typhoeus', '::', 'Request', '.', 'new', '(', '"#{protocol}#{@server}#{path}"', ',', 'put_params', ')', 'do_request', '(', 'put', ',', 'format', ')', 'end']
->Original Target:
['PUT', 'to', 'the', 'AMEE', 'API', 'passing', 'in', 'a', 'hash', 'of', 'data']
->Reconstructed Target:
PUT to the AMEE API passing in a hash of data
->Reconstructed Predication:
thethe request to thethe request to thethe request to thethe request to thethe request to the serverthe request to the serverthe request to the serverthe request to the serverthe request to the serverthe request to the serverthe request to the serverthe request to the serverthe request to the serverthe request to the serverthe request to the serverthe request to the serverthe server
->Raw Input:
summarize:def put ( path, data = { } ) format = data. delete ( :format ) || @format expire_matching "#{parent_path(path)}.*" query_params = { } query_params [ :returnUnit ] = data. delete ( :returnUnit ) if data [ :returnUnit ] query_params [ :returnPerUnit ] = data. delete ( :returnPerUnit ) if data [ :returnPerUnit ] put_params = { :verbose => DEBUG, :method => "put", :body => form_encode ( data ) } put_params [ :params ] = query_params unless query_params. empty? put = Typhoeus :: Request. new ( "#{protocol}#{@server}#{path}", put_params ) do_request ( put, format ) end
->Raw Target:
PUT to the AMEE API passing in a hash of data
--

1084=========
->Original Input:
['def', 'raw_put', '(', 'path', ',', 'body', ',', 'options', '=', '{', '}', ')', 'format', '=', 'options', '.', 'delete', '(', ':format', ')', '||', '@format', 'expire_matching', '"#{parent_path(path)}.*"', 'put', '=', 'Typhoeus', '::', 'Request', '.', 'new', '(', '"#{protocol}#{@server}#{path}"', ',', ':verbose', '=>', 'DEBUG', ',', ':method', '=>', '"put"', ',', ':body', '=>', 'body', ',', ':headers', '=>', '{', ":'", "'", '=>', 'options', '[', ':content_type', ']', '||', 'content_type', '(', 'format', ')', '}', ')', 'do_request', '(', 'put', ',', 'format', ')', 'end']
->Original Target:
['PUT', 'to', 'the', 'AMEE', 'API', 'passing', 'in', 'a', 'string', 'of', 'data']
->Reconstructed Target:
PUT to the AMEE API passing in a string of data
->Reconstructed Predication:
the request body. the request body.
->Raw Input:
summarize:def raw_put ( path, body, options = { } ) format = options. delete ( :format ) || @format expire_matching "#{parent_path(path)}.*" put = Typhoeus :: Request. new ( "#{protocol}#{@server}#{path}", :verbose => DEBUG, :method => "put", :body => body, :headers => { :''=> options [ :content_type ] || content_type ( format ) } ) do_request ( put, format ) end
->Raw Target:
PUT to the AMEE API passing in a string of data
--

1085=========
->Original Input:
['def', 'authenticate', 'request', '=', 'Typhoeus', '::', 'Request', '.', 'new', '(', '"#{protocol}#{@server}/auth/signIn"', ',', ':method', '=>', '"post"', ',', ':verbose', '=>', 'DEBUG', ',', ':headers', '=>', '{', ':Accept', '=>', 'content_type', '(', ':xml', ')', ',', '}', ',', ':body', '=>', 'form_encode', '(', ':username', '=>', '@username', ',', ':password', '=>', '@password', ')', ')', 'hydra', '.', 'queue', '(', 'request', ')', 'hydra', '.', 'run', 'response', '=', 'request', '.', 'response', '@auth_token', '=', 'response', '.', 'headers_hash', '[', "'AuthToken'", ']', 'd', '{', 'request', '.', 'url', '}', 'd', '{', 'response', '.', 'code', '}', 'd', '{', '@auth_token', '}', 'connection_failed', 'if', 'response', '.', 'code', '==', '0', 'unless', 'authenticated?', 'raise', 'AMEE', '::', 'AuthFailed', '.', 'new', '(', '"Authentication failed. Please check your username and password. (tried #{@username},#{@password})"', ')', 'end', 'if', 'response', '.', 'body', '.', 'is_json?', '@version', '=', 'JSON', '.', 'parse', '(', 'response', '.', 'body', ')', '[', '"user"', ']', '[', '"apiVersion"', ']', '.', 'to_f', 'elsif', 'response', '.', 'body', '.', 'is_xml?', '@version', '=', 'REXML', '::', 'Document', '.', 'new', '(', 'response', '.', 'body', ')', '.', 'elements', '[', "'Resources'", ']', '.', 'elements', '[', "'SignInResource'", ']', '.', 'elements', '[', "'User'", ']', '.', 'elements', '[', "'ApiVersion'", ']', '.', 'text', '.', 'to_f', 'else', '@version', '=', '1.0', 'end', 'end']
->Original Target:
['Post', 'to', 'the', 'sign', 'in', 'resource', 'on', 'the', 'API', 'so', 'that', 'all', 'future', 'requests', 'are', 'signed']
->Reconstructed Target:
Post to the sign in resource on the API so that all future requests are signed
->Reconstructed Predication:
auth_token =. body. is_json?auth_token =. body. is_json? @auth_token. body. is_xml? @auth_token. body. is_json? @auth_token. body. is_json? @auth_token. body. is_json? @auth_token. body. is_json? @auth_token. body. is_json?
->Raw Input:
summarize:def authenticate request = Typhoeus :: Request. new ( "#{protocol}#{@server}/auth/signIn", :method => "post", :verbose => DEBUG, :headers => { :Accept => content_type ( :xml ), }, :body => form_encode ( :username => @username, :password => @password ) ) hydra. queue ( request ) hydra. run response = request. response @auth_token = response. headers_hash [ 'AuthToken' ] d { request. url } d { response. code } d { @auth_token } connection_failed if response. code == 0 unless authenticated? raise AMEE :: AuthFailed. new ( "Authentication failed. Please check your username and password. (tried #{@username},#{@password})" ) end if response. body. is_json? @version = JSON. parse ( response. body ) [ "user" ] [ "apiVersion" ]. to_f elsif response. body. is_xml? @version = REXML :: Document. new ( response. body ). elements [ 'Resources' ]. elements [ 'SignInResource' ]. elements [ 'User' ]. elements [ 'ApiVersion' ]. text. to_f else @version = 1.0 end end
->Raw Target:
Post to the sign in resource on the API so that all future requests are signed
--

1086=========
->Original Input:
['def', 'response_ok?', '(', 'response', ',', 'request', ')', 'd', '{', 'request', '.', 'object_id', '}', 'd', '{', 'request', '}', 'd', '{', 'response', '.', 'object_id', '}', 'd', '{', 'response', '.', 'code', '}', 'd', '{', 'response', '.', 'headers_hash', '}', 'd', '{', 'response', '.', 'body', '}', 'case', 'response', '.', 'code', '.', 'to_i', 'when', '502', ',', '503', ',', '504', 'raise', 'AMEE', '::', 'ConnectionFailed', '.', 'new', '(', '"A connection error occurred while talking to AMEE: HTTP response code #{response.code}.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, \'\')}"', ')', 'when', '408', 'raise', 'AMEE', '::', 'TimeOut', '.', 'new', '(', '"Request timed out."', ')', 'when', '404', 'raise', 'AMEE', '::', 'NotFound', '.', 'new', '(', '"The URL was not found on the server.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, \'\')}"', ')', 'when', '403', 'raise', 'AMEE', '::', 'PermissionDenied', '.', 'new', '(', '"You do not have permission to perform the requested operation.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, \'\')}\\n#{request.body}\\Response: #{response.body}"', ')', 'when', '401', 'authenticate', 'return', 'false', 'when', '400', 'if', 'response', '.', 'body', '.', 'include?', '"would have resulted in a duplicate resource being created"', 'raise', 'AMEE', '::', 'DuplicateResource', '.', 'new', '(', '"The specified resource already exists. This is most often caused by creating an item that overlaps another in time.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, \'\')}\\n#{request.body}\\Response: #{response.body}"', ')', 'else', 'raise', 'AMEE', '::', 'BadRequest', '.', 'new', '(', '"Bad request. This is probably due to malformed input data.\\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, \'\')}\\n#{request.body}\\Response: #{response.body}"', ')', 'end', 'when', '200', ',', '201', ',', '204', 'return', 'response', 'when', '0', 'connection_failed', 'end', 'raise', 'AMEE', '::', 'UnknownError', '.', 'new', '(', '"An error occurred while talking to AMEE: HTTP response code #{response.code}.\\nRequest: #{request.method.upcase} #{request.url}\\n#{request.body}\\Response: #{response.body}"', ')', 'end']
->Original Target:
['run', 'each', 'request', 'through', 'some', 'basic', 'error', 'checking', 'and', 'if', 'needed', 'log', 'requests']
->Reconstructed Target:
run each request through some basic error checking and if needed log requests
->Reconstructed Predication:
response. object_id }response. object_id }response. object_id }response. object_id }response. object_idresponse. object_id }response. headers_hashresponse. headers_hash.response. body.response. body.response. body.response. body.response. body.. body.. body.. body.. body.. body
->Raw Input:
summarize:def response_ok? ( response, request ) d { request. object_id } d { request } d { response. object_id } d { response. code } d { response. headers_hash } d { response. body } case response. code. to_i when 502, 503, 504 raise AMEE :: ConnectionFailed. new ( "A connection error occurred while talking to AMEE: HTTP response code #{response.code}.\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}" ) when 408 raise AMEE :: TimeOut. new ( "Request timed out." ) when 404 raise AMEE :: NotFound. new ( "The URL was not found on the server.\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}" ) when 403 raise AMEE :: PermissionDenied. new ( "You do not have permission to perform the requested operation.\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}\n#{request.body}\Response: #{response.body}" ) when 401 authenticate return false when 400 if response. body. include? "would have resulted in a duplicate resource being created" raise AMEE :: DuplicateResource. new ( "The specified resource already exists. This is most often caused by creating an item that overlaps another in time.\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}\n#{request.body}\Response: #{response.body}" ) else raise AMEE :: BadRequest. new ( "Bad request. This is probably due to malformed input data.\nRequest: #{request.method.upcase} #{request.url.gsub(request.host, '')}\n#{request.body}\Response: #{response.body}" ) end when 200, 201, 204 return response when 0 connection_failed end raise AMEE :: UnknownError. new ( "An error occurred while talking to AMEE: HTTP response code #{response.code}.\nRequest: #{request.method.upcase} #{request.url}\n#{request.body}\Response: #{response.body}" ) end
->Raw Target:
run each request through some basic error checking and if needed log requests
--

1087=========
->Original Input:
['def', 'do_request', '(', 'request', ',', 'format', '=', '@format', ',', 'options', '=', '{', '}', ')', 'v3_request', '=', 'request', '.', 'url', '.', 'include?', '(', '"/#{v3_hostname}/"', ')', 'if', '!', '@auth_token', '&&', '!', 'v3_request', 'd', '"Authenticating first before we hit #{request.url}"', 'authenticate', 'end', 'request', '.', 'headers', '[', "'Accept'", ']', '=', 'content_type', '(', 'format', ')', 'request', '.', 'headers', '[', "'X-AMEE-Source'", ']', '=', '@amee_source', 'if', '@amee_source', 'path_and_query', '=', "'/'", '+', 'request', '.', 'url', '.', 'split', '(', "'/'", ',', '4', ')', '[', '3', ']', 'if', 'options', '[', ':cache', ']', 'response', '=', 'cache', '(', 'path_and_query', ')', '{', 'run_request', '(', 'request', ',', ':xml', ')', '}', 'else', 'response', '=', 'run_request', '(', 'request', ',', ':xml', ')', 'end', 'response', 'end']
->Original Target:
['Wrapper', 'for', 'sending', 'requests', 'through', 'to', 'the', 'API', '.', 'Takes', 'care', 'of', 'making', 'sure', 'requests', 'authenticated', 'and', 'if', 'set', 'attempts', 'to', 'retry', 'a', 'number', 'of', 'times', 'set', 'when', 'initialising', 'the', 'class']
->Reconstructed Target:
Wrapper for sending requests through to the API. Takes care of making sure requests authenticated and if set attempts to retry a number of times set when initialising the class
->Reconstructed Predication:
request. url, optionsrequest. headers [ 'Content-Type'headers [ 'Content-Length' ]request. headers [ 'Content-Type'request. headers [ 'Content-Type'request. headers [ 'Content-Length'] )response. body
->Raw Input:
summarize:def do_request ( request, format = @format, options = { } ) v3_request = request. url. include? ( "/#{v3_hostname}/" ) if! @auth_token &&! v3_request d "Authenticating first before we hit #{request.url}" authenticate end request. headers [ 'Accept' ] = content_type ( format ) request. headers [ 'X-AMEE-Source' ] = @amee_source if @amee_source path_and_query = '/' + request. url. split ( '/', 4 ) [ 3 ] if options [ :cache ] response = cache ( path_and_query ) { run_request ( request, :xml ) } else response = run_request ( request, :xml ) end response end
->Raw Target:
Wrapper for sending requests through to the API. Takes care of making sure requests authenticated and if set attempts to retry a number of times set when initialising the class
--

1088=========
->Original Input:
['def', 'run_request', '(', 'request', ',', 'format', ')', 'v3_request', '=', 'request', '.', 'url', '.', 'include?', '(', '"/#{v3_hostname}/"', ')', 'retries', '=', '[', '1', ']', '*', '@retries', 'begin', 'begin', 'd', '"Queuing the request for #{request.url}"', 'add_authentication_to', '(', 'request', ')', 'if', '@auth_token', '&&', '!', 'v3_request', 'hydra', '.', 'queue', 'request', 'hydra', '.', 'run', 'end', 'while', '!', 'response_ok?', '(', 'request', '.', 'response', ',', 'request', ')', '@auth_token', '=', 'request', '.', 'response', '.', 'headers_hash', '[', "'AuthToken'", ']', 'return', 'request', '.', 'response', 'rescue', 'AMEE', '::', 'ConnectionFailed', ',', 'AMEE', '::', 'TimeOut', '=>', 'e', 'if', 'delay', '=', 'retries', '.', 'shift', 'sleep', 'delay', 'retry', 'else', 'raise', 'end', 'end', 'end']
->Original Target:
['run', 'request', '.', 'Extracted', 'from', 'do_request', 'to', 'make', 'cache', 'code', 'simpler']
->Reconstructed Target:
run request. Extracted from do_request to make cache code simpler
->Reconstructed Predication:
the request for thethe request for thethe request for thethe request for thethe request for thethe request for thethe request for thethe request for thethe request for thethe request for the
->Raw Input:
summarize:def run_request ( request, format ) v3_request = request. url. include? ( "/#{v3_hostname}/" ) retries = [ 1 ] * @retries begin begin d "Queuing the request for #{request.url}" add_authentication_to ( request ) if @auth_token &&! v3_request hydra. queue request hydra. run end while! response_ok? ( request. response, request ) @auth_token = request. response. headers_hash [ 'AuthToken' ] return request. response rescue AMEE :: ConnectionFailed, AMEE :: TimeOut => e if delay = retries. shift sleep delay retry else raise end end end
->Raw Target:
run request. Extracted from do_request to make cache code simpler
--

1089=========
->Original Input:
['def', 'timed_place', '(', 'name', ',', 'keys', '=', '{', '}', ')', 'place', '=', 'create_or_find_place', '(', 'name', ',', 'keys', ',', 'TimedPlace', ')', '@timed_places', '[', 'place', ']', '=', 'true', 'place', 'end']
->Original Target:
['Create', 'and', 'return', 'a', 'new', 'timed', 'place', 'for', 'this', 'model', '.']
->Reconstructed Target:
Create and return a new timed place for this model.
->Reconstructed Predication:
a timed place. 
->Raw Input:
summarize:def timed_place ( name, keys = { } ) place = create_or_find_place ( name, keys, TimedPlace ) @timed_places [ place ] = true place end
->Raw Target:
Create and return a new timed place for this model.
--

1090=========
->Original Input:
['def', 'transition', '(', 'name', ')', 't', '=', 'find_transition', 'name', 'if', 't', '.', 'nil?', 't', '=', 'Transition', '.', 'new', 'name', ',', 'self', '@transitions', '<<', 't', 'end', 't', 'end']
->Original Target:
['Create', 'and', 'return', 'new', 'transition', 'for', 'this', 'model', '.', '+', 'name', '+', 'identifies', 'transition', 'in', 'the', 'net', '.']
->Reconstructed Target:
Create and return new transition for this model. + name + identifies transition in the net.
->Reconstructed Predication:
the transition to the given name
->Raw Input:
summarize:def transition ( name ) t = find_transition name if t. nil? t = Transition. new name, self @transitions << t end t end
->Raw Target:
Create and return new transition for this model. + name + identifies transition in the net.
--

1091=========
->Original Input:
['def', 'sim', '@stopped', '=', 'catch', ':stop_simulation', 'do', 'begin', 'fired', '=', 'fire_transitions', 'advanced', '=', 'move_clock_to', 'find_next_time', 'end', 'while', 'fired', '||', 'advanced', 'end', '@stopped', '=', 'false', 'if', '@stopped', '==', 'nil', 'rescue', 'StandardError', '=>', 'e', 'raise', 'SimulationError', '.', 'new', '(', 'e', ')', 'end']
->Original Target:
['Starts', 'simulation', 'of', 'this', 'net', '.']
->Reconstructed Target:
Starts simulation of this net.
->Reconstructed Predication:
the simulation to the current
->Raw Input:
summarize:def sim @stopped = catch :stop_simulation do begin fired = fire_transitions advanced = move_clock_to find_next_time end while fired || advanced end @stopped = false if @stopped == nil rescue StandardError => e raise SimulationError. new ( e ) end
->Raw Target:
Starts simulation of this net.
--

1092=========
->Original Input:
['def', 'output', '(', 'place', ',', '&', 'block', ')', 'raise', '"This is not a Place object!"', 'unless', 'place', '.', 'kind_of?', 'Place', 'raise', '"Tried to define output arc without expression! Block is required!"', 'unless', 'block_given?', '@outputs', '<<', 'OutputArc', '.', 'new', '(', 'place', ',', 'block', ')', 'end']
->Original Target:
['Add', 'output', 'arc', 'to', 'the', '+', 'place', '+', '.', '+', 'block', '+', 'is', 'the', 'arc', 's', 'expresstion', 'it', 'will', 'be', 'called', 'while', 'firing', 'transition', '.', 'Value', 'returned', 'from', 'the', 'block', 'will', 'be', 'put', 'in', 'output', 'place', '.', 'The', 'block', 'gets', '+', 'binding', '+', 'and', '+', 'clock', '+', 'values', '.', '+', 'binding', '+', 'is', 'a', 'hash', 'with', 'names', 'of', 'input', 'places', 'as', 'keys', 'nad', 'tokens', 'as', 'values', '.']
->Reconstructed Target:
Add output arc to the + place +. + block + is the arc s expresstion it will be called while firing transition. Value returned from the block will be put in output place. The block gets + binding + and + clock + values. + binding + is a hash with names of input places as keys nad tokens as values.
->Reconstructed Predication:
the output arc for the given
->Raw Input:
summarize:def output ( place, & block ) raise "This is not a Place object!" unless place. kind_of? Place raise "Tried to define output arc without expression! Block is required!" unless block_given? @outputs << OutputArc. new ( place, block ) end
->Raw Target:
Add output arc to the + place +. + block + is the arc s expresstion it will be called while firing transition. Value returned from the block will be put in output place. The block gets + binding + and + clock + values. + binding + is a hash with names of input places as keys nad tokens as values.
--

1093=========
->Original Input:
['def', 'fire', '(', 'clock', '=', '0', ')', 'mapping', '=', 'Enumerator', '.', 'new', 'do', '|', 'y', '|', 'get_sentry', '.', 'call', '(', 'input_markings', ',', 'clock', ',', 'y', ')', 'end', '.', 'first', 'return', 'false', 'if', 'mapping', '.', 'nil?', 'tcpn_binding', '=', 'TCPNBinding', '.', 'new', 'mapping', ',', 'input_markings', 'call_callbacks', ':before', ',', 'Event', '.', 'new', '(', '@name', ',', 'tcpn_binding', ',', 'clock', ',', '@net', ')', 'tokens_for_outputs', '=', '@outputs', '.', 'map', 'do', '|', 'o', '|', 'o', '.', 'block', '.', 'call', '(', 'tcpn_binding', ',', 'clock', ')', 'end', 'mapping', '.', 'each', 'do', '|', 'place_name', ',', 'token', '|', 'unless', 'token', '.', 'kind_of?', 'Token', 't', '=', 'if', 'token', '.', 'instance_of?', 'Array', 'token', 'else', '[', 'token', ']', 'end', 't', '.', 'each', 'do', '|', 't', '|', 'unless', 't', '.', 'kind_of?', 'Token', 'raise', 'InvalidToken', '.', 'new', '(', '"#{t.inspect} put by sentry for transition `#{name}` in binding for `#{place_name}`"', ')', 'end', 'end', 'end', 'deleted', '=', 'find_input', '(', 'place_name', ')', '.', 'delete', '(', 'token', ')', 'if', 'deleted', '.', 'nil?', 'raise', 'InvalidToken', '.', 'new', '(', '"#{token.inspect} put by sentry for transition `#{name}` does not exists in `#{place_name}`"', ')', 'end', 'end', '@outputs', '.', 'each', 'do', '|', 'o', '|', 'token', '=', 'tokens_for_outputs', '.', 'shift', 'o', '.', 'place', '.', 'add', 'token', 'unless', 'token', '.', 'nil?', 'end', 'call_callbacks', ':after', ',', 'Event', '.', 'new', '(', '@name', ',', 'mapping', ',', 'clock', ',', '@net', ')', 'true', 'rescue', 'InvalidToken', 'raise', 'rescue', 'RuntimeError', '=>', 'e', 'raise', 'FiringError', '.', 'new', '(', 'self', ',', 'e', ')', 'end']
->Original Target:
['fire', 'this', 'transition', 'if', 'possible', 'returns', 'true', 'if', 'fired', 'false', 'otherwise']
->Reconstructed Target:
fire this transition if possible returns true if fired false otherwise
->Reconstructed Predication:
the( @name,)) return true end
->Raw Input:
summarize:def fire ( clock = 0 ) mapping = Enumerator. new do | y | get_sentry. call ( input_markings, clock, y ) end. first return false if mapping. nil? tcpn_binding = TCPNBinding. new mapping, input_markings call_callbacks :before, Event. new ( @name, tcpn_binding, clock, @net ) tokens_for_outputs = @outputs. map do | o | o. block. call ( tcpn_binding, clock ) end mapping. each do | place_name, token | unless token. kind_of? Token t = if token. instance_of? Array token else [ token ] end t. each do | t | unless t. kind_of? Token raise InvalidToken. new ( "#{t.inspect} put by sentry for transition `#{name}` in binding for `#{place_name}`" ) end end end deleted = find_input ( place_name ). delete ( token ) if deleted. nil? raise InvalidToken. new ( "#{token.inspect} put by sentry for transition `#{name}` does not exists in `#{place_name}`" ) end end @outputs. each do | o | token = tokens_for_outputs. shift o. place. add token unless token. nil? end call_callbacks :after, Event. new ( @name, mapping, clock, @net ) true rescue InvalidToken raise rescue RuntimeError => e raise FiringError. new ( self, e ) end
->Raw Target:
fire this transition if possible returns true if fired false otherwise
--

1094=========
->Original Input:
['def', 'send_request', '(', 'text', ')', 'begin', 'request', '=', 'Net', '::', 'HTTP', '::', 'Post', '.', 'new', '(', '@url', '.', 'path', ',', '{', "'Content-Type'", '=>', "'text/xml'", ',', "'SOAPAction'", '=>', '\'"http://typograf.artlebedev.ru/webservices/ProcessText"\'', '}', ')', 'request', '.', 'body', '=', 'form_xml', '(', 'text', ',', '@options', ')', 'response', '=', 'Net', '::', 'HTTP', '.', 'new', '(', '@url', '.', 'host', ',', '@url', '.', 'port', ')', '.', 'start', 'do', '|', 'http', '|', 'http', '.', 'request', '(', 'request', ')', 'end', 'rescue', 'StandardError', '=>', 'exception', 'raise', 'NetworkError', '.', 'new', '(', 'exception', '.', 'message', ',', 'exception', '.', 'backtrace', ')', 'end', 'if', '!', 'response', '.', 'is_a?', '(', 'Net', '::', 'HTTPOK', ')', 'raise', 'NetworkError', ',', '"#{response.code}: #{response.message}"', 'end', 'if', 'RESULT', '=~', 'response', '.', 'body', 'body', '=', '$1', '.', 'gsub', '(', '/', '/', ',', "'>'", ')', '.', 'gsub', '(', '/', '/', ',', "'<'", ')', '.', 'gsub', '(', '/', '/', ',', "'&'", ')', 'body', '.', 'force_encoding', '(', '"UTF-8"', ')', '.', 'chomp', 'else', 'raise', 'NetworkError', ',', '"Can\'t match result #{response.body}"', 'end', 'end']
->Original Target:
['Process', 'text', 'with', 'remote', 'web', '-', 'service']
->Reconstructed Target:
Process text with remote web - service
->Reconstructed Predication:
thethe request to the serverthethethethethethethethe response body. The response
->Raw Input:
summarize:def send_request ( text ) begin request = Net :: HTTP :: Post. new ( @url. path, { 'Content-Type' => 'text/xml', 'SOAPAction' => '"http://typograf.artlebedev.ru/webservices/ProcessText"' } ) request. body = form_xml ( text, @options ) response = Net :: HTTP. new ( @url. host, @url. port ). start do | http | http. request ( request ) end rescue StandardError => exception raise NetworkError. new ( exception. message, exception. backtrace ) end if! response. is_a? ( Net :: HTTPOK ) raise NetworkError, "#{response.code}: #{response.message}" end if RESULT =~ response. body body = $1. gsub ( / /, '>' ). gsub ( / /, '<' ). gsub ( / /, '&' ) body. force_encoding ( "UTF-8" ). chomp else raise NetworkError, "Can't match result #{response.body}" end end
->Raw Target:
Process text with remote web - service
--

1095=========
->Original Input:
['def', 'install_librarian', '(', 'opts', '=', '{', '}', ')', 'librarian_version', '=', 'opts', '[', ':librarian_version', ']', '||=', 'nil', 'hosts', '.', 'each', 'do', '|', 'host', '|', 'install_package', 'host', ',', "'rubygems'", 'install_package', 'host', ',', "'git'", 'if', 'librarian_version', 'on', 'host', ',', '"gem install --no-ri --no-rdoc librarian-puppet -v \'#{librarian_version}\'"', 'else', 'on', 'host', ',', "'gem install --no-ri --no-rdoc librarian-puppet'", 'end', 'end', 'end']
->Original Target:
['Install', 'rubygems', 'and', 'the', 'librarian', '-', 'puppet', 'gem', 'onto', 'each', 'host']
->Reconstructed Target:
Install rubygems and the librarian - puppet gem onto each host
->Reconstructed Predication:
install the gem for thethe gem to install the
->Raw Input:
summarize:def install_librarian ( opts = { } ) librarian_version = opts [ :librarian_version ] ||= nil hosts. each do | host | install_package host, 'rubygems' install_package host, 'git' if librarian_version on host, "gem install --no-ri --no-rdoc librarian-puppet -v '#{librarian_version}'" else on host, 'gem install --no-ri --no-rdoc librarian-puppet' end end end
->Raw Target:
Install rubygems and the librarian - puppet gem onto each host
--

1096=========
->Original Input:
['def', 'librarian_install_modules', '(', 'directory', ',', 'module_name', ')', 'hosts', '.', 'each', 'do', '|', 'host', '|', 'sut_dir', '=', 'File', '.', 'join', '(', "'/tmp'", ',', 'module_name', ')', 'scp_to', 'host', ',', 'directory', ',', 'sut_dir', 'on', 'host', ',', '"cd #{sut_dir} && librarian-puppet install --clean --verbose --path #{host[\'distmoduledir\']}"', 'puppet_module_install', '(', ':source', '=>', 'directory', ',', ':module_name', '=>', 'module_name', ')', 'end', 'end']
->Original Target:
['Copy', 'the', 'module', 'under', 'test', 'to', 'a', 'temporary', 'directory', 'onto', 'the', 'host', 'and', 'execute', 'librarian', '-', 'puppet', 'to', 'install', 'dependencies', 'into', 'the', 'distmoduledir', '.']
->Reconstructed Target:
Copy the module under test to a temporary directory onto the host and execute librarian - puppet to install dependencies into the distmoduledir.
->Reconstructed Predication:
module_name
->Raw Input:
summarize:def librarian_install_modules ( directory, module_name ) hosts. each do | host | sut_dir = File. join ( '/tmp', module_name ) scp_to host, directory, sut_dir on host, "cd #{sut_dir} && librarian-puppet install --clean --verbose --path #{host['distmoduledir']}" puppet_module_install ( :source => directory, :module_name => module_name ) end end
->Raw Target:
Copy the module under test to a temporary directory onto the host and execute librarian - puppet to install dependencies into the distmoduledir.
--

1097=========
->Original Input:
['def', 'get_crisis', '(', 'identifier', ',', 'params', '=', 'nil', ')', 'return', 'nil', 'if', 'identifier', '.', 'nil?', 'or', 'identifier', '.', 'empty?', 'endpoint', '=', '"/v1/crises/#{identifier}.json?auth_token=#{@auth_token}"', 'endpoint', '+=', '"&#{URI.encode_www_form params}"', 'if', 'params', 'response', '=', 'self', '.', 'get', '(', 'endpoint', ')', 'Sigimera', '::', 'Crisis', '.', 'new', 'JSON', '.', 'parse', 'response', '.', 'body', 'if', 'response', 'and', 'response', '.', 'body', 'end']
->Original Target:
['This', 'method', 'returns', 'a', 'single', 'crisis', '.']
->Reconstructed Target:
This method returns a single crisis.
->Reconstructed Predication:
return the crisis for the
->Raw Input:
summarize:def get_crisis ( identifier, params = nil ) return nil if identifier. nil? or identifier. empty? endpoint = "/v1/crises/#{identifier}.json?auth_token=#{@auth_token}" endpoint += "&#{URI.encode_www_form params}" if params response = self. get ( endpoint ) Sigimera :: Crisis. new JSON. parse response. body if response and response. body end
->Raw Target:
This method returns a single crisis.
--

1098=========
->Original Input:
['def', 'get_crises_stat', 'response', '=', 'self', '.', 'get', '(', '"/v1/stats/crises.json?auth_token=#{@auth_token}"', ')', 'JSON', '.', 'parse', 'response', '.', 'body', 'if', 'response', 'and', 'response', '.', 'body', 'end']
->Original Target:
['This', 'method', 'returns', 'statistic', 'information', 'about', 'the', 'crises', '.']
->Reconstructed Target:
This method returns statistic information about the crises.
->Reconstructed Predication:
return the crises stats
->Raw Input:
summarize:def get_crises_stat response = self. get ( "/v1/stats/crises.json?auth_token=#{@auth_token}" ) JSON. parse response. body if response and response. body end
->Raw Target:
This method returns statistic information about the crises.
--

1099=========
->Original Input:
['def', 'get_user_stat', 'response', '=', 'self', '.', 'get', '(', '"/v1/stats/users.json?auth_token=#{@auth_token}"', ')', 'JSON', '.', 'parse', 'response', '.', 'body', 'if', 'response', 'and', 'response', '.', 'body', 'end']
->Original Target:
['This', 'method', 'returns', 'statistic', 'information', 'about', 'user', '.']
->Reconstructed Target:
This method returns statistic information about user.
->Reconstructed Predication:
return the user stats
->Raw Input:
summarize:def get_user_stat response = self. get ( "/v1/stats/users.json?auth_token=#{@auth_token}" ) JSON. parse response. body if response and response. body end
->Raw Target:
This method returns statistic information about user.
--

1100=========
->Original Input:
['def', 'posify', '*', 'source_methods', ',', '&', 'block', 'include', 'ModelClassAdditions', 'self', '.', 'pose_content', '=', 'proc', 'do', 'text_chunks', '=', 'source_methods', '.', 'map', '{', '|', 'source', '|', 'send', '(', 'source', ')', '}', 'text_chunks', '<<', 'instance_eval', '(', '&', 'block', ')', 'if', 'block', 'text_chunks', '.', 'reject', '(', '&', ':blank?', ')', '.', 'join', '(', "' '", ')', 'end', 'end']
->Original Target:
['Defines', 'the', 'searchable', 'content', 'in', 'ActiveRecord', 'objects', '.']
->Reconstructed Target:
Defines the searchable content in ActiveRecord objects.
->Reconstructed Predication:
the pose content of the
->Raw Input:
summarize:def posify * source_methods, & block include ModelClassAdditions self. pose_content = proc do text_chunks = source_methods. map { | source | send ( source ) } text_chunks << instance_eval ( & block ) if block text_chunks. reject ( & :blank? ). join ('' ) end end
->Raw Target:
Defines the searchable content in ActiveRecord objects.
--

1101=========
->Original Input:
['def', 'add', '(', 'objects', ')', 'unless', 'objects', '.', 'kind_of?', 'Array', 'objects', '=', '[', 'objects', ']', 'end', 'objects', '.', 'each', 'do', '|', 'object', '|', 'value', '=', 'object', 'if', 'object', '.', 'instance_of?', 'Hash', 'value', '=', 'object', '[', ':val', ']', 'end', 'add_token', 'prepare_token', '(', 'value', ')', 'end', 'end']
->Original Target:
['Creates', 'new', 'token', 'of', 'the', '+', 'object', '+', 'and', 'adds', 'it', 'to', 'the', 'marking', '.', 'Objects', 'added', 'to', 'the', 'marking', 'are', 'deep', '-', 'cloned', 'so', 'you', 'can', 'use', 'them', 'without', 'fear', 'to', 'interfere', 'with', 'TCPN', 'simulation', '.', 'But', 'have', 'it', 'in', 'mind!', 'If', 'you', 'put', 'a', 'large', 'object', 'with', 'a', 'lot', 'of', 'references', 'in', 'the', 'marking', 'it', 'will', 'significanntly', 'slow', 'down', 'simulation', 'and', 'increase', 'memory', 'usage', '.']
->Reconstructed Target:
Creates new token of the + object + and adds it to the marking. Objects added to the marking are deep - cloned so you can use them without fear to interfere with TCPN simulation. But have it in mind! If you put a large object with a lot of references in the marking it will significanntly slow down simulation and increase memory usage.
->Reconstructed Predication:
the token to be added to
->Raw Input:
summarize:def add ( objects ) unless objects. kind_of? Array objects = [ objects ] end objects. each do | object | value = object if object. instance_of? Hash value = object [ :val ] end add_token prepare_token ( value ) end end
->Raw Target:
Creates new token of the + object + and adds it to the marking. Objects added to the marking are deep - cloned so you can use them without fear to interfere with TCPN simulation. But have it in mind! If you put a large object with a lot of references in the marking it will significanntly slow down simulation and increase memory usage.
--

1102=========
->Original Input:
['def', 'delete', '(', 'tokens', ')', 'unless', 'tokens', '.', 'instance_of?', 'Array', 'tokens', '=', '[', 'tokens', ']', 'end', 'removed', '=', 'tokens', '.', 'map', 'do', '|', 'token', '|', 'validate_token!', '(', 'token', ')', 'delete_token', '(', 'token', ')', 'end', 'if', 'removed', '.', 'size', '==', '1', 'removed', '.', 'first', 'else', 'removed', 'end', 'end']
->Original Target:
['Deletes', 'the', '+', 'token', '+', 'from', 'the', 'marking', '.', 'To', 'do', 'it', 'you', 'must', 'first', 'find', 'the', 'token', 'in', 'the', 'marking', '.']
->Reconstructed Target:
Deletes the + token + from the marking. To do it you must first find the token in the marking.
->Reconstructed Predication:
delete a token or a list
->Raw Input:
summarize:def delete ( tokens ) unless tokens. instance_of? Array tokens = [ tokens ] end removed = tokens. map do | token | validate_token! ( token ) delete_token ( token ) end if removed. size == 1 removed. first else removed end end
->Raw Target:
Deletes the + token + from the marking. To do it you must first find the token in the marking.
--

1103=========
->Original Input:
['def', 'add_joins', 'arel', '@query', '.', 'joins', '.', 'inject', '(', 'arel', ')', 'do', '|', 'memo', ',', 'join_data', '|', 'add_join', 'memo', ',', 'join_data', 'end', 'end']
->Original Target:
['Creates', 'a', 'JOIN', 'to', 'the', 'given', 'expression', '.']
->Reconstructed Target:
Creates a JOIN to the given expression.
->Reconstructed Predication:
join_data
->Raw Input:
summarize:def add_joins arel @query. joins. inject ( arel ) do | memo, join_data | add_join memo, join_data end end
->Raw Target:
Creates a JOIN to the given expression.
--

1104=========
->Original Input:
['def', 'add_wheres', 'arel', '@query', '.', 'where', '.', 'inject', '(', 'arel', ')', '{', '|', 'memo', ',', 'where', '|', 'memo', '.', 'where', 'where', '}', 'end']
->Original Target:
['Adds', 'the', 'WHERE', 'clauses', 'from', 'the', 'given', 'query', 'to', 'the', 'given', 'arel', 'construct', '.']
->Reconstructed Target:
Adds the WHERE clauses from the given query to the given arel construct.
->Reconstructed Predication:
where where where
->Raw Input:
summarize:def add_wheres arel @query. where. inject ( arel ) { | memo, where | memo. where where } end
->Raw Target:
Adds the WHERE clauses from the given query to the given arel construct.
--

1105=========
->Original Input:
['def', 'load_classes', 'result', 'return', 'if', '@query', '.', 'ids_requested?', 'result', '.', 'each', 'do', '|', 'clazz', ',', 'ids', '|', 'if', 'ids', '.', 'size', '>', '0', 'result', '[', 'clazz', ']', '=', 'clazz', '.', 'where', '(', 'id', ':', 'ids', ')', 'if', '@query', '.', 'has_select', 'result', '[', 'clazz', ']', '=', 'result', '[', 'clazz', ']', '.', 'select', '(', '@query', '.', 'options', '[', ':select', ']', ')', 'end', 'end', 'end', 'end']
->Original Target:
['Converts', 'the', 'ids', 'to', 'classes', 'if', 'the', 'user', 'wants', 'classes', '.']
->Reconstructed Target:
Converts the ids to classes if the user wants classes.
->Reconstructed Predication:
the classes to load.
->Raw Input:
summarize:def load_classes result return if @query. ids_requested? result. each do | clazz, ids | if ids. size > 0 result [ clazz ] = clazz. where ( id : ids ) if @query. has_select result [ clazz ] = result [ clazz ]. select ( @query. options [ :select ] ) end end end end
->Raw Target:
Converts the ids to classes if the user wants classes.
--

1106=========
->Original Input:
['def', 'search_word', 'word', 'empty_result', '.', 'tap', 'do', '|', 'result', '|', 'data', '=', 'Assignment', '.', 'joins', '(', ':word', ')', '.', 'select', '(', "'pose_assignments.posable_id, pose_assignments.posable_type'", ')', '.', 'where', '(', "'pose_words.text LIKE ?'", ',', '"#{word}%"', ')', '.', 'where', '(', "'pose_assignments.posable_type IN (?)'", ',', '@query', '.', 'class_names', ')', 'data', '=', 'add_joins', 'data', 'data', '=', 'add_wheres', 'data', 'Assignment', '.', 'connection', '.', 'select_all', '(', 'data', '.', 'to_sql', ')', '.', 'each', 'do', '|', 'pose_assignment', '|', 'result', '[', 'pose_assignment', '[', "'posable_type'", ']', ']', '<<', 'pose_assignment', '[', "'posable_id'", ']', '.', 'to_i', 'end', 'end', 'end']
->Original Target:
['Finds', 'all', 'matching', 'ids', 'for', 'a', 'single', 'word', 'of', 'the', 'search', 'query', '.']
->Reconstructed Target:
Finds all matching ids for a single word of the search query.
->Reconstructed Predication:
search_word word
->Raw Input:
summarize:def search_word word empty_result. tap do | result | data = Assignment. joins ( :word ). select ( 'pose_assignments.posable_id, pose_assignments.posable_type' ). where ( 'pose_words.text LIKE?', "#{word}%" ). where ( 'pose_assignments.posable_type IN (?)', @query. class_names ) data = add_joins data data = add_wheres data Assignment. connection. select_all ( data. to_sql ). each do | pose_assignment | result [ pose_assignment [ 'posable_type' ] ] << pose_assignment [ 'posable_id' ]. to_i end end end
->Raw Target:
Finds all matching ids for a single word of the search query.
--

1107=========
->Original Input:
['def', 'search_words', '{', '}', '.', 'tap', 'do', '|', 'result', '|', '@query', '.', 'query_words', '.', 'each', 'do', '|', 'query_word', '|', 'search_word', '(', 'query_word', ')', '.', 'each', 'do', '|', 'class_name', ',', 'ids', '|', 'merge_search_result_word_matches', 'result', ',', 'class_name', ',', 'ids', 'end', 'end', 'end', 'end']
->Original Target:
['Returns', 'all', 'matching', 'ids', 'for', 'all', 'words', 'of', 'the', 'search', 'query', '.']
->Reconstructed Target:
Returns all matching ids for all words of the search query.
->Reconstructed Predication:
search results for the given query
->Raw Input:
summarize:def search_words { }. tap do | result | @query. query_words. each do | query_word | search_word ( query_word ). each do | class_name, ids | merge_search_result_word_matches result, class_name, ids end end end end
->Raw Target:
Returns all matching ids for all words of the search query.
--

1108=========
->Original Input:
['def', 'client_login_authorization_header', '(', 'http_method', ',', 'uri', ')', 'if', '@user', '&&', '@password', '&&', '!', '@auth_token', 'email', '=', 'CGI', '.', 'escape', '(', '@user', ')', 'password', '=', 'CGI', '.', 'escape', '(', '@password', ')', 'http', '=', 'Net', '::', 'HTTP', '.', 'new', '(', "'www.google.com'", ',', '443', ')', 'http', '.', 'use_ssl', '=', 'true', 'http', '.', 'verify_mode', '=', 'OpenSSL', '::', 'SSL', '::', 'VERIFY_NONE', 'resp', ',', 'data', '=', 'http', '.', 'post', '(', "'/accounts/ClientLogin'", ',', '"accountType=HOSTED_OR_GOOGLE&Email=#{email}&Passwd=#{password}&service=wise"', ',', '{', "'Content-Type'", '=>', "'application/x-www-form-urlencoded'", '}', ')', 'handle_response', '(', 'resp', ')', '@auth_token', '=', '(', 'data', '||', 'resp', '.', 'body', ')', '[', '/', '/n', ',', '1', ']', 'end', '@auth_token', '?', '{', "'Authorization'", '=>', '"GoogleLogin auth=#{@auth_token}"', '}', ':', '{', '}', 'end']
->Original Target:
['Deprecated', 'and', 'Not', 'recommended']
->Reconstructed Target:
Deprecated and Not recommended
->Reconstructed Predication:
http_method = http_method ||uri = uri.uri. pathuri. pathuri. path
->Raw Input:
summarize:def client_login_authorization_header ( http_method, uri ) if @user && @password &&! @auth_token email = CGI. escape ( @user ) password = CGI. escape ( @password ) http = Net :: HTTP. new ( 'www.google.com', 443 ) http. use_ssl = true http. verify_mode = OpenSSL :: SSL :: VERIFY_NONE resp, data = http. post ( '/accounts/ClientLogin', "accountType=HOSTED_OR_GOOGLE&Email=#{email}&Passwd=#{password}&service=wise", { 'Content-Type' => 'application/x-www-form-urlencoded' } ) handle_response ( resp ) @auth_token = ( data || resp. body ) [ / /n, 1 ] end @auth_token? { 'Authorization' => "GoogleLogin auth=#{@auth_token}" } : { } end
->Raw Target:
Deprecated and Not recommended
--

1109=========
->Original Input:
['def', 'app_folder', '(', 'app_name', '=', 'self', '.', 'current_app', ')', 'if', 'self', '.', 'type', '==', ':multi', 'if', 'app_name', '.', 'in?', 'self', '.', 'main_apps', '"#{self.folder}/main_apps/#{app_name}"', 'elsif', 'app_name', '.', 'in?', 'self', '.', 'engines', '"#{self.folder}/engines/#{app_name}"', 'end', 'elsif', 'self', '.', 'type', '==', ':single', 'self', '.', 'folder', 'end', 'end']
->Original Target:
['Ottiene', 'la', 'directory', 'corrente', 'nella', 'cartella', 'dell', 'app', 'specificata', '.', 'Prende', 'l', 'app', 'corrente', 'se', 'non', 'viene', 'specificata', 'nessuna', 'app', '.']
->Reconstructed Target:
Ottiene la directory corrente nella cartella dell app specificata. Prende l app corrente se non viene specificata nessuna app.
->Reconstructed Predication:
folder for the app.
->Raw Input:
summarize:def app_folder ( app_name = self. current_app ) if self. type == :multi if app_name. in? self. main_apps "#{self.folder}/main_apps/#{app_name}" elsif app_name. in? self. engines "#{self.folder}/engines/#{app_name}" end elsif self. type == :single self. folder end end
->Raw Target:
Ottiene la directory corrente nella cartella dell app specificata. Prende l app corrente se non viene specificata nessuna app.
--

1110=========
->Original Input:
['def', 'app_version_file', '(', 'app_name', '=', 'self', '.', 'current_app', ')', 'Dir', '.', 'glob', '(', '"#{app_folder(app_name)}/lib/**/version.rb"', ')', '.', 'min_by', 'do', '|', 'filename', '|', 'filename', '.', 'chars', '.', 'count', 'end', 'end']
->Original Target:
['Determina', 'il', 'file', 'di', 'versione', 'dell', 'app', '.', 'Prende', 'l', 'app', 'corrente', 'se', 'non', 'viene', 'specificata', 'nessuna', 'app', '.']
->Reconstructed Target:
Determina il file di versione dell app. Prende l app corrente se non viene specificata nessuna app.
->Reconstructed Predication:
the version file for the
->Raw Input:
summarize:def app_version_file ( app_name = self. current_app ) Dir. glob ( "#{app_folder(app_name)}/lib/**/version.rb" ). min_by do | filename | filename. chars. count end end
->Raw Target:
Determina il file di versione dell app. Prende l app corrente se non viene specificata nessuna app.
--

1111=========
->Original Input:
['def', 'app_version', '(', 'app_name', '=', 'self', '.', 'current_app', ')', 'if', 'File', '.', 'exists?', 'app_version_file', '(', 'app_name', ')', '.', 'to_s', 'File', '.', 'read', '(', 'app_version_file', '(', 'app_name', ')', ')', '.', 'match', '(', '/', '\\.', '\\n', '/', ')', '.', 'try', '(', ':captures', ')', '.', 'try', '(', ':first', ')', 'else', '`', '`', '.', 'split', '(', '"\\n"', ')', '.', 'first', 'end', 'end']
->Original Target:
['Ritorna', 'la', 'versione', 'dell', 'app', '.', 'Prende', 'l', 'app', 'corrente', 'se', 'non', 'viene', 'specificata', 'nessuna', 'app', '.']
->Reconstructed Target:
Ritorna la versione dell app. Prende l app corrente se non viene specificata nessuna app.
->Reconstructed Predication:
the current app version of thethe current app version of the
->Raw Input:
summarize:def app_version ( app_name = self. current_app ) if File. exists? app_version_file ( app_name ). to_s File. read ( app_version_file ( app_name ) ). match ( / \. \n / ). try ( :captures ). try ( :first ) else ` `. split ( "\n" ). first end end
->Raw Target:
Ritorna la versione dell app. Prende l app corrente se non viene specificata nessuna app.
--

1112=========
->Original Input:
['def', 'bump_app_version_to', '(', 'version', ')', 'if', 'File', '.', 'exists?', 'self', '.', 'app_version_file', 'version_file', '=', 'self', '.', 'app_version_file', 'version_content', '=', 'File', '.', 'read', '(', '"#{version_file}"', ')', 'File', '.', 'open', '(', 'version_file', ',', "'w+'", ')', 'do', '|', 'f', '|', 'f', '.', 'puts', 'version_content', '.', 'gsub', '(', '/', '\\.', '\\n', '/', ',', '"VERSION = \'#{version}\'\\n"', ')', 'end', 'end', 'end']
->Original Target:
['Alza', 'la', 'versione', 'dell', 'app', 'corrente', 'a', 'quella', 'specificata', '.']
->Reconstructed Target:
Alza la versione dell app corrente a quella specificata.
->Reconstructed Predication:
the app version to the
->Raw Input:
summarize:def bump_app_version_to ( version ) if File. exists? self. app_version_file version_file = self. app_version_file version_content = File. read ( "#{version_file}" ) File. open ( version_file, 'w+' ) do | f | f. puts version_content. gsub ( / \. \n /, "VERSION = '#{version}'\n" ) end end end
->Raw Target:
Alza la versione dell app corrente a quella specificata.
--

1113=========
->Original Input:
['def', 'load_project', 'config_file', '=', 'Dir', '.', 'glob', '(', '"#{Dir.pwd}/**/dev.yml"', ')', '.', 'first', 'raise', 'ExecutionError', '.', 'new', '"No valid configuration files found. Searched for a file named \'dev.yml\' "', '"in folder #{Dir.pwd} and all its subdirectories."', 'if', 'config_file', '.', 'nil?', '@project', '=', 'Dev', '::', 'Project', '.', 'new', '(', 'config_file', ')', 'end']
->Original Target:
['Inizializza', 'l', 'eseguibile', 'in', 'base', 'al', 'comando', 'passato', '.']
->Reconstructed Target:
Inizializza l eseguibile in base al comando passato.
->Reconstructed Predication:
the project to be loaded.
->Raw Input:
summarize:def load_project config_file = Dir. glob ( "#{Dir.pwd}/**/dev.yml" ). first raise ExecutionError. new "No valid configuration files found. Searched for a file named 'dev.yml' " "in folder #{Dir.pwd} and all its subdirectories." if config_file. nil? @project = Dev :: Project. new ( config_file ) end
->Raw Target:
Inizializza l eseguibile in base al comando passato.
--

1114=========
->Original Input:
['def', 'help', 'puts', 'print', '"Dev"', '.', 'green', 'print', '" - available commands:\\n"', 'puts', 'print', '"\\tversion\\t\\t"', '.', 'limegreen', 'print', '"Prints current version.\\n"', 'puts', 'print', '"\\tfeature\\t\\t"', '.', 'limegreen', 'print', '"Opens or closes a feature for the current app.\\n"', 'print', '"\\t\\t\\tWarning: the app is determined from the current working directory!\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev feature open my-new-feature"', '.', 'springgreen', 'print', '" (opens a new feature for the current app)"', 'print', '".\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev feature close my-new-feature"', '.', 'springgreen', 'print', '" (closes a developed new feature for the current app)"', 'print', '".\\n"', 'puts', 'print', '"\\thotfix\\t\\t"', '.', 'limegreen', 'print', '"Opens or closes a hotfix for the current app.\\n"', 'print', '"\\t\\t\\tWarning: the app is determined from the current working directory!\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev hotfix open 0.2.1"', '.', 'springgreen', 'print', '" (opens a new hotfix for the current app)"', 'print', '".\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev hotfix close 0.2.1"', '.', 'springgreen', 'print', '" (closes a developed new hotfix for the current app)"', 'print', '".\\n"', 'puts', 'print', '"\\trelease\\t\\t"', '.', 'limegreen', 'print', '"Opens or closes a release for the current app.\\n"', 'print', '"\\t\\t\\tWarning: the app is determined from the current working directory!\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev release open 0.2.0"', '.', 'springgreen', 'print', '" (opens a new release for the current app)"', 'print', '".\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev release close 0.2.0"', '.', 'springgreen', 'print', '" (closes a developed new release for the current app)"', 'print', '".\\n"', 'puts', 'print', '"\\tpull\\t\\t"', '.', 'limegreen', 'print', '"Pulls specified app\'s git repository, or pulls all apps if none are specified.\\n"', 'print', '"\\t\\t\\tWarning: the pulled branch is the one the app is currently on!\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev pull [myapp]"', '.', 'springgreen', 'print', '".\\n"', 'puts', 'print', '"\\tpush\\t\\t"', '.', 'limegreen', 'print', '"Commits and pushes the specified app.\\n"', 'print', '"\\t\\t\\tWarning: the pushed branch is the one the app is currently on!\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev push myapp \\"commit message\\""', '.', 'springgreen', 'print', '".\\n"', 'puts', 'print', '"\\ttest\\t\\t"', '.', 'limegreen', 'print', '"Runs the app\'s test suite. Tests must be written with rspec.\\n"', 'print', '"\\t\\t\\tIt is possibile to specify which app\'s test suite to run.\\n"', 'print', '"\\t\\t\\tIf nothing is specified, all main app\'s test suites are run.\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev test mymainapp myengine"', '.', 'springgreen', 'print', '" (runs tests for \'mymainapp\' and \'myengine\')"', 'print', '".\\n"', 'print', '"\\t\\t\\tExample: "', 'print', '"dev test"', '.', 'springgreen', 'print', '" (runs tests for all main apps and engines within this project)"', 'print', '".\\n"', 'puts', 'end']
->Original Target:
['Stampa', 'i', 'comandi', 'possibili', '.']
->Reconstructed Target:
Stampa i comandi possibili.
->Reconstructed Predication:
the current working directory.\n"app isthe current working directory.\n"app isthe current working directory.\n"app isthe current working directory.\n"app isthe current working directory.\n"app isthe current working directory.\n"app isthe current working directory.\n"app isthe current working directory.\n"app isthe current working directory.\n"app
->Raw Input:
summarize:def help puts print "Dev". green print " - available commands:\n" puts print "\tversion\t\t". limegreen print "Prints current version.\n" puts print "\tfeature\t\t". limegreen print "Opens or closes a feature for the current app.\n" print "\t\t\tWarning: the app is determined from the current working directory!\n" print "\t\t\tExample: " print "dev feature open my-new-feature". springgreen print " (opens a new feature for the current app)" print ".\n" print "\t\t\tExample: " print "dev feature close my-new-feature". springgreen print " (closes a developed new feature for the current app)" print ".\n" puts print "\thotfix\t\t". limegreen print "Opens or closes a hotfix for the current app.\n" print "\t\t\tWarning: the app is determined from the current working directory!\n" print "\t\t\tExample: " print "dev hotfix open 0.2.1". springgreen print " (opens a new hotfix for the current app)" print ".\n" print "\t\t\tExample: " print "dev hotfix close 0.2.1". springgreen print " (closes a developed new hotfix for the current app)" print ".\n" puts print "\trelease\t\t". limegreen print "Opens or closes a release for the current app.\n" print "\t\t\tWarning: the app is determined from the current working directory!\n" print "\t\t\tExample: " print "dev release open 0.2.0". springgreen print " (opens a new release for the current app)" print ".\n" print "\t\t\tExample: " print "dev release close 0.2.0". springgreen print " (closes a developed new release for the current app)" print ".\n" puts print "\tpull\t\t". limegreen print "Pulls specified app's git repository, or pulls all apps if none are specified.\n" print "\t\t\tWarning: the pulled branch is the one the app is currently on!\n" print
->Raw Target:
Stampa i comandi possibili.
--

1115=========
->Original Input:
['def', 'add', '(', 'objects', ',', 'timestamp', '=', '@time', ')', 'unless', 'objects', '.', 'kind_of?', 'Array', 'objects', '=', '[', 'objects', ']', 'end', 'objects', '.', 'each', 'do', '|', 'object', '|', 'if', 'object', '.', 'instance_of?', 'Hash', 'timestamp', '=', 'object', '[', ':ts', ']', '||', '0', 'object', '=', 'object', '[', ':val', ']', 'end', 'token', '=', 'prepare_token', '(', 'object', ',', 'timestamp', ')', 'timestamp', '=', 'token', '.', 'timestamp', 'if', 'timestamp', '>', '@time', 'add_to_waiting', 'token', 'else', 'add_token', 'token', 'end', 'end', 'end']
->Original Target:
['Create', 'a', 'new', 'TimedHashMarking', 'Creates', 'token', 'with', '+', 'object', '+', 'as', 'its', 'value', 'and', 'adds', 'it', 'to', 'the', 'marking', '.', 'if', 'no', 'timestamp', 'is', 'given', 'current', 'time', 'will', 'be', 'used', '.']
->Reconstructed Target:
Create a new TimedHashMarking Creates token with + object + as its value and adds it to the marking. if no timestamp is given current time will be used.
->Reconstructed Predication:
the given objects to be added
->Raw Input:
summarize:def add ( objects, timestamp = @time ) unless objects. kind_of? Array objects = [ objects ] end objects. each do | object | if object. instance_of? Hash timestamp = object [ :ts ] || 0 object = object [ :val ] end token = prepare_token ( object, timestamp ) timestamp = token. timestamp if timestamp > @time add_to_waiting token else add_token token end end end
->Raw Target:
Create a new TimedHashMarking Creates token with + object + as its value and adds it to the marking. if no timestamp is given current time will be used.
--

1116=========
->Original Input:
['def', 'time', '=', '(', 'time', ')', 'if', 'time', '<', '@time', 'raise', 'InvalidTime', '.', 'new', '(', '"You are trying to put back clock from #{@time} back to #{time}"', ')', 'end', '@time', '=', 'time', '@waiting', '.', 'keys', '.', 'sort', '.', 'each', 'do', '|', 'timestamp', '|', 'if', 'timestamp', '>', '@time', '@next_time', '=', 'timestamp', 'break', 'end', '@waiting', '[', 'timestamp', ']', '.', 'each', '{', '|', 'token', '|', 'add_token', 'token', '}', '@waiting', '.', 'delete', 'timestamp', 'end', '@next_time', '=', '0', 'if', '@waiting', '.', 'empty?', '@time', 'end']
->Original Target:
['Set', 'current', 'time', 'for', 'the', 'marking', '.', 'This', 'will', 'cause', 'moving', 'tokens', 'from', 'waiting', 'to', 'active', 'list', '.', 'Putting', 'clock', 'back', 'will', 'cause', 'error', '.']
->Reconstructed Target:
Set current time for the marking. This will cause moving tokens from waiting to active list. Putting clock back will cause error.
->Reconstructed Predication:
the clock to the giventhe clock to the given
->Raw Input:
summarize:def time = ( time ) if time < @time raise InvalidTime. new ( "You are trying to put back clock from #{@time} back to #{time}" ) end @time = time @waiting. keys. sort. each do | timestamp | if timestamp > @time @next_time = timestamp break end @waiting [ timestamp ]. each { | token | add_token token } @waiting. delete timestamp end @next_time = 0 if @waiting. empty? @time end
->Raw Target:
Set current time for the marking. This will cause moving tokens from waiting to active list. Putting clock back will cause error.
--

1117=========
->Original Input:
['def', 'send_message', 'data', ',', 'binary', '=', 'false', 'if', 'established?', 'unless', '@closing', '@socket', '.', 'send_data', '(', '@encoder', '.', 'encode', '(', 'data', '.', 'to_s', ',', 'binary', '?', 'BINARY_FRAME', ':', 'TEXT_FRAME', ')', ')', 'end', 'else', 'raise', 'WebSocketError', '.', 'new', '"can\'t send on a closed channel"', 'end', 'end']
->Original Target:
['Send', 'a', 'message', 'to', 'the', 'remote', 'host']
->Reconstructed Target:
Send a message to the remote host
->Reconstructed Predication:
send a message to the
->Raw Input:
summarize:def send_message data, binary = false if established? unless @closing @socket. send_data ( @encoder. encode ( data. to_s, binary? BINARY_FRAME : TEXT_FRAME ) ) end else raise WebSocketError. new "can't send on a closed channel" end end
->Raw Target:
Send a message to the remote host
--

1118=========
->Original Input:
['def', 'post', '(', 'options', ')', 'uri', '=', 'new_uri', 'params', '=', 'merge_params', '(', 'options', ')', 'response', '=', 'Net', '::', 'HTTP', '.', 'post_form', '(', 'uri', ',', 'params', ')', 'unless', 'response', '.', 'is_a?', '(', 'Net', '::', 'HTTPSuccess', ')', 'raise', '"#{response.code} #{response.message}\\n#{response.body}"', 'end', 'response', '.', 'body', 'end']
->Original Target:
['==', 'instance', 'methods', 'Make', 'a', 'POST', 'API', 'call', 'with', 'the', 'current', 'path', 'value', 'and']
->Reconstructed Target:
== instance methods Make a POST API call with the current path value and
->Reconstructed Predication:
POST a POST request to thethe request to the API
->Raw Input:
summarize:def post ( options ) uri = new_uri params = merge_params ( options ) response = Net :: HTTP. post_form ( uri, params ) unless response. is_a? ( Net :: HTTPSuccess ) raise "#{response.code} #{response.message}\n#{response.body}" end response. body end
->Raw Target:
== instance methods Make a POST API call with the current path value and
--

1119=========
->Original Input:
['def', 'delete', '(', 'options', '=', '{', '}', ')', 'uri', '=', 'new_uri', 'params', '=', 'merge_params', '(', 'options', ')', 'uri', '.', 'query', '=', 'URI', '.', 'encode_www_form', '(', 'params', ')', 'http', '=', 'Net', '::', 'HTTP', '.', 'new', '(', 'uri', '.', 'host', ',', 'uri', '.', 'port', ')', 'request', '=', 'Net', '::', 'HTTP', '::', 'Delete', '.', 'new', '(', 'uri', ')', 'response', '=', 'http', '.', 'request', '(', 'request', ')', 'unless', 'response', '.', 'is_a?', '(', 'Net', '::', 'HTTPSuccess', ')', 'raise', '"#{response.code} #{response.message}\\n#{response.body}"', 'end', 'true', 'end']
->Original Target:
['Make', 'a', 'DELETE', 'API', 'call', 'with', 'the', 'current', 'path', 'value', 'and']
->Reconstructed Target:
Make a DELETE API call with the current path value and
->Reconstructed Predication:
the request to thethe request to the endpoint
->Raw Input:
summarize:def delete ( options = { } ) uri = new_uri params = merge_params ( options ) uri. query = URI. encode_www_form ( params ) http = Net :: HTTP. new ( uri. host, uri. port ) request = Net :: HTTP :: Delete. new ( uri ) response = http. request ( request ) unless response. is_a? ( Net :: HTTPSuccess ) raise "#{response.code} #{response.message}\n#{response.body}" end true end
->Raw Target:
Make a DELETE API call with the current path value and
--

1120=========
->Original Input:
['def', 'instance_metadata', '(', 'name', ')', 'instance', '=', 'instance', '(', 'name', ')', 'config', '=', '{', '}', 'if', 'instance', '.', 'configured?', 'config', '=', 'instance', '.', 'configfile_hash', 'config', '[', '"ensure"', ']', '=', ':present', 'else', 'config', '[', '"ensure"', ']', '=', ':absent', 'end', 'config', '[', '"name"', ']', '=', 'name', 'config', 'end']
->Original Target:
['Return', 'a', 'has', 'representing', 'the', 'named', 'instance', '.', 'This', 'is', 'suitable', 'for', 'Puppet', 'type', 'and', 'provider', 'or', 'you', 'can', 'use', 'the', 'returned', 'info', 'for', 'whatever', 'you', 'like']
->Reconstructed Target:
Return a has representing the named instance. This is suitable for Puppet type and provider or you can use the returned info for whatever you like
->Reconstructed Predication:
the metadata for the specified instance
->Raw Input:
summarize:def instance_metadata ( name ) instance = instance ( name ) config = { } if instance. configured? config = instance. configfile_hash config [ "ensure" ] = :present else config [ "ensure" ] = :absent end config [ "name" ] = name config end
->Raw Target:
Return a has representing the named instance. This is suitable for Puppet type and provider or you can use the returned info for whatever you like
--

1121=========
->Original Input:
['def', 'instances_metadata', '(', ')', 'instance_wildcard', '=', 'File', '.', 'join', '(', '@vagrant_vm_dir', ',', '"*"', ',', '::', 'Vagrantomatic', '::', 'Instance', '::', 'VAGRANTFILE', ')', 'instances', '=', '{', '}', 'Dir', '.', 'glob', '(', 'instance_wildcard', ')', '.', 'each', '{', '|', 'f', '|', 'elements', '=', 'f', '.', 'split', '(', 'File', '::', 'SEPARATOR', ')', 'name', '=', 'elements', '[', 'elements', '.', 'size', '-', '2', ']', 'instances', '[', 'name', ']', '=', 'instance_metadata', '(', 'name', ')', '}', 'instances', 'end']
->Original Target:
['Return', 'a', 'hash', 'of', 'all', 'instances']
->Reconstructed Target:
Return a hash of all instances
->Reconstructed Predication:
instances metadata for the
->Raw Input:
summarize:def instances_metadata ( ) instance_wildcard = File. join ( @vagrant_vm_dir, "*", :: Vagrantomatic :: Instance :: VAGRANTFILE ) instances = { } Dir. glob ( instance_wildcard ). each { | f | elements = f. split ( File :: SEPARATOR ) name = elements [ elements. size - 2 ] instances [ name ] = instance_metadata ( name ) } instances end
->Raw Target:
Return a hash of all instances
--

1122=========
->Original Input:
['def', 'csv_read', '(', 'path', ')', 'lines', '=', 'begin', 'if', 'path', '=~', '/', '\\.', '/', 'Zlib', '::', 'GzipReader', '.', 'open', '(', 'path', ')', 'do', '|', 'f', '|', 'CSV', '.', 'new', '(', 'f', ')', '.', 'read', 'end', 'else', 'CSV', '.', 'read', '(', 'path', ')', 'end', 'end', 'keys', '=', 'lines', '.', 'shift', '.', 'map', '(', '&', ':to_sym', ')', 'klass', '=', 'Struct', '.', 'new', '(', '*', 'keys', ')', 'lines', '.', 'map', '{', '|', 'i', '|', 'klass', '.', 'new', '(', '*', 'i', ')', '}', 'end']
->Original Target:
['Read', 'a', 'csv', 'from', '+', 'path', '+', '.', 'Returns', 'an', 'array', 'of', 'Structs', 'using', 'the', 'keys', 'from', 'the', 'csv', 'header', 'row', '.']
->Reconstructed Target:
Read a csv from + path +. Returns an array of Structs using the keys from the csv header row.
->Reconstructed Predication:
the file to read.the file to read.
->Raw Input:
summarize:def csv_read ( path ) lines = begin if path =~ / \. / Zlib :: GzipReader. open ( path ) do | f | CSV. new ( f ). read end else CSV. read ( path ) end end keys = lines. shift. map ( & :to_sym ) klass = Struct. new ( * keys ) lines. map { | i | klass. new ( * i ) } end
->Raw Target:
Read a csv from + path +. Returns an array of Structs using the keys from the csv header row.
--

1123=========
->Original Input:
['def', 'csv_write', '(', 'path', ',', 'rows', ',', 'cols', ':', 'nil', ')', 'atomic_write', '(', 'path', ')', 'do', '|', 'tmp', '|', 'CSV', '.', 'open', '(', 'tmp', '.', 'path', ',', '"wb"', ')', '{', '|', 'f', '|', 'csv_write0', '(', 'f', ',', 'rows', ',', 'cols', ':', 'cols', ')', '}', 'end', 'end']
->Original Target:
['Write', '+', 'rows', '+', 'to', '+', 'path', '+', 'as', 'csv', '.', 'Rows', 'can', 'be', 'an', 'array', 'of', 'hashes', 'Structs', 'OpenStructs', 'or', 'anything', 'else', 'that', 'responds', 'to', 'to_h', '.', 'The', 'keys', 'from', 'the', 'first', 'row', 'are', 'used', 'as', 'the', 'csv', 'header', '.', 'If', '+', 'cols', '+', 'is', 'specified', 'it', 'will', 'be', 'used', 'as', 'the', 'column', 'keys', 'instead', '.']
->Reconstructed Target:
Write + rows + to + path + as csv. Rows can be an array of hashes Structs OpenStructs or anything else that responds to to_h. The keys from the first row are used as the csv header. If + cols + is specified it will be used as the column keys instead.
->Reconstructed Predication:
the file to write to
->Raw Input:
summarize:def csv_write ( path, rows, cols : nil ) atomic_write ( path ) do | tmp | CSV. open ( tmp. path, "wb" ) { | f | csv_write0 ( f, rows, cols : cols ) } end end
->Raw Target:
Write + rows + to + path + as csv. Rows can be an array of hashes Structs OpenStructs or anything else that responds to to_h. The keys from the first row are used as the csv header. If + cols + is specified it will be used as the column keys instead.
--

1124=========
->Original Input:
['def', 'csv_to_s', '(', 'rows', ',', 'cols', ':', 'nil', ')', 'string', '=', '""', 'f', '=', 'CSV', '.', 'new', '(', 'StringIO', '.', 'new', '(', 'string', ')', ')', 'csv_write0', '(', 'f', ',', 'rows', ',', 'cols', ':', 'cols', ')', 'string', 'end']
->Original Target:
['Returns', 'a', 'string', 'containing', '+', 'rows', '+', 'as', 'a', 'csv', '.', 'Similar', 'to', 'csv_write', '.']
->Reconstructed Target:
Returns a string containing + rows + as a csv. Similar to csv_write.
->Reconstructed Predication:
the CSV to a string
->Raw Input:
summarize:def csv_to_s ( rows, cols : nil ) string = "" f = CSV. new ( StringIO. new ( string ) ) csv_write0 ( f, rows, cols : cols ) string end
->Raw Target:
Returns a string containing + rows + as a csv. Similar to csv_write.
--

1125=========
->Original Input:
['def', 'add_value', '(', 'name', ',', 'type', ',', 'subtype', '=', 'nil', ')', 'if', 'type', '.', 'class', '==', 'RustyJson', '::', 'RustStruct', '||', 'subtype', '.', 'class', '==', 'RustyJson', '::', 'RustStruct', 'if', 'type', '.', 'class', '==', 'RustyJson', '::', 'RustStruct', 't', '=', 'type', 'type', '=', 'type', '.', 'name', 'struct', '=', 't', 'elsif', 'subtype', '.', 'class', '==', 'RustyJson', '::', 'RustStruct', 's', '=', 'subtype', 'subtype', '=', 'subtype', '.', 'name', 'struct', '=', 's', 'end', '@structs', '<<', 'struct', 'RustStruct', '.', 'add_type', '(', 'struct', '.', 'name', ',', 'struct', '.', 'name', ')', 'end', '@values', '[', 'name', ']', '=', '[', 'type', ',', 'subtype', ']', 'true', 'end']
->Original Target:
['Add', 'Value', 'is', 'how', 'we', 'add', 'keys', 'to', 'the', 'resulting', 'Struct', 'We', 'need', 'a', 'name', 'and', 'a', 'type', 'and', 'potentially', 'a', 'subtype']
->Reconstructed Target:
Add Value is how we add keys to the resulting Struct We need a name and a type and potentially a subtype
->Reconstructed Predication:
the value to be added to
->Raw Input:
summarize:def add_value ( name, type, subtype = nil ) if type. class == RustyJson :: RustStruct || subtype. class == RustyJson :: RustStruct if type. class == RustyJson :: RustStruct t = type type = type. name struct = t elsif subtype. class == RustyJson :: RustStruct s = subtype subtype = subtype. name struct = s end @structs << struct RustStruct. add_type ( struct. name, struct. name ) end @values [ name ] = [ type, subtype ] true end
->Raw Target:
Add Value is how we add keys to the resulting Struct We need a name and a type and potentially a subtype
--

1126=========
->Original Input:
['def', 'rotate', '(', 'hsh', ')', 'current_ec2', ',', 'new_ec2', '=', 'hsh', '.', 'first', 'cur_instances', '=', 'EC2', '.', 'by_tags', '(', '"Name"', '=>', 'current_ec2', '.', 'to_s', ')', 'new_instances', '=', 'EC2', '.', 'by_tags', '(', '"Name"', '=>', 'new_ec2', '.', 'to_s', ')', 'register_and_wait', 'new_instances', 'deregister', 'cur_instances', 'end']
->Original Target:
['Rotate', 'servers', 'given']
->Reconstructed Target:
Rotate servers given
->Reconstructed Predication:
the new instance and the new
->Raw Input:
summarize:def rotate ( hsh ) current_ec2, new_ec2 = hsh. first cur_instances = EC2. by_tags ( "Name" => current_ec2. to_s ) new_instances = EC2. by_tags ( "Name" => new_ec2. to_s ) register_and_wait new_instances deregister cur_instances end
->Raw Target:
Rotate servers given
--

1127=========
->Original Input:
['def', 'wait_for_state', '(', 'instances', ',', 'exp_state', ')', 'time', '=', '0', 'all_good', '=', 'false', 'loop', 'do', 'all_good', '=', 'instances', '.', 'all?', 'do', '|', 'i', '|', 'state', '=', 'i', '.', 'elb_health', '[', ':state', ']', 'puts', '"#{i.id}: #{state}"', 'exp_state', '==', 'state', 'end', 'break', 'if', 'all_good', '||', 'time', '>', 'timeout', 'sleep', '1', 'time', '+=', '1', 'end', 'unless', 'all_good', 'raise', '"Instances are out of service"', 'end', 'end']
->Original Target:
['Wait', 'for', 'all', 'the', 'instances', 'to', 'become', 'InService']
->Reconstructed Target:
Wait for all the instances to become InService
->Reconstructed Predication:
wait for the state of
->Raw Input:
summarize:def wait_for_state ( instances, exp_state ) time = 0 all_good = false loop do all_good = instances. all? do | i | state = i. elb_health [ :state ] puts "#{i.id}: #{state}" exp_state == state end break if all_good || time > timeout sleep 1 time += 1 end unless all_good raise "Instances are out of service" end end
->Raw Target:
Wait for all the instances to become InService
--

1128=========
->Original Input:
['def', 'read', '(', 'path', ')', 'owconnect', 'do', '|', 'socket', '|', 'owwrite', '(', 'socket', ',', ':path', '=>', 'path', ',', ':function', '=>', 'READ', ')', 'return', 'to_number', '(', 'owread', '(', 'socket', ')', '.', 'data', ')', 'end', 'end']
->Original Target:
['Read', 'a', 'value', 'from', 'an', 'OW', 'path', '.']
->Reconstructed Target:
Read a value from an OW path.
->Reconstructed Predication:
 def read ( path
->Raw Input:
summarize:def read ( path ) owconnect do | socket | owwrite ( socket, :path => path, :function => READ ) return to_number ( owread ( socket ). data ) end end
->Raw Target:
Read a value from an OW path.
--

1129=========
->Original Input:
['def', 'write', '(', 'path', ',', 'value', ')', 'owconnect', 'do', '|', 'socket', '|', 'owwrite', '(', 'socket', ',', ':path', '=>', 'path', ',', ':value', '=>', 'value', '.', 'to_s', ',', ':function', '=>', 'WRITE', ')', 'return', 'owread', '(', 'socket', ')', '.', 'return_value', 'end', 'end']
->Original Target:
['Write', 'a', 'value', 'to', 'an', 'OW', 'path', '.']
->Reconstructed Target:
Write a value to an OW path.
->Reconstructed Predication:
 def write ( path
->Raw Input:
summarize:def write ( path, value ) owconnect do | socket | owwrite ( socket, :path => path, :value => value. to_s, :function => WRITE ) return owread ( socket ). return_value end end
->Raw Target:
Write a value to an OW path.
--

1130=========
->Original Input:
['def', 'dir', '(', 'path', ')', 'owconnect', 'do', '|', 'socket', '|', 'owwrite', '(', 'socket', ',', ':path', '=>', 'path', ',', ':function', '=>', 'DIR', ')', 'fields', '=', '[', ']', 'while', 'true', 'response', '=', 'owread', '(', 'socket', ')', 'if', 'response', '.', 'data', 'fields', '<<', 'response', '.', 'data', 'else', 'break', 'end', 'end', 'return', 'fields', 'end', 'end']
->Original Target:
['List', 'the', 'contents', 'of', 'an', 'OW', 'path', '.']
->Reconstructed Target:
List the contents of an OW path.
->Reconstructed Predication:
end end  def dir
->Raw Input:
summarize:def dir ( path ) owconnect do | socket | owwrite ( socket, :path => path, :function => DIR ) fields = [ ] while true response = owread ( socket ) if response. data fields << response. data else break end end return fields end end
->Raw Target:
List the contents of an OW path.
--

1131=========
->Original Input:
['def', 'sum_totals_by_model', '@sum_totals_by_model', '||=', 'begin', 'totals', '=', 'Hash', '.', 'new', '{', '|', 'hash', ',', 'key', '|', 'hash', '[', 'key', ']', '=', 'Hash', '.', 'new', '(', '0', ')', '}', '@queries_by_model', '.', 'each', 'do', '|', 'model', ',', 'queries', '|', 'totals', '[', 'model', ']', '[', ':query_count', ']', '=', 'queries', '.', 'length', 'queries', '.', 'each', 'do', '|', 'query', '|', 'query', '.', 'statistics', '.', 'each', 'do', '|', 'stat', ',', 'value', '|', 'totals', '[', 'model', ']', '[', 'stat', ']', '+=', 'value', 'end', 'end', 'totals', '[', 'model', ']', '[', ':datastore_interaction_time', ']', '=', 'totals', '[', 'model', ']', '[', ':datastore_interaction_time', ']', 'end', 'totals', 'end', 'end']
->Original Target:
['sums', 'up', 'statistics', 'across', 'all', 'queries', 'indexed', 'by', 'model']
->Reconstructed Target:
sums up statistics across all queries indexed by model
->Reconstructed Predication:
@queries_by_model = Hash. new@total_totals_by_model = Hash. new@total_totals_by_model = Hash. new@total_totals_by_model = Hash. new
->Raw Input:
summarize:def sum_totals_by_model @sum_totals_by_model ||= begin totals = Hash. new { | hash, key | hash [ key ] = Hash. new ( 0 ) } @queries_by_model. each do | model, queries | totals [ model ] [ :query_count ] = queries. length queries. each do | query | query. statistics. each do | stat, value | totals [ model ] [ stat ] += value end end totals [ model ] [ :datastore_interaction_time ] = totals [ model ] [ :datastore_interaction_time ] end totals end end
->Raw Target:
sums up statistics across all queries indexed by model
--

1132=========
->Original Input:
['def', 'sum_totals', '@sum_totals', '||=', 'begin', 'totals', '=', 'Hash', '.', 'new', '(', '0', ')', 'sum_totals_by_model', '.', 'each', 'do', '|', '_', ',', 'model_totals', '|', 'model_totals', '.', 'each', 'do', '|', 'stat', ',', 'value', '|', 'totals', '[', 'stat', ']', '+=', 'value', 'end', 'end', 'totals', 'end', 'end']
->Original Target:
['sums', 'up', 'statistics', 'across', 'all', 'models', 'and', 'queries']
->Reconstructed Target:
sums up statistics across all models and queries
->Reconstructed Predication:
the totals of the model
->Raw Input:
summarize:def sum_totals @sum_totals ||= begin totals = Hash. new ( 0 ) sum_totals_by_model. each do | _, model_totals | model_totals. each do | stat, value | totals [ stat ] += value end end totals end end
->Raw Target:
sums up statistics across all models and queries
--

1133=========
->Original Input:
['def', 'to_label', 's', '=', "'%016x%08x'", 'sec', '=', 'tai_second', 'ts', '=', 'if', 'sec', '>=', '0', 'sec', '+', 'EPOCH', 'else', 'EPOCH', '-', 'sec', 'end', 'Label', '.', 'new', 's', '%', '[', 'ts', ',', 'tai_nanosecond', ']', 'end']
->Original Target:
['Warning', 'this', 'will', 'probably', 'gain', 'inappropriate', 'accuracy', '-', 'Ruby', 'does', 'not', 'support', 'the', 'same', 'level', 'of', 'timing', 'accuracy', 'as', 'TAI64N', 'and', 'TA64NA', 'can', 'provide', '.']
->Reconstructed Target:
Warning this will probably gain inappropriate accuracy - Ruby does not support the same level of timing accuracy as TAI64N and TA64NA can provide.
->Reconstructed Predication:
a label with a time
->Raw Input:
summarize:def to_label s = '%016x%08x' sec = tai_second ts = if sec >= 0 sec + EPOCH else EPOCH - sec end Label. new s % [ ts, tai_nanosecond ] end
->Raw Target:
Warning this will probably gain inappropriate accuracy - Ruby does not support the same level of timing accuracy as TAI64N and TA64NA can provide.
--

1134=========
->Original Input:
['def', 'put', '(', 'name', ',', 'object', ')', 'raise', '"This ObjectContext already has an instance or configuration for \'#{name.to_s}\'"', 'if', 'directly_has?', '(', 'name', ')', 'Conject', '.', 'install_object_context', '(', 'object', ',', 'self', ')', 'object', '.', 'instance_variable_set', '(', ':@_conject_contextual_name', ',', 'name', '.', 'to_s', ')', '@cache', '[', 'name', '.', 'to_sym', ']', '=', 'object', 'end']
->Original Target:
['Inject', 'a', 'named', 'object', 'into', 'this', 'context']
->Reconstructed Target:
Inject a named object into this context
->Reconstructed Predication:
the object to be used for
->Raw Input:
summarize:def put ( name, object ) raise "This ObjectContext already has an instance or configuration for '#{name.to_s}'" if directly_has? ( name ) Conject. install_object_context ( object, self ) object. instance_variable_set ( :@_conject_contextual_name, name. to_s ) @cache [ name. to_sym ] = object end
->Raw Target:
Inject a named object into this context
--

1135=========
->Original Input:
['def', 'configure_objects', '(', 'confs', '=', '{', '}', ')', 'confs', '.', 'each', 'do', '|', 'key', ',', 'opts', '|', 'key', '=', 'key', '.', 'to_sym', '@object_configs', '[', 'key', ']', '=', '{', '}', 'unless', 'has_config?', '(', 'key', ')', '@object_configs', '[', 'key', ']', '.', 'merge!', '(', 'opts', ')', 'end', 'end']
->Original Target:
['Allow', 'configuration', 'options', 'to', 'be', 'set', 'for', 'named', 'objects', '.']
->Reconstructed Target:
Allow configuration options to be set for named objects.
->Reconstructed Predication:
the object configurations to be used
->Raw Input:
summarize:def configure_objects ( confs = { } ) confs. each do | key, opts | key = key. to_sym @object_configs [ key ] = { } unless has_config? ( key ) @object_configs [ key ]. merge! ( opts ) end end
->Raw Target:
Allow configuration options to be set for named objects.
--

1136=========
->Original Input:
['def', 'httperf', 'warm_up', '=', 'false', 'httperf_cmd', '=', 'build_httperf_cmd', 'if', 'warm_up', 'status', '"\\n#{httperf_cmd} (warm up run)"', 'IO', '.', 'popen', '(', '"#{httperf_cmd} 2>&1"', ')', 'else', 'IO', '.', 'popen', '(', '"#{httperf_cmd} 2>&1"', ')', 'do', '|', 'pipe', '|', 'status', '"\\n#{httperf_cmd}"', '@results', '<<', '(', 'httperf_result', '=', 'HttperfResult', '.', 'new', '(', '{', ':rate', '=>', '@current_rate', ',', ':server', '=>', '@current_job', '.', 'server', ',', ':port', '=>', '@current_job', '.', 'port', ',', ':uri', '=>', '@current_job', '.', 'uri', ',', ':num_conns', '=>', '@current_job', '.', 'num_conns', ',', ':description', '=>', '@current_job', '.', 'description', '}', ')', ')', 'HttperfResultParser', '.', 'new', '(', 'pipe', ')', '.', 'parse', '(', 'httperf_result', ')', 'end', 'end', 'end']
->Original Target:
['Runs', 'httperf', 'with', 'a', 'given', 'request', 'rate', '.', 'Parses', 'the', 'output', 'and', 'returns', 'a', 'hash', 'with', 'the', 'results', '.']
->Reconstructed Target:
Runs httperf with a given request rate. Parses the output and returns a hash with the results.
->Reconstructed Predication:
thethe result to be returned.
->Raw Input:
summarize:def httperf warm_up = false httperf_cmd = build_httperf_cmd if warm_up status "\n#{httperf_cmd} (warm up run)" IO. popen ( "#{httperf_cmd} 2>&1" ) else IO. popen ( "#{httperf_cmd} 2>&1" ) do | pipe | status "\n#{httperf_cmd}" @results << ( httperf_result = HttperfResult. new ( { :rate => @current_rate, :server => @current_job. server, :port => @current_job. port, :uri => @current_job. uri, :num_conns => @current_job. num_conns, :description => @current_job. description } ) ) HttperfResultParser. new ( pipe ). parse ( httperf_result ) end end end
->Raw Target:
Runs httperf with a given request rate. Parses the output and returns a hash with the results.
--

1137=========
->Original Input:
['def', 'url', '(', 'path', ',', 'params', '=', '{', '}', ')', 'params', '=', 'params', '.', 'inject', '(', '{', '}', ',', '&', '@@stringify', ')', 'path', '=', 'path', '.', 'gsub', '(', '@@placeholder', ')', '{', 'params', '.', 'delete', '(', '$1', ',', '&', '@@required', ')', '}', 'params', '=', 'params', '.', 'inject', '(', "''", ',', '&', '@@parameterize', ')', '[', 'path', ',', 'params', ']', '.', 'reject', '(', '&', ':nil?', ')', '.', 'reject', '(', '&', ':empty?', ')', '.', 'join', '(', "'?'", ')', 'end']
->Original Target:
['Converts', 'a', 'path', 'and', 'params', 'to', 'a', 'Salesforce', '-', 'suitable', 'URL', '.']
->Reconstructed Target:
Converts a path and params to a Salesforce - suitable URL.
->Reconstructed Predication:
url path params paramsurl path params
->Raw Input:
summarize:def url ( path, params = { } ) params = params. inject ( { }, & @@stringify ) path = path. gsub ( @@placeholder ) { params. delete ( $1, & @@required ) } params = params. inject ( '', & @@parameterize ) [ path, params ]. reject ( & :nil? ). reject ( & :empty? ). join ( '?' ) end
->Raw Target:
Converts a path and params to a Salesforce - suitable URL.
--

1138=========
->Original Input:
['def', 'url?', '(', 'string', ')', 'return', 'false', 'unless', 'string', '.', 'to_s', '=~', 'url_pattern', 'return', 'false', 'if', 'string', '.', 'to_s', '=~', '@@placeholder', 'true', 'end']
->Original Target:
['Identifies', 'a', 'valid', 'URL', 'for', 'this', 'REST', 'instance']
->Reconstructed Target:
Identifies a valid URL for this REST instance
->Reconstructed Predication:
return true if string. to_s
->Raw Input:
summarize:def url? ( string ) return false unless string. to_s =~ url_pattern return false if string. to_s =~ @@placeholder true end
->Raw Target:
Identifies a valid URL for this REST instance
--

1139=========
->Original Input:
['def', 'assit_equal', '(', 'expected', ',', 'actual', ',', 'message', '=', '"Object expected to be equal"', ')', 'if', '(', 'expected', '!=', 'actual', ')', 'message', '<<', '" expected #{expected} but was #{actual}"', 'assit', '(', 'false', ',', 'message', ')', 'end', 'end']
->Original Target:
['Assert', 'if', 'two', 'objects', 'are', 'equal']
->Reconstructed Target:
Assert if two objects are equal
->Reconstructed Predication:
object to be equal to object
->Raw Input:
summarize:def assit_equal ( expected, actual, message = "Object expected to be equal" ) if ( expected!= actual ) message << " expected #{expected} but was #{actual}" assit ( false, message ) end end
->Raw Target:
Assert if two objects are equal
--

1140=========
->Original Input:
['def', 'assit_kind_of', '(', 'klass', ',', 'object', ',', 'message', '=', '"Object of wrong type"', ')', 'if', '(', '!', 'object', '.', 'kind_of?', '(', 'klass', ')', ')', 'message', '<<', '" (Expected #{klass} but was #{object.class})"', 'assit', '(', 'false', ',', 'message', ')', 'end', 'end']
->Original Target:
['Assert', 'if', 'something', 'is', 'of', 'the', 'right', 'type']
->Reconstructed Target:
Assert if something is of the right type
->Reconstructed Predication:
object must be a
->Raw Input:
summarize:def assit_kind_of ( klass, object, message = "Object of wrong type" ) if (! object. kind_of? ( klass ) ) message << " (Expected #{klass} but was #{object.class})" assit ( false, message ) end end
->Raw Target:
Assert if something is of the right type
--

1141=========
->Original Input:
['def', 'assit_real_string', '(', 'object', ',', 'message', '=', '"Not a non-empty string."', ')', 'unless', '(', 'object', '&&', 'object', '.', 'kind_of?', '(', 'String', ')', '&&', 'object', '.', 'strip', '!=', '""', ')', 'assit', '(', 'false', ',', 'message', ')', 'end', 'end']
->Original Target:
['Asserts', 'that', 'the', 'given', 'element', 'is', 'a', 'string', 'that', 'is', 'not', 'nil', 'and', 'not', 'an', 'empty', 'string', 'or', 'a', 'string', 'only', 'containing', 'whitspaces']
->Reconstructed Target:
Asserts that the given element is a string that is not nil and not an empty string or a string only containing whitspaces
->Reconstructed Predication:
the string to be assited. Returns the
->Raw Input:
summarize:def assit_real_string ( object, message = "Not a non-empty string." ) unless ( object && object. kind_of? ( String ) && object. strip!= "" ) assit ( false, message ) end end
->Raw Target:
Asserts that the given element is a string that is not nil and not an empty string or a string only containing whitspaces
--

1142=========
->Original Input:
['def', 'assit_block', '(', '&', 'block', ')', 'errors', '=', '[', ']', 'assit', '(', '(', 'block', '.', 'call', '(', 'errors', ')', '&&', 'errors', '.', 'size', '==', '0', ')', ',', 'errors', '.', 'join', '(', "', '", ')', ')', 'end']
->Original Target:
['Executes', 'the', 'given', 'block', 'and', 'asserts', 'if', 'the', 'result', 'is', 'true', '.', 'This', 'allows', 'you', 'to', 'assert', 'on', 'complex', 'custom', 'expressions', 'and', 'be', 'able', 'to', 'disable', 'those', 'expressions', 'together', 'with', 'the', 'assertions', '.', 'See', 'the', 'README', 'for', 'more', '.']
->Reconstructed Target:
Executes the given block and asserts if the result is true. This allows you to assert on complex custom expressions and be able to disable those expressions together with the assertions. See the README for more.
->Reconstructed Predication:
the block to be used for
->Raw Input:
summarize:def assit_block ( & block ) errors = [ ] assit ( ( block. call ( errors ) && errors. size == 0 ), errors. join ( ',') ) end
->Raw Target:
Executes the given block and asserts if the result is true. This allows you to assert on complex custom expressions and be able to disable those expressions together with the assertions. See the README for more.
--

1143=========
->Original Input:
['def', 'poll', 'interval', ':', '10', ',', '&', 'block', 'raise', "'#poll requires a block'", 'unless', 'block_given?', 'response_id', '=', '0', 'loop', 'do', 'res', '=', 'self', '.', 'sync', 'response_id', 'if', 'res', 'response_id', '=', 'res', '[', "'rid'", ']', 'yield', 'res', 'end', 'sleep', 'interval', 'end', 'end']
->Original Target:
['Polls', 'the', 'client', 'for', 'incremental', 'changes', '.']
->Reconstructed Target:
Polls the client for incremental changes.
->Reconstructed Predication:
block until the block is
->Raw Input:
summarize:def poll interval : 10, & block raise '#poll requires a block' unless block_given? response_id = 0 loop do res = self. sync response_id if res response_id = res [ 'rid' ] yield res end sleep interval end end
->Raw Target:
Polls the client for incremental changes.
--

1144=========
->Original Input:
['def', 'sync', 'response_id', '=', '0', 'req', '=', 'self', '.', 'class', '.', 'get', "'/sync/maindata'", ',', 'format', ':', ':json', ',', 'query', ':', '{', 'rid', ':', 'response_id', '}', 'res', '=', 'req', '.', 'parsed_response', 'if', 'req', '.', 'success?', 'return', 'res', 'end', 'end']
->Original Target:
['Requests', 'partial', 'data', 'from', 'the', 'client', '.']
->Reconstructed Target:
Requests partial data from the client.
->Reconstructed Predication:
return the sync data for the
->Raw Input:
summarize:def sync response_id = 0 req = self. class. get '/sync/maindata', format : :json, query : { rid : response_id } res = req. parsed_response if req. success? return res end end
->Raw Target:
Requests partial data from the client.
--

1145=========
->Original Input:
['def', 'add_trackers', 'torrent_hash', ',', 'urls', 'urls', '=', 'Array', '(', 'urls', ')', 'urls', '=', 'urls', '.', 'map', '{', '|', 'url', '|', 'url', '.', 'gsub', '(', "'&'", ',', "'%26'", ')', '}', 'urls', '=', 'urls', '.', 'join', '(', "'%0A'", ')', 'options', '=', '{', 'body', ':', '"hash=#{torrent_hash}&urls=#{urls}"', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/addTrackers'", ',', 'options', ')', 'end']
->Original Target:
['Add', 'one', 'or', 'more', 'trackers', 'to', 'a', 'torrent']
->Reconstructed Target:
Add one or more trackers to a torrent
->Reconstructed Predication:
 def add_trackers ( torrent_hash
->Raw Input:
summarize:def add_trackers torrent_hash, urls urls = Array ( urls ) urls = urls. map { | url | url. gsub ( '&', '%26' ) } urls = urls. join ( '%0A' ) options = { body : "hash=#{torrent_hash}&urls=#{urls}" } self. class. post ( '/command/addTrackers', options ) end
->Raw Target:
Add one or more trackers to a torrent
--

1146=========
->Original Input:
['def', 'download', 'urls', 'urls', '=', 'Array', '(', 'urls', ')', 'urls', '=', 'urls', '.', 'join', '(', "'%0A'", ')', 'options', '=', '{', 'body', ':', '"urls=#{urls}"', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/download'", ',', 'options', ')', 'end']
->Original Target:
['Begin', 'downloading', 'one', 'or', 'more', 'torrents', '.']
->Reconstructed Target:
Begin downloading one or more torrents.
->Reconstructed Predication:
 def download ( urls
->Raw Input:
summarize:def download urls urls = Array ( urls ) urls = urls. join ( '%0A' ) options = { body : "urls=#{urls}" } self. class. post ( '/command/download', options ) end
->Raw Target:
Begin downloading one or more torrents.
--

1147=========
->Original Input:
['def', 'delete_torrent_and_data', 'torrent_hashes', 'torrent_hashes', '=', 'Array', '(', 'torrent_hashes', ')', 'torrent_hashes', '=', 'torrent_hashes', '.', 'join', '(', "'|'", ')', 'options', '=', '{', 'body', ':', '"hashes=#{torrent_hashes}"', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/deletePerm'", ',', 'options', ')', 'end']
->Original Target:
['Delete', 'one', 'or', 'more', 'torrents', 'AND', 'THEIR', 'DATA']
->Reconstructed Target:
Delete one or more torrents AND THEIR DATA
->Reconstructed Predication:
 def delete_torrent_and_data torrent_hashes
->Raw Input:
summarize:def delete_torrent_and_data torrent_hashes torrent_hashes = Array ( torrent_hashes ) torrent_hashes = torrent_hashes. join ( '|' ) options = { body : "hashes=#{torrent_hashes}" } self. class. post ( '/command/deletePerm', options ) end
->Raw Target:
Delete one or more torrents AND THEIR DATA
--

1148=========
->Original Input:
['def', 'set_location', '(', 'torrent_hashes', ',', 'path', ')', 'torrent_hashes', '=', 'Array', '(', 'torrent_hashes', ')', 'torrent_hashes', '=', 'torrent_hashes', '.', 'join', '(', "'|'", ')', 'options', '=', '{', 'body', ':', '{', '"hashes"', '=>', 'torrent_hashes', ',', '"location"', '=>', 'path', '}', ',', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/setLocation'", ',', 'options', ')', 'end']
->Original Target:
['Set', 'location', 'for', 'a', 'torrent']
->Reconstructed Target:
Set location for a torrent
->Reconstructed Predication:
 def set_location ( torrent_hashes
->Raw Input:
summarize:def set_location ( torrent_hashes, path ) torrent_hashes = Array ( torrent_hashes ) torrent_hashes = torrent_hashes. join ( '|' ) options = { body : { "hashes" => torrent_hashes, "location" => path }, } self. class. post ( '/command/setLocation', options ) end
->Raw Target:
Set location for a torrent
--

1149=========
->Original Input:
['def', 'increase_priority', 'torrent_hashes', 'torrent_hashes', '=', 'Array', '(', 'torrent_hashes', ')', 'torrent_hashes', '=', 'torrent_hashes', '.', 'join', '(', "'|'", ')', 'options', '=', '{', 'body', ':', '"hashes=#{torrent_hashes}"', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/increasePrio'", ',', 'options', ')', 'end']
->Original Target:
['Increase', 'the', 'priority', 'of', 'one', 'or', 'more', 'torrents']
->Reconstructed Target:
Increase the priority of one or more torrents
->Reconstructed Predication:
the priority of a torrent
->Raw Input:
summarize:def increase_priority torrent_hashes torrent_hashes = Array ( torrent_hashes ) torrent_hashes = torrent_hashes. join ( '|' ) options = { body : "hashes=#{torrent_hashes}" } self. class. post ( '/command/increasePrio', options ) end
->Raw Target:
Increase the priority of one or more torrents
--

1150=========
->Original Input:
['def', 'decrease_priority', 'torrent_hashes', 'torrent_hashes', '=', 'Array', '(', 'torrent_hashes', ')', 'torrent_hashes', '=', 'torrent_hashes', '.', 'join', '(', "'|'", ')', 'options', '=', '{', 'body', ':', '"hashes=#{torrent_hashes}"', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/decreasePrio'", ',', 'options', ')', 'end']
->Original Target:
['Decrease', 'the', 'priority', 'of', 'one', 'or', 'more', 'torrents']
->Reconstructed Target:
Decrease the priority of one or more torrents
->Reconstructed Predication:
the number of torrents to decrease
->Raw Input:
summarize:def decrease_priority torrent_hashes torrent_hashes = Array ( torrent_hashes ) torrent_hashes = torrent_hashes. join ( '|' ) options = { body : "hashes=#{torrent_hashes}" } self. class. post ( '/command/decreasePrio', options ) end
->Raw Target:
Decrease the priority of one or more torrents
--

1151=========
->Original Input:
['def', 'maximize_priority', 'torrent_hashes', 'torrent_hashes', '=', 'Array', '(', 'torrent_hashes', ')', 'torrent_hashes', '=', 'torrent_hashes', '.', 'join', '(', "'|'", ')', 'options', '=', '{', 'body', ':', '"hashes=#{torrent_hashes}"', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/topPrio'", ',', 'options', ')', 'end']
->Original Target:
['Increase', 'the', 'priority', 'of', 'one', 'or', 'more', 'torrents', 'to', 'the', 'maximum', 'value']
->Reconstructed Target:
Increase the priority of one or more torrents to the maximum value
->Reconstructed Predication:
the maximize priority of a torrent
->Raw Input:
summarize:def maximize_priority torrent_hashes torrent_hashes = Array ( torrent_hashes ) torrent_hashes = torrent_hashes. join ( '|' ) options = { body : "hashes=#{torrent_hashes}" } self. class. post ( '/command/topPrio', options ) end
->Raw Target:
Increase the priority of one or more torrents to the maximum value
--

1152=========
->Original Input:
['def', 'minimize_priority', 'torrent_hashes', 'torrent_hashes', '=', 'Array', '(', 'torrent_hashes', ')', 'torrent_hashes', '=', 'torrent_hashes', '.', 'join', '(', "'|'", ')', 'options', '=', '{', 'body', ':', '"hashes=#{torrent_hashes}"', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/bottomPrio'", ',', 'options', ')', 'end']
->Original Target:
['Decrease', 'the', 'priority', 'of', 'one', 'or', 'more', 'torrents', 'to', 'the', 'minimum', 'value']
->Reconstructed Target:
Decrease the priority of one or more torrents to the minimum value
->Reconstructed Predication:
the number of torrents to minimize
->Raw Input:
summarize:def minimize_priority torrent_hashes torrent_hashes = Array ( torrent_hashes ) torrent_hashes = torrent_hashes. join ( '|' ) options = { body : "hashes=#{torrent_hashes}" } self. class. post ( '/command/bottomPrio', options ) end
->Raw Target:
Decrease the priority of one or more torrents to the minimum value
--

1153=========
->Original Input:
['def', 'set_file_priority', 'torrent_hash', ',', 'file_id', ',', 'priority', 'query', '=', '[', '"hash=#{torrent_hash}"', ',', '"id=#{file_id}"', ',', '"priority=#{priority}"', ']', 'options', '=', '{', 'body', ':', 'query', '.', 'join', '(', "'&'", ')', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/setFilePrio'", ',', 'options', ')', 'end']
->Original Target:
['Set', 'the', 'download', 'priority', 'of', 'a', 'file', 'within', 'a', 'torrent']
->Reconstructed Target:
Set the download priority of a file within a torrent
->Reconstructed Predication:
 def set_file_priority ( torrent_hash
->Raw Input:
summarize:def set_file_priority torrent_hash, file_id, priority query = [ "hash=#{torrent_hash}", "id=#{file_id}", "priority=#{priority}" ] options = { body : query. join ( '&' ) } self. class. post ( '/command/setFilePrio', options ) end
->Raw Target:
Set the download priority of a file within a torrent
--

1154=========
->Original Input:
['def', 'set_download_limit', 'torrent_hash', ',', 'limit', 'query', '=', '[', '"hashes=#{torrent_hash}"', ',', '"limit=#{limit}"', ']', 'options', '=', '{', 'body', ':', 'query', '.', 'join', '(', "'&'", ')', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/setTorrentsDlLimit'", ',', 'options', ')', 'end']
->Original Target:
['Set', 'a', 'torrent', 's', 'download', 'limit']
->Reconstructed Target:
Set a torrent s download limit
->Reconstructed Predication:
 def set_download_limit ( torrent_hash
->Raw Input:
summarize:def set_download_limit torrent_hash, limit query = [ "hashes=#{torrent_hash}", "limit=#{limit}" ] options = { body : query. join ( '&' ) } self. class. post ( '/command/setTorrentsDlLimit', options ) end
->Raw Target:
Set a torrent s download limit
--

1155=========
->Original Input:
['def', 'set_upload_limit', 'torrent_hash', ',', 'limit', 'query', '=', '[', '"hashes=#{torrent_hash}"', ',', '"limit=#{limit}"', ']', 'options', '=', '{', 'body', ':', 'query', '.', 'join', '(', "'&'", ')', '}', 'self', '.', 'class', '.', 'post', '(', "'/command/setTorrentsUpLimit'", ',', 'options', ')', 'end']
->Original Target:
['Set', 'a', 'torrent', 's', 'upload', 'limit']
->Reconstructed Target:
Set a torrent s upload limit
->Reconstructed Predication:
 def set_upload_limit ( torrent_hash
->Raw Input:
summarize:def set_upload_limit torrent_hash, limit query = [ "hashes=#{torrent_hash}", "limit=#{limit}" ] options = { body : query. join ( '&' ) } self. class. post ( '/command/setTorrentsUpLimit', options ) end
->Raw Target:
Set a torrent s upload limit
--

1156=========
->Original Input:
['def', 'md5_file', '(', 'path', ')', 'File', '.', 'open', '(', 'path', ')', 'do', '|', 'f', '|', 'digest', ',', 'buf', '=', 'Digest', '::', 'MD5', '.', 'new', ',', '""', 'while', 'f', '.', 'read', '(', '4096', ',', 'buf', ')', 'digest', '.', 'update', '(', 'buf', ')', 'end', 'digest', '.', 'hexdigest', 'end', 'end']
->Original Target:
['Return', 'the', 'md5', 'checksum', 'for', 'the', 'file', 'at', '+', 'path', '+', '.']
->Reconstructed Target:
Return the md5 checksum for the file at + path +.
->Reconstructed Predication:
file path
->Raw Input:
summarize:def md5_file ( path ) File. open ( path ) do | f | digest, buf = Digest :: MD5. new, "" while f. read ( 4096, buf ) digest. update ( buf ) end digest. hexdigest end end
->Raw Target:
Return the md5 checksum for the file at + path +.
--

1157=========
->Original Input:
['def', 'keys', '(', '*', 'a', ')', 'if', 'block_given?', 'bucket', '.', 'keys', '(', '*', 'a', ')', 'do', '|', 'keys', '|', 'if', 'keys', '.', 'kind_of?', 'Array', 'keys', '.', 'each', 'do', '|', 'key', '|', 'yield', 'key', 'end', 'else', 'yield', 'keys', 'end', 'end', 'else', 'bucket', '.', 'keys', '(', '*', 'a', ')', 'end', 'end']
->Original Target:
['Iterate', 'over', 'all', 'keys', '.']
->Reconstructed Target:
Iterate over all keys.
->Reconstructed Predication:
the keys of the bucket
->Raw Input:
summarize:def keys ( * a ) if block_given? bucket. keys ( * a ) do | keys | if keys. kind_of? Array keys. each do | key | yield key end else yield keys end end else bucket. keys ( * a ) end end
->Raw Target:
Iterate over all keys.
--

1158=========
->Original Input:
['def', 'each', 'bucket', '.', 'keys', 'do', '|', 'keys', '|', 'keys', '.', 'each', 'do', '|', 'key', '|', 'if', 'x', '=', 'self', '[', 'key', ']', 'yield', 'x', 'end', 'end', 'end', 'end']
->Original Target:
['Iterate', 'over', 'all', 'items', 'using', 'key', 'streaming', '.']
->Reconstructed Target:
Iterate over all items using key streaming.
->Reconstructed Predication:
each key in the bucket
->Raw Input:
summarize:def each bucket. keys do | keys | keys. each do | key | if x = self [ key ] yield x end end end end
->Raw Target:
Iterate over all items using key streaming.
--

1159=========
->Original Input:
['def', 'run', '(', 'command', ',', 'args', '=', 'nil', ')', 'cmd', '=', 'CommandLine', '.', 'new', '(', 'command', ',', 'args', ')', 'vputs', '(', 'cmd', ')', 'cmd', '.', 'run', 'end']
->Original Target:
['Run', 'an', 'external', 'command', '.', 'Raise', 'Error', 'if', 'something', 'goes', 'wrong', '.', 'The', 'command', 'will', 'be', 'echoed', 'if', 'verbose?', '.']
->Reconstructed Target:
Run an external command. Raise Error if something goes wrong. The command will be echoed if verbose?.
->Reconstructed Predication:
 def run ( command
->Raw Input:
summarize:def run ( command, args = nil ) cmd = CommandLine. new ( command, args ) vputs ( cmd ) cmd. run end
->Raw Target:
Run an external command. Raise Error if something goes wrong. The command will be echoed if verbose?.
--

1160=========
->Original Input:
['def', 'clicks', '(', 'options', '=', '{', '}', ')', 'options', '=', 'update_by_expire_time', 'options', 'if', 'clicks_not_latest?', '(', 'options', ')', '@rsqoot_clicks', '=', 'get', '(', "'clicks'", ',', 'options', ',', 'SqootClick', ')', '@rsqoot_clicks', '=', '@rsqoot_clicks', '.', 'clicks', 'if', '@rsqoot_clicks', '@rsqoot_clicks', '=', '@rsqoot_clicks', '.', 'clicks', '.', 'map', '(', '&', ':click', ')', 'if', '@rsqoot_clicks', '.', 'clicks', 'end', 'logger', '(', 'uri', ':', 'sqoot_query_uri', ',', 'records', ':', '@rsqoot_clicks', ',', 'type', ':', "'clicks'", ',', 'opts', ':', 'options', ')', '@rsqoot_clicks', 'end']
->Original Target:
['Retrieve', 'a', 'list', 'of', 'clicks', 'based', 'on', 'the', 'following', 'parameters']
->Reconstructed Target:
Retrieve a list of clicks based on the following parameters
->Reconstructed Predication:
: clicks :: clicks : clicks: clicks )
->Raw Input:
summarize:def clicks ( options = { } ) options = update_by_expire_time options if clicks_not_latest? ( options ) @rsqoot_clicks = get ( 'clicks', options, SqootClick ) @rsqoot_clicks = @rsqoot_clicks. clicks if @rsqoot_clicks @rsqoot_clicks = @rsqoot_clicks. clicks. map ( & :click ) if @rsqoot_clicks. clicks end logger ( uri : sqoot_query_uri, records : @rsqoot_clicks, type : 'clicks', opts : options ) @rsqoot_clicks end
->Raw Target:
Retrieve a list of clicks based on the following parameters
--

1161=========
->Original Input:
['def', 'build_instances', '(', 'template', '=', 'nil', ')', 'build_args', '=', 'if', 'template', '==', ':template', '[', 'build_options', '.', 'first', '.', 'merge', '(', 'count', ':', '1', ')', ']', 'else', 'build_options', 'end', 'build_args', '.', 'map', 'do', '|', 'args', '|', 'instances', '=', 'create_instance', 'args', 'apply_tags', '(', 'instances', ')', 'instances', 'end', '.', 'flatten', 'end']
->Original Target:
['Build', 'instances', 'using', 'build', 'options']
->Reconstructed Target:
Build instances using build options
->Reconstructed Predication:
instances to be built
->Raw Input:
summarize:def build_instances ( template = nil ) build_args = if template == :template [ build_options. first. merge ( count : 1 ) ] else build_options end build_args. map do | args | instances = create_instance args apply_tags ( instances ) instances end. flatten end
->Raw Target:
Build instances using build options
--

1162=========
->Original Input:
['def', 'scope', '(', 'scope_name', ',', 'scope_enum_keys', ')', 'target_enum', '=', '@record_class', '.', 'defined_enums', '[', '@enum_name', '.', 'to_s', ']', 'sub_enum_values', '=', 'target_enum', '.', 'values_at', '(', '*', 'scope_enum_keys', ')', 'if', '@record_class', '.', 'defined_enum_scopes', '.', 'has_key?', '(', 'scope_name', ')', 'fail', 'ArgumentError', ',', '"Conflicting scope names. A scope named #{scope_name} has already been defined"', 'elsif', 'sub_enum_values', '.', 'include?', '(', 'nil', ')', 'unknown_key', '=', 'scope_enum_keys', '[', 'sub_enum_values', '.', 'index', '(', 'nil', ')', ']', 'fail', 'ArgumentError', ',', '"Unknown key - #{unknown_key} for enum #{@enum_name}"', 'elsif', '@record_class', '.', 'respond_to?', '(', 'scope_name', '.', 'to_s', '.', 'pluralize', ')', 'fail', 'ArgumentError', ',', '"Scope name - #{scope_name} conflicts with a class method of the same name"', 'elsif', '@record_class', '.', 'instance_methods', '.', 'include?', '(', '"#{scope_name}?"', '.', 'to_sym', ')', 'fail', 'ArgumentError', ',', '"Scope name - #{scope_name} conflicts with the instance method - #{scope_name}?"', 'end', 'sub_enum_entries', '=', 'target_enum', '.', 'slice', '(', '*', 'scope_enum_keys', ')', '@record_class', '.', 'defined_enum_scopes', '[', 'scope_name', ']', '=', 'sub_enum_entries', '@record_class', '.', 'send', '(', ':define_method', ',', '"#{scope_name}?"', ')', '{', 'sub_enum_entries', '.', 'include?', 'self', '.', 'role', '}', '@record_class', '.', 'scope', 'scope_name', '.', 'to_s', '.', 'pluralize', ',', '->', '{', '@record_class', '.', 'where', '(', '"#{@enum_name}"', '=>', 'sub_enum_entries', '.', 'values', ')', '}', '@scope_names', '<<', 'scope_name', 'end']
->Original Target:
['Initialize', 'a', 'new', 'ScopeCreator', 'object']
->Reconstructed Target:
Initialize a new ScopeCreator object
->Reconstructed Predication:
scope_name. to_s. pluralizescope_name. to_s. pluralizescope_name. to_s. pluralizescope_name. to_s.scope_name. to_s. pluralize) {. values ). values ). values ). values ). values ). values ). values ). values ). values ). values ). values ).
->Raw Input:
summarize:def scope ( scope_name, scope_enum_keys ) target_enum = @record_class. defined_enums [ @enum_name. to_s ] sub_enum_values = target_enum. values_at ( * scope_enum_keys ) if @record_class. defined_enum_scopes. has_key? ( scope_name ) fail ArgumentError, "Conflicting scope names. A scope named #{scope_name} has already been defined" elsif sub_enum_values. include? ( nil ) unknown_key = scope_enum_keys [ sub_enum_values. index ( nil ) ] fail ArgumentError, "Unknown key - #{unknown_key} for enum #{@enum_name}" elsif @record_class. respond_to? ( scope_name. to_s. pluralize ) fail ArgumentError, "Scope name - #{scope_name} conflicts with a class method of the same name" elsif @record_class. instance_methods. include? ( "#{scope_name}?". to_sym ) fail ArgumentError, "Scope name - #{scope_name} conflicts with the instance method - #{scope_name}?" end sub_enum_entries = target_enum. slice ( * scope_enum_keys ) @record_class. defined_enum_scopes [ scope_name ] = sub_enum_entries @record_class. send ( :define_method, "#{scope_name}?" ) { sub_enum_entries. include? self. role } @record_class. scope scope_name. to_s. pluralize, -> { @record_class. where ( "#{@enum_name}" => sub_enum_entries. values ) } @scope_names << scope_name end
->Raw Target:
Initialize a new ScopeCreator object
--

1163=========
->Original Input:
['def', 'configure', 'configuration', '=', '{', ':options', '=>', '{', ':verbose', '=>', 'false', ',', ':coloring', '=>', "'AUTO'", '}', ',', ':mount', '=>', '{', ':source', '=>', '{', ':name', '=>', 'nil', '}', ',', ':mountpoint', '=>', '{', ':name', '=>', 'nil', '}', ',', ':passphrasefile', '=>', '{', ':name', '=>', "'passphrase'", '}', ',', ':keyfile', '=>', '{', ':name', '=>', "'encfs6.xml'", '}', ',', ':cmd', '=>', 'nil', ',', ':executable', '=>', 'nil', '}', ',', ':unmount', '=>', '{', ':mountpoint', '=>', '{', ':name', '=>', 'nil', '}', ',', ':cmd', '=>', 'nil', ',', ':executable', '=>', 'nil', '}', ',', ':copy', '=>', '{', ':source', '=>', '{', ':name', '=>', 'nil', '}', ',', ':destination', '=>', '{', ':name', '=>', 'nil', '}', ',', ':cmd', '=>', 'nil', ',', ':executable', '=>', 'nil', '}', '}', 'config', '=', '@options', '[', ':config', ']', 'unless', 'config', 'config', '=', '[', 'File', '.', 'join', '(', '@working_dir', ',', '"revenc.conf"', ')', ',', 'File', '.', 'join', '(', '@working_dir', ',', '".revenc.conf"', ')', ',', 'File', '.', 'join', '(', '@working_dir', ',', '"config"', ',', '"revenc.conf"', ')', ',', 'File', '.', 'expand_path', '(', 'File', '.', 'join', '(', '"~"', ',', '".revenc.conf"', ')', ')', ']', '.', 'detect', '{', '|', 'filename', '|', 'File', '.', 'exists?', '(', 'filename', ')', '}', 'end', 'if', 'config', '&&', 'File', '.', 'exists?', '(', 'config', ')', '@options', '[', ':config', ']', '=', 'config', 'config_contents', '=', 'YAML', '::', 'load', '(', 'File', '.', 'open', '(', 'config', ')', ')', 'configuration', '.', 'merge!', '(', 'config_contents', '.', 'symbolize_keys!', ')', 'if', 'config_contents', '&&', 'config_contents', '.', 'is_a?', '(', 'Hash', ')', 'else', 'raise', '"config file not found"', 'if', '@options', '[', ':config', ']', 'end', '@options', '=', 'configuration', '[', ':options', ']', '.', 'merge!', '(', '@options', ')', '@options', '.', 'symbolize_keys!', '@options', '[', ':mount', ']', '=', 'configuration', '[', ':mount', ']', '.', 'recursively_symbolize_keys!', 'if', 'configuration', '[', ':mount', ']', '@options', '[', ':unmount', ']', '=', 'configuration', '[', ':unmount', ']', '.', 'recursively_symbolize_keys!', 'if', 'configuration', '[', ':unmount', ']', '@options', '[', ':copy', ']', '=', 'configuration', '[', ':copy', ']', '.', 'recursively_symbolize_keys!', 'if', 'configuration', '[', ':copy', ']', 'end']
->Original Target:
['read', 'options', 'from', 'YAML', 'config']
->Reconstructed Target:
read options from YAML config
->Reconstructed Predication:
:command => { :name =>:command => { :name =>:command => { :name =>:command => { :name =>:command => { :name =>:command => { :name =>:command => { :name =>:command => { :name =>:command => { :name =>:command => { :name =>:command => { :name =>:command => { :name =>:
->Raw Input:
summarize:def configure configuration = { :options => { :verbose => false, :coloring => 'AUTO' }, :mount => { :source => { :name => nil }, :mountpoint => { :name => nil }, :passphrasefile => { :name => 'passphrase' }, :keyfile => { :name => 'encfs6.xml' }, :cmd => nil, :executable => nil }, :unmount => { :mountpoint => { :name => nil }, :cmd => nil, :executable => nil }, :copy => { :source => { :name => nil }, :destination => { :name => nil }, :cmd => nil, :executable => nil } } config = @options [ :config ] unless config config = [ File. join ( @working_dir, "revenc.conf" ), File. join ( @working_dir, ".revenc.conf" ), File. join ( @working_dir, "config", "revenc.conf" ), File. expand_path ( File. join ( "~", ".revenc.conf" ) ) ]. detect { | filename | File. exists? ( filename ) } end if config && File. exists? ( config ) @options [ :config ] = config config_contents = YAML :: load ( File. open ( config ) ) configuration. merge! ( config_contents. symbolize_keys! ) if config_contents && config_contents. is_a? ( Hash ) else raise "config file not found" if @options [ :config ] end @options = configuration [ :options ]. merge! ( @options ) @options. symbolize_keys! @options [ :mount ] = configuration [ :mount ]. recursively_symbolize_keys! if configuration [ :mount ] @options [ :unmount ] = configuration [ :unmount ]. recursively_symbolize_keys! if configuration [ :unmount ] @options [ :copy ] = configuration [ :copy ]. recursively_symbolize_keys! if configuration [ :copy ] end
->Raw Target:
read options from YAML config
--

1164=========
->Original Input:
['def', 'mark_new_entries', '(', 'response', ')', 'digests', '=', 'summary_digests', 'response', '.', 'entries', '.', 'each', 'do', '|', 'e', '|', 'seen', '=', 'digests', '.', 'include?', '(', 'digest_for', '(', 'e', ')', ')', 'e', '.', 'instance_variable_set', '(', ':@_seen', ',', 'seen', ')', 'end', 'response', 'end']
->Original Target:
['Marks', 'entries', 'as', 'either', 'seen', 'or', 'not', 'seen', 'based', 'on', 'the', 'unique', 'signature', 'of', 'the', 'entry', 'which', 'is', 'calculated', 'by', 'taking', 'the', 'MD5', 'of', 'common', 'attributes', '.']
->Reconstructed Target:
Marks entries as either seen or not seen based on the unique signature of the entry which is calculated by taking the MD5 of common attributes.
->Reconstructed Predication:
the summary of the new entries
->Raw Input:
summarize:def mark_new_entries ( response ) digests = summary_digests response. entries. each do | e | seen = digests. include? ( digest_for ( e ) ) e. instance_variable_set ( :@_seen, seen ) end response end
->Raw Target:
Marks entries as either seen or not seen based on the unique signature of the entry which is calculated by taking the MD5 of common attributes.
--

1165=========
->Original Input:
['def', 'set_header_options', '(', 'curl', ')', 'summary', '=', 'summary_for_feed', 'unless', 'summary', '.', 'nil?', 'curl', '.', 'headers', '[', "'If-None-Match'", ']', '=', 'summary', '[', ':etag', ']', 'unless', 'summary', '[', ':etag', ']', '.', 'nil?', 'curl', '.', 'headers', '[', "'If-Modified-Since'", ']', '=', 'summary', '[', ':last_modified', ']', 'unless', 'summary', '[', ':last_modified', ']', '.', 'nil?', 'end', 'curl', 'end']
->Original Target:
['Sets', 'the', 'headers', 'from', 'the', 'backend', 'if', 'available']
->Reconstructed Target:
Sets the headers from the backend if available
->Reconstructed Predication:
the header options for the
->Raw Input:
summarize:def set_header_options ( curl ) summary = summary_for_feed unless summary. nil? curl. headers [ 'If-None-Match' ] = summary [ :etag ] unless summary [ :etag ]. nil? curl. headers [ 'If-Modified-Since' ] = summary [ :last_modified ] unless summary [ :last_modified ]. nil? end curl end
->Raw Target:
Sets the headers from the backend if available
--

1166=========
->Original Input:
['def', 'store_summary_to_backend', '(', 'feed', ',', 'curl', ')', 'headers', '=', 'HttpHeaders', '.', 'new', '(', 'curl', '.', 'header_str', ')', 'summary', '=', '{', '}', 'summary', '.', 'merge!', '(', ':etag', '=>', 'headers', '.', 'etag', ')', 'unless', 'headers', '.', 'etag', '.', 'nil?', 'summary', '.', 'merge!', '(', ':last_modified', '=>', 'headers', '.', 'last_modified', ')', 'unless', 'headers', '.', 'last_modified', '.', 'nil?', 'new_digest_set', '=', 'feed', '.', 'entries', '.', 'map', 'do', '|', 'e', '|', 'digest_for', '(', 'e', ')', 'end', 'new_digest_set', '=', 'summary_for_feed', '[', ':digests', ']', '.', 'unshift', '(', 'new_digest_set', ')', 'new_digest_set', '=', 'new_digest_set', '[', '0', '..', '@options', '[', ':retained_digest_size', ']', ']', 'summary', '.', 'merge!', '(', ':digests', '=>', 'new_digest_set', ')', 'set_summary', '(', 'summary', ')', 'end']
->Original Target:
['Stores', 'information', 'about', 'the', 'retrieval', 'including', 'ETag', 'Last', '-', 'Modified', 'and', 'MD5', 'digests', 'of', 'all', 'entries', 'to', 'the', 'backend', 'store', '.', 'This', 'enables', 'conditional', 'GET', 'usage', 'on', 'subsequent', 'requests', 'and', 'marking', 'of', 'entries', 'as', 'either', 'new', 'or', 'seen', '.']
->Reconstructed Target:
Stores information about the retrieval including ETag Last - Modified and MD5 digests of all entries to the backend store. This enables conditional GET usage on subsequent requests and marking of entries as either new or seen.
->Reconstructed Predication:
the feed to the backendthe feed to the backend.
->Raw Input:
summarize:def store_summary_to_backend ( feed, curl ) headers = HttpHeaders. new ( curl. header_str ) summary = { } summary. merge! ( :etag => headers. etag ) unless headers. etag. nil? summary. merge! ( :last_modified => headers. last_modified ) unless headers. last_modified. nil? new_digest_set = feed. entries. map do | e | digest_for ( e ) end new_digest_set = summary_for_feed [ :digests ]. unshift ( new_digest_set ) new_digest_set = new_digest_set [ 0.. @options [ :retained_digest_size ] ] summary. merge! ( :digests => new_digest_set ) set_summary ( summary ) end
->Raw Target:
Stores information about the retrieval including ETag Last - Modified and MD5 digests of all entries to the backend store. This enables conditional GET usage on subsequent requests and marking of entries as either new or seen.
--

1167=========
->Original Input:
['def', 'error_manager', '(', 'uri', ',', 'response', ')', 'case', 'response', 'when', 'Net', '::', 'HTTPSuccess', 'then', 'begin', 'data', '=', 'JSON', '.', 'parse', '(', 'response', '.', 'body', ')', 'rescue', 'data', '=', '{', '}', 'end', 'data', '[', "'headers'", ']', '=', 'response', '.', 'to_hash', '(', ')', 'return', 'data', 'when', 'Net', '::', 'HTTPBadRequest', 'raise', 'Ropenstack', '::', 'MalformedRequestError', ',', 'response', '.', 'body', 'when', 'Net', '::', 'HTTPNotFound', 'raise', 'Ropenstack', '::', 'NotFoundError', ',', '"URI: #{uri} \\n"', '+', 'response', '.', 'body', 'when', 'Net', '::', 'HTTPUnauthorized', 'raise', 'Ropenstack', '::', 'UnauthorisedError', ',', 'response', '.', 'body', 'else', 'raise', 'Ropenstack', '::', 'RopenstackError', ',', 'response', '.', 'body', 'end', 'end']
->Original Target:
['All', 'responses', 'from', 'openstack', 'where', 'any', 'errors', 'need', 'to', 'be', 'caught', 'are', 'passed', 'through', 'this', 'function', '.', 'Unless', 'a', 'successful', 'response', 'is', 'passed', 'it', 'will', 'throw', 'a', 'Ropenstack', 'error', '.', 'If', 'successful', 'returns', 'a', 'hash', 'of', 'response', 'body', 'unless', 'response', 'body', 'is', 'nil', 'then', 'it', 'returns', 'an', 'empty', 'hash', '.']
->Reconstructed Target:
All responses from openstack where any errors need to be caught are passed through this function. Unless a successful response is passed it will throw a Ropenstack error. If successful returns a hash of response body unless response body is nil then it returns an empty hash.
->Reconstructed Predication:
the error
->Raw Input:
summarize:def error_manager ( uri, response ) case response when Net :: HTTPSuccess then begin data = JSON. parse ( response. body ) rescue data = { } end data [ 'headers' ] = response. to_hash ( ) return data when Net :: HTTPBadRequest raise Ropenstack :: MalformedRequestError, response. body when Net :: HTTPNotFound raise Ropenstack :: NotFoundError, "URI: #{uri} \n" + response. body when Net :: HTTPUnauthorized raise Ropenstack :: UnauthorisedError, response. body else raise Ropenstack :: RopenstackError, response. body end end
->Raw Target:
All responses from openstack where any errors need to be caught are passed through this function. Unless a successful response is passed it will throw a Ropenstack error. If successful returns a hash of response body unless response body is nil then it returns an empty hash.
--

1168=========
->Original Input:
['def', 'do_request', '(', 'uri', ',', 'request', ',', 'manage_errors', '=', 'true', ',', 'timeout', '=', '10', ')', 'begin', 'http', '=', 'build_http', '(', 'uri', ',', 'timeout', ')', 'if', '(', 'manage_errors', ')', 'return', 'error_manager', '(', 'uri', ',', 'http', '.', 'request', '(', 'request', ')', ')', 'else', 'http', '.', 'request', '(', 'request', ')', 'return', '{', '"Success"', '=>', 'true', '}', 'end', 'rescue', 'Timeout', '::', 'Error', 'raise', 'Ropenstack', '::', 'TimeoutError', ',', '"It took longer than #{timeout} to connect to #{uri.to_s}"', 'rescue', 'Errno', '::', 'ECONNREFUSED', 'raise', 'Ropenstack', '::', 'TimeoutError', ',', '"It took longer than #{timeout} to connect to #{uri.to_s}"', 'end', 'end']
->Original Target:
['The', 'function', 'which', 'you', 'call', 'to', 'perform', 'a', 'http', 'request', 'using', 'the', 'request', 'object', 'given', 'in', 'the', 'parameters', '.', 'By', 'default', 'manage', 'errors', 'is', 'true', 'so', 'all', 'responses', 'are', 'passed', 'through', 'the', 'error', 'manager', 'which', 'converts', 'the', 'into', 'Ropenstack', 'errors', '.']
->Reconstructed Target:
The function which you call to perform a http request using the request object given in the parameters. By default manage errors is true so all responses are passed through the error manager which converts the into Ropenstack errors.
->Reconstructed Predication:
the request to the serverthe server to the server,the server to the server,the server, the server willthe server, the server willthe server, the server will be
->Raw Input:
summarize:def do_request ( uri, request, manage_errors = true, timeout = 10 ) begin http = build_http ( uri, timeout ) if ( manage_errors ) return error_manager ( uri, http. request ( request ) ) else http. request ( request ) return { "Success" => true } end rescue Timeout :: Error raise Ropenstack :: TimeoutError, "It took longer than #{timeout} to connect to #{uri.to_s}" rescue Errno :: ECONNREFUSED raise Ropenstack :: TimeoutError, "It took longer than #{timeout} to connect to #{uri.to_s}" end end
->Raw Target:
The function which you call to perform a http request using the request object given in the parameters. By default manage errors is true so all responses are passed through the error manager which converts the into Ropenstack errors.
--

1169=========
->Original Input:
['def', 'get_request', '(', 'uri', ',', 'token', '=', 'nil', ',', 'manage_errors', '=', 'true', ')', 'request', '=', 'Net', '::', 'HTTP', '::', 'Get', '.', 'new', '(', 'uri', '.', 'request_uri', ',', 'initheader', '=', 'build_headers', '(', 'token', ')', ')', 'return', 'do_request', '(', 'uri', ',', 'request', ',', 'manage_errors', ')', 'end']
->Original Target:
['Wrapper', 'function', 'for', 'a', 'get', 'request', 'just', 'provide', 'a', 'uri', 'and', 'it', 'will', 'return', 'you', 'a', 'hash', 'with', 'the', 'result', 'data', '.', 'For', 'authenticated', 'transactions', 'a', 'token', 'can', 'be', 'provided', '.', 'Implemented', 'using', 'the', 'do_request', 'method', '.']
->Reconstructed Target:
Wrapper function for a get request just provide a uri and it will return you a hash with the result data. For authenticated transactions a token can be provided. Implemented using the do_request method.
->Reconstructed Predication:
the request to the server.
->Raw Input:
summarize:def get_request ( uri, token = nil, manage_errors = true ) request = Net :: HTTP :: Get. new ( uri. request_uri, initheader = build_headers ( token ) ) return do_request ( uri, request, manage_errors ) end
->Raw Target:
Wrapper function for a get request just provide a uri and it will return you a hash with the result data. For authenticated transactions a token can be provided. Implemented using the do_request method.
--

1170=========
->Original Input:
['def', 'delete_request', '(', 'uri', ',', 'token', '=', 'nil', ',', 'manage_errors', '=', 'true', ')', 'request', '=', 'Net', '::', 'HTTP', '::', 'Delete', '.', 'new', '(', 'uri', '.', 'request_uri', ',', 'initheader', '=', 'build_headers', '(', 'token', ')', ')', 'return', 'do_request', '(', 'uri', ',', 'request', ',', 'manage_errors', ')', 'end']
->Original Target:
['Wrapper', 'function', 'for', 'delete', 'requests', 'just', 'provide', 'a', 'uri', 'and', 'it', 'will', 'return', 'you', 'a', 'hash', 'with', 'the', 'result', 'data', '.', 'For', 'authenticated', 'transactions', 'a', 'token', 'can', 'be', 'provided', '.', 'Implemented', 'using', 'the', 'do_request', 'method', '.']
->Reconstructed Target:
Wrapper function for delete requests just provide a uri and it will return you a hash with the result data. For authenticated transactions a token can be provided. Implemented using the do_request method.
->Reconstructed Predication:
the request to the endpoint
->Raw Input:
summarize:def delete_request ( uri, token = nil, manage_errors = true ) request = Net :: HTTP :: Delete. new ( uri. request_uri, initheader = build_headers ( token ) ) return do_request ( uri, request, manage_errors ) end
->Raw Target:
Wrapper function for delete requests just provide a uri and it will return you a hash with the result data. For authenticated transactions a token can be provided. Implemented using the do_request method.
--

1171=========
->Original Input:
['def', 'put_request', '(', 'uri', ',', 'body', ',', 'token', '=', 'nil', ',', 'manage_errors', '=', 'true', ')', 'request', '=', 'Net', '::', 'HTTP', '::', 'Put', '.', 'new', '(', 'uri', '.', 'request_uri', ',', 'initheader', '=', 'build_headers', '(', 'token', ')', ')', 'request', '.', 'body', '=', 'body', '.', 'to_json', 'return', 'do_request', '(', 'uri', ',', 'request', ',', 'manage_errors', ')', 'end']
->Original Target:
['Wrapper', 'function', 'for', 'a', 'put', 'request', 'just', 'provide', 'a', 'uri', 'and', 'a', 'hash', 'of', 'the', 'data', 'to', 'send', 'then', 'it', 'will', 'return', 'you', 'a', 'hash', 'with', 'the', 'result', 'data', '.', 'For', 'authenticated', 'transactions', 'a', 'token', 'can', 'be', 'provided', '.', 'Implemented', 'using', 'the', 'do_request', 'method']
->Reconstructed Target:
Wrapper function for a put request just provide a uri and a hash of the data to send then it will return you a hash with the result data. For authenticated transactions a token can be provided. Implemented using the do_request method
->Reconstructed Predication:
the request body. 
->Raw Input:
summarize:def put_request ( uri, body, token = nil, manage_errors = true ) request = Net :: HTTP :: Put. new ( uri. request_uri, initheader = build_headers ( token ) ) request. body = body. to_json return do_request ( uri, request, manage_errors ) end
->Raw Target:
Wrapper function for a put request just provide a uri and a hash of the data to send then it will return you a hash with the result data. For authenticated transactions a token can be provided. Implemented using the do_request method
--

1172=========
->Original Input:
['def', 'post_request', '(', 'uri', ',', 'body', ',', 'token', '=', 'nil', ',', 'manage_errors', '=', 'true', ')', 'request', '=', 'Net', '::', 'HTTP', '::', 'Post', '.', 'new', '(', 'uri', '.', 'request_uri', ',', 'initheader', '=', 'build_headers', '(', 'token', ')', ')', 'request', '.', 'body', '=', 'body', '.', 'to_json', 'return', 'do_request', '(', 'uri', ',', 'request', ',', 'manage_errors', ')', 'end']
->Original Target:
['Wrapper', 'function', 'for', 'a', 'put', 'request', 'just', 'provide', 'a', 'uri', 'and', 'a', 'hash', 'of', 'the', 'data', 'to', 'send', 'then', 'it', 'will', 'return', 'you', 'a', 'hash', 'with', 'the', 'result', 'data', '.', 'For', 'authenticated', 'transactions', 'a', 'token', 'can', 'be', 'provided', '.']
->Reconstructed Target:
Wrapper function for a put request just provide a uri and a hash of the data to send then it will return you a hash with the result data. For authenticated transactions a token can be provided.
->Reconstructed Predication:
POST request body
->Raw Input:
summarize:def post_request ( uri, body, token = nil, manage_errors = true ) request = Net :: HTTP :: Post. new ( uri. request_uri, initheader = build_headers ( token ) ) request. body = body. to_json return do_request ( uri, request, manage_errors ) end
->Raw Target:
Wrapper function for a put request just provide a uri and a hash of the data to send then it will return you a hash with the result data. For authenticated transactions a token can be provided.
--

1173=========
->Original Input:
['def', 'article', '(', 'id', ')', 'url', '=', 'index', '.', 'knowledgeManagement', '.', 'articles', '.', 'article', 'url', '=', 'url', '(', 'url', ',', 'ArticleID', ':', 'id', ')', 'decorate', '(', 'get', '(', 'url', ')', '.', 'body', ')', '{', '|', 'o', '|', 'autodefine', '(', 'o', ')', '}', 'end']
->Original Target:
['Gets', 'an', 'article', 'by', 'ID']
->Reconstructed Target:
Gets an article by ID
->Reconstructed Predication:
article : article  defarticle : article
->Raw Input:
summarize:def article ( id ) url = index. knowledgeManagement. articles. article url = url ( url, ArticleID : id ) decorate ( get ( url ). body ) { | o | autodefine ( o ) } end
->Raw Target:
Gets an article by ID
--

1174=========
->Original Input:
['def', 'upload_image_from_file', '(', 'name', ',', 'disk_format', ',', 'container_format', ',', 'minDisk', ',', 'minRam', ',', 'is_public', ',', 'file', ')', 'data', '=', '{', '"name"', '=>', 'name', ',', '"disk_format"', '=>', 'disk_format', ',', '"container_format"', '=>', 'container_format', ',', '"minDisk"', '=>', 'minDisk', ',', '"minRam"', '=>', 'minRam', ',', '"public"', '=>', 'is_public', '}', 'imagesBefore', '=', 'images', '(', ')', 'post_request', '(', 'address', '(', '"images"', ')', ',', 'data', ',', '@token', ',', 'false', ')', 'imagesAfter', '=', 'images', '(', ')', 'foundNewImage', '=', 'true', 'image', '=', 'nil', 'imagesAfter', '.', 'each', 'do', '|', 'imageA', '|', 'imagesBefore', '.', 'each', 'do', '|', 'imageB', '|', 'if', '(', 'imageA', '==', 'imageB', ')', 'foundNewImage', '=', 'false', 'end', 'end', 'if', '(', 'foundNewImage', ')', 'image', '=', 'imageA', 'break', 'end', 'end', 'return', 'put_octect', '(', 'address', '(', 'image', '[', '"file"', ']', ')', ',', 'file', '.', 'read', ',', 'false', ')', 'end']
->Original Target:
['BELOW', 'HERE', 'IS', 'OLD', 'CODE', 'THAT', 'MAY', 'OR', 'MAYNOT', 'WORK', 'THAR', 'BE', 'DRAGONS']
->Reconstructed Target:
BELOW HERE IS OLD CODE THAT MAY OR MAYNOT WORK THAR BE DRAGONS
->Reconstructed Predication:
file )return
->Raw Input:
summarize:def upload_image_from_file ( name, disk_format, container_format, minDisk, minRam, is_public, file ) data = { "name" => name, "disk_format" => disk_format, "container_format" => container_format, "minDisk" => minDisk, "minRam" => minRam, "public" => is_public } imagesBefore = images ( ) post_request ( address ( "images" ), data, @token, false ) imagesAfter = images ( ) foundNewImage = true image = nil imagesAfter. each do | imageA | imagesBefore. each do | imageB | if ( imageA == imageB ) foundNewImage = false end end if ( foundNewImage ) image = imageA break end end return put_octect ( address ( image [ "file" ] ), file. read, false ) end
->Raw Target:
BELOW HERE IS OLD CODE THAT MAY OR MAYNOT WORK THAR BE DRAGONS
--

1175=========
->Original Input:
['def', 'put_octect', '(', 'uri', ',', 'data', ',', 'manage_errors', ')', 'headers', '=', 'build_headers', '(', '@token', ')', 'headers', '[', '"Content-Type"', ']', '=', "'application/octet-stream'", 'req', '=', 'Net', '::', 'HTTP', '::', 'Put', '.', 'new', '(', 'uri', '.', 'request_uri', ',', 'initheader', '=', 'headers', ')', 'req', '.', 'body', '=', 'data', 'return', 'do_request', '(', 'uri', ',', 'req', ',', 'manage_errors', ',', '0', ')', 'end']
->Original Target:
['Special', 'rest', 'call', 'for', 'sending', 'a', 'file', 'stream', 'using', 'an', 'octet', '-', 'stream', 'main', 'change', 'is', 'just', 'custom', 'headers', '.', 'Still', 'implemented', 'using', 'do_request', 'function', '.']
->Reconstructed Target:
Special rest call for sending a file stream using an octet - stream main change is just custom headers. Still implemented using do_request function.
->Reconstructed Predication:
the data to be put into
->Raw Input:
summarize:def put_octect ( uri, data, manage_errors ) headers = build_headers ( @token ) headers [ "Content-Type" ] = 'application/octet-stream' req = Net :: HTTP :: Put. new ( uri. request_uri, initheader = headers ) req. body = data return do_request ( uri, req, manage_errors, 0 ) end
->Raw Target:
Special rest call for sending a file stream using an octet - stream main change is just custom headers. Still implemented using do_request function.
--

1176=========
->Original Input:
['def', 'relative_path', '(', 'path', ')', 'path', '=', 'File', '.', 'expand_path', '(', 'path', ')', 'root', '=', 'full_path', '(', '""', ')', 'if', 'path', '.', 'size', '>=', 'root', '.', 'size', '&&', 'path', '[', '0', '...', 'root', '.', 'size', ']', '==', 'root', 'path', '[', '0', '...', 'root', '.', 'size', ']', '=', '""', 'path', '=', '"/"', 'if', 'path', '.', 'size', '==', '0', 'path', 'end', 'end']
->Original Target:
['Returns', 'a', 'path', 'relative', 'to', 'the', 'base', 'path', 'given', 'the', 'full', 'path', '.', 'This', 'is', 'the', 'inverse', 'of', 'full_path', '.']
->Reconstructed Target:
Returns a path relative to the base path given the full path. This is the inverse of full_path.
->Reconstructed Predication:
path : path to the file
->Raw Input:
summarize:def relative_path ( path ) path = File. expand_path ( path ) root = full_path ( "" ) if path. size >= root. size && path [ 0... root. size ] == root path [ 0... root. size ] = "" path = "/" if path. size == 0 path end end
->Raw Target:
Returns a path relative to the base path given the full path. This is the inverse of full_path.
--

1177=========
->Original Input:
['def', 'index', '(', 'path', ')', '@entries', '=', '[', ']', 'Dir', '.', 'entries', '(', 'path', ')', '.', 'each', 'do', '|', 'entry', '|', 'relative_path', '=', 'relative_path', '(', 'File', '.', 'join', '(', 'path', ',', 'entry', ')', ')', 'if', 'entry', '!=', '"."', '&&', 'relative_path', '@entries', '<<', '{', ':name', '=>', 'entry', ',', ':href', '=>', 'relative_path', '}', 'end', 'end', '@path', '=', 'path', 'haml', ':index', 'end']
->Original Target:
['Renders', 'an', 'index', 'page', 'for', 'the', 'specified', 'directory', '.']
->Reconstructed Target:
Renders an index page for the specified directory.
->Reconstructed Predication:
@path = path @entries =
->Raw Input:
summarize:def index ( path ) @entries = [ ] Dir. entries ( path ). each do | entry | relative_path = relative_path ( File. join ( path, entry ) ) if entry!= "." && relative_path @entries << { :name => entry, :href => relative_path } end end @path = path haml :index end
->Raw Target:
Renders an index page for the specified directory.
--

1178=========
->Original Input:
['def', 'accessors_from_headers!', 'raise', '"Can\'t define accessors from headers in a table without headers"', 'unless', '@has_headers', 'self', '.', 'accessors', '=', 'headers', '.', 'map', '{', '|', 'val', '|', '(', 'val', '&&', '!', 'val', '.', 'empty?', ')', '?', 'val', '.', 'to_s', '.', 'downcase', '.', 'tr', '(', "'^a-z0-9_'", ',', "'_'", ')', '.', 'squeeze', '(', "'_'", ')', '.', 'gsub', '(', '/', '\\A', '\\z', '/', ',', "''", ')', '.', 'to_sym', ':', 'nil', '}', 'end']
->Original Target:
['Create', 'a', 'new', 'table', '.']
->Reconstructed Target:
Create a new table.
->Reconstructed Predication:
the table with the given headers.
->Raw Input:
summarize:def accessors_from_headers! raise "Can't define accessors from headers in a table without headers" unless @has_headers self. accessors = headers. map { | val | ( val &&! val. empty? )? val. to_s. downcase. tr ( '^a-z0-9_', '_' ). squeeze ( '_' ). gsub ( / \A \z /, '' ). to_sym : nil } end
->Raw Target:
Create a new table.
--

1179=========
->Original Input:
['def', '<<', '(', 'row', ')', 'index', '=', '@data', '.', 'size', 'begin', 'row', '=', 'row', '.', 'to_ary', 'rescue', 'NoMethodError', 'raise', 'ArgumentError', ',', '"Row must be provided as Array or respond to `to_ary`, but got #{row.class} in row #{index}"', 'unless', 'row', '.', 'respond_to?', '(', ':to_ary', ')', 'raise', 'end', 'raise', 'InvalidColumnCount', '.', 'new', '(', 'index', ',', 'row', '.', 'size', ',', 'column_count', ')', 'if', '@data', '.', 'first', '&&', 'row', '.', 'size', '!=', '@data', '.', 'first', '.', 'size', '@data', '<<', 'row', '@rows', '<<', 'Row', '.', 'new', '(', 'self', ',', 'index', ',', 'row', ')', 'self', 'end']
->Original Target:
['Append', 'a', 'row', 'to', 'the', 'table', '.']
->Reconstructed Target:
Append a row to the table.
->Reconstructed Predication:
the row to be summarizeed.
->Raw Input:
summarize:def << ( row ) index = @data. size begin row = row. to_ary rescue NoMethodError raise ArgumentError, "Row must be provided as Array or respond to `to_ary`, but got #{row.class} in row #{index}" unless row. respond_to? ( :to_ary ) raise end raise InvalidColumnCount. new ( index, row. size, column_count ) if @data. first && row. size!= @data. first. size @data << row @rows << Row. new ( self, index, row ) self end
->Raw Target:
Append a row to the table.
--

1180=========
->Original Input:
['def', 'html', '(', 'id', ',', 'time', ')', 'inline_footnote_label', '=', 'Build', '.', 'tag', '(', '"span"', ',', 'Build', '.', 'tag', '(', '"sup"', ',', 'id', '.', 'to_s', ')', ',', ':class', '=>', '"inline-footnote-number"', ')', 'Build', '.', 'tag', '(', '"a"', ',', 'inline_footnote_label', ',', ':href', '=>', '"#footnote#{id}#{time}"', ')', 'end']
->Original Target:
['This', 'is', 'the', 'method', 'that', 'will', 'place', 'the', 'anchor', 'tag', 'and', 'id', 'of', 'the', 'footnote', 'within', 'the', 'paragraph', 'body', 'itself', '.']
->Reconstructed Target:
This is the method that will place the anchor tag and id of the footnote within the paragraph body itself.
->Reconstructed Predication:
footnotefootnote_label
->Raw Input:
summarize:def html ( id, time ) inline_footnote_label = Build. tag ( "span", Build. tag ( "sup", id. to_s ), :class => "inline-footnote-number" ) Build. tag ( "a", inline_footnote_label, :href => "#footnote#{id}#{time}" ) end
->Raw Target:
This is the method that will place the anchor tag and id of the footnote within the paragraph body itself.
--

1181=========
->Original Input:
['def', 'footnote_html', '(', 'id', ',', 'time', ')', 'footnote_label', '=', 'Build', '.', 'tag', '(', '"span"', ',', 'Build', '.', 'tag', '(', '"sup"', ',', 'id', '.', 'to_s', ')', ',', ':class', '=>', '"footnote-number"', ')', 'footnote_content', '=', 'sequence', '.', 'elements', '.', 'map', '{', '|', 's', '|', 's', '.', 'html', '}', '.', 'join', 'Build', '.', 'tag', '(', '"div"', ',', 'footnote_label', '+', 'footnote_content', ',', ':id', '=>', '"footnote#{id}#{time}"', ',', ':class', '=>', '"footnote"', ')', 'end']
->Original Target:
['This', 'is', 'the', 'method', 'that', 'will', 'actually', 'spit', 'out', 'the', 'div', 'that', 'the', 'footnote', 's', 'content', 'is', 'in', '.', 'This', 'will', 'generally', 'be', 'called', 'after', 'all', 'of', 'the', 'paragraph', 's', 'text', 'has', 'been', 'spit', 'out', 'so', 'that', 'the', 'footnotes', 'can', 'be', 'appended', 'after', '.', 'Note', 'that', 'it', 'needs', 'to', 'be', 'passed', 'an', 'id', 'from', 'the', 'caller', 'so', 'that', 'it', 'can', 'be', 'linked', 'to', 'corretly', 'with', 'an', 'anchor', 'tag', 'in', 'the', 'body', 'of', 'the', 'main', 'text', '.']
->Reconstructed Target:
This is the method that will actually spit out the div that the footnote s content is in. This will generally be called after all of the paragraph s text has been spit out so that the footnotes can be appended after. Note that it needs to be passed an id from the caller so that it can be linked to corretly with an anchor tag in the body of the main text.
->Reconstructed Predication:
footnotefootnote_content
->Raw Input:
summarize:def footnote_html ( id, time ) footnote_label = Build. tag ( "span", Build. tag ( "sup", id. to_s ), :class => "footnote-number" ) footnote_content = sequence. elements. map { | s | s. html }. join Build. tag ( "div", footnote_label + footnote_content, :id => "footnote#{id}#{time}", :class => "footnote" ) end
->Raw Target:
This is the method that will actually spit out the div that the footnote s content is in. This will generally be called after all of the paragraph s text has been spit out so that the footnotes can be appended after. Note that it needs to be passed an id from the caller so that it can be linked to corretly with an anchor tag in the body of the main text.
--

1182=========
->Original Input:
['def', 'instance_action', '(', 'id', ',', 'action', ',', 'param', ')', 'case', 'action', 'when', '"RESTART"', 'post_request', '(', 'address', '(', '"/instances/"', '+', 'id', '+', '"/action"', ')', ',', '{', ':restart', '=>', '{', '}', '}', ',', '@token', ')', 'when', '"RESIZE"', 'if', 'param', '.', 'is_a?', 'String', 'post_request', '(', 'address', '(', '"/instances/"', '+', 'id', '+', '"/action"', ')', ',', '{', ':resize', '=>', '{', ':flavorRef', '=>', 'param', '}', '}', ',', '@token', ')', 'elsif', 'param', '.', 'is_a?', 'Int', 'post_request', '(', 'address', '(', '"/instances/"', '+', 'id', '+', '"/action"', ')', ',', '{', ':resize', '=>', '{', ':volume', '=>', '{', ':size', '=>', 'param', '}', '}', '}', ',', '@token', ')', 'else', 'raise', 'Ropenstack', '::', 'RopenstackError', ',', '"Invalid Parameter Passed"', 'end', 'else', 'raise', 'Ropenstack', '::', 'RopenstackError', ',', '"Invalid Action Passed"', 'end', 'end']
->Original Target:
['Database', 'Instance', 'Actions']
->Reconstructed Target:
Database Instance Actions
->Reconstructed Predication:
the specified instance action and thethe specified action and the parameterthe specifiedthe specifiedthe specified action and thethe specified parameter and thethe specified action and thethe specified parameter and thethe specified action and thethe specified parameter and thethe specified parameter and thethe specified parameter and thethe specified parameter and thethe specified parameter and thethe specified parameter and thethe specified parameter and thethe specified parameter and the
->Raw Input:
summarize:def instance_action ( id, action, param ) case action when "RESTART" post_request ( address ( "/instances/" + id + "/action" ), { :restart => { } }, @token ) when "RESIZE" if param. is_a? String post_request ( address ( "/instances/" + id + "/action" ), { :resize => { :flavorRef => param } }, @token ) elsif param. is_a? Int post_request ( address ( "/instances/" + id + "/action" ), { :resize => { :volume => { :size => param } } }, @token ) else raise Ropenstack :: RopenstackError, "Invalid Parameter Passed" end else raise Ropenstack :: RopenstackError, "Invalid Action Passed" end end
->Raw Target:
Database Instance Actions
--

1183=========
->Original Input:
['def', 'add', '(', 'error_on', ',', 'message', '=', '"Unknown error"', ')', 'if', 'error_on', '.', 'is_a?', '(', 'Symbol', ')', 'error_on_str', '=', 'error_on', '.', 'to_s', 'else', 'error_on_str', '=', 'underscore', '(', 'error_on', '.', 'class', '.', 'name', ')', 'end', 'error_on_str', '=', 'error_on_str', '.', 'gsub', '(', '/', '\\/', '/', ',', "'_'", ')', 'error_on_str', '=', 'error_on_str', '.', 'gsub', '(', '/', '/', ',', "' '", ')', 'error_on_str', '=', 'error_on_str', '.', 'gsub', '(', '/', '/', ',', "''", ')', '.', 'strip', '@errors', '[', 'error_on_str', ']', '||=', '[', ']', '@errors', '[', 'error_on_str', ']', '<<', 'message', '.', 'to_s', 'end']
->Original Target:
['add', 'errors', 'error_on', 'can', 'be', 'a', 'symbol', 'or', 'object', 'instance']
->Reconstructed Target:
add errors error_on can be a symbol or object instance
->Reconstructed Predication:
the error message for thethe error message for the error_on
->Raw Input:
summarize:def add ( error_on, message = "Unknown error" ) if error_on. is_a? ( Symbol ) error_on_str = error_on. to_s else error_on_str = underscore ( error_on. class. name ) end error_on_str = error_on_str. gsub ( / \/ /, '_' ) error_on_str = error_on_str. gsub ( / /,'' ) error_on_str = error_on_str. gsub ( / /, '' ). strip @errors [ error_on_str ] ||= [ ] @errors [ error_on_str ] << message. to_s end
->Raw Target:
add errors error_on can be a symbol or object instance
--

1184=========
->Original Input:
['def', 'coords_of_neighbors', '(', 'x', ',', 'y', ')', 'coords_of_neighbors', '=', '[', ']', '(', 'x', '-', '1', ')', '.', 'upto', '(', 'x', '+', '1', ')', '.', 'each', 'do', '|', 'neighbors_x', '|', '(', 'y', '-', '1', ')', '.', 'upto', '(', 'y', '+', '1', ')', '.', 'each', 'do', '|', 'neighbors_y', '|', 'next', 'if', '(', 'x', '==', 'neighbors_x', ')', '&&', '(', 'y', '==', 'neighbors_y', ')', 'coords_of_neighbors', '<<', '[', 'neighbors_x', ',', 'neighbors_y', ']', 'end', 'end', 'coords_of_neighbors', 'end']
->Original Target:
['Calculates', 'the', 'co', '-', 'ordinates', 'of', 'neighbors', 'of', 'a', 'given', 'pair', 'of', 'co', '-', 'ordinates', '.']
->Reconstructed Target:
Calculates the co - ordinates of neighbors of a given pair of co - ordinates.
->Reconstructed Predication:
the coords of the neighbors
->Raw Input:
summarize:def coords_of_neighbors ( x, y ) coords_of_neighbors = [ ] ( x - 1 ). upto ( x + 1 ). each do | neighbors_x | ( y - 1 ). upto ( y + 1 ). each do | neighbors_y | next if ( x == neighbors_x ) && ( y == neighbors_y ) coords_of_neighbors << [ neighbors_x, neighbors_y ] end end coords_of_neighbors end
->Raw Target:
Calculates the co - ordinates of neighbors of a given pair of co - ordinates.
--

1185=========
->Original Input:
['def', 'merchant', '(', 'id', ',', 'options', '=', '{', '}', ')', 'options', '=', 'update_by_expire_time', 'options', 'if', 'merchant_not_latest?', '(', 'id', ')', '@rsqoot_merchant', '=', 'get', '(', '"merchants/#{id}"', ',', 'options', ',', 'SqootMerchant', ')', '@rsqoot_merchant', '=', '@rsqoot_merchant', '.', 'merchant', 'if', '@rsqoot_merchant', 'end', 'logger', '(', 'uri', ':', 'sqoot_query_uri', ',', 'records', ':', '[', '@rsqoot_merchant', ']', ',', 'type', ':', "'merchants'", ',', 'opts', ':', 'options', ')', '@rsqoot_merchant', 'end']
->Original Target:
['Retrieve', 'a', 'list', 'of', 'merchants', 'base', 'on', 'the', 'following', 'parameters']
->Reconstructed Target:
Retrieve a list of merchants base on the following parameters
->Reconstructed Predication:
: id : id options: id ) : id
->Raw Input:
summarize:def merchant ( id, options = { } ) options = update_by_expire_time options if merchant_not_latest? ( id ) @rsqoot_merchant = get ( "merchants/#{id}", options, SqootMerchant ) @rsqoot_merchant = @rsqoot_merchant. merchant if @rsqoot_merchant end logger ( uri : sqoot_query_uri, records : [ @rsqoot_merchant ], type :'merchants', opts : options ) @rsqoot_merchant end
->Raw Target:
Retrieve a list of merchants base on the following parameters
--

1186=========
->Original Input:
['def', 'encode', 'data', ',', 'opcode', '=', 'TEXT_FRAME', 'frame', '=', '[', ']', 'frame', '<<', '(', 'opcode', '|', '0x80', ')', 'packr', '=', '"CC"', 'if', 'opcode', '==', 'TEXT_FRAME', 'data', '.', 'force_encoding', '(', '"UTF-8"', ')', 'if', '!', 'data', '.', 'valid_encoding?', 'raise', '"Invalid UTF!"', 'end', 'end', 'len', '=', 'data', '?', 'data', '.', 'bytesize', ':', '0', 'if', 'len', '<=', '125', 'frame', '<<', '(', 'len', '|', '0x80', ')', 'elsif', 'len', '<', '65536', 'frame', '<<', '(', '126', '|', '0x80', ')', 'frame', '<<', 'len', 'packr', '<<', '"n"', 'else', 'frame', '<<', '(', '127', '|', '0x80', ')', 'frame', '<<', 'len', 'packr', '<<', '"L!>"', 'end', 'key', '=', 'rand', '(', '2', '**', '31', ')', 'frame', '<<', 'key', 'packr', '<<', '"N"', 'len', '.', 'times', 'do', '|', 'i', '|', 'frame', '<<', '(', '(', 'data', '.', 'getbyte', '(', 'i', ')', '^', '(', 'key', '>>', '(', '(', '3', '-', '(', 'i', '%', '4', ')', ')', '*', '8', ')', ')', ')', '&', '0xFF', ')', 'end', 'frame', '.', 'pack', '(', '"#{packr}C*"', ')', 'end']
->Original Target:
['Encode', 'a', 'standard', 'payload', 'to', 'a', 'hybi10', 'WebSocket', 'frame']
->Reconstructed Target:
Encode a standard payload to a hybi10 WebSocket frame
->Reconstructed Predication:
datadata ) frame << data
->Raw Input:
summarize:def encode data, opcode = TEXT_FRAME frame = [ ] frame << ( opcode | 0x80 ) packr = "CC" if opcode == TEXT_FRAME data. force_encoding ( "UTF-8" ) if! data. valid_encoding? raise "Invalid UTF!" end end len = data? data. bytesize : 0 if len <= 125 frame << ( len | 0x80 ) elsif len < 65536 frame << ( 126 | 0x80 ) frame << len packr << "n" else frame << ( 127 | 0x80 ) frame << len packr << "L!>" end key = rand ( 2 ** 31 ) frame << key packr << "N" len. times do | i | frame << ( ( data. getbyte ( i ) ^ ( key >> ( ( 3 - ( i % 4 ) ) * 8 ) ) ) & 0xFF ) end frame. pack ( "#{packr}C*" ) end
->Raw Target:
Encode a standard payload to a hybi10 WebSocket frame
--

1187=========
->Original Input:
['def', 'challah_permission', 'unless', 'included_modules', '.', 'include?', '(', 'InstanceMethods', ')', 'include', 'InstanceMethods', 'extend', 'ClassMethods', 'end', 'class_eval', 'do', 'validates_presence_of', ':name', ',', ':key', 'validates_uniqueness_of', ':name', ',', ':key', 'validates_format_of', ':key', ',', ':with', '=>', '/', '/', ',', ':message', '=>', ':invalid_key', 'has_many', ':permission_roles', ',', ':dependent', '=>', ':destroy', 'has_many', ':roles', ',', ':through', '=>', ':permission_roles', ',', ':order', '=>', "'roles.name'", 'has_many', ':permission_users', ',', ':dependent', '=>', ':destroy', 'has_many', ':users', ',', ':through', '=>', ':permission_users', ',', ':order', '=>', "'users.last_name, users.first_name'", 'default_scope', 'order', '(', "'permissions.name'", ')', 'attr_accessible', ':name', ',', ':description', ',', ':key', ',', ':locked', 'after_create', ':add_to_admin_role', 'end', 'end']
->Original Target:
['This', 'method', 'sets', 'up', 'the', '+', 'Permission', '+', 'class', 'with', 'all', 'baked', 'in', 'methods', '.']
->Reconstructed Target:
This method sets up the + Permission + class with all baked in methods.
->Reconstructed Predication:
:description, :locked:roles, :users, :locked
->Raw Input:
summarize:def challah_permission unless included_modules. include? ( InstanceMethods ) include InstanceMethods extend ClassMethods end class_eval do validates_presence_of :name, :key validates_uniqueness_of :name, :key validates_format_of :key, :with => / /, :message => :invalid_key has_many :permission_roles, :dependent => :destroy has_many :roles, :through => :permission_roles, :order => 'roles.name' has_many :permission_users, :dependent => :destroy has_many :users, :through => :permission_users, :order => 'users.last_name, users.first_name' default_scope order ( 'permissions.name' ) attr_accessible :name, :description, :key, :locked after_create :add_to_admin_role end end
->Raw Target:
This method sets up the + Permission + class with all baked in methods.
--

1188=========
->Original Input:
['def', 'post', 'hash', '=', '{', '}', ',', 'payload', 'raise', "'Payload cannot be blank'", 'if', 'payload', '.', 'nil?', '||', 'payload', '.', 'empty?', 'hash', '.', 'symbolize_keys!', 'call', '(', ':post', ',', 'hash', '[', ':endpoint', ']', ',', '(', 'hash', '[', ':args', ']', '||', '{', '}', ')', '.', 'merge', '(', '{', ':method', '=>', ':post', '}', ')', ',', 'payload', ')', 'end']
->Original Target:
['makes', 'a', 'POST', 'request']
->Reconstructed Target:
makes a POST request
->Reconstructed Predication:
payload  def post
->Raw Input:
summarize:def post hash = { }, payload raise 'Payload cannot be blank' if payload. nil? || payload. empty? hash. symbolize_keys! call ( :post, hash [ :endpoint ], ( hash [ :args ] || { } ). merge ( { :method => :post } ), payload ) end
->Raw Target:
makes a POST request
--

1189=========
->Original Input:
['def', 'create_network', '(', 'name', ',', 'tenant', ',', 'admin_state_up', '=', 'true', ')', 'data', '=', '{', "'network'", '=>', '{', "'name'", '=>', 'name', ',', "'tenant_id'", '=>', 'tenant', ',', "'admin_state_up'", '=>', 'admin_state_up', '}', '}', 'return', 'post_request', '(', 'address', '(', '"networks"', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Create', 'a', 'new', 'network', 'on', 'Openstack', 'given', 'a', 'name', 'and', 'tenant', 'id', '.']
->Reconstructed Target:
Create a new network on Openstack given a name and tenant id.
->Reconstructed Predication:
Create a network. 
->Raw Input:
summarize:def create_network ( name, tenant, admin_state_up = true ) data = { 'network' => { 'name' => name, 'tenant_id' => tenant, 'admin_state_up' => admin_state_up } } return post_request ( address ( "networks" ), data, @token ) end
->Raw Target:
Create a new network on Openstack given a name and tenant id.
--

1190=========
->Original Input:
['def', 'create_port', '(', 'network', ',', 'subnet', '=', 'nil', ',', 'device', '=', 'nil', ',', 'device_owner', '=', 'nil', ')', 'data', '=', '{', "'port'", '=>', '{', "'network_id'", '=>', 'network', ',', '}', '}', 'unless', 'device_owner', '.', 'nil?', 'data', '[', "'port'", ']', '[', "'device_owner'", ']', '=', 'device_owner', 'end', 'unless', 'device', '.', 'nil?', 'data', '[', "'port'", ']', '[', "'device_id'", ']', '=', 'device', 'end', 'unless', 'subnet', '.', 'nil?', 'data', '[', "'port'", ']', '[', "'fixed_ips'", ']', '=', '[', '{', "'subnet_id'", '=>', 'subnet', '}', ']', 'end', 'puts', 'data', 'return', 'post_request', '(', 'address', '(', '"ports"', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Create', 'a', 'new', 'port', 'given', 'network', 'and', 'device', 'ids', 'optional', 'parameter', 'subnet', 'id', 'allows', 'for', 'scoping', 'the', 'port', 'to', 'a', 'single', 'subnet', '.']
->Reconstructed Target:
Create a new port given network and device ids optional parameter subnet id allows for scoping the port to a single subnet.
->Reconstructed Predication:
the networkthe subnetthe network the devicethe subnet the devicethe subnet the device belongs to
->Raw Input:
summarize:def create_port ( network, subnet = nil, device = nil, device_owner = nil ) data = { 'port' => { 'network_id' => network, } } unless device_owner. nil? data [ 'port' ] [ 'device_owner' ] = device_owner end unless device. nil? data [ 'port' ] [ 'device_id' ] = device end unless subnet. nil? data [ 'port' ] [ 'fixed_ips' ] = [ {'subnet_id' => subnet } ] end puts data return post_request ( address ( "ports" ), data, @token ) end
->Raw Target:
Create a new port given network and device ids optional parameter subnet id allows for scoping the port to a single subnet.
--

1191=========
->Original Input:
['def', 'move_port_to_subnets', '(', 'port_id', ',', 'subnet_ids', ')', 'id_list', '=', 'Array', '.', 'new', '(', ')', 'subnet_ids', '.', 'each', 'do', '|', 'id', '|', 'id_list', '<<', '{', '"subnet_id"', '=>', 'id', '}', 'end', 'return', 'update_port', '(', 'port_id', ',', 'id_list', ')', 'end']
->Original Target:
['Weird', 'function', 'for', 'adding', 'a', 'port', 'to', 'multiple', 'subnets', 'if', 'nessessary', '.']
->Reconstructed Target:
Weird function for adding a port to multiple subnets if nessessary.
->Reconstructed Predication:
port to subnet. 
->Raw Input:
summarize:def move_port_to_subnets ( port_id, subnet_ids ) id_list = Array. new ( ) subnet_ids. each do | id | id_list << { "subnet_id" => id } end return update_port ( port_id, id_list ) end
->Raw Target:
Weird function for adding a port to multiple subnets if nessessary.
--

1192=========
->Original Input:
['def', 'json', '(', 'data', '=', '{', '}', ',', 'options', '=', '{', '}', ')', 'response', '[', 'CONTENT_TYPE', ']', '=', 'APPLICATION_JSON', 'response', '.', 'status', '=', 'options', '[', ':status', ']', 'if', 'options', '.', 'has_key?', '(', ':status', ')', 'response', '.', 'write', 'self', '.', 'class', '.', 'json_serializer', '.', 'dump', '(', 'data', ')', 'end']
->Original Target:
['This', 'is', 'a', 'convenience', 'method', 'that', 'sets', 'the', 'Content', '-', 'Type', 'headers', 'and', 'writes', 'the', 'JSON', 'String', 'to', 'the', 'response', '.']
->Reconstructed Target:
This is a convenience method that sets the Content - Type headers and writes the JSON String to the response.
->Reconstructed Predication:
 def json_response ( response
->Raw Input:
summarize:def json ( data = { }, options = { } ) response [ CONTENT_TYPE ] = APPLICATION_JSON response. status = options [ :status ] if options. has_key? ( :status ) response. write self. class. json_serializer. dump ( data ) end
->Raw Target:
This is a convenience method that sets the Content - Type headers and writes the JSON String to the response.
--

1193=========
->Original Input:
['def', 'redirect_to', '(', 'url', ',', 'options', '=', '{', '}', ')', 'full_url', '=', 'absolute_url', '(', 'url', ',', 'options', ')', 'response', '[', 'LOCATION', ']', '=', 'full_url', 'respond_with', '302', 'full_url', 'end']
->Original Target:
['This', 'is', 'a', 'convenience', 'method', 'that', 'forms', 'an', 'absolute', 'URL', 'based', 'on', 'the', 'url', 'parameter', 'which', 'can', 'be', 'a', 'relative', 'or', 'absolute', 'URL', 'and', 'then', 'sets', 'the', 'headers', 'and', 'the', 'body', 'appropriately', 'to', 'do', 'a', '302', 'redirect', '.']
->Reconstructed Target:
This is a convenience method that forms an absolute URL based on the url parameter which can be a relative or absolute URL and then sets the headers and the body appropriately to do a 302 redirect.
->Reconstructed Predication:
redirect to url
->Raw Input:
summarize:def redirect_to ( url, options = { } ) full_url = absolute_url ( url, options ) response [ LOCATION ] = full_url respond_with 302 full_url end
->Raw Target:
This is a convenience method that forms an absolute URL based on the url parameter which can be a relative or absolute URL and then sets the headers and the body appropriately to do a 302 redirect.
--

1194=========
->Original Input:
['def', 'servers', '(', 'id', ')', 'endpoint', '=', '"/servers"', 'unless', 'id', '.', 'nil?', 'endpoint', '=', 'endpoint', '+', '"/"', '+', 'id', 'end', 'return', 'get_request', '(', 'address', '(', 'endpoint', ')', ',', '@token', ')', 'end']
->Original Target:
['Gets', 'a', 'list', 'of', 'servers', 'from', 'OpenStack']
->Reconstructed Target:
Gets a list of servers from OpenStack
->Reconstructed Predication:
the server for the specified server
->Raw Input:
summarize:def servers ( id ) endpoint = "/servers" unless id. nil? endpoint = endpoint + "/" + id end return get_request ( address ( endpoint ), @token ) end
->Raw Target:
Gets a list of servers from OpenStack
--

1195=========
->Original Input:
['def', 'create_server', '(', 'name', ',', 'image', ',', 'flavor', ',', 'networks', '=', 'nil', ',', 'keypair', '=', 'nil', ',', 'security_group', '=', 'nil', ',', 'metadata', '=', 'nil', ')', 'data', '=', '{', '"server"', '=>', '{', '"name"', '=>', 'name', ',', '"imageRef"', '=>', 'image', ',', '"flavorRef"', '=>', 'flavor', ',', '}', '}', 'unless', 'networks', '.', 'nil?', 'data', '[', '"server"', ']', '[', '"networks"', ']', '=', 'networks', 'end', 'unless', 'keypair', '.', 'nil?', 'data', '[', '"server"', ']', '[', '"key_name"', ']', '=', 'keypair', 'end', 'unless', 'security_group', '.', 'nil?', 'data', '[', '"server"', ']', '[', '"security_group"', ']', '=', 'security_group', 'end', 'return', 'post_request', '(', 'address', '(', '"/servers"', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Creates', 'a', 'server', 'on', 'OpenStack', '.']
->Reconstructed Target:
Creates a server on OpenStack.
->Reconstructed Predication:
the server metadata for thethe server metadatathe server metadata for thethe server metadatathe server metadata
->Raw Input:
summarize:def create_server ( name, image, flavor, networks = nil, keypair = nil, security_group = nil, metadata = nil ) data = { "server" => { "name" => name, "imageRef" => image, "flavorRef" => flavor, } } unless networks. nil? data [ "server" ] [ "networks" ] = networks end unless keypair. nil? data [ "server" ] [ "key_name" ] = keypair end unless security_group. nil? data [ "server" ] [ "security_group" ] = security_group end return post_request ( address ( "/servers" ), data, @token ) end
->Raw Target:
Creates a server on OpenStack.
--

1196=========
->Original Input:
['def', 'action', '(', 'id', ',', 'act', ',', '*', 'args', ')', 'data', '=', 'case', 'act', 'when', '"reboot"', 'then', '{', "'reboot'", '=>', '{', '"type"', '=>', 'args', '[', '0', ']', '}', '}', 'when', '"vnc"', 'then', '{', "'os-getVNCConsole'", '=>', '{', '"type"', '=>', '"novnc"', '}', '}', 'when', '"stop"', 'then', '{', "'os-stop'", '=>', "'null'", '}', 'when', '"start"', 'then', '{', "'os-start'", '=>', "'null'", '}', 'when', '"pause"', 'then', '{', "'pause'", '=>', "'null'", '}', 'when', '"unpause"', 'then', '{', "'unpause'", '=>', "'null'", '}', 'when', '"suspend"', 'then', '{', "'suspend'", '=>', "'null'", '}', 'when', '"resume"', 'then', '{', "'resume'", '=>', "'null'", '}', 'when', '"create_image"', 'then', '{', "'createImage'", '=>', '{', "'name'", '=>', 'args', '[', '0', ']', ',', "'metadata'", '=>', 'args', '[', '1', ']', '}', '}', 'else', 'raise', '"Invalid Action"', 'end', 'return', 'post_request', '(', 'address', '(', '"/servers/"', '+', 'id', '+', '"/action"', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Perform', 'an', 'action', 'on', 'a', 'server', 'on', 'Openstack', 'by', 'passing', 'an', 'id', 'and', 'an', 'action', 'some', 'actions', 'require', 'more', 'data', '.']
->Reconstructed Target:
Perform an action on a server on Openstack by passing an id and an action some actions require more data.
->Reconstructed Predication:
the server'sthe server'sthe server'sthe server's
->Raw Input:
summarize:def action ( id, act, * args ) data = case act when "reboot" then {'reboot' => { "type" => args [ 0 ] } } when "vnc" then { 'os-getVNCConsole' => { "type" => "novnc" } } when "stop" then { 'os-stop' => 'null' } when "start" then { 'os-start' => 'null' } when "pause" then { 'pause' => 'null' } when "unpause" then { 'unpause' => 'null' } when "suspend" then {'suspend' => 'null' } when "resume" then {'resume' => 'null' } when "create_image" then { 'createImage' => { 'name' => args [ 0 ],'metadata' => args [ 1 ] } } else raise "Invalid Action" end return post_request ( address ( "/servers/" + id + "/action" ), data, @token ) end
->Raw Target:
Perform an action on a server on Openstack by passing an id and an action some actions require more data.
--

1197=========
->Original Input:
['def', 'delete_image', '(', 'id', ')', 'uri', '=', 'URI', '.', 'parse', '(', '"http://"', '+', '@location', '.', 'host', '+', '":"', '+', '@location', '.', 'port', '.', 'to_s', '+', '"/v2/images/"', '+', 'id', ')', 'return', 'delete_request', '(', 'uri', ',', '@token', ')', 'end']
->Original Target:
['Delete', 'an', 'image', 'stored', 'on', 'Openstack', 'through', 'the', 'nova', 'endpoint']
->Reconstructed Target:
Delete an image stored on Openstack through the nova endpoint
->Reconstructed Predication:
delete an image. 
->Raw Input:
summarize:def delete_image ( id ) uri = URI. parse ( "http://" + @location. host + ":" + @location. port. to_s + "/v2/images/" + id ) return delete_request ( uri, @token ) end
->Raw Target:
Delete an image stored on Openstack through the nova endpoint
--

1198=========
->Original Input:
['def', 'get', '(', 'path', ',', 'opts', '=', '{', '}', ',', 'wrapper', '=', '::', 'Hashie', '::', 'Mash', ')', 'uri', ',', 'headers', '=', 'url_generator', '(', 'path', ',', 'opts', ')', 'begin', 'json', '=', 'JSON', '.', 'parse', 'uri', '.', 'open', '(', 'headers', ')', '.', 'read', 'result', '=', 'wrapper', '.', 'new', 'json', '@query_options', '=', 'result', '.', 'query', 'result', 'rescue', '=>', 'e', 'logger', '(', 'error', ':', 'e', ')', 'nil', 'end', 'end']
->Original Target:
['Get', 'method', 'use', 'by', 'all', 'other', 'API', 'qeury', 'methods', 'fetch', 'records', 'from', 'the', 'Sqoot', 'API', 'V2', 'url', 'and', 'provide', 'wrapper', 'functionality']
->Reconstructed Target:
Get method use by all other API qeury methods fetch records from the Sqoot API V2 url and provide wrapper functionality
->Reconstructed Predication:
the request to the given path
->Raw Input:
summarize:def get ( path, opts = { }, wrapper = :: Hashie :: Mash ) uri, headers = url_generator ( path, opts ) begin json = JSON. parse uri. open ( headers ). read result = wrapper. new json @query_options = result. query result rescue => e logger ( error : e ) nil end end
->Raw Target:
Get method use by all other API qeury methods fetch records from the Sqoot API V2 url and provide wrapper functionality
--

1199=========
->Original Input:
['def', 'set_basepath', 'if', 'self', '.', 'parent', '.', 'nil?', 'self', '.', 'basepath', '=', 'self', '.', 'basename', 'self', '.', 'basedirpath', '||=', "''", 'else', 'self', '.', 'basepath', '=', 'self', '.', 'parent', '.', 'basepath', '+', "'/'", '+', 'self', '.', 'basename', 'self', '.', 'basedirpath', '||=', 'self', '.', 'parent', '.', 'basepath', '+', "'/'", 'end', 'end']
->Original Target:
['operations', 'with', 'path']
->Reconstructed Target:
operations with path
->Reconstructed Predication:
basepath = self. basename
->Raw Input:
summarize:def set_basepath if self. parent. nil? self. basepath = self. basename self. basedirpath ||= '' else self. basepath = self. parent. basepath + '/' + self. basename self. basedirpath ||= self. parent. basepath + '/' end end
->Raw Target:
operations with path
--

1200=========
->Original Input:
['def', 'commissions', '(', 'options', '=', '{', '}', ')', 'options', '=', 'update_by_expire_time', 'options', 'if', 'commissions_not_latest?', '(', 'options', ')', '@rsqoot_commissions', '=', 'get', '(', "'commissions'", ',', 'options', ',', 'SqootCommission', ')', '@rsqoot_commissions', '=', '@rsqoot_commissions', '.', 'commissions', 'if', '@rsqoot_commissions', 'end', 'logger', '(', 'uri', ':', 'sqoot_query_uri', ',', 'records', ':', '@rsqoot_commissions', ',', 'type', ':', "'commissions'", ',', 'opts', ':', 'options', ')', '@rsqoot_commissions', 'end']
->Original Target:
['Retrieve', 'information', 'of', 'commissions', 'based', 'on', 'the', 'following', 'parameters']
->Reconstructed Target:
Retrieve information of commissions based on the following parameters
->Reconstructed Predication:
the list of@rsqoot_commissions = nil end  def
->Raw Input:
summarize:def commissions ( options = { } ) options = update_by_expire_time options if commissions_not_latest? ( options ) @rsqoot_commissions = get ( 'commissions', options, SqootCommission ) @rsqoot_commissions = @rsqoot_commissions. commissions if @rsqoot_commissions end logger ( uri : sqoot_query_uri, records : @rsqoot_commissions, type : 'commissions', opts : options ) @rsqoot_commissions end
->Raw Target:
Retrieve information of commissions based on the following parameters
--

1201=========
->Original Input:
['def', 'leagues', '(', 'opts', '=', '{', '}', ')', 'season', '=', 'opts', '.', 'fetch', '(', ':season', ')', '{', 'Time', '.', 'now', '.', 'year', '}', 'json_response', 'get', '(', '"competitions/?season=#{season}"', ')', 'end']
->Original Target:
['List', 'all', 'available', 'leagues', '.']
->Reconstructed Target:
List all available leagues.
->Reconstructed Predication:
the leagues for the given season
->Raw Input:
summarize:def leagues ( opts = { } ) season = opts. fetch ( :season ) { Time. now. year } json_response get ( "competitions/?season=#{season}" ) end
->Raw Target:
List all available leagues.
--

1202=========
->Original Input:
['def', 'match', '(', '*', 'args', ',', '&', 'block', ')', 'z', '=', 'Module', '.', 'new', 'do', 'include', 'Ov', 'extend', 'self', 'def', 'try', '(', '*', 'args', ',', '&', 'block', ')', 'let', ':anon_method', ',', '*', 'args', ',', '&', 'block', 'end', 'def', 'otherwise', '(', '&', 'block', ')', 'let', ':otherwise', ',', '&', 'block', 'end', 'instance_eval', '&', 'block', 'end', 'begin', 'z', '.', 'anon_method', '(', '*', 'args', ')', 'rescue', 'Ov', '::', 'NotImplementError', '=>', 'e', 'z', '.', 'otherwise', 'end', 'end']
->Original Target:
['Add', 'match', 'method', 'which', 'work', 'like', 'case', 'statement', 'but', 'for', 'types']
->Reconstructed Target:
Add match method which work like case statement but for types
->Reconstructed Predication:
the method to be matched
->Raw Input:
summarize:def match ( * args, & block ) z = Module. new do include Ov extend self def try ( * args, & block ) let :anon_method, * args, & block end def otherwise ( & block ) let :otherwise, & block end instance_eval & block end begin z. anon_method ( * args ) rescue Ov :: NotImplementError => e z. otherwise end end
->Raw Target:
Add match method which work like case statement but for types
--

1203=========
->Original Input:
['def', 'fetch', '(', 'column', ',', '*', 'default_value', ',', '&', 'default_block', ')', 'raise', 'ArgumentError', ',', '"Must only provide at max one default value or one default block"', 'if', 'default_value', '.', 'size', '>', '(', 'block_given?', '?', '0', ':', '1', ')', 'index', '=', 'case', 'column', 'when', 'Symbol', 'then', '@table', '.', 'index_for_accessor', '(', 'column', ')', 'when', 'String', 'then', '@table', '.', 'index_for_header', '(', 'column', ')', 'when', 'Integer', 'then', 'column', 'else', 'raise', 'InvalidColumnSpecifier', ',', '"Invalid index type, expected Symbol, String or Integer, but got #{column.class}"', 'end', '@data', '.', 'fetch', '(', 'index', ',', '*', 'default_value', ',', '&', 'default_block', ')', 'end']
->Original Target:
['Tries', 'to', 'return', 'the', 'value', 'of', 'the', 'column', 'identified', 'by', 'index', 'corresponding', 'accessor', 'or', 'header', '.', 'It', 'throws', 'an', 'IndexError', 'exception', 'if', 'the', 'referenced', 'index', 'lies', 'outside', 'of', 'the', 'array', 'bounds', '.', 'This', 'error', 'can', 'be', 'prevented', 'by', 'supplying', 'a', 'second', 'argument', 'which', 'will', 'act', 'as', 'a', 'default', 'value', '.']
->Reconstructed Target:
Tries to return the value of the column identified by index corresponding accessor or header. It throws an IndexError exception if the referenced index lies outside of the array bounds. This error can be prevented by supplying a second argument which will act as a default value.
->Reconstructed Predication:
the default value for the giventhe default value and the defaultthe default value and the default
->Raw Input:
summarize:def fetch ( column, * default_value, & default_block ) raise ArgumentError, "Must only provide at max one default value or one default block" if default_value. size > ( block_given?? 0 : 1 ) index = case column when Symbol then @table. index_for_accessor ( column ) when String then @table. index_for_header ( column ) when Integer then column else raise InvalidColumnSpecifier, "Invalid index type, expected Symbol, String or Integer, but got #{column.class}" end @data. fetch ( index, * default_value, & default_block ) end
->Raw Target:
Tries to return the value of the column identified by index corresponding accessor or header. It throws an IndexError exception if the referenced index lies outside of the array bounds. This error can be prevented by supplying a second argument which will act as a default value.
--

1204=========
->Original Input:
['def', 'at', '(', 'column', ')', 'case', 'column', 'when', 'Symbol', 'then', 'at_accessor', '(', 'column', ')', 'when', 'String', 'then', 'at_header', '(', 'column', ')', 'when', 'Integer', 'then', 'at_index', '(', 'column', ')', 'when', 'Range', 'then', '@data', '[', 'column', ']', 'else', 'raise', 'InvalidColumnSpecifier', ',', '"Invalid index type, expected Symbol, String or Integer, but got #{column.class}"', 'end', 'end']
->Original Target:
['Access', 'a', 'single', 'cell', 'by', 'either', 'index', 'index', '-', 'range', 'accessor', 'or', 'header', '-', 'name', '.']
->Reconstructed Target:
Access a single cell by either index index - range accessor or header - name.
->Reconstructed Predication:
the column to be summarizeed.
->Raw Input:
summarize:def at ( column ) case column when Symbol then at_accessor ( column ) when String then at_header ( column ) when Integer then at_index ( column ) when Range then @data [ column ] else raise InvalidColumnSpecifier, "Invalid index type, expected Symbol, String or Integer, but got #{column.class}" end end
->Raw Target:
Access a single cell by either index index - range accessor or header - name.
--

1205=========
->Original Input:
['def', 'values_at', '(', '*', 'columns', ')', 'result', '=', '[', ']', 'columns', '.', 'each', 'do', '|', 'column', '|', 'data', '=', 'at', '(', 'column', ')', 'if', 'column', '.', 'is_a?', '(', 'Range', ')', 'result', '.', 'concat', '(', 'data', ')', 'if', 'data', 'else', 'result', '<<', 'data', 'end', 'end', 'result', 'end']
->Original Target:
['Access', 'multiple', 'values', 'by', 'either', 'index', 'index', '-', 'range', 'accessor', 'or', 'header', '-', 'name', '.']
->Reconstructed Target:
Access multiple values by either index index - range accessor or header - name.
->Reconstructed Predication:
the values of the given
->Raw Input:
summarize:def values_at ( * columns ) result = [ ] columns. each do | column | data = at ( column ) if column. is_a? ( Range ) result. concat ( data ) if data else result << data end end result end
->Raw Target:
Access multiple values by either index index - range accessor or header - name.
--

1206=========
->Original Input:
['def', 'method_missing', '(', 'name', ',', '*', 'args', ',', '&', 'block', ')', 'return', 'super', 'unless', '@table', '.', 'accessors?', 'name', '=~', '/', '\\w', '/', 'name_mod', ',', 'assign', '=', '$1', ',', '$2', 'index', '=', '@table', '.', 'index_for_accessor', '(', 'name_mod', ')', 'arg_count', '=', 'assign', '?', '1', ':', '0', 'return', 'super', 'unless', 'index', 'raise', 'ArgumentError', ',', '"Wrong number of arguments (#{args.size} for #{arg_count})"', 'if', 'args', '.', 'size', '>', 'arg_count', 'if', 'assign', 'then', '@data', '[', 'index', ']', '=', 'args', '.', 'first', 'else', '@data', '[', 'index', ']', 'end', 'end']
->Original Target:
['Allow', 'reading', 'and', 'writing', 'cell', 'values', 'by', 'their', 'accessor', 'name', '.']
->Reconstructed Target:
Allow reading and writing cell values by their accessor name.
->Reconstructed Predication:
the method to be called
->Raw Input:
summarize:def method_missing ( name, * args, & block ) return super unless @table. accessors? name =~ / \w / name_mod, assign = $1, $2 index = @table. index_for_accessor ( name_mod ) arg_count = assign? 1 : 0 return super unless index raise ArgumentError, "Wrong number of arguments (#{args.size} for #{arg_count})" if args. size > arg_count if assign then @data [ index ] = args. first else @data [ index ] end end
->Raw Target:
Allow reading and writing cell values by their accessor name.
--

1207=========
->Original Input:
['def', 'authorize', '(', 'auth', '=', '{', '}', ')', '@authentication', '||=', 'TaskMapper', '::', 'Authenticator', '.', 'new', '(', 'auth', ')', 'auth', '=', '@authentication', 'if', '(', 'auth', '.', 'account', '.', 'nil?', 'and', 'auth', '.', 'subdomain', '.', 'nil?', ')', 'or', 'auth', '.', 'username', '.', 'nil?', 'or', 'auth', '.', 'password', '.', 'nil?', 'raise', '"Please provide at least an account (subdomain), username and password)"', 'end', 'UnfuddleAPI', '.', 'protocol', '=', 'auth', '.', 'protocol', 'if', 'auth', '.', 'protocol?', 'UnfuddleAPI', '.', 'account', '=', 'auth', '.', 'account', '||', 'auth', '.', 'subdomain', 'UnfuddleAPI', '.', 'authenticate', '(', 'auth', '.', 'username', ',', 'auth', '.', 'password', ')', 'end']
->Original Target:
['Providers', 'must', 'define', 'an', 'authorize', 'method', '.', 'This', 'is', 'used', 'to', 'initialize', 'and', 'set', 'authentication', 'parameters', 'to', 'access', 'the', 'API']
->Reconstructed Target:
Providers must define an authorize method. This is used to initialize and set authentication parameters to access the API
->Reconstructed Predication:
the user to authorize the user
->Raw Input:
summarize:def authorize ( auth = { } ) @authentication ||= TaskMapper :: Authenticator. new ( auth ) auth = @authentication if ( auth. account. nil? and auth. subdomain. nil? ) or auth. username. nil? or auth. password. nil? raise "Please provide at least an account (subdomain), username and password)" end UnfuddleAPI. protocol = auth. protocol if auth. protocol? UnfuddleAPI. account = auth. account || auth. subdomain UnfuddleAPI. authenticate ( auth. username, auth. password ) end
->Raw Target:
Providers must define an authorize method. This is used to initialize and set authentication parameters to access the API
--

1208=========
->Original Input:
['def', 'routers', '(', 'id', '=', 'nil', ')', 'endpoint', '=', '"routers"', 'unless', 'id', '.', 'nil?', 'endpoint', '=', 'endpoint', '+', '"/"', '+', 'id', 'end', 'return', 'get_request', '(', 'address', '(', 'endpoint', ')', ',', '@token', ')', 'end']
->Original Target:
['Get', 'a', 'list', 'of', 'a', 'tenants', 'routers']
->Reconstructed Target:
Get a list of a tenants routers
->Reconstructed Predication:
the routers endpoint.  def routers
->Raw Input:
summarize:def routers ( id = nil ) endpoint = "routers" unless id. nil? endpoint = endpoint + "/" + id end return get_request ( address ( endpoint ), @token ) end
->Raw Target:
Get a list of a tenants routers
--

1209=========
->Original Input:
['def', 'create_router', '(', 'name', ',', 'admin_state_up', '=', 'true', ')', 'data', '=', '{', "'router'", '=>', '{', "'name'", '=>', 'name', ',', "'admin_state_up'", '=>', 'admin_state_up', ',', '}', '}', 'return', 'post_request', '(', 'address', '(', '"routers"', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Create', 'a', 'new', 'router', 'with', 'a', 'given', 'name', '.']
->Reconstructed Target:
Create a new router with a given name.
->Reconstructed Predication:
the router to be created.
->Raw Input:
summarize:def create_router ( name, admin_state_up = true ) data = { 'router' => { 'name' => name, 'admin_state_up' => admin_state_up, } } return post_request ( address ( "routers" ), data, @token ) end
->Raw Target:
Create a new router with a given name.
--

1210=========
->Original Input:
['def', 'delete_router_interface', '(', 'router', ',', 'id', ',', 'type', ')', 'data', '=', 'case', 'type', 'when', "'port'", 'then', '{', "'port_id'", '=>', 'id', '}', 'when', "'subnet'", 'then', '{', "'subnet_id'", '=>', 'id', '}', 'else', 'raise', '"Invalid Interface Type"', 'end', 'return', 'put_request', '(', 'address', '(', '"routers/"', '+', 'router', '+', '"/remove_router_interface"', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Delete', 'a', 'connection', 'between', 'a', 'subnet', 'and', 'router', 'given', 'either', 'port', 'or', 'subnet', 'ids', '.']
->Reconstructed Target:
Delete a connection between a subnet and router given either port or subnet ids.
->Reconstructed Predication:
the router interface to the specifiedthe router interface to the specified
->Raw Input:
summarize:def delete_router_interface ( router, id, type ) data = case type when 'port' then { 'port_id' => id } when'subnet' then {'subnet_id' => id } else raise "Invalid Interface Type" end return put_request ( address ( "routers/" + router + "/remove_router_interface" ), data, @token ) end
->Raw Target:
Delete a connection between a subnet and router given either port or subnet ids.
--

1211=========
->Original Input:
['def', 'where', '(', 'method', ')', '@complete', ',', '@result', '=', 'nil', ',', 'nil', 'z', '=', 'find_or_next', '(', 'method', ')', '{', '|', 'method', '|', 'self', '.', 'find', '{', '|', 'm', '|', 'm', '.', 'eql?', '(', 'method', ')', '}', '}', '.', 'find_or_next', '(', 'method', ')', '{', '|', 'method', '|', 'self', '.', 'find', '{', '|', 'm', '|', 'm', '.', 'eql0?', '(', 'method', ')', '}', '}', '.', 'find_or_next', '(', 'method', ')', '{', '|', 'method', '|', 'self', '.', 'find', '{', '|', 'm', '|', 'm', '.', 'like?', '(', 'method', ')', '}', '}', '.', 'find_or_next', '(', 'method', ')', '{', '|', 'method', '|', 'self', '.', 'find', '{', '|', 'm', '|', 'm', '.', 'like0?', '(', 'method', ')', '}', '}', '.', 'get', 'end']
->Original Target:
['find', 'in', 'self', 'find', 'in', 'ancestors', 'find', 'types', 'find', 'any', 'types']
->Reconstructed Target:
find in self find in ancestors find types find any types
->Reconstructed Predication:
method ) { | m| m |method ) { || m | m...
->Raw Input:
summarize:def where ( method ) @complete, @result = nil, nil z = find_or_next ( method ) { | method | self. find { | m | m. eql? ( method ) } }. find_or_next ( method ) { | method | self. find { | m | m. eql0? ( method ) } }. find_or_next ( method ) { | method | self. find { | m | m. like? ( method ) } }. find_or_next ( method ) { | method | self. find { | m | m. like0? ( method ) } }. get end
->Raw Target:
find in self find in ancestors find types find any types
--

1212=========
->Original Input:
['def', 'load', 'config_files', '.', 'each', 'do', '|', 'file', '|', 'config', '=', 'YAML', '::', 'load', '(', 'File', '.', 'open', '(', 'file', ')', ')', '@config', '.', 'merge!', 'config', 'end', 'end']
->Original Target:
['load', 'config', 'from', 'files']
->Reconstructed Target:
load config from files
->Reconstructed Predication:
the configuration file to load
->Raw Input:
summarize:def load config_files. each do | file | config = YAML :: load ( File. open ( file ) ) @config. merge! config end end
->Raw Target:
load config from files
--

1213=========
->Original Input:
['def', 'providers', '(', 'options', '=', '{', '}', ')', 'options', '=', 'update_by_expire_time', 'options', 'query', '=', 'options', '.', 'delete', '(', ':query', ')', 'if', 'providers_not_latest?', '(', 'options', ')', '@rsqoot_providers', '=', 'get', '(', "'providers'", ',', 'options', ',', 'SqootProvider', ')', '@rsqoot_providers', '=', '@rsqoot_providers', '.', 'providers', '.', 'map', '(', '&', ':provider', ')', 'if', '@rsqoot_providers', 'end', 'result', '=', 'query', '.', 'present?', '?', 'query_providers', '(', 'query', ')', ':', '@rsqoot_providers', 'logger', '(', 'uri', ':', 'sqoot_query_uri', ',', 'records', ':', 'result', ',', 'type', ':', "'providers'", ',', 'opts', ':', 'options', ')', 'result', 'end']
->Original Target:
['Retrieve', 'a', 'list', 'of', 'providers', 'base', 'on', 'the', 'following', 'parameters']
->Reconstructed Target:
Retrieve a list of providers base on the following parameters
->Reconstructed Predication:
the providers to be returned.
->Raw Input:
summarize:def providers ( options = { } ) options = update_by_expire_time options query = options. delete ( :query ) if providers_not_latest? ( options ) @rsqoot_providers = get ( 'providers', options, SqootProvider ) @rsqoot_providers = @rsqoot_providers. providers. map ( & :provider ) if @rsqoot_providers end result = query. present?? query_providers ( query ) : @rsqoot_providers logger ( uri : sqoot_query_uri, records : result, type : 'providers', opts : options ) result end
->Raw Target:
Retrieve a list of providers base on the following parameters
--

1214=========
->Original Input:
['def', 'categories', '(', 'options', '=', '{', '}', ')', 'options', '=', 'update_by_expire_time', 'options', 'query', '=', 'options', '.', 'delete', '(', ':query', ')', 'if', 'categories_not_latest?', '(', 'options', ')', '@rsqoot_categories', '=', 'get', '(', "'categories'", ',', 'options', ',', 'SqootCategory', ')', '@rsqoot_categories', '=', '@rsqoot_categories', '.', 'categories', '.', 'map', '(', '&', ':category', ')', 'if', '@rsqoot_categories', 'end', 'result', '=', 'query', '.', 'present?', '?', 'query_categories', '(', 'query', ')', ':', '@rsqoot_categories', 'logger', '(', 'uri', ':', 'sqoot_query_uri', ',', 'records', ':', 'result', ',', 'type', ':', "'categories'", ',', 'opts', ':', 'options', ')', 'result', 'end']
->Original Target:
['Retrieve', 'a', 'list', 'of', 'categories', 'base', 'on', 'the', 'following', 'parameters']
->Reconstructed Target:
Retrieve a list of categories base on the following parameters
->Reconstructed Predication:
::
->Raw Input:
summarize:def categories ( options = { } ) options = update_by_expire_time options query = options. delete ( :query ) if categories_not_latest? ( options ) @rsqoot_categories = get ( 'categories', options, SqootCategory ) @rsqoot_categories = @rsqoot_categories. categories. map ( & :category ) if @rsqoot_categories end result = query. present?? query_categories ( query ) : @rsqoot_categories logger ( uri : sqoot_query_uri, records : result, type : 'categories', opts : options ) result end
->Raw Target:
Retrieve a list of categories base on the following parameters
--

1215=========
->Original Input:
['def', 'challah_role', 'unless', 'included_modules', '.', 'include?', '(', 'InstanceMethods', ')', 'include', 'InstanceMethods', 'extend', 'ClassMethods', 'end', 'class_eval', 'do', 'validates', ':name', ',', ':presence', '=>', 'true', ',', ':uniqueness', '=>', 'true', 'has_many', ':permission_roles', ',', ':dependent', '=>', ':destroy', 'has_many', ':permissions', ',', ':through', '=>', ':permission_roles', ',', ':order', '=>', "'permissions.name'", 'has_many', ':users', ',', ':order', '=>', "'users.first_name, users.last_name'", 'default_scope', 'order', '(', "'roles.name'", ')', 'after_save', ':save_permission_keys', 'attr_accessible', ':description', ',', ':default_path', ',', ':locked', ',', ':name', 'end', 'end']
->Original Target:
['This', 'method', 'sets', 'up', 'the', '+', 'Role', '+', 'class', 'with', 'all', 'baked', 'in', 'methods', '.']
->Reconstructed Target:
This method sets up the + Role + class with all baked in methods.
->Reconstructed Predication:
:description description : description of the
->Raw Input:
summarize:def challah_role unless included_modules. include? ( InstanceMethods ) include InstanceMethods extend ClassMethods end class_eval do validates :name, :presence => true, :uniqueness => true has_many :permission_roles, :dependent => :destroy has_many :permissions, :through => :permission_roles, :order => 'permissions.name' has_many :users, :order => 'users.first_name, users.last_name' default_scope order ( 'roles.name' ) after_save :save_permission_keys attr_accessible :description, :default_path, :locked, :name end end
->Raw Target:
This method sets up the + Role + class with all baked in methods.
--

1216=========
->Original Input:
['def', 'check_for_upgrade', 'if', 'plan_id_changed?', 'old_plan', '=', 'Plan', '.', 'find', '(', 'plan_id_was', ')', 'if', 'plan_id_was', '.', 'present?', 'self', '.', 'upgraded', '=', 'true', 'if', 'old_plan', '.', 'nil?', '||', 'old_plan', '.', 'order', '<', 'plan', '.', 'order', 'end', 'end']
->Original Target:
['def', 'nil_if_blank', 'self', '.', 'trial_end', '=', 'nil', 'if', 'self', '.', 'trial_end', '.', 'blank?', 'end']
->Reconstructed Target:
def nil_if_blank self. trial_end = nil if self. trial_end. blank? end
->Reconstructed Predication:
the plan to be upgraded
->Raw Input:
summarize:def check_for_upgrade if plan_id_changed? old_plan = Plan. find ( plan_id_was ) if plan_id_was. present? self. upgraded = true if old_plan. nil? || old_plan. order < plan. order end end
->Raw Target:
def nil_if_blank self. trial_end = nil if self. trial_end. blank? end
--

1217=========
->Original Input:
['def', 'method_missing', '(', 'name', ',', '*', 'args', ',', '&', 'block', ')', 'obj', '=', '__getobj__', '__substitute_self__', '(', 'obj', '.', '__send__', '(', 'name', ',', '*', 'args', ',', '&', 'block', ')', ',', 'obj', ')', 'end']
->Original Target:
['if', 'chainable', 'method', 'or', 'returns', 'self', 'for', 'some', 'other', 'reason', 'return', 'this', 'proxy', 'instead']
->Reconstructed Target:
if chainable method or returns self for some other reason return this proxy instead
->Reconstructed Predication:
the method to be called
->Raw Input:
summarize:def method_missing ( name, * args, & block ) obj = __getobj__ __substitute_self__ ( obj. __send__ ( name, * args, & block ), obj ) end
->Raw Target:
if chainable method or returns self for some other reason return this proxy instead
--

1218=========
->Original Input:
['def', 'deals', '(', 'options', '=', '{', '}', ')', 'options', '=', 'update_by_expire_time', 'options', 'if', 'deals_not_latest?', '(', 'options', ')', 'uniq', '=', '!', '!', 'options', '.', 'delete', '(', ':uniq', ')', '@rsqoot_deals', '=', 'get', '(', "'deals'", ',', 'options', ',', 'SqootDeal', ')', '||', '[', ']', '@rsqoot_deals', '=', '@rsqoot_deals', '.', 'deals', '.', 'map', '(', '&', ':deal', ')', 'unless', '@rsqoot_deals', '.', 'empty?', '@rsqoot_deals', '=', 'uniq_deals', '(', '@rsqoot_deals', ')', 'if', 'uniq', 'end', 'logger', '(', 'uri', ':', 'sqoot_query_uri', ',', 'records', ':', '@rsqoot_deals', ',', 'type', ':', "'deals'", ',', 'opts', ':', 'options', ')', '@rsqoot_deals', 'end']
->Original Target:
['Retrieve', 'a', 'list', 'of', 'deals', 'based', 'on', 'the', 'following', 'parameters']
->Reconstructed Target:
Retrieve a list of deals based on the following parameters
->Reconstructed Predication:
: return :: return : return :
->Raw Input:
summarize:def deals ( options = { } ) options = update_by_expire_time options if deals_not_latest? ( options ) uniq =!! options. delete ( :uniq ) @rsqoot_deals = get ( 'deals', options, SqootDeal ) || [ ] @rsqoot_deals = @rsqoot_deals. deals. map ( & :deal ) unless @rsqoot_deals. empty? @rsqoot_deals = uniq_deals ( @rsqoot_deals ) if uniq end logger ( uri : sqoot_query_uri, records : @rsqoot_deals, type : 'deals', opts : options ) @rsqoot_deals end
->Raw Target:
Retrieve a list of deals based on the following parameters
--

1219=========
->Original Input:
['def', 'deal', '(', 'id', ',', 'options', '=', '{', '}', ')', 'options', '=', 'update_by_expire_time', 'options', 'if', 'deal_not_latest?', '(', 'id', ')', '@rsqoot_deal', '=', 'get', '(', '"deals/#{id}"', ',', 'options', ',', 'SqootDeal', ')', '@rsqoot_deal', '=', '@rsqoot_deal', '.', 'deal', 'if', '@rsqoot_deal', 'end', 'logger', '(', 'uri', ':', 'sqoot_query_uri', ',', 'records', ':', '[', '@rsqoot_deal', ']', ',', 'type', ':', "'deal'", ',', 'opts', ':', 'options', ')', '@rsqoot_deal', 'end']
->Original Target:
['Retrieve', 'a', 'deal', 'by', 'id']
->Reconstructed Target:
Retrieve a deal by id
->Reconstructed Predication:
thethe record you want to
->Raw Input:
summarize:def deal ( id, options = { } ) options = update_by_expire_time options if deal_not_latest? ( id ) @rsqoot_deal = get ( "deals/#{id}", options, SqootDeal ) @rsqoot_deal = @rsqoot_deal. deal if @rsqoot_deal end logger ( uri : sqoot_query_uri, records : [ @rsqoot_deal ], type : 'deal', opts : options ) @rsqoot_deal end
->Raw Target:
Retrieve a deal by id
--

1220=========
->Original Input:
['def', 'total_sqoot_deals', '(', 'options', '=', '{', '}', ')', '@total_deals', '||=', '[', ']', '@cached_pages', '||=', '[', ']', 'page', '=', 'options', '[', ':page', ']', '||', '1', 'check_query_change', 'options', 'unless', 'page_cached?', 'page', '@total_deals', '+=', 'deals', '(', 'options', ')', '@total_deals', '.', 'uniq!', '@cached_pages', '<<', 'page', '.', 'to_s', '@cached_pages', '.', 'uniq!', 'end', '@total_deals', 'end']
->Original Target:
['Auto', 'Increment', 'for', 'deals', 'query', '.']
->Reconstructed Target:
Auto Increment for deals query.
->Reconstructed Predication:
the total total of the
->Raw Input:
summarize:def total_sqoot_deals ( options = { } ) @total_deals ||= [ ] @cached_pages ||= [ ] page = options [ :page ] || 1 check_query_change options unless page_cached? page @total_deals += deals ( options ) @total_deals. uniq! @cached_pages << page. to_s @cached_pages. uniq! end @total_deals end
->Raw Target:
Auto Increment for deals query.
--

1221=========
->Original Input:
['def', 'uniq_deals', '(', 'deals', '=', '[', ']', ')', 'titles', '=', 'deals', '.', 'map', '(', '&', ':title', ')', '.', 'uniq', 'titles', '.', 'map', 'do', '|', 'title', '|', 'deals', '.', 'map', 'do', '|', 'deal', '|', 'deal', 'if', 'deal', '.', 'try', '(', ':title', ')', '==', 'title', 'end', '.', 'compact', '.', 'last', 'end', '.', 'flatten', 'end']
->Original Target:
['Uniq', 'deals', 'from', 'Sqoot', 'because', 'there', 'are', 'some', 'many', 'duplicated', 'deals', 'with', 'different', 'ids', 'Simplely', 'distinguish', 'them', 'by', 'their', 'titles']
->Reconstructed Target:
Uniq deals from Sqoot because there are some many duplicated deals with different ids Simplely distinguish them by their titles
->Reconstructed Predication:
the unique deals
->Raw Input:
summarize:def uniq_deals ( deals = [ ] ) titles = deals. map ( & :title ). uniq titles. map do | title | deals. map do | deal | deal if deal. try ( :title ) == title end. compact. last end. flatten end
->Raw Target:
Uniq deals from Sqoot because there are some many duplicated deals with different ids Simplely distinguish them by their titles
--

1222=========
->Original Input:
['def', 'load_cookies', '(', 'file', ')', 'now', '=', '::', 'Time', '.', 'now', 'io', '=', 'case', 'file', 'when', 'String', 'open', '(', 'file', ')', 'else', 'file', 'end', 'io', '.', 'each_line', 'do', '|', 'line', '|', 'line', '.', 'chomp!', 'line', '.', 'gsub!', '(', '/', '/', ',', "''", ')', 'fields', '=', 'line', '.', 'split', '(', '"\\t"', ')', 'next', 'if', 'fields', '.', 'length', '!=', '7', 'name', ',', 'value', ',', 'domain', ',', 'for_domain', ',', 'path', ',', 'secure', ',', 'version', '=', 'fields', '[', '5', ']', ',', 'fields', '[', '6', ']', ',', 'fields', '[', '0', ']', ',', '(', 'fields', '[', '1', ']', '==', '"TRUE"', ')', ',', 'fields', '[', '2', ']', ',', '(', 'fields', '[', '3', ']', '==', '"TRUE"', ')', ',', '0', 'expires_seconds', '=', 'fields', '[', '4', ']', '.', 'to_i', 'expires', '=', '(', 'expires_seconds', '==', '0', ')', '?', 'nil', ':', '::', 'Time', '.', 'at', '(', 'expires_seconds', ')', 'next', 'if', 'expires', 'and', '(', 'expires', '<', 'now', ')', 'cookies', '.', 'add', '(', 'name', ',', 'value', ',', 'domain', ':', 'domain', ',', 'path', ':', 'path', ',', 'expires', ':', 'expires', ',', 'secure', ':', 'secure', ')', 'end', 'io', '.', 'close', 'if', 'String', '===', 'file', 'self', 'end']
->Original Target:
['Read', 'cookies', 'from', 'Mozilla', 'cookies', '.', 'txt', '-', 'style', 'IO', 'stream']
->Reconstructed Target:
Read cookies from Mozilla cookies. txt - style IO stream
->Reconstructed Predication:
= cookies.= cookies.........
->Raw Input:
summarize:def load_cookies ( file ) now = :: Time. now io = case file when String open ( file ) else file end io. each_line do | line | line. chomp! line. gsub! ( / /, '' ) fields = line. split ( "\t" ) next if fields. length!= 7 name, value, domain, for_domain, path, secure, version = fields [ 5 ], fields [ 6 ], fields [ 0 ], ( fields [ 1 ] == "TRUE" ), fields [ 2 ], ( fields [ 3 ] == "TRUE" ), 0 expires_seconds = fields [ 4 ]. to_i expires = ( expires_seconds == 0 )? nil : :: Time. at ( expires_seconds ) next if expires and ( expires < now ) cookies. add ( name, value, domain : domain, path : path, expires : expires, secure : secure ) end io. close if String === file self end
->Raw Target:
Read cookies from Mozilla cookies. txt - style IO stream
--

1223=========
->Original Input:
['def', 'dump_cookies', '(', 'file', ')', 'io', '=', 'case', 'file', 'when', 'String', 'open', '(', 'file', ',', '"w"', ')', 'else', 'file', 'end', 'cookies', '.', 'to_a', '.', 'each', 'do', '|', 'cookie', '|', 'io', '.', 'puts', '(', '[', 'cookie', '[', ':domain', ']', ',', '"FALSE"', ',', 'cookie', '[', ':path', ']', ',', 'cookie', '[', ':secure', ']', '?', '"TRUE"', ':', '"FALSE"', ',', 'cookie', '[', ':expires', ']', '.', 'to_i', '.', 'to_s', ',', 'cookie', '[', ':name', ']', ',', 'cookie', '[', ':value', ']', ']', '.', 'join', '(', '"\\t"', ')', ')', 'end', 'io', '.', 'close', 'if', 'String', '===', 'file', 'self', 'end']
->Original Target:
['Write', 'cookies', 'to', 'Mozilla', 'cookies', '.', 'txt', '-', 'style', 'IO', 'stream']
->Reconstructed Target:
Write cookies to Mozilla cookies. txt - style IO stream
->Reconstructed Predication:
the cookies to the file
->Raw Input:
summarize:def dump_cookies ( file ) io = case file when String open ( file, "w" ) else file end cookies. to_a. each do | cookie | io. puts ( [ cookie [ :domain ], "FALSE", cookie [ :path ], cookie [ :secure ]? "TRUE" : "FALSE", cookie [ :expires ]. to_i. to_s, cookie [ :name ], cookie [ :value ] ]. join ( "\t" ) ) end io. close if String === file self end
->Raw Target:
Write cookies to Mozilla cookies. txt - style IO stream
--

1224=========
->Original Input:
['def', 'set2', '(', 'selector', ',', 'value', '=', 'nil', ')', 'elem', '=', 'element', '(', 'xpath', ':', 'selector', ')', '.', 'to_subtype', 'case', 'elem', 'when', 'Watir', '::', 'Radio', 'elem', '.', 'set', 'when', 'Watir', '::', 'Select', 'elem', '.', 'select', 'value', 'when', 'Watir', '::', 'Input', 'elem', '.', 'set', 'value', 'when', 'Watir', '::', 'TextArea', 'elem', '.', 'set', 'value', 'else', 'elem', '.', 'click', 'end', 'end']
->Original Target:
['quick', 'set', 'value', '.']
->Reconstructed Target:
quick set value.
->Reconstructed Predication:
Set the value of the
->Raw Input:
summarize:def set2 ( selector, value = nil ) elem = element ( xpath : selector ). to_subtype case elem when Watir :: Radio elem. set when Watir :: Select elem. select value when Watir :: Input elem. set value when Watir :: TextArea elem. set value else elem. click end end
->Raw Target:
quick set value.
--

1225=========
->Original Input:
['def', 'update_by_expire_time', '(', 'options', '=', '{', '}', ')', '@expired_in', '=', 'options', '[', ':expired_in', ']', 'if', 'options', '[', ':expired_in', ']', '.', 'present?', 'time', '=', 'Time', '.', 'now', '.', 'to_i', '/', 'expired_in', '.', 'to_i', 'options', '.', 'merge', '(', 'expired_in', ':', 'time', ')', 'end']
->Original Target:
['Add', 'expired', 'time', 'functionality', 'to', 'this', 'gem', 'By', 'default', 'is', '1', '.', 'hour', 'and', 'can', 'be', 'replaced', 'anywhere']
->Reconstructed Target:
Add expired time functionality to this gem By default is 1. hour and can be replaced anywhere
->Reconstructed Predication:
 def update_by_expire_time ( expired_in
->Raw Input:
summarize:def update_by_expire_time ( options = { } ) @expired_in = options [ :expired_in ] if options [ :expired_in ]. present? time = Time. now. to_i / expired_in. to_i options. merge ( expired_in : time ) end
->Raw Target:
Add expired time functionality to this gem By default is 1. hour and can be replaced anywhere
--

1226=========
->Original Input:
['def', 'get', '(', 'options', '=', '{', '}', ')', 'uri', '=', 'new_uri', 'params', '=', 'merge_params', '(', 'options', ')', 'uri', '.', 'query', '=', 'URI', '.', 'encode_www_form', '(', 'params', ')', 'Net', '::', 'HTTP', '.', 'start', '(', 'uri', '.', 'host', ',', 'uri', '.', 'port', ',', ':use_ssl', '=>', 'uri', '.', 'scheme', '==', "'https'", ')', 'do', '|', 'http', '|', 'request', '=', 'Net', '::', 'HTTP', '::', 'Get', '.', 'new', '(', 'uri', ')', 'response', '=', 'http', '.', 'request', '(', 'request', ')', 'unless', 'response', '.', 'is_a?', '(', 'Net', '::', 'HTTPSuccess', ')', 'raise', '"#{response.code} #{response.message}\\n#{response.body}"', 'end', 'return', 'response', '.', 'body', 'end', 'end']
->Original Target:
['Make', 'a', 'GET', 'API', 'call', 'with', 'the', 'current', 'path', 'value', 'and']
->Reconstructed Target:
Make a GET API call with the current path value and
->Reconstructed Predication:
the request to thethe request to the endpoint.
->Raw Input:
summarize:def get ( options = { } ) uri = new_uri params = merge_params ( options ) uri. query = URI. encode_www_form ( params ) Net :: HTTP. start ( uri. host, uri. port, :use_ssl => uri. scheme == 'https' ) do | http | request = Net :: HTTP :: Get. new ( uri ) response = http. request ( request ) unless response. is_a? ( Net :: HTTPSuccess ) raise "#{response.code} #{response.message}\n#{response.body}" end return response. body end end
->Raw Target:
Make a GET API call with the current path value and
--

1227=========
->Original Input:
['def', 'images', '(', 'id', ',', 'tenant_id', ')', 'if', 'id', '.', 'nil?', 'return', 'get_request', '(', 'address', '(', 'tenant_id', ',', '"images/detail"', ')', ',', '@token', ')', 'else', 'return', 'get_request', '(', 'address', '(', 'tenant_id', ',', '"images/"', '+', 'id', ')', ',', '@token', ')', 'end', 'end']
->Original Target:
['No', 'ID', 'provided', '-', 'Lists', 'details', 'for', 'available', 'images', '.', 'ID', 'provided', '-', 'Shows', 'the', 'image', 'details', 'as', 'headers', 'and', 'the', 'image', 'binary', 'in', 'the', 'body', '.']
->Reconstructed Target:
No ID provided - Lists details for available images. ID provided - Shows the image details as headers and the image binary in the body.
->Reconstructed Predication:
the images for the specified image
->Raw Input:
summarize:def images ( id, tenant_id ) if id. nil? return get_request ( address ( tenant_id, "images/detail" ), @token ) else return get_request ( address ( tenant_id, "images/" + id ), @token ) end end
->Raw Target:
No ID provided - Lists details for available images. ID provided - Shows the image details as headers and the image binary in the body.
--

1228=========
->Original Input:
['def', 'image_create', '(', 'name', ',', 'disk_format', ',', 'container_format', ',', 'create_image', ',', 'tenant_id', ')', 'data', '=', '{', ':name', '=>', 'name', ',', ':disk_format', '=>', 'disk_format', ',', ':container_format', '=>', 'container_format', '}', 'unless', 'create_image', '.', 'nil?', 'data', '[', ':create_image', ']', '=', 'create_image', 'end', 'post_request', '(', 'address', '(', 'tenant_id', ',', '"images"', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Registers', 'a', 'virtual', 'machine', 'image', '.']
->Reconstructed Target:
Registers a virtual machine image.
->Reconstructed Predication:
Create an image for a
->Raw Input:
summarize:def image_create ( name, disk_format, container_format, create_image, tenant_id ) data = { :name => name, :disk_format => disk_format, :container_format => container_format } unless create_image. nil? data [ :create_image ] = create_image end post_request ( address ( tenant_id, "images" ), data, @token ) end
->Raw Target:
Registers a virtual machine image.
--

1229=========
->Original Input:
['def', 'replace_memberships', '(', 'id', ',', 'memberships', ',', 'tenant_id', ')', 'data', '=', '{', ':memberships', '=>', 'memberships', '}', 'put_request', '(', 'address', '(', 'tenant_id', ',', '"images/"', '+', 'id', '+', '"/members"', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Replaces', 'the', 'membership', 'list', 'for', 'an', 'image', '.']
->Reconstructed Target:
Replaces the membership list for an image.
->Reconstructed Predication:
the memberships to the specified memberships
->Raw Input:
summarize:def replace_memberships ( id, memberships, tenant_id ) data = { :memberships => memberships } put_request ( address ( tenant_id, "images/" + id + "/members" ), data, @token ) end
->Raw Target:
Replaces the membership list for an image.
--

1230=========
->Original Input:
['def', 'add_member', '(', 'id', ',', 'member_id', ',', 'can_share', ',', 'tenant_id', ')', 'if', 'can_share', '.', 'nil?', 'data', '=', '{', ':member', '=>', '{', ':can_share', '=>', 'false', '}', '}', 'else', 'data', '=', '{', ':member', '=>', '{', ':can_share', '=>', 'can_share', '}', '}', 'end', 'put_request', '(', 'address', '(', 'tenant_id', ',', '"images/"', '+', 'id', '+', '"/members/"', '+', 'member_id', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Adds', 'a', 'member', 'to', 'an', 'image', '.']
->Reconstructed Target:
Adds a member to an image.
->Reconstructed Predication:
the member to be added
->Raw Input:
summarize:def add_member ( id, member_id, can_share, tenant_id ) if can_share. nil? data = { :member => { :can_share => false } } else data = { :member => { :can_share => can_share } } end put_request ( address ( tenant_id, "images/" + id + "/members/" + member_id ), data, @token ) end
->Raw Target:
Adds a member to an image.
--

1231=========
->Original Input:
['def', 'mkdir', '(', 'dir', ',', 'owner', ':', 'nil', ',', 'mode', ':', 'nil', ')', 'FileUtils', '.', 'mkdir_p', '(', 'dir', ',', 'verbose', ':', 'verbose?', ')', 'chown', '(', 'dir', ',', 'owner', ')', 'if', 'owner', 'chmod', '(', 'dir', ',', 'mode', ')', 'if', 'mode', 'end']
->Original Target:
['Like', 'mkdir', '-', 'p', '+', 'dir', '+', '.', 'If', '+', 'owner', '+', 'is', 'specified', 'the', 'directory', 'will', 'be', 'chowned', 'to', 'owner', '.', 'If', '+', 'mode', '+', 'is', 'specified', 'the', 'directory', 'will', 'be', 'chmodded', 'to', 'mode', '.', 'Like', 'all', 'file', 'commands', 'the', 'operation', 'will', 'be', 'printed', 'out', 'if', 'verbose?', '.']
->Reconstructed Target:
Like mkdir - p + dir +. If + owner + is specified the directory will be chowned to owner. If + mode + is specified the directory will be chmodded to mode. Like all file commands the operation will be printed out if verbose?.
->Reconstructed Predication:
the directory to the given
->Raw Input:
summarize:def mkdir ( dir, owner : nil, mode : nil ) FileUtils. mkdir_p ( dir, verbose : verbose? ) chown ( dir, owner ) if owner chmod ( dir, mode ) if mode end
->Raw Target:
Like mkdir - p + dir +. If + owner + is specified the directory will be chowned to owner. If + mode + is specified the directory will be chmodded to mode. Like all file commands the operation will be printed out if verbose?.
--

1232=========
->Original Input:
['def', 'cp', '(', 'src', ',', 'dst', ',', 'mkdir', ':', 'false', ',', 'owner', ':', 'nil', ',', 'mode', ':', 'nil', ')', 'mkdir_if_necessary', '(', 'File', '.', 'dirname', '(', 'dst', ')', ')', 'if', 'mkdir', 'FileUtils', '.', 'cp_r', '(', 'src', ',', 'dst', ',', 'preserve', ':', 'true', ',', 'verbose', ':', 'verbose?', ')', 'chown', '(', 'dst', ',', 'owner', ')', 'if', 'owner', '&&', '!', 'File', '.', 'symlink?', '(', 'dst', ')', 'chmod', '(', 'dst', ',', 'mode', ')', 'if', 'mode', 'end']
->Original Target:
['Like', 'cp', '-', 'pr', '+', 'src', '+', '+', 'dst', '.', 'If', '+', 'mkdir', '+', 'is', 'true', 'the', 'dst', 'directoy', 'will', 'be', 'created', 'if', 'necessary', 'before', 'the', 'copy', '.', 'If', '+', 'owner', '+', 'is', 'specified', 'the', 'directory', 'will', 'be', 'chowned', 'to', 'owner', '.', 'If', '+', 'mode', '+', 'is', 'specified', 'the', 'directory', 'will', 'be', 'chmodded', 'to', 'mode', '.', 'Like', 'all', 'file', 'commands', 'the', 'operation', 'will', 'be', 'printed', 'out', 'if', 'verbose?', '.']
->Reconstructed Target:
Like cp - pr + src + + dst. If + mkdir + is true the dst directoy will be created if necessary before the copy. If + owner + is specified the directory will be chowned to owner. If + mode + is specified the directory will be chmodded to mode. Like all file commands the operation will be printed out if verbose?.
->Reconstructed Predication:
: cp_r dst : dst: dst : dst
->Raw Input:
summarize:def cp ( src, dst, mkdir : false, owner : nil, mode : nil ) mkdir_if_necessary ( File. dirname ( dst ) ) if mkdir FileUtils. cp_r ( src, dst, preserve : true, verbose : verbose? ) chown ( dst, owner ) if owner &&! File. symlink? ( dst ) chmod ( dst, mode ) if mode end
->Raw Target:
Like cp - pr + src + + dst. If + mkdir + is true the dst directoy will be created if necessary before the copy. If + owner + is specified the directory will be chowned to owner. If + mode + is specified the directory will be chmodded to mode. Like all file commands the operation will be printed out if verbose?.
--

1233=========
->Original Input:
['def', 'mv', '(', 'src', ',', 'dst', ',', 'mkdir', ':', 'false', ')', 'mkdir_if_necessary', '(', 'File', '.', 'dirname', '(', 'dst', ')', ')', 'if', 'mkdir', 'FileUtils', '.', 'mv', '(', 'src', ',', 'dst', ',', 'verbose', ':', 'verbose?', ')', 'end']
->Original Target:
['Like', 'mv', '+', 'src', '+', '+', 'dst', '.', 'If', '+', 'mkdir', '+', 'is', 'true', 'the', 'dst', 'directoy', 'will', 'be', 'created', 'if', 'necessary', 'before', 'the', 'copy', '.', 'Like', 'all', 'file', 'commands', 'the', 'operation', 'will', 'be', 'printed', 'out', 'if', 'verbose?', '.']
->Reconstructed Target:
Like mv + src + + dst. If + mkdir + is true the dst directoy will be created if necessary before the copy. Like all file commands the operation will be printed out if verbose?.
->Reconstructed Predication:
dest file.  def
->Raw Input:
summarize:def mv ( src, dst, mkdir : false ) mkdir_if_necessary ( File. dirname ( dst ) ) if mkdir FileUtils. mv ( src, dst, verbose : verbose? ) end
->Raw Target:
Like mv + src + + dst. If + mkdir + is true the dst directoy will be created if necessary before the copy. Like all file commands the operation will be printed out if verbose?.
--

1234=========
->Original Input:
['def', 'ln', '(', 'src', ',', 'dst', ')', 'FileUtils', '.', 'ln_sf', '(', 'src', ',', 'dst', ',', 'verbose', ':', 'verbose?', ')', 'rescue', 'Errno', '::', 'EEXIST', '=>', 'e', 'raise', 'e', 'if', '!', '(', 'File', '.', 'symlink?', '(', 'dst', ')', '&&', 'src', '==', 'File', '.', 'readlink', '(', 'dst', ')', ')', 'end']
->Original Target:
['Like', 'ln', '-', 'sf', '+', 'src', '+', '+', 'dst', '.', 'The', 'command', 'will', 'be', 'printed', 'out', 'if', 'verbose?', '.']
->Reconstructed Target:
Like ln - sf + src + + dst. The command will be printed out if verbose?.
->Reconstructed Predication:
the file to the file
->Raw Input:
summarize:def ln ( src, dst ) FileUtils. ln_sf ( src, dst, verbose : verbose? ) rescue Errno :: EEXIST => e raise e if! ( File. symlink? ( dst ) && src == File. readlink ( dst ) ) end
->Raw Target:
Like ln - sf + src + + dst. The command will be printed out if verbose?.
--

1235=========
->Original Input:
['def', 'chmod', '(', 'file', ',', 'mode', ')', 'return', 'if', 'File', '.', 'stat', '(', 'file', ')', '.', 'mode', '==', 'mode', 'FileUtils', '.', 'chmod', '(', 'mode', ',', 'file', ',', 'verbose', ':', 'verbose?', ')', 'end']
->Original Target:
['Like', 'chmod', 'mode', 'file', '.', 'Like', 'all', 'file', 'commands', 'the', 'operation', 'will', 'be', 'printed', 'out', 'if', 'verbose?', '.']
->Reconstructed Target:
Like chmod mode file. Like all file commands the operation will be printed out if verbose?.
->Reconstructed Predication:
file : path to filefile : path
->Raw Input:
summarize:def chmod ( file, mode ) return if File. stat ( file ). mode == mode FileUtils. chmod ( mode, file, verbose : verbose? ) end
->Raw Target:
Like chmod mode file. Like all file commands the operation will be printed out if verbose?.
--

1236=========
->Original Input:
['def', 'rm_and_mkdir', '(', 'dir', ')', 'raise', '"don\'t do this"', 'if', 'dir', '==', '""', 'FileUtils', '.', 'rm_rf', '(', 'dir', ',', 'verbose', ':', 'verbose?', ')', 'mkdir', '(', 'dir', ')', 'end']
->Original Target:
['Like', 'rm', '-', 'rf', '&&', 'mkdir', '-', 'p', '.', 'Like', 'all', 'file', 'commands', 'the', 'operation', 'will', 'be', 'printed', 'out', 'if', 'verbose?', '.']
->Reconstructed Target:
Like rm - rf && mkdir - p. Like all file commands the operation will be printed out if verbose?.
->Reconstructed Predication:
the directory to the given
->Raw Input:
summarize:def rm_and_mkdir ( dir ) raise "don't do this" if dir == "" FileUtils. rm_rf ( dir, verbose : verbose? ) mkdir ( dir ) end
->Raw Target:
Like rm - rf && mkdir - p. Like all file commands the operation will be printed out if verbose?.
--

1237=========
->Original Input:
['def', 'copy_metadata', '(', 'src', ',', 'dst', ')', 'stat', '=', 'File', '.', 'stat', '(', 'src', ')', 'File', '.', 'chmod', '(', 'stat', '.', 'mode', ',', 'dst', ')', 'File', '.', 'utime', '(', 'stat', '.', 'atime', ',', 'stat', '.', 'mtime', ',', 'dst', ')', 'end']
->Original Target:
['Copy', 'mode', 'atime', 'and', 'mtime', 'from', '+', 'src', '+', 'to', '+', 'dst', '+', '.', 'This', 'one', 'is', 'rarely', 'used', 'and', 'doesn', 't', 'echo', '.']
->Reconstructed Target:
Copy mode atime and mtime from + src + to + dst +. This one is rarely used and doesn t echo.
->Reconstructed Predication:
the file to the destination
->Raw Input:
summarize:def copy_metadata ( src, dst ) stat = File. stat ( src ) File. chmod ( stat. mode, dst ) File. utime ( stat. atime, stat. mtime, dst ) end
->Raw Target:
Copy mode atime and mtime from + src + to + dst +. This one is rarely used and doesn t echo.
--

1238=========
->Original Input:
['def', 'atomic_write', '(', 'path', ')', 'tmp', '=', 'Tempfile', '.', 'new', '(', 'File', '.', 'basename', '(', 'path', ')', ')', 'yield', '(', 'tmp', ')', 'tmp', '.', 'close', 'chmod', '(', 'tmp', '.', 'path', ',', '0o644', ')', 'mv', '(', 'tmp', '.', 'path', ',', 'path', ')', 'ensure', 'rm_if_necessary', '(', 'tmp', '.', 'path', ')', 'end']
->Original Target:
['Atomically', 'write', 'to', '+', 'path', '+', '.', 'An', 'open', 'temp', 'file', 'is', 'yielded', '.']
->Reconstructed Target:
Atomically write to + path +. An open temp file is yielded.
->Reconstructed Predication:
write a file to a
->Raw Input:
summarize:def atomic_write ( path ) tmp = Tempfile. new ( File. basename ( path ) ) yield ( tmp ) tmp. close chmod ( tmp. path, 0o644 ) mv ( tmp. path, path ) ensure rm_if_necessary ( tmp. path ) end
->Raw Target:
Atomically write to + path +. An open temp file is yielded.
--

1239=========
->Original Input:
['def', 'handle_requests', 'until', '@requestmq', '.', 'empty?', 'request', '=', '@requestmq', '.', 'deq', '(', 'true', ')', 'begin', 'request', '.', 'response', '=', '@app', '.', 'call', '(', 'request', '.', 'env', ')', 'rescue', 'Exception', '=>', 'e', 'request', '.', 'exception', '=', 'e', 'ensure', 'body', '=', 'request', '.', 'response', '.', 'try', '(', ':last', ')', 'body', '.', 'close', 'if', 'body', '.', 'respond_to?', ':close', 'end', 'end', 'end']
->Original Target:
['Should', 'be', 'run', 'by', 'another', 'thread', '-', 'respond', 'to', 'all', 'queued', 'requests']
->Reconstructed Target:
Should be run by another thread - respond to all queued requests
->Reconstructed Predication:
the request queue and the response
->Raw Input:
summarize:def handle_requests until @requestmq. empty? request = @requestmq. deq ( true ) begin request. response = @app. call ( request. env ) rescue Exception => e request. exception = e ensure body = request. response. try ( :last ) body. close if body. respond_to? :close end end end
->Raw Target:
Should be run by another thread - respond to all queued requests
--

1240=========
->Original Input:
['def', 'configfile_hash', 'config', '=', '{', '}', 'begin', 'json', '=', 'File', '.', 'read', '(', 'configfile', ')', 'config', '=', 'JSON', '.', 'parse', '(', 'json', ')', 'rescue', 'Errno', '::', 'ENOENT', '@logger', '.', 'debug', '"#{configfile} does not exist"', '@force_save', '=', 'true', 'rescue', 'JSON', '::', 'ParserError', '@logger', '.', 'debug', '"JSON parse error in #{configfile}"', '@force_save', '=', 'true', 'end', 'config', 'end']
->Original Target:
['return', 'a', 'hash', 'of', 'the', 'configfile', 'or', 'empty', 'hash', 'if', 'error', 'encountered']
->Reconstructed Target:
return a hash of the configfile or empty hash if error encountered
->Reconstructed Predication:
configfile = configfile_hash configfile =configfile = configfile_hash
->Raw Input:
summarize:def configfile_hash config = { } begin json = File. read ( configfile ) config = JSON. parse ( json ) rescue Errno :: ENOENT @logger. debug "#{configfile} does not exist" @force_save = true rescue JSON :: ParserError @logger. debug "JSON parse error in #{configfile}" @force_save = true end config end
->Raw Target:
return a hash of the configfile or empty hash if error encountered
--

1241=========
->Original Input:
['def', 'email_addresses', '(', 'text', ')', 'text', '.', 'gsub', '(', '@regex', '[', ':mail', ']', ')', 'do', 'text', '=', '$&', 'if', 'auto_linked?', '(', '$`', ',', "$'", ')', 'text', 'else', 'display_text', '=', '(', 'block_given?', ')', '?', 'yield', '(', 'text', ')', ':', 'text', '"<a href=\'mailto:#{text}\'>#{display_text}</a>"', 'end', 'end', 'end']
->Original Target:
['Turns', 'all', 'email', 'addresses', 'into', 'clickable', 'links', '.', 'If', 'a', 'block', 'is', 'given', 'each', 'email', 'is', 'yielded', 'and', 'the', 'result', 'is', 'used', 'as', 'the', 'link', 'text', '.']
->Reconstructed Target:
Turns all email addresses into clickable links. If a block is given each email is yielded and the result is used as the link text.
->Reconstructed Predication:
email addresses
->Raw Input:
summarize:def email_addresses ( text ) text. gsub ( @regex [ :mail ] ) do text = $& if auto_linked? ( $`, $' ) text else display_text = ( block_given? )? yield ( text ) : text "<a href='mailto:#{text}'>#{display_text}</a>" end end end
->Raw Target:
Turns all email addresses into clickable links. If a block is given each email is yielded and the result is used as the link text.
--

1242=========
->Original Input:
['def', 'plural', '(', 'rule', ',', 'replacement', ')', '@uncountables', '.', 'delete', '(', 'rule', ')', 'if', 'rule', '.', 'is_a?', '(', 'String', ')', '@uncountables', '.', 'delete', '(', 'replacement', ')', '@plurals', '.', 'insert', '(', '0', ',', '[', 'rule', ',', 'replacement', ']', ')', 'end']
->Original Target:
['Specifies', 'a', 'new', 'pluralization', 'rule', 'and', 'its', 'replacement', '.', 'The', 'rule', 'can', 'either', 'be', 'a', 'string', 'or', 'a', 'regular', 'expression', '.', 'The', 'replacement', 'should', 'always', 'be', 'a', 'string', 'that', 'may', 'include', 'references', 'to', 'the', 'matched', 'data', 'from', 'the', 'rule', '.']
->Reconstructed Target:
Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression. The replacement should always be a string that may include references to the matched data from the rule.
->Reconstructed Predication:
the plural form of the given
->Raw Input:
summarize:def plural ( rule, replacement ) @uncountables. delete ( rule ) if rule. is_a? ( String ) @uncountables. delete ( replacement ) @plurals. insert ( 0, [ rule, replacement ] ) end
->Raw Target:
Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression. The replacement should always be a string that may include references to the matched data from the rule.
--

1243=========
->Original Input:
['def', 'singular', '(', 'rule', ',', 'replacement', ')', '@uncountables', '.', 'delete', '(', 'rule', ')', 'if', 'rule', '.', 'is_a?', '(', 'String', ')', '@uncountables', '.', 'delete', '(', 'replacement', ')', '@singulars', '.', 'insert', '(', '0', ',', '[', 'rule', ',', 'replacement', ']', ')', 'end']
->Original Target:
['Specifies', 'a', 'new', 'singularization', 'rule', 'and', 'its', 'replacement', '.', 'The', 'rule', 'can', 'either', 'be', 'a', 'string', 'or', 'a', 'regular', 'expression', '.', 'The', 'replacement', 'should', 'always', 'be', 'a', 'string', 'that', 'may', 'include', 'references', 'to', 'the', 'matched', 'data', 'from', 'the', 'rule', '.']
->Reconstructed Target:
Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression. The replacement should always be a string that may include references to the matched data from the rule.
->Reconstructed Predication:
the singular form of a rule
->Raw Input:
summarize:def singular ( rule, replacement ) @uncountables. delete ( rule ) if rule. is_a? ( String ) @uncountables. delete ( replacement ) @singulars. insert ( 0, [ rule, replacement ] ) end
->Raw Target:
Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression. The replacement should always be a string that may include references to the matched data from the rule.
--

1244=========
->Original Input:
['def', 'irregular', '(', 'singular', ',', 'plural', ')', '@uncountables', '.', 'delete', '(', 'singular', ')', '@uncountables', '.', 'delete', '(', 'plural', ')', 'if', 'singular', '[', '0', ',', '1', ']', '.', 'upcase', '==', 'plural', '[', '0', ',', '1', ']', '.', 'upcase', 'plural', '(', 'Regexp', '.', 'new', '(', '"(#{singular[0,1]})#{singular[1..-1]}$"', ',', '"i"', ')', ',', "'\\1'", '+', 'plural', '[', '1', '..', '-', '1', ']', ')', 'singular', '(', 'Regexp', '.', 'new', '(', '"(#{plural[0,1]})#{plural[1..-1]}$"', ',', '"i"', ')', ',', "'\\1'", '+', 'singular', '[', '1', '..', '-', '1', ']', ')', 'else', 'plural', '(', 'Regexp', '.', 'new', '(', '"#{singular[0,1].upcase}(?i)#{singular[1..-1]}$"', ')', ',', 'plural', '[', '0', ',', '1', ']', '.', 'upcase', '+', 'plural', '[', '1', '..', '-', '1', ']', ')', 'plural', '(', 'Regexp', '.', 'new', '(', '"#{singular[0,1].downcase}(?i)#{singular[1..-1]}$"', ')', ',', 'plural', '[', '0', ',', '1', ']', '.', 'downcase', '+', 'plural', '[', '1', '..', '-', '1', ']', ')', 'singular', '(', 'Regexp', '.', 'new', '(', '"#{plural[0,1].upcase}(?i)#{plural[1..-1]}$"', ')', ',', 'singular', '[', '0', ',', '1', ']', '.', 'upcase', '+', 'singular', '[', '1', '..', '-', '1', ']', ')', 'singular', '(', 'Regexp', '.', 'new', '(', '"#{plural[0,1].downcase}(?i)#{plural[1..-1]}$"', ')', ',', 'singular', '[', '0', ',', '1', ']', '.', 'downcase', '+', 'singular', '[', '1', '..', '-', '1', ']', ')', 'end', 'end']
->Original Target:
['Specifies', 'a', 'new', 'irregular', 'that', 'applies', 'to', 'both', 'pluralization', 'and', 'singularization', 'at', 'the', 'same', 'time', '.', 'This', 'can', 'only', 'be', 'used', 'for', 'strings', 'not', 'regular', 'expressions', '.', 'You', 'simply', 'pass', 'the', 'irregular', 'in', 'singular', 'and', 'plural', 'form', '.']
->Reconstructed Target:
Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used for strings not regular expressions. You simply pass the irregular in singular and plural form.
->Reconstructed Predication:
) plural ( Regexp.new ( "#{singular[0,1].upcase}(?i)#{singular[1..-1]}$" ),1.. - 1 ]) singular ( Regexp.new ( "#{plural[0,1].downcase}(?i)#{plural[1..-1]}$" ),1.. - 1 ]) plural ( Regexp.new ( "#{plural[0,1].upcase}(?
->Raw Input:
summarize:def irregular ( singular, plural ) @uncountables. delete ( singular ) @uncountables. delete ( plural ) if singular [ 0, 1 ]. upcase == plural [ 0, 1 ]. upcase plural ( Regexp. new ( "(#{singular[0,1]})#{singular[1..-1]}$", "i" ), '\1' + plural [ 1.. - 1 ] ) singular ( Regexp. new ( "(#{plural[0,1]})#{plural[1..-1]}$", "i" ), '\1' + singular [ 1.. - 1 ] ) else plural ( Regexp. new ( "#{singular[0,1].upcase}(?i)#{singular[1..-1]}$" ), plural [ 0, 1 ]. upcase + plural [ 1.. - 1 ] ) plural ( Regexp. new ( "#{singular[0,1].downcase}(?i)#{singular[1..-1]}$" ), plural [ 0, 1 ]. downcase + plural [ 1.. - 1 ] ) singular ( Regexp. new ( "#{plural[0,1].upcase}(?i)#{plural[1..-1]}$" ), singular [ 0, 1 ]. upcase + singular [ 1.. - 1 ] ) singular ( Regexp. new ( "#{plural[0,1].downcase}(?i)#{plural[1..-1]}$" ), singular [ 0, 1 ]. downcase + singular [ 1.. - 1 ] ) end end
->Raw Target:
Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used for strings not regular expressions. You simply pass the irregular in singular and plural form.
--

1245=========
->Original Input:
['def', 'execute', 'raise', 'errors', '.', 'to_sentences', 'unless', 'valid?', 'result', '=', 'false', 'mutex', '=', 'Mutagem', '::', 'Mutex', '.', 'new', '(', "'revenc.lck'", ')', 'lock_successful', '=', 'mutex', '.', 'execute', 'do', 'result', '=', 'system_cmd', '(', 'cmd', ')', 'end', 'raise', '"action failed, lock file present"', 'unless', 'lock_successful', 'result', 'end']
->Original Target:
['run', 'the', 'action', 'if', 'valid', 'and', 'return', 'true', 'if', 'successful']
->Reconstructed Target:
run the action if valid and return true if successful
->Reconstructed Predication:
 def execute cmd =
->Raw Input:
summarize:def execute raise errors. to_sentences unless valid? result = false mutex = Mutagem :: Mutex. new ('revenc.lck' ) lock_successful = mutex. execute do result = system_cmd ( cmd ) end raise "action failed, lock file present" unless lock_successful result end
->Raw Target:
run the action if valid and return true if successful
--

1246=========
->Original Input:
['def', 'output', 'opts', '=', 'options', 'if', 'opts', '.', 'format', 'FileUtils', '.', 'mkdir_p', 'opts', '.', 'output_dir', 'formatted_output', 'end', '@results', '.', 'clear', 'end']
->Original Target:
['Output', 'the', 'results', 'based', 'on', 'the', 'requested', 'output', 'format']
->Reconstructed Target:
Output the results based on the requested output format
->Reconstructed Predication:
@output = opts. output
->Raw Input:
summarize:def output opts = options if opts. format FileUtils. mkdir_p opts. output_dir formatted_output end @results. clear end
->Raw Target:
Output the results based on the requested output format
--

1247=========
->Original Input:
['def', 'run', 'while', '@jobs', '.', 'length', '>', '0', 'do', '@current_job', '=', '@jobs', '.', 'pop', '@current_rate', '=', '@current_job', '.', 'high_rate', '.', 'to_i', 'httperf', 'true', '(', '@current_job', '.', 'low_rate', '.', 'to_i', '..', '@current_job', '.', 'high_rate', '.', 'to_i', ')', '.', 'step', '(', '@current_job', '.', 'rate_step', '.', 'to_i', ')', 'do', '|', 'rate', '|', '@current_rate', '=', 'rate', 'httperf', 'end', 'output', 'end', 'end']
->Original Target:
['Run', 'httperf', 'from', 'low_rate', 'to', 'high_rate', 'stepping', 'by', 'rate_step']
->Reconstructed Target:
Run httperf from low_rate to high_rate stepping by rate_step
->Reconstructed Predication:
the job to run the job
->Raw Input:
summarize:def run while @jobs. length > 0 do @current_job = @jobs. pop @current_rate = @current_job. high_rate. to_i httperf true ( @current_job. low_rate. to_i.. @current_job. high_rate. to_i ). step ( @current_job. rate_step. to_i ) do | rate | @current_rate = rate httperf end output end end
->Raw Target:
Run httperf from low_rate to high_rate stepping by rate_step
--

1248=========
->Original Input:
['def', 'authenticate', '(', 'username', ',', 'password', ',', 'tenant', '=', 'nil', ')', 'data', '=', '{', '"auth"', '=>', '{', '"passwordCredentials"', '=>', '{', '"username"', '=>', 'username', ',', '"password"', '=>', 'password', '}', '}', '}', 'unless', 'tenant', '.', 'nil?', 'data', '[', '"auth"', ']', '[', '"tenantName"', ']', '=', 'tenant', 'end', '@data', '=', 'post_request', '(', 'address', '(', '"/tokens"', ')', ',', 'data', ',', '@token', ')', 'end']
->Original Target:
['Authenticate', 'via', 'keystone', 'unless', 'a', 'token', 'and', 'tenant', 'are', 'defined', 'then', 'a', 'unscoped', 'token', 'is', 'returned', 'with', 'all', 'associated', 'data', 'and', 'stored', 'in', 'the']
->Reconstructed Target:
Authenticate via keystone unless a token and tenant are defined then a unscoped token is returned with all associated data and stored in the
->Reconstructed Predication:
the user to authenticate thethe user to authenticate the user
->Raw Input:
summarize:def authenticate ( username, password, tenant = nil ) data = { "auth" => { "passwordCredentials" => { "username" => username, "password" => password } } } unless tenant. nil? data [ "auth" ] [ "tenantName" ] = tenant end @data = post_request ( address ( "/tokens" ), data, @token ) end
->Raw Target:
Authenticate via keystone unless a token and tenant are defined then a unscoped token is returned with all associated data and stored in the
--

1249=========
->Original Input:
['def', 'add_to_services', '(', 'name', ',', 'type', ',', 'description', ')', 'data', '=', '{', "'OS-KSADM:service'", '=>', '{', "'name'", '=>', 'name', ',', "'type'", '=>', 'type', ',', "'description'", '=>', 'description', '}', '}', 'return', 'post_request', '(', 'address', '(', '"/OS-KSADM/services"', ')', ',', 'data', ',', 'token', '(', ')', ')', 'end']
->Original Target:
['Add', 'a', 'service', 'to', 'the', 'keystone', 'services', 'directory']
->Reconstructed Target:
Add a service to the keystone services directory
->Reconstructed Predication:
Add a service to thethe service you want to add
->Raw Input:
summarize:def add_to_services ( name, type, description ) data = { 'OS-KSADM:service' => { 'name' => name, 'type' => type, 'description' => description } } return post_request ( address ( "/OS-KSADM/services" ), data, token ( ) ) end
->Raw Target:
Add a service to the keystone services directory
--

1250=========
->Original Input:
['def', 'add_endpoint', '(', 'region', ',', 'service_id', ',', 'publicurl', ',', 'adminurl', ',', 'internalurl', ')', 'data', '=', '{', "'endpoint'", '=>', '{', "'region'", '=>', 'region', ',', "'service_id'", '=>', 'service_id', ',', "'publicurl'", '=>', 'publicurl', ',', "'adminurl'", '=>', 'adminurl', ',', "'internalurl'", '=>', 'internalurl', '}', '}', 'return', 'post_request', '(', 'address', '(', '"/endpoints"', ')', ',', 'data', ',', 'token', '(', ')', ')', 'end']
->Original Target:
['Add', 'an', 'endpoint', 'list']
->Reconstructed Target:
Add an endpoint list
->Reconstructed Predication:
endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint endpoint
->Raw Input:
summarize:def add_endpoint ( region, service_id, publicurl, adminurl, internalurl ) data = { 'endpoint' => {'region' => region,'service_id' => service_id, 'publicurl' => publicurl, 'adminurl' => adminurl, 'internalurl' => internalurl } } return post_request ( address ( "/endpoints" ), data, token ( ) ) end
->Raw Target:
Add an endpoint list
--

1251=========
->Original Input:
['def', 'get_endpoints', '(', 'token', '=', 'nil', ')', 'if', 'token', '.', 'nil?', 'return', 'get_request', '(', 'address', '(', '"/endpoints"', ')', ',', 'token', '(', ')', ')', 'else', 'return', 'get_request', '(', 'address', '(', '"/tokens/#{token}/endpoints"', ')', ',', 'token', '(', ')', ')', 'end', 'end']
->Original Target:
['Get', 'the', 'endpoint', 'list']
->Reconstructed Target:
Get the endpoint list
->Reconstructed Predication:
endpoint for a token.
->Raw Input:
summarize:def get_endpoints ( token = nil ) if token. nil? return get_request ( address ( "/endpoints" ), token ( ) ) else return get_request ( address ( "/tokens/#{token}/endpoints" ), token ( ) ) end end
->Raw Target:
Get the endpoint list
--

1252=========
->Original Input:
['def', 'disable_method', '(', 'method_name', ',', 'message', '=', 'nil', ')', 'disabled_methods', '[', 'method_name', ']', '||=', 'DisabledMethod', '.', 'new', '(', 'self', ',', 'method_name', ',', 'message', ')', 'disabled_methods', '[', 'method_name', ']', '.', 'disable!', 'end']
->Original Target:
['Disables', 'an', 'instance', 'method', '.']
->Reconstructed Target:
Disables an instance method.
->Reconstructed Predication:
the method to be disabled
->Raw Input:
summarize:def disable_method ( method_name, message = nil ) disabled_methods [ method_name ] ||= DisabledMethod. new ( self, method_name, message ) disabled_methods [ method_name ]. disable! end
->Raw Target:
Disables an instance method.
--

1253=========
->Original Input:
['def', 'to_proc', 'disabled_method', '=', 'self', 'Proc', '.', 'new', 'do', '|', '*', 'args', ',', '&', 'block', '|', 'disabled_method', '.', 'execute', '(', 'self', ',', '*', 'args', ',', '&', 'block', ')', 'end', 'end']
->Original Target:
['Returns', 'a', 'Proc', 'that', 'acts', 'as', 'a', 'replacement', 'for', 'the', 'disabled', 'method', '.']
->Reconstructed Target:
Returns a Proc that acts as a replacement for the disabled method.
->Reconstructed Predication:
the disabled method.
->Raw Input:
summarize:def to_proc disabled_method = self Proc. new do | * args, & block | disabled_method. execute ( self, * args, & block ) end end
->Raw Target:
Returns a Proc that acts as a replacement for the disabled method.
--

1254=========
->Original Input:
['def', 'execute', '(', 'object', ',', '*', 'args', ',', '&', 'block', ')', 'if', 'disabled?', 'raise', 'NoMethodError', ',', 'message', 'else', 'object', '.', 'send', '(', 'aliased_name', ',', '*', 'args', ',', '&', 'block', ')', 'end', 'end']
->Original Target:
['The', 'replacement', 'for', 'the', 'original', 'method', '.', 'It', 'will', 'raise', 'a', 'NoMethodError', 'if', 'the', 'method', 'is', 'disabled', '.', 'Otherwise', 'it', 'will', 'execute', 'the', 'original', 'method', '.']
->Reconstructed Target:
The replacement for the original method. It will raise a NoMethodError if the method is disabled. Otherwise it will execute the original method.
->Reconstructed Predication:
the object to execute the given
->Raw Input:
summarize:def execute ( object, * args, & block ) if disabled? raise NoMethodError, message else object. send ( aliased_name, * args, & block ) end end
->Raw Target:
The replacement for the original method. It will raise a NoMethodError if the method is disabled. Otherwise it will execute the original method.
--

1255=========
->Original Input:
['def', 'alias_method!', 'klass', '.', 'send', '(', ':define_method', ',', 'replacement_name', ',', '&', 'self', ')', 'klass', '.', 'send', '(', ':alias_method', ',', 'aliased_name', ',', 'method_name', ')', 'klass', '.', 'send', '(', ':alias_method', ',', 'method_name', ',', 'replacement_name', ')', 'end']
->Original Target:
['Replaces', 'the', 'original', 'implementation', 'of', 'the', 'method', 'with', 'an', 'implementation', 'that', 'allows', 'disabling', '.']
->Reconstructed Target:
Replaces the original implementation of the method with an implementation that allows disabling.
->Reconstructed Predication:
the method to be called
->Raw Input:
summarize:def alias_method! klass. send ( :define_method, replacement_name, & self ) klass. send ( :alias_method, aliased_name, method_name ) klass. send ( :alias_method, method_name, replacement_name ) end
->Raw Target:
Replaces the original implementation of the method with an implementation that allows disabling.
--

1256=========
->Original Input:
['def', 'secret_to_public', '(', 'secret', ',', 'form', '=', ':byte', ')', 'publickey', '=', 'p_secret_to_public', '(', 'change_argument_format', '(', 'secret', ',', 'form', ')', ')', 'return', 'change_result_format', '(', 'publickey', ',', 'form', ')', 'end']
->Original Target:
['calculate', 'public', 'key', 'from', 'secret']
->Reconstructed Target:
calculate public key from secret
->Reconstructed Predication:
public key
->Raw Input:
summarize:def secret_to_public ( secret, form = :byte ) publickey = p_secret_to_public ( change_argument_format ( secret, form ) ) return change_result_format ( publickey, form ) end
->Raw Target:
calculate public key from secret
--

1257=========
->Original Input:
['def', 'point_equal', '(', 'pa', ',', 'pb', ')', 'return', 'false', 'if', '(', 'pa', '[', '0', ']', '*', 'pb', '[', '2', ']', '-', 'pb', '[', '0', ']', '*', 'pa', '[', '2', ']', ')', '%', '@@p', '!=', '0', 'return', 'false', 'if', '(', 'pa', '[', '1', ']', '*', 'pb', '[', '2', ']', '-', 'pb', '[', '1', ']', '*', 'pa', '[', '2', ']', ')', '%', '@@p', '!=', '0', 'return', 'true', 'end']
->Original Target:
['return', 'point', 'A', '==', 'point', 'B']
->Reconstructed Target:
return point A == point B
->Reconstructed Predication:
pa [ 0 ] *
->Raw Input:
summarize:def point_equal ( pa, pb ) return false if ( pa [ 0 ] * pb [ 2 ] - pb [ 0 ] * pa [ 2 ] ) % @@p!= 0 return false if ( pa [ 1 ] * pb [ 2 ] - pb [ 1 ] * pa [ 2 ] ) % @@p!= 0 return true end
->Raw Target:
return point A == point B
--

1258=========
->Original Input:
['def', 'recover_x', '(', 'y', ',', 'sign', ')', 'return', 'nil', 'if', 'y', '>=', '@@p', 'x2', '=', '(', 'y', '*', 'y', '-', '1', ')', '*', 'modp_inv', '(', '@@d', '*', 'y', '*', 'y', '+', '1', ')', 'if', 'x2', '.', 'equal?', '0', 'then', 'unless', 'sign', '.', 'equal?', '0', 'then', 'return', 'nil', 'else', 'return', '0', 'end', 'end', 'x', '=', 'pow_mod', '(', 'x2', ',', '(', '(', '@@p', '+', '3', ')', '/', '8', ')', ',', '@@p', ')', 'x', '=', 'x', '*', '@@modp_sqrt_m1', '%', '@@p', 'unless', '(', '(', 'x', '*', 'x', '-', 'x2', ')', '%', '@@p', ')', '.', 'equal?', '0', 'return', 'nil', 'unless', '(', '(', 'x', '*', 'x', '-', 'x2', ')', '%', '@@p', ')', '.', 'equal?', '0', 'x', '=', '@@p', '-', 'x', 'unless', '(', 'x', '&', '1', ')', '.', 'equal?', 'sign', 'return', 'x', 'end']
->Original Target:
['region', 'point', 'manipulation', 'Compute', 'corresponding', 'x', '-', 'coordinate', 'with', 'low', 'bit', 'corresponding', 'to', 'sign', 'or', 'return', 'nil', 'on', 'failure']
->Reconstructed Target:
region point manipulation Compute corresponding x - coordinate with low bit corresponding to sign or return nil on failure
->Reconstructed Predication:
x2 = x * xx2 = x * x2x2 ) % @@px2 ) % @@px2 ) % @@px2 ) % @@px2 ) % @@px2 ) % @@px2 ) % @@px2 ) % @@p
->Raw Input:
summarize:def recover_x ( y, sign ) return nil if y >= @@p x2 = ( y * y - 1 ) * modp_inv ( @@d * y * y + 1 ) if x2. equal? 0 then unless sign. equal? 0 then return nil else return 0 end end x = pow_mod ( x2, ( ( @@p + 3 ) / 8 ), @@p ) x = x * @@modp_sqrt_m1 % @@p unless ( ( x * x - x2 ) % @@p ). equal? 0 return nil unless ( ( x * x - x2 ) % @@p ). equal? 0 x = @@p - x unless ( x & 1 ). equal? sign return x end
->Raw Target:
region point manipulation Compute corresponding x - coordinate with low bit corresponding to sign or return nil on failure
--

1259=========
->Original Input:
['def', 'point_decompress', '(', 's', ')', 'raise', 'ArgumentError', ',', '"Invalid input length for decompression"', 'unless', 's', '.', 'length', '.', 'equal?', '32', 'y', '=', 'int_form_bytes', '(', 's', ')', 'sign', '=', 'y', '>>', '255', 'y', '&=', '(', '1', '<<', '255', ')', '-', '1', 'x', '=', 'recover_x', '(', 'y', ',', 'sign', ')', 'if', 'x', '.', 'nil?', 'then', 'return', 'nil', 'else', 'return', '[', 'x', ',', 'y', ',', '1', ',', 'x', '*', 'y', '%', '@@p', ']', 'end', 'end']
->Original Target:
['decompress', 'point', 'that', 'is', 'compressed', 'into', '32bytes']
->Reconstructed Target:
decompress point that is compressed into 32bytes
->Reconstructed Predication:
return a compressed point
->Raw Input:
summarize:def point_decompress ( s ) raise ArgumentError, "Invalid input length for decompression" unless s. length. equal? 32 y = int_form_bytes ( s ) sign = y >> 255 y &= ( 1 << 255 ) - 1 x = recover_x ( y, sign ) if x. nil? then return nil else return [ x, y, 1, x * y % @@p ] end end
->Raw Target:
decompress point that is compressed into 32bytes
--

1260=========
->Original Input:
['def', 'p_secret_to_public', '(', 'secret', ')', 'expanded', '=', 'secret_expand', '(', 'secret', ')', 'a', '=', 'expanded', '.', 'first', 'return', 'point_compress', '(', 'point_mul', '(', 'a', ',', '@@G', ')', ')', 'end']
->Original Target:
['public_keyKey', '=', 'aG', 'a', 'is', 'generated', 'form', 'a', 'secret']
->Reconstructed Target:
public_keyKey = aG a is generated form a secret
->Reconstructed Predication:
return the public secret
->Raw Input:
summarize:def p_secret_to_public ( secret ) expanded = secret_expand ( secret ) a = expanded. first return point_compress ( point_mul ( a, @@G ) ) end
->Raw Target:
public_keyKey = aG a is generated form a secret
--

1261=========
->Original Input:
['def', 'part', '(', 'name', ')', 'parts', '.', 'select', '{', '|', 'p', '|', 'p', '.', 'name', '.', 'downcase', '==', 'name', '.', 'to_s', '.', 'downcase', '}', '.', 'first', 'end']
->Original Target:
['get', 'part', 'by', 'its', 'name', 'param']
->Reconstructed Target:
get part by its name param
->Reconstructed Predication:
the part with the given name
->Raw Input:
summarize:def part ( name ) parts. select { | p | p. name. downcase == name. to_s. downcase }. first end
->Raw Target:
get part by its name param
--
